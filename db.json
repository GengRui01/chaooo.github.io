{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style-dark.styl","path":"css/style-dark.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","path":"img/bg-dark.jpg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/css/share.styl","path":"share/css/share.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","path":"share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","path":"share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","path":"share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","path":"share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/js/social-share.js","path":"share/js/social-share.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/share/js/qrcode.js","path":"share/js/qrcode.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1562469885966},{"_id":"themes/BlueLake/README.en.md","hash":"76269fd9d9f7f6f457b242ae73d0e90f104de5fb","modified":1562469885967},{"_id":"themes/BlueLake/README.md","hash":"18a900a2987acb5d43086f141929627df38c179d","modified":1562469885969},{"_id":"themes/BlueLake/_config.yml","hash":"11ae55cf053accd4aa2ccb64bc9318a0a95bb500","modified":1563803496440},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1562469886004},{"_id":"source/_posts/01-数据库系统基础.md","hash":"a125b92f27866bff2884aa37dd386f924a6b1174","modified":1566916609827},{"_id":"source/_posts/01_JavaSE语法基础.md","hash":"d8792c5c3ede2f5b3a0cd96d41a9f19139b83aa1","modified":1563633938313},{"_id":"source/_posts/02_JavaSE面向对象.md","hash":"cb0e5b2e259bda4de5af812bac03ef0636902648","modified":1563633951139},{"_id":"source/_posts/03_JavaSE核心工具类.md","hash":"75b5de0302952f7f9ebc3ca86c253f4513778dfa","modified":1563633962537},{"_id":"source/_posts/04_JavaSE集合框架.md","hash":"a9b3ed5e9f9987089fa51ec705d50f098b21fee1","modified":1563634003086},{"_id":"source/_posts/05_JavaSE异常处理机制.md","hash":"495aec297457c5b43e8347e13d77e89df7e2500b","modified":1563634011992},{"_id":"source/_posts/06_JavaSE输入输出-IO.md","hash":"28d932f4e494069a23289d4c89dc4ffedbbe5482","modified":1563634029875},{"_id":"source/_posts/07_JavaSE多线程.md","hash":"204210a552f7795bc8834ab144734209a49c94a9","modified":1563634315308},{"_id":"source/_posts/08_JavaSE反射机制.md","hash":"c083db1e82b5078e3c049adfa3b3405422fd081e","modified":1563634600906},{"_id":"source/_posts/09_JavaSE网络编程.md","hash":"f978e9a1627317403de1cbd18f85a50eca805800","modified":1563634912870},{"_id":"source/_posts/10_JavaSE常用设计模式.md","hash":"ac509f94622374f4d98b4646132c132ef299c4c9","modified":1563635016395},{"_id":"source/_posts/11_JavaSE数据结构与算法入门.md","hash":"7cc83fefb9ca9253ba35526278cbd52c2164d39f","modified":1563635285419},{"_id":"source/_posts/12_JavaWeb编程基础.md","hash":"910d62d12a6d9e63764b08aa11f6aa5e9de6a889","modified":1564055995682},{"_id":"source/_posts/13-Spring基础和IoC控制反转.md","hash":"ccd5b9228ebc7215c111d4e2e5467eed5baeb407","modified":1566917750125},{"_id":"source/_posts/14-SpringIoC注解实现.md","hash":"219a55bea0658542ca5381c5a69bea8b7c84b8d5","modified":1566917745009},{"_id":"source/_posts/15-SpringJDBC详解.md","hash":"8dc6dbf68ba65bbfe60e289b27e774934550f194","modified":1566917739395},{"_id":"source/_posts/16-Spring事务管理.md","hash":"132ef3e4da4434ae469dca374989a061ae43a952","modified":1566917734127},{"_id":"source/_posts/17-Spring面向切面编程AOP.md","hash":"8a620a34fda66c5e8533fc1fe9c70fe633ca00b4","modified":1566917722336},{"_id":"source/_posts/18-SpringMVC框架.md","hash":"2fbd870ef80e0e84d8d424b2a3fef41cafe34d58","modified":1566917717931},{"_id":"source/_posts/19-Java持久层框架Mybatis.md","hash":"adab1c30beebb941be13913476a7140f5007f36e","modified":1566917708273},{"_id":"source/_posts/20-SSM框架整合.md","hash":"0c105206f57cd97b9355d3de9b59b1b8504dd9ec","modified":1566917799909},{"_id":"source/_posts/BlueLake博客主题的详细配置.md","hash":"9d59601ce904b64eef4ad750ae85d7945a438f69","modified":1563631762498},{"_id":"source/_posts/Hexo3-2-github搭建静态博客.md","hash":"d6e8eac054081ce193035a1c3e43571af05353c6","modified":1562468771430},{"_id":"source/_posts/MongoDB学习笔记.md","hash":"39011edebf356d56bf4f7173f6a4dab0323193bb","modified":1562481374618},{"_id":"source/_posts/Web包管理器-Bower.md","hash":"c217401b1a6d971c97c69b37a1fa0f9030bcefac","modified":1562468771447},{"_id":"source/_posts/Win10下配置Nginx-php7-mysql-5-6.md","hash":"2b8d194c452cb7c58839ab1f6c8abb8c30bc4acd","modified":1562468771448},{"_id":"source/_posts/hello-world.md","hash":"a571d5a7c330d8906075139a7f69c5cc4b3cf87f","modified":1562468771449},{"_id":"source/_posts/sublime-text3个人习惯配置-C.md","hash":"d4acd3ecea1ca691ec17878f4d33444538cb3e35","modified":1562551351461},{"_id":"source/_posts/自定义HEXO站内搜索Javascript-json.md","hash":"1e2403133c932229249893d8e083d3cb16ebca59","modified":1562468771450},{"_id":"source/_posts/谈谈开源.md","hash":"dc5f94513e0298a02193b8b7552fbc2ba78a818f","modified":1566918122852},{"_id":"source/about/index.md","hash":"083adf2e49d2a4b6d47af102abc5ebc11fa47ff8","modified":1562468771451},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1562469885882},{"_id":"themes/BlueLake/.git/config","hash":"7e25608fae05296ec4af5a16d8ecf5042faf30a3","modified":1562469885893},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1562469873988},{"_id":"themes/BlueLake/.git/index","hash":"79b2516e716b33233c4adb15499edd12aac79faa","modified":1562491125764},{"_id":"themes/BlueLake/.git/packed-refs","hash":"6fb50c49066dc1d6109757f03a9a2ae69c6eb0d4","modified":1562469885873},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"85f06e2ea9a45bb55761b29cda4487f782557b2b","modified":1562469885971},{"_id":"themes/BlueLake/languages/en.yml","hash":"fe087d478a81ffc15f93f2295bc2b6f49a149c3d","modified":1562469885972},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"a57b9b768346adfe1c1553c4b727d5c113a52480","modified":1562469885973},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"fff49dfae21808bb1edd74dfe4f14c457b64c191","modified":1562469885974},{"_id":"themes/BlueLake/languages/ko.yml","hash":"bd3c4058a43a0f6e239f360261f3260c87c185f0","modified":1562469885975},{"_id":"themes/BlueLake/languages/tr.yml","hash":"47d1dfd33fb1f0acbb1dfd400854d265ae8ccd45","modified":1562469885976},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"b388d0e44084026dedaf4ffdf7536e06bc8b37a8","modified":1562469885977},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"9a7ffb9f16af9fdca51d818e4fd2eb9f7e8ba9cf","modified":1562469885978},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1562469885997},{"_id":"themes/BlueLake/layout/base.jade","hash":"fd0d4e3878e48c5aa40bb1946703b9543fb5d3c7","modified":1563792785492},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1562469885999},{"_id":"themes/BlueLake/layout/index.jade","hash":"6406182f71d0f36757e91c5ec999f244c1f83c68","modified":1562469886000},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1562469886001},{"_id":"themes/BlueLake/layout/post.jade","hash":"2099b699b9d22ec60e9970f4877cfd091a8622bf","modified":1562485541543},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1562469886003},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1562469886005},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1562469886010},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1562469873990},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1562469873997},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1562469873999},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1562469874001},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1562469874002},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1562469874003},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1562469874013},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1562469874015},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1562469874017},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1562469874019},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885888},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"0c80970e25b8532e3009220eaa100fc64520ee95","modified":1562485550493},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1562469885980},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"3fa65886665e8165640d22ede8dd3b06a0554583","modified":1562481831332},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"f95aa1d48752fe47046c0ba89199ad765351b510","modified":1562482109311},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"138e32ba7f01ced06558a8bbcf85423f697abb00","modified":1562485602196},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1562469885984},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1562469885985},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1562469885986},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1562469885987},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"44de0851108bca8404f5614d5101c7a7ee67754d","modified":1562482168921},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1562469885988},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1562469885989},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1562469885990},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1562469885991},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1562469885992},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1562469885993},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1562469885993},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1562469885994},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1562469885995},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","hash":"11dfe68ade914332c484a4dceaec215bf8b62ee7","modified":1562469886006},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1562469886007},{"_id":"themes/BlueLake/source/css/style-dark.styl","hash":"3f45549a1aff27a14eae81d9be74977337d14464","modified":1563171730301},{"_id":"themes/BlueLake/source/css/style.styl","hash":"a990d649eb2d4dacfec0910d05d839a5f677c02b","modified":1563172208518},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1562469886012},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1562469886013},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1562469886014},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1562469886016},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1562469886021},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1562469886022},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1562469886023},{"_id":"themes/BlueLake/.git/objects/pack/pack-a8648c582315762d09a3092df6c5cdc5460c3b90.idx","hash":"6c886117ec82a594e268a026b2ae258365b5f898","modified":1562469885599},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"c267bddbfc3cc43de3f7124c4449d3b343552f72","modified":1562469885886},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1562469886018},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1562469886020},{"_id":"themes/BlueLake/source/share/css/share.styl","hash":"e1337f4029ddd37e8d9657d1b05023b5ea715acf","modified":1562469886025},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1562469886026},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1562469886027},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1562469886028},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1562469886029},{"_id":"themes/BlueLake/source/share/js/social-share.js","hash":"fe73d3b1c63a498f18f885fc83d631c2b63535e7","modified":1562469886032},{"_id":"themes/BlueLake/source/share/js/qrcode.js","hash":"962ad9cb87afa140a644178e5f3c53e2514ea1e5","modified":1562469886031},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885887},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1562469885880},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885879},{"_id":"themes/BlueLake/.git/objects/pack/pack-a8648c582315762d09a3092df6c5cdc5460c3b90.pack","hash":"3b75145e7fa3a9bb5347db68bcf9e6ac5eef9d62","modified":1562469885722},{"_id":"public/baidusitemap.xml","hash":"167ac941b0929f958fec33d6eae95f709bf9550c","modified":1566918140261},{"_id":"public/atom.xml","hash":"ec1de183c0d37156e8559cbb89ee10b1cdd88ba9","modified":1566918140262},{"_id":"public/content.json","hash":"6a1efcaf43d5a1140484623f6aaf58a994fa8602","modified":1566918140264},{"_id":"public/search.xml","hash":"426eb00f72746d58a5fc625911829bcacf5ce12e","modified":1566918140297},{"_id":"public/sitemap.xml","hash":"363e5b241ccd6ad773acec4ec90a3dad3b460763","modified":1566918140297},{"_id":"public/about/index.html","hash":"49dedf46da8f746a78417bdffa148677f3a30af2","modified":1566918140313},{"_id":"public/2019/07/11/谈谈开源.html","hash":"a5834ed614006efe16281e6ae2c32e484b65d627","modified":1566918140313},{"_id":"public/2015/12/31/hello-world.html","hash":"6232c53216c0f90ec53e3da4afea10edb2106098","modified":1566918140313},{"_id":"public/archives/index.html","hash":"8c9503f438460639c69717e0c4003458527c0e10","modified":1566918140313},{"_id":"public/archives/2015/index.html","hash":"d6f20713a61f1d11bc6757b06a65d44bf36ea4f7","modified":1566918140313},{"_id":"public/archives/2015/12/index.html","hash":"d6f20713a61f1d11bc6757b06a65d44bf36ea4f7","modified":1566918140314},{"_id":"public/archives/2016/index.html","hash":"8f47ea9bc993915595b00baea40b5d6df6611d39","modified":1566918140314},{"_id":"public/archives/2016/05/index.html","hash":"7b5089c74b34102efcc7edcca2a9a852f775e4f8","modified":1566918140314},{"_id":"public/archives/2016/06/index.html","hash":"610a239fa0458df87299017b5c5d362a521558a6","modified":1566918140314},{"_id":"public/archives/2016/07/index.html","hash":"f0998e573a442560988e86ba11ad2fc275ca3008","modified":1566918140314},{"_id":"public/archives/2016/08/index.html","hash":"c5a29e240804ef391d351b108d30516db011665c","modified":1566918140314},{"_id":"public/archives/2016/11/index.html","hash":"dd911e054e268029cab52eff5890a567db1d2282","modified":1566918140314},{"_id":"public/archives/2016/12/index.html","hash":"bf37f29c0e838c038dd2a827cf0bcba339ec907c","modified":1566918140314},{"_id":"public/archives/2019/index.html","hash":"d5f5163bd1bec1db5484b4e5c14918325ae1724c","modified":1566918140314},{"_id":"public/archives/2019/02/index.html","hash":"3fe4cf5f2f8cf2ecedf5fa869d95ec707a46b741","modified":1566918140315},{"_id":"public/archives/2019/07/index.html","hash":"2dd6276594f082939211d391a0432e5778866d60","modified":1566918140315},{"_id":"public/archives/2019/08/index.html","hash":"f825a6e5da9494d47cc19a653996d74ea1087403","modified":1566918140316},{"_id":"public/categories/javaSE知识梳理/index.html","hash":"295b797beef4bcf6a6daf1bae2ccf48e079b706d","modified":1566918140316},{"_id":"public/categories/JavaWeb编程/index.html","hash":"61b97036ccf92887625671f1f8930ceb7b85cb23","modified":1566918140317},{"_id":"public/categories/hexo博客折腾/index.html","hash":"85fd7dc65d96ae7cd7dd1c462cabe5512c2c2857","modified":1566918140317},{"_id":"public/categories/前端工具/index.html","hash":"8aa0977b608633bba60abedff7ac556646f00846","modified":1566918140317},{"_id":"public/categories/杂谈/index.html","hash":"7e0b1018ce03f4c01a431d390ab805dd56825218","modified":1566918140317},{"_id":"public/categories/数据库/index.html","hash":"f77d16f23459cb2446bf8a9bb804a2274dda2a2b","modified":1566918140317},{"_id":"public/categories/数据库系统/index.html","hash":"3fbd07cbafe62ef70acd158a5022e9a833f3caf9","modified":1566918140317},{"_id":"public/index.html","hash":"a4009cf20eaa381340cc77a97e8b38ced9ab230d","modified":1566918140317},{"_id":"public/page/2/index.html","hash":"a1a472fe1f88535e61f8681701ec42f7bd455433","modified":1566918140318},{"_id":"public/tags/javaSE/index.html","hash":"d654968f8d01af0ad9edf4e25d2a5865797cd931","modified":1566918140318},{"_id":"public/tags/后端开发/index.html","hash":"4577d37c57421073ab42e854ebfcbe9e6c469272","modified":1566918140318},{"_id":"public/tags/javaEE/index.html","hash":"104749efe927ef6f63314055fbabda21a3bfa921","modified":1566918140318},{"_id":"public/tags/Spring/index.html","hash":"b919d4076ba22e1c394e9633b71ed84b8a7704e6","modified":1566918140319},{"_id":"public/tags/hexo/index.html","hash":"0d23280cc12279e0b7c2283a1b7e4118c9e0b001","modified":1566918140319},{"_id":"public/tags/bower/index.html","hash":"ce230da4b487d20fbae20bca17efb81361faf789","modified":1566918140319},{"_id":"public/tags/sublime/index.html","hash":"1a69d26e2aa16ed71e569535f2f2ef4cf332e2c0","modified":1566918140319},{"_id":"public/tags/javascript/index.html","hash":"4b67c8c94156b8e0e48b5b3016895ba4babe9bf0","modified":1566918140319},{"_id":"public/tags/开源/index.html","hash":"673b496cb7544a0a7f07ae6a86d5cb796c9fbabc","modified":1566918140319},{"_id":"public/tags/BlueLake/index.html","hash":"44505ea0a17d6e903ac49411121d3d6a84978dec","modified":1566918140319},{"_id":"public/tags/mongodb/index.html","hash":"c65edeec32933ab67c3c57caba1704726b364bbb","modified":1566918140319},{"_id":"public/tags/数据库/index.html","hash":"e60f003c17be1af8eb2ec03fdd9605f2cf98a637","modified":1566918140320},{"_id":"public/2019/08/27/20-SSM框架整合.html","hash":"409975572a0ce851e09e69c68afbef60b71cb8b3","modified":1566918140320},{"_id":"public/2019/08/27/19-Java持久层框架Mybatis.html","hash":"01e2b884d67632912e06e840610919c38b342ccd","modified":1566918140320},{"_id":"public/2019/08/27/18-SpringMVC框架.html","hash":"27ec80655947395f4b79302b7ad605ca423d0dc2","modified":1566918140320},{"_id":"public/2019/08/27/17-Spring面向切面编程AOP.html","hash":"8b6707cfe9e2a15d90f97da4c444533a601e305f","modified":1566918140320},{"_id":"public/2019/08/27/16-Spring事务管理.html","hash":"93644ce12bd738416abdd23ab75b7277eeab04fb","modified":1566918140320},{"_id":"public/2019/08/27/15-SpringJDBC详解.html","hash":"691ec9e29dcf9e3fed2ad443b987ddd25b8555b2","modified":1566918140321},{"_id":"public/2019/08/27/14-SpringIoC注解实现.html","hash":"04bd3f4b623eb7dd9bcb69121aca127805cef9cb","modified":1566918140321},{"_id":"public/2019/08/27/13-Spring基础和IoC控制反转.html","hash":"e089d13852ca90b3ebf8de73124343b3c8480430","modified":1566918140321},{"_id":"public/2019/07/22/01-数据库系统基础.html","hash":"57c40e590bac0a59a54c29a5b668f1b8e6abd1dc","modified":1566918140321},{"_id":"public/2019/07/20/12_JavaWeb编程基础.html","hash":"dabcd54427ebc04635f8b398e1a8c8ca6a384963","modified":1566918140321},{"_id":"public/2019/07/15/11_JavaSE数据结构与算法入门.html","hash":"6f26d3f0b3462f8e68f3554a2792a79b230c02c9","modified":1566918140322},{"_id":"public/2019/07/15/10_JavaSE常用设计模式.html","hash":"9cf9a092c3465bca5fb3afd4d30150219299d40a","modified":1566918140322},{"_id":"public/2019/07/12/09_JavaSE网络编程.html","hash":"818b5d54631d9be304192ad8be96066ea2b7a6af","modified":1566918140322},{"_id":"public/2019/07/10/08_JavaSE反射机制.html","hash":"97d31b8341a5ce0bf100cc10a334aacd602f4041","modified":1566918140322},{"_id":"public/2019/07/09/07_JavaSE多线程.html","hash":"1393115e0c973a9962187fa038251dae1968eed2","modified":1566918140322},{"_id":"public/2019/07/09/06_JavaSE输入输出-IO.html","hash":"b161bc88b355eee0587d44ad881c3a2d61a815da","modified":1566918140322},{"_id":"public/2019/07/09/05_JavaSE异常处理机制.html","hash":"f0308d44bbce4f63471551dc3196b750c74fb724","modified":1566918140322},{"_id":"public/2019/07/08/04_JavaSE集合框架.html","hash":"f4ebcd2dd3487a969d3bd0b529c738e08d819313","modified":1566918140323},{"_id":"public/2019/07/08/03_JavaSE核心工具类.html","hash":"77fab8b28c1f27051d8bd5eb6c681bed11d17004","modified":1566918140323},{"_id":"public/2019/07/07/02_JavaSE面向对象.html","hash":"13d5ace134f08ff8a069520a73d2c10189e5f685","modified":1566918140323},{"_id":"public/2019/07/07/01_JavaSE语法基础.html","hash":"f91f02f30233bcfbe370fe1b35a01d9464ace839","modified":1566918140323},{"_id":"public/2019/02/22/Win10下配置Nginx-php7-mysql-5-6.html","hash":"e7ce34293570a0a2b98be226a6448fdd3479a9f7","modified":1566918140323},{"_id":"public/2016/12/29/BlueLake博客主题的详细配置.html","hash":"3e8d3bea65bac7b0ca8ba5cb1d9b69afe0814ae5","modified":1566918140323},{"_id":"public/2016/11/09/自定义HEXO站内搜索Javascript-json.html","hash":"e97f749ee192dcc0faa3afba0154eaf4913fea40","modified":1566918140323},{"_id":"public/2016/08/12/Web包管理器-Bower.html","hash":"3f0b7630d64780de308ba08c29254787fcd1526f","modified":1566918140324},{"_id":"public/2016/07/30/MongoDB学习笔记.html","hash":"0e2157eda68e1a73cdb83a4412312d68f19505d9","modified":1566918140324},{"_id":"public/2016/06/29/sublime-text3个人习惯配置-C.html","hash":"d9b78eafc2c009644887044be4c6e6011e840fd7","modified":1566918140324},{"_id":"public/2016/05/23/Hexo3-2-github搭建静态博客.html","hash":"5c7377ea8454682032aa9f2fafa50933333ec745","modified":1566918140324},{"_id":"public/page/3/index.html","hash":"78b31bc4b975f9f1da5cae8094c8646e02f13dc0","modified":1566918140324},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1566918140341},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1566918140341},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1566918140342},{"_id":"public/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1566918140342},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1566918140342},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1566918140342},{"_id":"public/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1566918140342},{"_id":"public/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1566918140342},{"_id":"public/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1566918140343},{"_id":"public/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1566918140343},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1566918140794},{"_id":"public/css/highlight.css","hash":"fb0403feb34cc8bb8b1f28f238540d36588b86df","modified":1566918140809},{"_id":"public/css/highlight-dark.css","hash":"0fabf7a922ac0703492ba406608ce972f749bbb9","modified":1566918140809},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1566918140810},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1566918140810},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1566918140810},{"_id":"public/share/css/share.css","hash":"31af1d5174b1f7d3d62813dda5339f911ce0e668","modified":1566918140810},{"_id":"public/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1566918140810},{"_id":"public/share/js/social-share.js","hash":"9bfe34fe7691833e90815c5c862545bde581cf29","modified":1566918141333},{"_id":"public/css/style-dark.css","hash":"fe766cb081431bdf98fc1aebe7be991af6a789f4","modified":1566918141340},{"_id":"public/css/style.css","hash":"97c009cd85c252083b08d8c156767692bd5ec24e","modified":1566918141340},{"_id":"public/share/js/qrcode.js","hash":"9caa0d9a9ba4409a3f77540a1b15a7617aeb28e8","modified":1566918141345}],"Category":[{"name":"javaSE知识梳理","_id":"cjztylo3z0003yot3ajbds344"},{"name":"JavaWeb编程","_id":"cjztylo4b0008yot3imj3n5ti"},{"name":"hexo博客折腾","_id":"cjztylo4z000nyot34nzjpwvu"},{"name":"前端工具","_id":"cjztylo52000ryot31zchuvcs"},{"name":"杂谈","_id":"cjztylo590017yot3yiv9h3u0"},{"name":"数据库","_id":"cjztylo6o002oyot3qiolm8ld"},{"name":"数据库系统","_id":"cjztyloaj0037yot3ve1joalp"}],"Data":[],"Page":[{"title":"about","date":"2016-11-09T09:29:51.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-09 17:29:51\n---\n","updated":"2019-07-07T03:06:11.451Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjztylo3t0001yot329hs42gj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"五、JavaSE异常处理机制","date":"2019-07-09T00:34:31.000Z","_content":"\n\nJava语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [异常的分支结构](#id2)\n3. [添加处理异常的手段](#id3)\n4. [异常的捕获](#id4)\n5. [异常的抛出](#id5)\n6. [自定义异常](#id6)\n7. [总结](#id7)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 异常用于在Java语言中描述运行阶段发生的错误。\n- 在Java中有一个定义好的规则Throwable（可以抛出的）\n- java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。\n    * Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。\n    * Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。\n- java.lang.Exception类是所有异常的超类，主要分为两大类：\n    * RuntimeException - 运行时异常，也叫非检测性异常\n    * IOException和其他异常 - 其他异常也叫做检测性异常\n\n> 注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。\n\n```\nThrowable类\n    |————Exception类\n        |————RuntimeException异常\n            |————ArithmeticException类\n            |————ArrayIndexOutOfBoundsException类\n            |————NullPointerException类\n            |————ClassCastException类\n            |————NumberFormatException类\n        |————IOException和其他异常\n    |————Error类\n```\n\n\n<span id=\"id2\"><span>\n### 2. 异常的分支结构\n#### 2.1 运行时异常（非检查异常）\n1. Error和RuntimeException都算作运行时异常\n2. javac编译的时候，不会提示和发现的，\n3. 在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)\n4. 要求大家出现这样异常的时候 知道怎么产生及如何修改\n    + InputMisMatchException 输入不匹配\n        - int value = input.nextInt();//   abc\n    + *NumberFormatException 数字格式化\n        - int value = Integer.parseInt(\"123.45\");\n    + NegativeArraySizeException 数组长度负数\n        - int[] array = new int[-2];\n    + *ArrayIndexOutOfBoundsException 数组索引越界\n        - int[] array = {1,2,3};\n        - array[5];\n    + *5NullPointerException 空指针异常\n        - int[][] array = new int[3][];\n        - array[0][0] =10;\n        - Person p = null;\n        - p.getName();\n    + ArithmeticException 数字异常\n        - 10/0    整数不允许除以0    Infinity小数除以0会产生无穷\n    + *ClassCastException 造型异常\n        - Person p = new Teacher();\n        - Student s = (Student)p;\n    + *StringIndexOutOfBoundsException 字符串越界\n        - String str = \"abc\";\n        - str.charAt(5);\n    + *IndexOutOfBoundsException 集合越界\n        - List家族\n        - ArrayList  list = new ArrayList();\n        - list.add(); list.add(); list.add();\n        - list.get(5);\n    + IllegalArgumentException 非法参数异常\n        - ArrayList  list = new ArrayList(-1);\n\n#### 2.2 编译时异常(检查异常)\n- 除了Error和RuntimeException以外其他的异常\n- javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)\n- 因为这样的异常在程序运行过程中极有可能产生问题的\n- 异常产生后后续的所有执行就停止\n\n``` java\n//eg: InterruptException\ntry{\n    Thread.sleep(5000);\n}catch(Exception e){\n    //...\n}\n```\n\n\n<span id=\"id3\"><span>\n### 3. 添加处理异常的手段\n- 处理异常不是 异常消失了\n- 处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行\n- 两种手段：\n    * 异常的捕获：try{}catch(){}[ finally{} ]\n    * throws抛出\n- final，finally，finalize区别\n    * final：特征修饰符，修饰变量，属性，方法，类\n        + 修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)\n        + 修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)\n        + 修饰方法：不能被子类重写\n        + 修饰类：不能被其他的子类继承\n    * finally：处理异常手段的一部分\n        + try{}catch(){}后面的一个部分\n        + 这个部分可有可无，如果有只能含有一份，且必须执行\n    * finalize：是Object类中的一个protected方法\n        + 对象没有任何引用指向的时候 -- 会被GC回收\n        + 当对象回收的时候 默认调用finalize方法\n        + 若想要看到对象回收的效果，可以重写 public void finalize(){}\n\n\n<span id=\"id4\"><span>\n### 4. 异常的捕获\n``` java\ntry{\n    可能发生异常的代码;\n}catch(异常类型 引用变量){\n    针对该异常的处理代码;\n}catch ...\nfinally{\n    无论是否发生异常都要执行的代码;\n}\n```\n\n- 处理异常放在方法内部 可能会出现的小问题\n    * 如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。\n\n```\npublic String test() {\n    try {\n        //...可能产生异常的的代码\n        return \"值1\";//事先约定好 返回值\n    }catch(Exception e){\n        e.printStackTrace();//打印输出异常的名字\n    }finally {\n        System.out.println(\"finally块执行啦\");\n    }\n    return \"值2\";\n}\n```\n\n- 上述执行结果：若try中代码块产生异常return返回 **值2**，若try中无异常则return返回 **值1**，无论return在哪finally都会执行。\n\n> 异常捕获的注意事项：\n> - 当需要多分catch分子时，切记小类型应该放在大类型的前面；\n> - 懒人写法：catch(Exception e){...}\n> - finally通常用于善后处理，如：关闭已经打开的文件等。\n\n\n<span id=\"id5\"><span>\n### 5. 异常的抛出\n- 当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。\n- 语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,...{} ，\n<br>如：`public void show() throw Exception {}`\n- 重写方法的抛出规则：\n    * 不抛出异常\n    * 抛出父类异常中的子类异常\n    * 抛出和父类一样的异常\n    * 不能抛出同级不一样的异常\n    * 不能抛出更大的异常\n\n\n<span id=\"id6\"><span>\n### 6. 自定义异常\n- 可以根据需要自定义异常类。\n- 自定义异常的方式：\n    * 继承Exception或者异常的子类。\n    * 提供两个构造，无参构造和String做参数的构造。 \n- 异常的手段\n    * 如果继承是RuntimeException---->运行时异常(不需要必须添加处理手段)\n    * 如果继承是Exception----->编译时异常(必须添加处理手段)\n- 类中可以写带String参数的构造方法，可以做细致的说明\n- 通过throw关键字，new一个异常的对象\n- 主动产生异常：`throw new 异常类型();`\n\n\n<span id=\"id7\"><span>\n### 7. 总结\n- 1.在开发中尽量使用条件判断避免异常的发生;\n- 2.若实在避免不了，则进行异常捕获；\n- 3.若实在捕获不了，则进行异常抛出；\n- 4.若需要使用针对性异常，则自定义异常。\n\n","source":"_posts/05_JavaSE异常处理机制.md","raw":"---\ntitle: 五、JavaSE异常处理机制\ndate: 2019-07-09 08:34:31\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\nJava语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [异常的分支结构](#id2)\n3. [添加处理异常的手段](#id3)\n4. [异常的捕获](#id4)\n5. [异常的抛出](#id5)\n6. [自定义异常](#id6)\n7. [总结](#id7)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 异常用于在Java语言中描述运行阶段发生的错误。\n- 在Java中有一个定义好的规则Throwable（可以抛出的）\n- java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。\n    * Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。\n    * Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。\n- java.lang.Exception类是所有异常的超类，主要分为两大类：\n    * RuntimeException - 运行时异常，也叫非检测性异常\n    * IOException和其他异常 - 其他异常也叫做检测性异常\n\n> 注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。\n\n```\nThrowable类\n    |————Exception类\n        |————RuntimeException异常\n            |————ArithmeticException类\n            |————ArrayIndexOutOfBoundsException类\n            |————NullPointerException类\n            |————ClassCastException类\n            |————NumberFormatException类\n        |————IOException和其他异常\n    |————Error类\n```\n\n\n<span id=\"id2\"><span>\n### 2. 异常的分支结构\n#### 2.1 运行时异常（非检查异常）\n1. Error和RuntimeException都算作运行时异常\n2. javac编译的时候，不会提示和发现的，\n3. 在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)\n4. 要求大家出现这样异常的时候 知道怎么产生及如何修改\n    + InputMisMatchException 输入不匹配\n        - int value = input.nextInt();//   abc\n    + *NumberFormatException 数字格式化\n        - int value = Integer.parseInt(\"123.45\");\n    + NegativeArraySizeException 数组长度负数\n        - int[] array = new int[-2];\n    + *ArrayIndexOutOfBoundsException 数组索引越界\n        - int[] array = {1,2,3};\n        - array[5];\n    + *5NullPointerException 空指针异常\n        - int[][] array = new int[3][];\n        - array[0][0] =10;\n        - Person p = null;\n        - p.getName();\n    + ArithmeticException 数字异常\n        - 10/0    整数不允许除以0    Infinity小数除以0会产生无穷\n    + *ClassCastException 造型异常\n        - Person p = new Teacher();\n        - Student s = (Student)p;\n    + *StringIndexOutOfBoundsException 字符串越界\n        - String str = \"abc\";\n        - str.charAt(5);\n    + *IndexOutOfBoundsException 集合越界\n        - List家族\n        - ArrayList  list = new ArrayList();\n        - list.add(); list.add(); list.add();\n        - list.get(5);\n    + IllegalArgumentException 非法参数异常\n        - ArrayList  list = new ArrayList(-1);\n\n#### 2.2 编译时异常(检查异常)\n- 除了Error和RuntimeException以外其他的异常\n- javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)\n- 因为这样的异常在程序运行过程中极有可能产生问题的\n- 异常产生后后续的所有执行就停止\n\n``` java\n//eg: InterruptException\ntry{\n    Thread.sleep(5000);\n}catch(Exception e){\n    //...\n}\n```\n\n\n<span id=\"id3\"><span>\n### 3. 添加处理异常的手段\n- 处理异常不是 异常消失了\n- 处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行\n- 两种手段：\n    * 异常的捕获：try{}catch(){}[ finally{} ]\n    * throws抛出\n- final，finally，finalize区别\n    * final：特征修饰符，修饰变量，属性，方法，类\n        + 修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)\n        + 修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)\n        + 修饰方法：不能被子类重写\n        + 修饰类：不能被其他的子类继承\n    * finally：处理异常手段的一部分\n        + try{}catch(){}后面的一个部分\n        + 这个部分可有可无，如果有只能含有一份，且必须执行\n    * finalize：是Object类中的一个protected方法\n        + 对象没有任何引用指向的时候 -- 会被GC回收\n        + 当对象回收的时候 默认调用finalize方法\n        + 若想要看到对象回收的效果，可以重写 public void finalize(){}\n\n\n<span id=\"id4\"><span>\n### 4. 异常的捕获\n``` java\ntry{\n    可能发生异常的代码;\n}catch(异常类型 引用变量){\n    针对该异常的处理代码;\n}catch ...\nfinally{\n    无论是否发生异常都要执行的代码;\n}\n```\n\n- 处理异常放在方法内部 可能会出现的小问题\n    * 如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。\n\n```\npublic String test() {\n    try {\n        //...可能产生异常的的代码\n        return \"值1\";//事先约定好 返回值\n    }catch(Exception e){\n        e.printStackTrace();//打印输出异常的名字\n    }finally {\n        System.out.println(\"finally块执行啦\");\n    }\n    return \"值2\";\n}\n```\n\n- 上述执行结果：若try中代码块产生异常return返回 **值2**，若try中无异常则return返回 **值1**，无论return在哪finally都会执行。\n\n> 异常捕获的注意事项：\n> - 当需要多分catch分子时，切记小类型应该放在大类型的前面；\n> - 懒人写法：catch(Exception e){...}\n> - finally通常用于善后处理，如：关闭已经打开的文件等。\n\n\n<span id=\"id5\"><span>\n### 5. 异常的抛出\n- 当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。\n- 语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,...{} ，\n<br>如：`public void show() throw Exception {}`\n- 重写方法的抛出规则：\n    * 不抛出异常\n    * 抛出父类异常中的子类异常\n    * 抛出和父类一样的异常\n    * 不能抛出同级不一样的异常\n    * 不能抛出更大的异常\n\n\n<span id=\"id6\"><span>\n### 6. 自定义异常\n- 可以根据需要自定义异常类。\n- 自定义异常的方式：\n    * 继承Exception或者异常的子类。\n    * 提供两个构造，无参构造和String做参数的构造。 \n- 异常的手段\n    * 如果继承是RuntimeException---->运行时异常(不需要必须添加处理手段)\n    * 如果继承是Exception----->编译时异常(必须添加处理手段)\n- 类中可以写带String参数的构造方法，可以做细致的说明\n- 通过throw关键字，new一个异常的对象\n- 主动产生异常：`throw new 异常类型();`\n\n\n<span id=\"id7\"><span>\n### 7. 总结\n- 1.在开发中尽量使用条件判断避免异常的发生;\n- 2.若实在避免不了，则进行异常捕获；\n- 3.若实在捕获不了，则进行异常抛出；\n- 4.若需要使用针对性异常，则自定义异常。\n\n","slug":"05_JavaSE异常处理机制","published":1,"updated":"2019-07-20T14:46:51.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo3h0000yot31hcwfkoa","content":"<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">异常的分支结构</a></li>\n<li><a href=\"#id3\">添加处理异常的手段</a></li>\n<li><a href=\"#id4\">异常的捕获</a></li>\n<li><a href=\"#id5\">异常的抛出</a></li>\n<li><a href=\"#id6\">自定义异常</a></li>\n<li><a href=\"#id7\">总结</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>异常用于在Java语言中描述运行阶段发生的错误。</li>\n<li>在Java中有一个定义好的规则Throwable（可以抛出的）</li>\n<li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul>\n<li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li>\n<li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li>\n</ul>\n</li>\n<li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul>\n<li>RuntimeException - 运行时异常，也叫非检测性异常</li>\n<li>IOException和其他异常 - 其他异常也叫做检测性异常</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable类</span><br><span class=\"line\">    |————Exception类</span><br><span class=\"line\">        |————RuntimeException异常</span><br><span class=\"line\">            |————ArithmeticException类</span><br><span class=\"line\">            |————ArrayIndexOutOfBoundsException类</span><br><span class=\"line\">            |————NullPointerException类</span><br><span class=\"line\">            |————ClassCastException类</span><br><span class=\"line\">            |————NumberFormatException类</span><br><span class=\"line\">        |————IOException和其他异常</span><br><span class=\"line\">    |————Error类</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-异常的分支结构\"><a href=\"#2-异常的分支结构\" class=\"headerlink\" title=\"2. 异常的分支结构\"></a>2. 异常的分支结构</h3><h4 id=\"2-1-运行时异常（非检查异常）\"><a href=\"#2-1-运行时异常（非检查异常）\" class=\"headerlink\" title=\"2.1 运行时异常（非检查异常）\"></a>2.1 运行时异常（非检查异常）</h4><ol>\n<li>Error和RuntimeException都算作运行时异常</li>\n<li>javac编译的时候，不会提示和发现的，</li>\n<li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li>\n<li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul>\n<li>InputMisMatchException 输入不匹配<ul>\n<li>int value = input.nextInt();//   abc</li>\n</ul>\n</li>\n<li>*NumberFormatException 数字格式化<ul>\n<li>int value = Integer.parseInt(“123.45”);</li>\n</ul>\n</li>\n<li>NegativeArraySizeException 数组长度负数<ul>\n<li>int[] array = new int[-2];</li>\n</ul>\n</li>\n<li>*ArrayIndexOutOfBoundsException 数组索引越界<ul>\n<li>int[] array = {1,2,3};</li>\n<li>array[5];</li>\n</ul>\n</li>\n<li>*5NullPointerException 空指针异常<ul>\n<li>int[][] array = new int[3][];</li>\n<li>array[0][0] =10;</li>\n<li>Person p = null;</li>\n<li>p.getName();</li>\n</ul>\n</li>\n<li>ArithmeticException 数字异常<ul>\n<li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li>\n</ul>\n</li>\n<li>*ClassCastException 造型异常<ul>\n<li>Person p = new Teacher();</li>\n<li>Student s = (Student)p;</li>\n</ul>\n</li>\n<li>*StringIndexOutOfBoundsException 字符串越界<ul>\n<li>String str = “abc”;</li>\n<li>str.charAt(5);</li>\n</ul>\n</li>\n<li>*IndexOutOfBoundsException 集合越界<ul>\n<li>List家族</li>\n<li>ArrayList  list = new ArrayList();</li>\n<li>list.add(); list.add(); list.add();</li>\n<li>list.get(5);</li>\n</ul>\n</li>\n<li>IllegalArgumentException 非法参数异常<ul>\n<li>ArrayList  list = new ArrayList(-1);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-编译时异常-检查异常\"><a href=\"#2-2-编译时异常-检查异常\" class=\"headerlink\" title=\"2.2 编译时异常(检查异常)\"></a>2.2 编译时异常(检查异常)</h4><ul>\n<li>除了Error和RuntimeException以外其他的异常</li>\n<li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li>\n<li>因为这样的异常在程序运行过程中极有可能产生问题的</li>\n<li>异常产生后后续的所有执行就停止</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg: InterruptException</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-添加处理异常的手段\"><a href=\"#3-添加处理异常的手段\" class=\"headerlink\" title=\"3. 添加处理异常的手段\"></a>3. 添加处理异常的手段</h3><ul>\n<li>处理异常不是 异常消失了</li>\n<li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li>\n<li>两种手段：<ul>\n<li>异常的捕获：try{}catch(){}[ finally{} ]</li>\n<li>throws抛出</li>\n</ul>\n</li>\n<li>final，finally，finalize区别<ul>\n<li>final：特征修饰符，修饰变量，属性，方法，类<ul>\n<li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li>\n<li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li>\n<li>修饰方法：不能被子类重写</li>\n<li>修饰类：不能被其他的子类继承</li>\n</ul>\n</li>\n<li>finally：处理异常手段的一部分<ul>\n<li>try{}catch(){}后面的一个部分</li>\n<li>这个部分可有可无，如果有只能含有一份，且必须执行</li>\n</ul>\n</li>\n<li>finalize：是Object类中的一个protected方法<ul>\n<li>对象没有任何引用指向的时候 – 会被GC回收</li>\n<li>当对象回收的时候 默认调用finalize方法</li>\n<li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-异常的捕获\"><a href=\"#4-异常的捕获\" class=\"headerlink\" title=\"4. 异常的捕获\"></a>4. 异常的捕获</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    可能发生异常的代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常类型 引用变量)&#123;</span><br><span class=\"line\">    针对该异常的处理代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> ...</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    无论是否发生异常都要执行的代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理异常放在方法内部 可能会出现的小问题<ul>\n<li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String test() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //...可能产生异常的的代码</span><br><span class=\"line\">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();//打印输出异常的名字</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;值2&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li>\n</ul>\n<blockquote>\n<p>异常捕获的注意事项：</p>\n<ul>\n<li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li>\n<li>懒人写法：catch(Exception e){…}</li>\n<li>finally通常用于善后处理，如：关闭已经打开的文件等。</li>\n</ul>\n</blockquote>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常的抛出\"><a href=\"#5-异常的抛出\" class=\"headerlink\" title=\"5. 异常的抛出\"></a>5. 异常的抛出</h3><ul>\n<li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li>\n<li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li>\n<li>重写方法的抛出规则：<ul>\n<li>不抛出异常</li>\n<li>抛出父类异常中的子类异常</li>\n<li>抛出和父类一样的异常</li>\n<li>不能抛出同级不一样的异常</li>\n<li>不能抛出更大的异常</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-自定义异常\"><a href=\"#6-自定义异常\" class=\"headerlink\" title=\"6. 自定义异常\"></a>6. 自定义异常</h3><ul>\n<li>可以根据需要自定义异常类。</li>\n<li>自定义异常的方式：<ul>\n<li>继承Exception或者异常的子类。</li>\n<li>提供两个构造，无参构造和String做参数的构造。 </li>\n</ul>\n</li>\n<li>异常的手段<ul>\n<li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li>\n<li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li>\n</ul>\n</li>\n<li>类中可以写带String参数的构造方法，可以做细致的说明</li>\n<li>通过throw关键字，new一个异常的对象</li>\n<li>主动产生异常：<code>throw new 异常类型();</code></li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><ul>\n<li>1.在开发中尽量使用条件判断避免异常的发生;</li>\n<li>2.若实在避免不了，则进行异常捕获；</li>\n<li>3.若实在捕获不了，则进行异常抛出；</li>\n<li>4.若需要使用针对性异常，则自定义异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">异常的分支结构</a></li>\n<li><a href=\"#id3\">添加处理异常的手段</a></li>\n<li><a href=\"#id4\">异常的捕获</a></li>\n<li><a href=\"#id5\">异常的抛出</a></li>\n<li><a href=\"#id6\">自定义异常</a></li>\n<li><a href=\"#id7\">总结</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>异常用于在Java语言中描述运行阶段发生的错误。</li>\n<li>在Java中有一个定义好的规则Throwable（可以抛出的）</li>\n<li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul>\n<li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li>\n<li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li>\n</ul>\n</li>\n<li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul>\n<li>RuntimeException - 运行时异常，也叫非检测性异常</li>\n<li>IOException和其他异常 - 其他异常也叫做检测性异常</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable类</span><br><span class=\"line\">    |————Exception类</span><br><span class=\"line\">        |————RuntimeException异常</span><br><span class=\"line\">            |————ArithmeticException类</span><br><span class=\"line\">            |————ArrayIndexOutOfBoundsException类</span><br><span class=\"line\">            |————NullPointerException类</span><br><span class=\"line\">            |————ClassCastException类</span><br><span class=\"line\">            |————NumberFormatException类</span><br><span class=\"line\">        |————IOException和其他异常</span><br><span class=\"line\">    |————Error类</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-异常的分支结构\"><a href=\"#2-异常的分支结构\" class=\"headerlink\" title=\"2. 异常的分支结构\"></a>2. 异常的分支结构</h3><h4 id=\"2-1-运行时异常（非检查异常）\"><a href=\"#2-1-运行时异常（非检查异常）\" class=\"headerlink\" title=\"2.1 运行时异常（非检查异常）\"></a>2.1 运行时异常（非检查异常）</h4><ol>\n<li>Error和RuntimeException都算作运行时异常</li>\n<li>javac编译的时候，不会提示和发现的，</li>\n<li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li>\n<li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul>\n<li>InputMisMatchException 输入不匹配<ul>\n<li>int value = input.nextInt();//   abc</li>\n</ul>\n</li>\n<li>*NumberFormatException 数字格式化<ul>\n<li>int value = Integer.parseInt(“123.45”);</li>\n</ul>\n</li>\n<li>NegativeArraySizeException 数组长度负数<ul>\n<li>int[] array = new int[-2];</li>\n</ul>\n</li>\n<li>*ArrayIndexOutOfBoundsException 数组索引越界<ul>\n<li>int[] array = {1,2,3};</li>\n<li>array[5];</li>\n</ul>\n</li>\n<li>*5NullPointerException 空指针异常<ul>\n<li>int[][] array = new int[3][];</li>\n<li>array[0][0] =10;</li>\n<li>Person p = null;</li>\n<li>p.getName();</li>\n</ul>\n</li>\n<li>ArithmeticException 数字异常<ul>\n<li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li>\n</ul>\n</li>\n<li>*ClassCastException 造型异常<ul>\n<li>Person p = new Teacher();</li>\n<li>Student s = (Student)p;</li>\n</ul>\n</li>\n<li>*StringIndexOutOfBoundsException 字符串越界<ul>\n<li>String str = “abc”;</li>\n<li>str.charAt(5);</li>\n</ul>\n</li>\n<li>*IndexOutOfBoundsException 集合越界<ul>\n<li>List家族</li>\n<li>ArrayList  list = new ArrayList();</li>\n<li>list.add(); list.add(); list.add();</li>\n<li>list.get(5);</li>\n</ul>\n</li>\n<li>IllegalArgumentException 非法参数异常<ul>\n<li>ArrayList  list = new ArrayList(-1);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-编译时异常-检查异常\"><a href=\"#2-2-编译时异常-检查异常\" class=\"headerlink\" title=\"2.2 编译时异常(检查异常)\"></a>2.2 编译时异常(检查异常)</h4><ul>\n<li>除了Error和RuntimeException以外其他的异常</li>\n<li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li>\n<li>因为这样的异常在程序运行过程中极有可能产生问题的</li>\n<li>异常产生后后续的所有执行就停止</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg: InterruptException</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-添加处理异常的手段\"><a href=\"#3-添加处理异常的手段\" class=\"headerlink\" title=\"3. 添加处理异常的手段\"></a>3. 添加处理异常的手段</h3><ul>\n<li>处理异常不是 异常消失了</li>\n<li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li>\n<li>两种手段：<ul>\n<li>异常的捕获：try{}catch(){}[ finally{} ]</li>\n<li>throws抛出</li>\n</ul>\n</li>\n<li>final，finally，finalize区别<ul>\n<li>final：特征修饰符，修饰变量，属性，方法，类<ul>\n<li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li>\n<li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li>\n<li>修饰方法：不能被子类重写</li>\n<li>修饰类：不能被其他的子类继承</li>\n</ul>\n</li>\n<li>finally：处理异常手段的一部分<ul>\n<li>try{}catch(){}后面的一个部分</li>\n<li>这个部分可有可无，如果有只能含有一份，且必须执行</li>\n</ul>\n</li>\n<li>finalize：是Object类中的一个protected方法<ul>\n<li>对象没有任何引用指向的时候 – 会被GC回收</li>\n<li>当对象回收的时候 默认调用finalize方法</li>\n<li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-异常的捕获\"><a href=\"#4-异常的捕获\" class=\"headerlink\" title=\"4. 异常的捕获\"></a>4. 异常的捕获</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    可能发生异常的代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常类型 引用变量)&#123;</span><br><span class=\"line\">    针对该异常的处理代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> ...</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    无论是否发生异常都要执行的代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理异常放在方法内部 可能会出现的小问题<ul>\n<li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String test() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //...可能产生异常的的代码</span><br><span class=\"line\">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();//打印输出异常的名字</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;值2&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li>\n</ul>\n<blockquote>\n<p>异常捕获的注意事项：</p>\n<ul>\n<li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li>\n<li>懒人写法：catch(Exception e){…}</li>\n<li>finally通常用于善后处理，如：关闭已经打开的文件等。</li>\n</ul>\n</blockquote>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常的抛出\"><a href=\"#5-异常的抛出\" class=\"headerlink\" title=\"5. 异常的抛出\"></a>5. 异常的抛出</h3><ul>\n<li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li>\n<li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li>\n<li>重写方法的抛出规则：<ul>\n<li>不抛出异常</li>\n<li>抛出父类异常中的子类异常</li>\n<li>抛出和父类一样的异常</li>\n<li>不能抛出同级不一样的异常</li>\n<li>不能抛出更大的异常</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-自定义异常\"><a href=\"#6-自定义异常\" class=\"headerlink\" title=\"6. 自定义异常\"></a>6. 自定义异常</h3><ul>\n<li>可以根据需要自定义异常类。</li>\n<li>自定义异常的方式：<ul>\n<li>继承Exception或者异常的子类。</li>\n<li>提供两个构造，无参构造和String做参数的构造。 </li>\n</ul>\n</li>\n<li>异常的手段<ul>\n<li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li>\n<li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li>\n</ul>\n</li>\n<li>类中可以写带String参数的构造方法，可以做细致的说明</li>\n<li>通过throw关键字，new一个异常的对象</li>\n<li>主动产生异常：<code>throw new 异常类型();</code></li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><ul>\n<li>1.在开发中尽量使用条件判断避免异常的发生;</li>\n<li>2.若实在避免不了，则进行异常捕获；</li>\n<li>3.若实在捕获不了，则进行异常抛出；</li>\n<li>4.若需要使用针对性异常，则自定义异常。</li>\n</ul>"},{"title":"十四、Spring IoC注解实现","date":"2019-08-27T14:44:07.000Z","_content":"\n1. [回顾xml方式管理Java Bean](#id1)\n2. [注解方式管理Java Bean](#id2)\n3. [注解方式Bean的注入](#id3)\n4. [注解方式Bean的常用配置项(作用域,生命周期,懒加载等)](#id4)\n\n\n<span id=\"id1\"><span>\n### 1. 回顾xml方式管理Java Bean\n1. 将一个Bean交由Spring创建并管理\n    - `<baen id=\"bean\" class=\"包名.Bean\"></baen>`\n2. 获取Spring上下文\n    - `ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");`\n3. 获取Bean\n    - `Bean bean = app.getBean(\"bean\", Bean.class);`\n\n\n<span id=\"id2\"><span>\n### 2. 注解方式管理Java Bean\n一、创建一个class配置文件\n``` java\n@Configuration\npublic class MyConfiguration{\n    //将一个Bean交由Spring创建并管理\n    @Bean(name=\"bean1\")\n    public Bean bean(){\n        return Bean = new Bean();\n    }\n}\n```\n\n二、获取Spring上下文\n``` java\nApplicationContext context = \n    new AnnotationConfigApplicationContext(MyConfiguration.class);\n```\n\n三、获取Bean\n``` java\nBean1 bean1 = context.getBean(\"bean1\", Bean1.class);\n```\n\n#### 2.1 简化注解方式的步骤1\n一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）\n``` java\n@Configuration //该注解可理解当前class等同于一个xml文件\n@ComponentScan(\"包路径\") //开启组件扫描\npublic class MyConfiguration{}\n```\n> 在applicationContext.xml中开启组件扫描方式`<context:component-scan base-package=\"包路径\"/>`。\n\n二、 将交由Spring管理的类加上`@Component`注解，或（`@Repository`，`@Controller`，`@Service`）\n``` java\n@Component(\"bean1\")//通过构造方法实例化Bean1\npublic class Bean1{\n    //...\n}\n```\n> @Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 \n> - @Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 \n> - @Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 \n> - @Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 \n\n#### 2.2 Bean别名\n一、 xml形式：通过name属性或alias标签\n``` xml\n<bean id=\"bean1\" name=\"bean2,bean3\" class=\"com...Bean\"/>\n<alias name=\"bean1\" alias=\"bean4\"/>\n```\n\n二、 注解形式\n``` java\n@Configuration\npublic class MyConfiguration{\n    @Bean(name={\"bean1\",\"bean2\",\"bean3\"})\n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n```\n> 注意：@Component只能指定一个名字，@Component默认值为**类名首字母小写**，也可以自定义，如:`@Component(\"bean1\")`； 默认@scope为singleton单例，也可以进行指定\n\n\n\n<span id=\"id3\"><span>\n### 3. 注解方式Bean的注入\n一、 **`@Value(\"值\")`**：常用于基本数据类型值注入，`值`可用EL表达式。\n``` java\n@Component\npublic class Player{\n    @Value(\"张三\")\n    private String name;\n    //...\n}\n```\n\n二、 **`@Autowired`**：常用于复杂类型值的注入\n    + `@Autowired`：可以用在**成员变量**，**setter方法**，**构造方法**上；优先按照类型进行匹配，匹配不上启用名字进行匹配。\n    + `@Qualifier(\"名字\")` 根据名字匹配，配合@Autowired，**不能用在构造方法上**；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，`@Autowired(required=false)`:尽量去找，组件不存在也不报错。\n    + @Autowired的**原理**：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性\n``` java\n@Component\npublic class Player{\n    @Value(\"张三\")\n    private String name;\n\n    /** 用于成员变量 */\n    //@Autowired\n    //@Qualifier(\"card1\")\n    private Card card;\n\n    /** 用于构造方法 */\n    //@Autowired\n    public Player(Card card) {\n        super();\n        this.card = card;\n    }\n\n    /** 用于setter方法 */\n    @Autowired(required=false)\n    public void setCard(Card card) {\n        this.card = card;\n    }\n}\n```\n\n三、 **`@Resource`**：常用于复杂类型值的注入\n    + @Resource：用在**成员变量**和**setter方法**上，是**JDK**1.6支持的注解，优先按照名字匹配，可以通过`@Resource(name=\"名\")`指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。\n``` java\n@Component\npublic class Player{\n    @Resource(name=\"card\")\n    private Card card;\n    //...\n}\n```\n\n集合类型值注入实例\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\npublic class MyConfiguration{\n    @Bean\n    public List<String> list(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        return list;\n    }\n}\n\n@Component\npublic class Player{\n    @Autowired\n    private List<String> list;\n    //...\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)\n#### 4.1 注解方式Bean的作用域\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\npublic class MyConfiguration{\n    @Bean(name=\"bean1\")\n    @Scope(\"singleton\")\n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n\n@Component\n@Scope(\"singleton\")\npublic class Bean{}\n```\n\n\n#### 4.2 注解方式Bean的懒加载\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\n@Lazy //相当于xml中default-lazy-init=\"true\"\npublic class MyConfiguration{\n    @Bean(name=\"bean1\")\n    @Lazy \n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n\n@Component\n@Lazy\npublic class Bean{}\n```\n\n\n#### 4.3 Bean初始化和销毁\n一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。\n``` java\npublic class Bean implements InitializingBean{\n    @Override\n    public void afterPropertiesSet(){\n        //执行一些初始化后的工作\n    }\n}\n\npublic class Bean implements DisposableBean{\n    @Override\n    public void destroy(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n二、xml形式\n``` java\npublic class Bean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n``` xml\n<bean id=\"bean\" class=\"example.Bean\" \n        init-method=\"init\" \n        destroy-method=\"cleanup\"></bean>\n```\n\n三、注解形式1，@Bean(initMethod=\"init\", destroyMethod=\"cleanup\")\n``` java\npublic class Bean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n\n@Configuration\npublic class MyConfiguration{\n    @Bean(initMethod=\"init\", destroyMethod=\"cleanup\")\n    public Bean bean(){\n        return new Bean();\n    }\n}\n```\n\n四、注解形式2，添加@PostConstruct，@PreDestroy\n``` java\n@Component\npublic class Bean{\n    @PostConstruct\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    @PreDestroy\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n","source":"_posts/14-SpringIoC注解实现.md","raw":"---\ntitle: 十四、Spring IoC注解实现\ndate: 2019-08-27 22:44:07\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\n1. [回顾xml方式管理Java Bean](#id1)\n2. [注解方式管理Java Bean](#id2)\n3. [注解方式Bean的注入](#id3)\n4. [注解方式Bean的常用配置项(作用域,生命周期,懒加载等)](#id4)\n\n\n<span id=\"id1\"><span>\n### 1. 回顾xml方式管理Java Bean\n1. 将一个Bean交由Spring创建并管理\n    - `<baen id=\"bean\" class=\"包名.Bean\"></baen>`\n2. 获取Spring上下文\n    - `ApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");`\n3. 获取Bean\n    - `Bean bean = app.getBean(\"bean\", Bean.class);`\n\n\n<span id=\"id2\"><span>\n### 2. 注解方式管理Java Bean\n一、创建一个class配置文件\n``` java\n@Configuration\npublic class MyConfiguration{\n    //将一个Bean交由Spring创建并管理\n    @Bean(name=\"bean1\")\n    public Bean bean(){\n        return Bean = new Bean();\n    }\n}\n```\n\n二、获取Spring上下文\n``` java\nApplicationContext context = \n    new AnnotationConfigApplicationContext(MyConfiguration.class);\n```\n\n三、获取Bean\n``` java\nBean1 bean1 = context.getBean(\"bean1\", Bean1.class);\n```\n\n#### 2.1 简化注解方式的步骤1\n一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）\n``` java\n@Configuration //该注解可理解当前class等同于一个xml文件\n@ComponentScan(\"包路径\") //开启组件扫描\npublic class MyConfiguration{}\n```\n> 在applicationContext.xml中开启组件扫描方式`<context:component-scan base-package=\"包路径\"/>`。\n\n二、 将交由Spring管理的类加上`@Component`注解，或（`@Repository`，`@Controller`，`@Service`）\n``` java\n@Component(\"bean1\")//通过构造方法实例化Bean1\npublic class Bean1{\n    //...\n}\n```\n> @Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 \n> - @Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 \n> - @Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 \n> - @Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 \n\n#### 2.2 Bean别名\n一、 xml形式：通过name属性或alias标签\n``` xml\n<bean id=\"bean1\" name=\"bean2,bean3\" class=\"com...Bean\"/>\n<alias name=\"bean1\" alias=\"bean4\"/>\n```\n\n二、 注解形式\n``` java\n@Configuration\npublic class MyConfiguration{\n    @Bean(name={\"bean1\",\"bean2\",\"bean3\"})\n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n```\n> 注意：@Component只能指定一个名字，@Component默认值为**类名首字母小写**，也可以自定义，如:`@Component(\"bean1\")`； 默认@scope为singleton单例，也可以进行指定\n\n\n\n<span id=\"id3\"><span>\n### 3. 注解方式Bean的注入\n一、 **`@Value(\"值\")`**：常用于基本数据类型值注入，`值`可用EL表达式。\n``` java\n@Component\npublic class Player{\n    @Value(\"张三\")\n    private String name;\n    //...\n}\n```\n\n二、 **`@Autowired`**：常用于复杂类型值的注入\n    + `@Autowired`：可以用在**成员变量**，**setter方法**，**构造方法**上；优先按照类型进行匹配，匹配不上启用名字进行匹配。\n    + `@Qualifier(\"名字\")` 根据名字匹配，配合@Autowired，**不能用在构造方法上**；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，`@Autowired(required=false)`:尽量去找，组件不存在也不报错。\n    + @Autowired的**原理**：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性\n``` java\n@Component\npublic class Player{\n    @Value(\"张三\")\n    private String name;\n\n    /** 用于成员变量 */\n    //@Autowired\n    //@Qualifier(\"card1\")\n    private Card card;\n\n    /** 用于构造方法 */\n    //@Autowired\n    public Player(Card card) {\n        super();\n        this.card = card;\n    }\n\n    /** 用于setter方法 */\n    @Autowired(required=false)\n    public void setCard(Card card) {\n        this.card = card;\n    }\n}\n```\n\n三、 **`@Resource`**：常用于复杂类型值的注入\n    + @Resource：用在**成员变量**和**setter方法**上，是**JDK**1.6支持的注解，优先按照名字匹配，可以通过`@Resource(name=\"名\")`指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。\n``` java\n@Component\npublic class Player{\n    @Resource(name=\"card\")\n    private Card card;\n    //...\n}\n```\n\n集合类型值注入实例\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\npublic class MyConfiguration{\n    @Bean\n    public List<String> list(){\n        List<String> list = new ArrayList<String>();\n        list.add(\"aaa\");\n        list.add(\"bbb\");\n        return list;\n    }\n}\n\n@Component\npublic class Player{\n    @Autowired\n    private List<String> list;\n    //...\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)\n#### 4.1 注解方式Bean的作用域\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\npublic class MyConfiguration{\n    @Bean(name=\"bean1\")\n    @Scope(\"singleton\")\n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n\n@Component\n@Scope(\"singleton\")\npublic class Bean{}\n```\n\n\n#### 4.2 注解方式Bean的懒加载\n``` java\n@Configuration\n@ComponentScan(\"包路径\")\n@Lazy //相当于xml中default-lazy-init=\"true\"\npublic class MyConfiguration{\n    @Bean(name=\"bean1\")\n    @Lazy \n    public Bean1 bean1(){\n        return Bean1 = new Bean1();\n    }\n}\n\n@Component\n@Lazy\npublic class Bean{}\n```\n\n\n#### 4.3 Bean初始化和销毁\n一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。\n``` java\npublic class Bean implements InitializingBean{\n    @Override\n    public void afterPropertiesSet(){\n        //执行一些初始化后的工作\n    }\n}\n\npublic class Bean implements DisposableBean{\n    @Override\n    public void destroy(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n二、xml形式\n``` java\npublic class Bean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n``` xml\n<bean id=\"bean\" class=\"example.Bean\" \n        init-method=\"init\" \n        destroy-method=\"cleanup\"></bean>\n```\n\n三、注解形式1，@Bean(initMethod=\"init\", destroyMethod=\"cleanup\")\n``` java\npublic class Bean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n\n@Configuration\npublic class MyConfiguration{\n    @Bean(initMethod=\"init\", destroyMethod=\"cleanup\")\n    public Bean bean(){\n        return new Bean();\n    }\n}\n```\n\n四、注解形式2，添加@PostConstruct，@PreDestroy\n``` java\n@Component\npublic class Bean{\n    @PostConstruct\n    public void init(){\n        //执行一些初始化后的工作\n    }\n    @PreDestroy\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n","slug":"14-SpringIoC注解实现","published":1,"updated":"2019-08-27T14:55:45.009Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo3v0002yot3ioxkvzls","content":"<ol>\n<li><a href=\"#id1\">回顾xml方式管理Java Bean</a></li>\n<li><a href=\"#id2\">注解方式管理Java Bean</a></li>\n<li><a href=\"#id3\">注解方式Bean的注入</a></li>\n<li><a href=\"#id4\">注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-回顾xml方式管理Java-Bean\"><a href=\"#1-回顾xml方式管理Java-Bean\" class=\"headerlink\" title=\"1. 回顾xml方式管理Java Bean\"></a>1. 回顾xml方式管理Java Bean</h3><ol>\n<li>将一个Bean交由Spring创建并管理<ul>\n<li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li>\n</ul>\n</li>\n<li>获取Spring上下文<ul>\n<li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li>\n</ul>\n</li>\n<li>获取Bean<ul>\n<li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-注解方式管理Java-Bean\"><a href=\"#2-注解方式管理Java-Bean\" class=\"headerlink\" title=\"2. 注解方式管理Java Bean\"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将一个Bean交由Spring创建并管理</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean <span class=\"title\">bean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean = <span class=\"keyword\">new</span> Bean();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、获取Spring上下文</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure>\n\n<p>三、获取Bean</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bean1 bean1 = context.getBean(<span class=\"string\">\"bean1\"</span>, Bean1.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-简化注解方式的步骤1\"><a href=\"#2-1-简化注解方式的步骤1\" class=\"headerlink\" title=\"2.1 简化注解方式的步骤1\"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">//该注解可理解当前class等同于一个xml文件</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>) <span class=\"comment\">//开启组件扫描</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p>\n</blockquote>\n<p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"bean1\"</span>)<span class=\"comment\">//通过构造方法实例化Bean1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p>\n<ul>\n<li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li>\n<li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li>\n<li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 </li>\n</ul>\n</blockquote>\n<h4 id=\"2-2-Bean别名\"><a href=\"#2-2-Bean别名\" class=\"headerlink\" title=\"2.2 Bean别名\"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bean2,bean3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com...Bean\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">alias</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"bean4\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>二、 注解形式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=&#123;<span class=\"string\">\"bean1\"</span>,<span class=\"string\">\"bean2\"</span>,<span class=\"string\">\"bean3\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-注解方式Bean的注入\"><a href=\"#3-注解方式Bean的注入\" class=\"headerlink\" title=\"3. 注解方式Bean的注入\"></a>3. 注解方式Bean的注入</h3><p>一、 <strong><code>@Value(&quot;值&quot;)</code></strong>：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"张三\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、 <strong><code>@Autowired</code></strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在<strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"张三\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于成员变量 */</span></span><br><span class=\"line\">    <span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">    <span class=\"comment\">//@Qualifier(\"card1\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于构造方法 */</span></span><br><span class=\"line\">    <span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Player</span><span class=\"params\">(Card card)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.card = card;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于setter方法 */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCard</span><span class=\"params\">(Card card)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.card = card;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三、 <strong><code>@Resource</code></strong>：常用于复杂类型值的注入<br>    + @Resource：用在<strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span>(name=<span class=\"string\">\"card\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>集合类型值注入实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">list</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"aaa\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"bbb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等\"><a href=\"#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等\" class=\"headerlink\" title=\"4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)\"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id=\"4-1-注解方式Bean的作用域\"><a href=\"#4-1-注解方式Bean的作用域\" class=\"headerlink\" title=\"4.1 注解方式Bean的作用域\"></a>4.1 注解方式Bean的作用域</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Scope</span>(<span class=\"string\">\"singleton\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"singleton\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-注解方式Bean的懒加载\"><a href=\"#4-2-注解方式Bean的懒加载\" class=\"headerlink\" title=\"4.2 注解方式Bean的懒加载\"></a>4.2 注解方式Bean的懒加载</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Lazy</span> <span class=\"comment\">//相当于xml中default-lazy-init=\"true\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-Bean初始化和销毁\"><a href=\"#4-3-Bean初始化和销毁\" class=\"headerlink\" title=\"4.3 Bean初始化和销毁\"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> <span class=\"keyword\">implements</span> <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、xml形式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Bean\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"cleanup\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(initMethod=<span class=\"string\">\"init\"</span>, destroyMethod=<span class=\"string\">\"cleanup\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean <span class=\"title\">bean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bean();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>四、注解形式2，添加@PostConstruct，@PreDestroy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><a href=\"#id1\">回顾xml方式管理Java Bean</a></li>\n<li><a href=\"#id2\">注解方式管理Java Bean</a></li>\n<li><a href=\"#id3\">注解方式Bean的注入</a></li>\n<li><a href=\"#id4\">注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-回顾xml方式管理Java-Bean\"><a href=\"#1-回顾xml方式管理Java-Bean\" class=\"headerlink\" title=\"1. 回顾xml方式管理Java Bean\"></a>1. 回顾xml方式管理Java Bean</h3><ol>\n<li>将一个Bean交由Spring创建并管理<ul>\n<li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li>\n</ul>\n</li>\n<li>获取Spring上下文<ul>\n<li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li>\n</ul>\n</li>\n<li>获取Bean<ul>\n<li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-注解方式管理Java-Bean\"><a href=\"#2-注解方式管理Java-Bean\" class=\"headerlink\" title=\"2. 注解方式管理Java Bean\"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//将一个Bean交由Spring创建并管理</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean <span class=\"title\">bean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean = <span class=\"keyword\">new</span> Bean();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、获取Spring上下文</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(MyConfiguration.class);</span><br></pre></td></tr></table></figure>\n\n<p>三、获取Bean</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Bean1 bean1 = context.getBean(<span class=\"string\">\"bean1\"</span>, Bean1.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-1-简化注解方式的步骤1\"><a href=\"#2-1-简化注解方式的步骤1\" class=\"headerlink\" title=\"2.1 简化注解方式的步骤1\"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">//该注解可理解当前class等同于一个xml文件</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>) <span class=\"comment\">//开启组件扫描</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p>\n</blockquote>\n<p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span>(<span class=\"string\">\"bean1\"</span>)<span class=\"comment\">//通过构造方法实例化Bean1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p>\n<ul>\n<li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li>\n<li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li>\n<li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 </li>\n</ul>\n</blockquote>\n<h4 id=\"2-2-Bean别名\"><a href=\"#2-2-Bean别名\" class=\"headerlink\" title=\"2.2 Bean别名\"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bean2,bean3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com...Bean\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">alias</span> <span class=\"attr\">name</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"bean4\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>二、 注解形式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=&#123;<span class=\"string\">\"bean1\"</span>,<span class=\"string\">\"bean2\"</span>,<span class=\"string\">\"bean3\"</span>&#125;)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-注解方式Bean的注入\"><a href=\"#3-注解方式Bean的注入\" class=\"headerlink\" title=\"3. 注解方式Bean的注入\"></a>3. 注解方式Bean的注入</h3><p>一、 <strong><code>@Value(&quot;值&quot;)</code></strong>：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"张三\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、 <strong><code>@Autowired</code></strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在<strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value</span>(<span class=\"string\">\"张三\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于成员变量 */</span></span><br><span class=\"line\">    <span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">    <span class=\"comment\">//@Qualifier(\"card1\")</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于构造方法 */</span></span><br><span class=\"line\">    <span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Player</span><span class=\"params\">(Card card)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.card = card;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 用于setter方法 */</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>(required=<span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCard</span><span class=\"params\">(Card card)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.card = card;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>三、 <strong><code>@Resource</code></strong>：常用于复杂类型值的注入<br>    + @Resource：用在<strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span>(name=<span class=\"string\">\"card\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Card card;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>集合类型值注入实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">list</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"aaa\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"bbb\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;String&gt; list;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等\"><a href=\"#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等\" class=\"headerlink\" title=\"4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)\"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id=\"4-1-注解方式Bean的作用域\"><a href=\"#4-1-注解方式Bean的作用域\" class=\"headerlink\" title=\"4.1 注解方式Bean的作用域\"></a>4.1 注解方式Bean的作用域</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Scope</span>(<span class=\"string\">\"singleton\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope</span>(<span class=\"string\">\"singleton\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-注解方式Bean的懒加载\"><a href=\"#4-2-注解方式Bean的懒加载\" class=\"headerlink\" title=\"4.2 注解方式Bean的懒加载\"></a>4.2 注解方式Bean的懒加载</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"包路径\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Lazy</span> <span class=\"comment\">//相当于xml中default-lazy-init=\"true\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name=<span class=\"string\">\"bean1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Lazy</span> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean1 <span class=\"title\">bean1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Bean1 = <span class=\"keyword\">new</span> Bean1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-Bean初始化和销毁\"><a href=\"#4-3-Bean初始化和销毁\" class=\"headerlink\" title=\"4.3 Bean初始化和销毁\"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span> <span class=\"keyword\">implements</span> <span class=\"title\">DisposableBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二、xml形式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.Bean\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"cleanup\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>三、注解形式1，@Bean(initMethod=”init”, destroyMethod=”cleanup”)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(initMethod=<span class=\"string\">\"init\"</span>, destroyMethod=<span class=\"string\">\"cleanup\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Bean <span class=\"title\">bean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bean();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>四、注解形式2，添加@PostConstruct，@PreDestroy</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"十五、SpringJDBC详解","date":"2019-08-27T14:46:07.000Z","_content":"\nSpring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的**声明式**事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。\n<!-- more -->\n\n1. [数据源配置](#id1)\n2. [JdbcTemplate的使用](#id2)\n3. [通过实现RowMapper接口把查询结果映射到Java对象](#id3)\n4. [JdbcTemplate对象的主要方法](#id4)\n5. [异常转换](#id5)\n\n\n<span id=\"id1\"><span>\n### 1. 数据源配置\n``` java\n@Configuration\n@ComponentScan(\"com.jdbc\")\npublic class MyConfiguration {\n    @Bean\n    public DataSource mysqlDataSource() {\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"123456\");\n        return dataSource;\n    }\n    @Bean\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(mysqlDataSource());\n    }\n}\n```\n\n也可以使用XML配置来实现配置效果：\n``` xml\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n<!-- 定义jdbcTemplate对象 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n    <constructor-arg index=\"0\" ref=\"dataSource\"></constructor-arg>\n</bean>\n<!-- 开启组件扫描 -->\n<context:component-scan base-package=\"com.jdbc\"></context:component-scan>\n```\n\n\n<span id=\"id2\"><span>\n### 2. JdbcTemplate的使用\nJdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。\nJdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。\n\n基本的查询：\n``` java\n//DAO实现类\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public int getCount() {\n        String sql = \"select count(*) from emp32\";\n        return jdbcTemplate.queryForObject(sql, Integer.class);\n    }\n//...\n```\n\n\n<span id=\"id3\"><span>\n### 3. 通过实现RowMapper接口把查询结果映射到Java对象\n``` java\npublic class EmpRowMapper implements RowMapper<Emp> {\n    @Override\n    public Emp mapRow(ResultSet rs, int n) throws SQLException {\n        return new Emp(\n            rs.getInt(\"id\"),\n            rs.getString(\"name\"),\n            rs.getDouble(\"salary\")\n        );\n    }\n}\n```\n\n``` java\n//DAO实现类\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public Emp getEmpById(int id) {\n        String sql = \"select * from emp32 where id=?\";\n        return jdbcTemplate.queryForObject(sql, new EmpRowMapper(), id);\n    }\n//...\n```\n\n\n<span id=\"id4\"><span>\n### 4. JdbcTemplate对象的主要方法 \n1. queryForInt()：\n``` java\n//查询一个整数类型\nint count = jdbcTemplateObject.queryForInt(\"select count(*) from emp32\");\n\n//一个使用绑定变量的简单查询\nint age = jdbcTemplateObject.queryForInt(\"select age from emp32 where id = ?\", new Object[]{10});\n```\n\n2. queryForLong()：\n``` java\n//查询一个 long类型\nlong count = jdbcTemplateObject.queryForLong(\"select count(*) from emp32\");\n```\n\n3. queryForObject()：\n``` java\n//查询字符串\nString SQL = \"select name from emp32 where id = ?\";\nString name = jdbcTemplateObject.queryForObject(SQL, new Object[]{10}, String.class);\n\n//查询并返回一个对象：\nString SQL = \"select * from emp32 where id = ?\";\nemp32 student = jdbcTemplateObject.queryForObject(SQL, new Object[]{10}, new EmpRowMapper());\n\n//查询并返回多个对象：\nString SQL = \"select * from emp32\";\nList<emp32> students = jdbcTemplateObject.query(SQL, new EmpRowMapper());\n```\n\n\n4. update()：\n``` java\n//在表中插入一行：\nString SQL = \"insert into emp32 (name, age) values (?, ?)\";\njdbcTemplateObject.update( SQL, new Object[]{\"Zara\", 11} );\n\n//更新表中的一行：\nString SQL = \"update emp32 set name = ? where id = ?\";\njdbcTemplateObject.update( SQL, new Object[]{\"Zara\", 10} );\n\n//从表中删除一行：\nString SQL = \"delete emp32 where id = ?\";\njdbcTemplateObject.update( SQL, new Object[]{20} );\n```\n\n5. execute()：执行DDL语句\n``` java\nString SQL = \"CREATE TABLE emp32(\n\tid\t\tINT AUTO_INCREMENT,\n\tNAME\tVARCHAR(30),\n\tsalary\tDOUBLE DEFAULT 5000,\n\tCONSTRAINT student_id_pk PRIMARY KEY(id),\n\tCONSTRAINT student_name_uk UNIQUE(NAME)\n)\";\njdbcTemplateObject.execute( SQL );\n```\n\n\n<span id=\"id5\"><span>\n### 5. 异常转换\n- Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。\n- 所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。\n- 这样可以使异常处理机制独立于当前使用的具体数据库。\n- 除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。\n\n例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：\n``` java\npublic class CustomSQLErrorCodeTranslator extends SQLErrorCodeSQLExceptionTranslator {\n    @Override\n    protected DataAccessException customTranslate\n      (String task, String sql, SQLException sqlException) {\n        if (sqlException.getErrorCode() == -104) {\n            return new DuplicateKeyException(\"完整性约束冲突\", sqlException);\n        }\n        return null;\n    }\n}\n```\n\n\n","source":"_posts/15-SpringJDBC详解.md","raw":"---\ntitle: 十五、SpringJDBC详解\ndate: 2019-08-27 22:46:07\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nSpring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的**声明式**事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。\n<!-- more -->\n\n1. [数据源配置](#id1)\n2. [JdbcTemplate的使用](#id2)\n3. [通过实现RowMapper接口把查询结果映射到Java对象](#id3)\n4. [JdbcTemplate对象的主要方法](#id4)\n5. [异常转换](#id5)\n\n\n<span id=\"id1\"><span>\n### 1. 数据源配置\n``` java\n@Configuration\n@ComponentScan(\"com.jdbc\")\npublic class MyConfiguration {\n    @Bean\n    public DataSource mysqlDataSource() {\n        BasicDataSource dataSource = new BasicDataSource();\n        dataSource.setDriverClassName(\"com.mysql.cj.jdbc.Driver\");\n        dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"123456\");\n        return dataSource;\n    }\n    @Bean\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(mysqlDataSource());\n    }\n}\n```\n\n也可以使用XML配置来实现配置效果：\n``` xml\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n<!-- 定义jdbcTemplate对象 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n    <constructor-arg index=\"0\" ref=\"dataSource\"></constructor-arg>\n</bean>\n<!-- 开启组件扫描 -->\n<context:component-scan base-package=\"com.jdbc\"></context:component-scan>\n```\n\n\n<span id=\"id2\"><span>\n### 2. JdbcTemplate的使用\nJdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。\nJdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。\n\n基本的查询：\n``` java\n//DAO实现类\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public int getCount() {\n        String sql = \"select count(*) from emp32\";\n        return jdbcTemplate.queryForObject(sql, Integer.class);\n    }\n//...\n```\n\n\n<span id=\"id3\"><span>\n### 3. 通过实现RowMapper接口把查询结果映射到Java对象\n``` java\npublic class EmpRowMapper implements RowMapper<Emp> {\n    @Override\n    public Emp mapRow(ResultSet rs, int n) throws SQLException {\n        return new Emp(\n            rs.getInt(\"id\"),\n            rs.getString(\"name\"),\n            rs.getDouble(\"salary\")\n        );\n    }\n}\n```\n\n``` java\n//DAO实现类\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    @Override\n    public Emp getEmpById(int id) {\n        String sql = \"select * from emp32 where id=?\";\n        return jdbcTemplate.queryForObject(sql, new EmpRowMapper(), id);\n    }\n//...\n```\n\n\n<span id=\"id4\"><span>\n### 4. JdbcTemplate对象的主要方法 \n1. queryForInt()：\n``` java\n//查询一个整数类型\nint count = jdbcTemplateObject.queryForInt(\"select count(*) from emp32\");\n\n//一个使用绑定变量的简单查询\nint age = jdbcTemplateObject.queryForInt(\"select age from emp32 where id = ?\", new Object[]{10});\n```\n\n2. queryForLong()：\n``` java\n//查询一个 long类型\nlong count = jdbcTemplateObject.queryForLong(\"select count(*) from emp32\");\n```\n\n3. queryForObject()：\n``` java\n//查询字符串\nString SQL = \"select name from emp32 where id = ?\";\nString name = jdbcTemplateObject.queryForObject(SQL, new Object[]{10}, String.class);\n\n//查询并返回一个对象：\nString SQL = \"select * from emp32 where id = ?\";\nemp32 student = jdbcTemplateObject.queryForObject(SQL, new Object[]{10}, new EmpRowMapper());\n\n//查询并返回多个对象：\nString SQL = \"select * from emp32\";\nList<emp32> students = jdbcTemplateObject.query(SQL, new EmpRowMapper());\n```\n\n\n4. update()：\n``` java\n//在表中插入一行：\nString SQL = \"insert into emp32 (name, age) values (?, ?)\";\njdbcTemplateObject.update( SQL, new Object[]{\"Zara\", 11} );\n\n//更新表中的一行：\nString SQL = \"update emp32 set name = ? where id = ?\";\njdbcTemplateObject.update( SQL, new Object[]{\"Zara\", 10} );\n\n//从表中删除一行：\nString SQL = \"delete emp32 where id = ?\";\njdbcTemplateObject.update( SQL, new Object[]{20} );\n```\n\n5. execute()：执行DDL语句\n``` java\nString SQL = \"CREATE TABLE emp32(\n\tid\t\tINT AUTO_INCREMENT,\n\tNAME\tVARCHAR(30),\n\tsalary\tDOUBLE DEFAULT 5000,\n\tCONSTRAINT student_id_pk PRIMARY KEY(id),\n\tCONSTRAINT student_name_uk UNIQUE(NAME)\n)\";\njdbcTemplateObject.execute( SQL );\n```\n\n\n<span id=\"id5\"><span>\n### 5. 异常转换\n- Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。\n- 所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。\n- 这样可以使异常处理机制独立于当前使用的具体数据库。\n- 除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。\n\n例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：\n``` java\npublic class CustomSQLErrorCodeTranslator extends SQLErrorCodeSQLExceptionTranslator {\n    @Override\n    protected DataAccessException customTranslate\n      (String task, String sql, SQLException sqlException) {\n        if (sqlException.getErrorCode() == -104) {\n            return new DuplicateKeyException(\"完整性约束冲突\", sqlException);\n        }\n        return null;\n    }\n}\n```\n\n\n","slug":"15-SpringJDBC详解","published":1,"updated":"2019-08-27T14:55:39.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo440005yot38c0vif3e","content":"<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">数据源配置</a></li>\n<li><a href=\"#id2\">JdbcTemplate的使用</a></li>\n<li><a href=\"#id3\">通过实现RowMapper接口把查询结果映射到Java对象</a></li>\n<li><a href=\"#id4\">JdbcTemplate对象的主要方法</a></li>\n<li><a href=\"#id5\">异常转换</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据源配置\"><a href=\"#1-数据源配置\" class=\"headerlink\" title=\"1. 数据源配置\"></a>1. 数据源配置</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"com.jdbc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">mysqlDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        BasicDataSource dataSource = <span class=\"keyword\">new</span> BasicDataSource();</span><br><span class=\"line\">        dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>);</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(mysqlDataSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用XML配置来实现配置效果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.jdbc\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-JdbcTemplate的使用\"><a href=\"#2-JdbcTemplate的使用\" class=\"headerlink\" title=\"2. JdbcTemplate的使用\"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p>\n<p>基本的查询：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DAO实现类</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String sql = <span class=\"string\">\"select count(*) from emp32\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-通过实现RowMapper接口把查询结果映射到Java对象\"><a href=\"#3-通过实现RowMapper接口把查询结果映射到Java对象\" class=\"headerlink\" title=\"3. 通过实现RowMapper接口把查询结果映射到Java对象\"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">Emp</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Emp(</span><br><span class=\"line\">            rs.getInt(<span class=\"string\">\"id\"</span>),</span><br><span class=\"line\">            rs.getString(<span class=\"string\">\"name\"</span>),</span><br><span class=\"line\">            rs.getDouble(<span class=\"string\">\"salary\"</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DAO实现类</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">getEmpById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        String sql = <span class=\"string\">\"select * from emp32 where id=?\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(sql, <span class=\"keyword\">new</span> EmpRowMapper(), id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-JdbcTemplate对象的主要方法\"><a href=\"#4-JdbcTemplate对象的主要方法\" class=\"headerlink\" title=\"4. JdbcTemplate对象的主要方法\"></a>4. JdbcTemplate对象的主要方法</h3><ol>\n<li><p>queryForInt()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询一个整数类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = jdbcTemplateObject.queryForInt(<span class=\"string\">\"select count(*) from emp32\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一个使用绑定变量的简单查询</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> age = jdbcTemplateObject.queryForInt(<span class=\"string\">\"select age from emp32 where id = ?\"</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>queryForLong()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询一个 long类型</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> count = jdbcTemplateObject.queryForLong(<span class=\"string\">\"select count(*) from emp32\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>queryForObject()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询字符串</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select name from emp32 where id = ?\"</span>;</span><br><span class=\"line\">String name = jdbcTemplateObject.queryForObject(SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询并返回一个对象：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select * from emp32 where id = ?\"</span>;</span><br><span class=\"line\">emp32 student = jdbcTemplateObject.queryForObject(SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;, <span class=\"keyword\">new</span> EmpRowMapper());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询并返回多个对象：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select * from emp32\"</span>;</span><br><span class=\"line\">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class=\"keyword\">new</span> EmpRowMapper());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>update()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在表中插入一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"insert into emp32 (name, age) values (?, ?)\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"Zara\"</span>, <span class=\"number\">11</span>&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新表中的一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"update emp32 set name = ? where id = ?\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"Zara\"</span>, <span class=\"number\">10</span>&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从表中删除一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"delete emp32 where id = ?\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">20</span>&#125; );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>execute()：执行DDL语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String SQL = <span class=\"string\">\"CREATE TABLE emp32(</span></span><br><span class=\"line\"><span class=\"string\">\tid\t\tINT AUTO_INCREMENT,</span></span><br><span class=\"line\"><span class=\"string\">\tNAME\tVARCHAR(30),</span></span><br><span class=\"line\"><span class=\"string\">\tsalary\tDOUBLE DEFAULT 5000,</span></span><br><span class=\"line\"><span class=\"string\">\tCONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class=\"line\"><span class=\"string\">\tCONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class=\"line\"><span class=\"string\">)\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常转换\"><a href=\"#5-异常转换\" class=\"headerlink\" title=\"5. 异常转换\"></a>5. 异常转换</h3><ul>\n<li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li>\n<li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li>\n<li>这样可以使异常处理机制独立于当前使用的具体数据库。</li>\n<li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li>\n</ul>\n<p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomSQLErrorCodeTranslator</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLErrorCodeSQLExceptionTranslator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> DataAccessException customTranslate</span><br><span class=\"line\">      (String task, String sql, SQLException sqlException) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sqlException.getErrorCode() == -<span class=\"number\">104</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DuplicateKeyException(<span class=\"string\">\"完整性约束冲突\"</span>, sqlException);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p>","more":"<ol>\n<li><a href=\"#id1\">数据源配置</a></li>\n<li><a href=\"#id2\">JdbcTemplate的使用</a></li>\n<li><a href=\"#id3\">通过实现RowMapper接口把查询结果映射到Java对象</a></li>\n<li><a href=\"#id4\">JdbcTemplate对象的主要方法</a></li>\n<li><a href=\"#id5\">异常转换</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据源配置\"><a href=\"#1-数据源配置\" class=\"headerlink\" title=\"1. 数据源配置\"></a>1. 数据源配置</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(<span class=\"string\">\"com.jdbc\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfiguration</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">mysqlDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        BasicDataSource dataSource = <span class=\"keyword\">new</span> BasicDataSource();</span><br><span class=\"line\">        dataSource.setDriverClassName(<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>);</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JdbcTemplate <span class=\"title\">jdbcTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTemplate(mysqlDataSource());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以使用XML配置来实现配置效果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.jdbc\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-JdbcTemplate的使用\"><a href=\"#2-JdbcTemplate的使用\" class=\"headerlink\" title=\"2. JdbcTemplate的使用\"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p>\n<p>基本的查询：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DAO实现类</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String sql = <span class=\"string\">\"select count(*) from emp32\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-通过实现RowMapper接口把查询结果映射到Java对象\"><a href=\"#3-通过实现RowMapper接口把查询结果映射到Java对象\" class=\"headerlink\" title=\"3. 通过实现RowMapper接口把查询结果映射到Java对象\"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">Emp</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs, <span class=\"keyword\">int</span> n)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Emp(</span><br><span class=\"line\">            rs.getInt(<span class=\"string\">\"id\"</span>),</span><br><span class=\"line\">            rs.getString(<span class=\"string\">\"name\"</span>),</span><br><span class=\"line\">            rs.getDouble(<span class=\"string\">\"salary\"</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//DAO实现类</span></span><br><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">getEmpById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        String sql = <span class=\"string\">\"select * from emp32 where id=?\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(sql, <span class=\"keyword\">new</span> EmpRowMapper(), id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-JdbcTemplate对象的主要方法\"><a href=\"#4-JdbcTemplate对象的主要方法\" class=\"headerlink\" title=\"4. JdbcTemplate对象的主要方法\"></a>4. JdbcTemplate对象的主要方法</h3><ol>\n<li><p>queryForInt()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询一个整数类型</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> count = jdbcTemplateObject.queryForInt(<span class=\"string\">\"select count(*) from emp32\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一个使用绑定变量的简单查询</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> age = jdbcTemplateObject.queryForInt(<span class=\"string\">\"select age from emp32 where id = ?\"</span>, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>queryForLong()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询一个 long类型</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> count = jdbcTemplateObject.queryForLong(<span class=\"string\">\"select count(*) from emp32\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>queryForObject()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询字符串</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select name from emp32 where id = ?\"</span>;</span><br><span class=\"line\">String name = jdbcTemplateObject.queryForObject(SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询并返回一个对象：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select * from emp32 where id = ?\"</span>;</span><br><span class=\"line\">emp32 student = jdbcTemplateObject.queryForObject(SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">10</span>&#125;, <span class=\"keyword\">new</span> EmpRowMapper());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询并返回多个对象：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"select * from emp32\"</span>;</span><br><span class=\"line\">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class=\"keyword\">new</span> EmpRowMapper());</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>update()：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在表中插入一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"insert into emp32 (name, age) values (?, ?)\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"Zara\"</span>, <span class=\"number\">11</span>&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//更新表中的一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"update emp32 set name = ? where id = ?\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">\"Zara\"</span>, <span class=\"number\">10</span>&#125; );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从表中删除一行：</span></span><br><span class=\"line\">String SQL = <span class=\"string\">\"delete emp32 where id = ?\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.update( SQL, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"number\">20</span>&#125; );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>execute()：执行DDL语句</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String SQL = <span class=\"string\">\"CREATE TABLE emp32(</span></span><br><span class=\"line\"><span class=\"string\">\tid\t\tINT AUTO_INCREMENT,</span></span><br><span class=\"line\"><span class=\"string\">\tNAME\tVARCHAR(30),</span></span><br><span class=\"line\"><span class=\"string\">\tsalary\tDOUBLE DEFAULT 5000,</span></span><br><span class=\"line\"><span class=\"string\">\tCONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class=\"line\"><span class=\"string\">\tCONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class=\"line\"><span class=\"string\">)\"</span>;</span><br><span class=\"line\">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常转换\"><a href=\"#5-异常转换\" class=\"headerlink\" title=\"5. 异常转换\"></a>5. 异常转换</h3><ul>\n<li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li>\n<li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li>\n<li>这样可以使异常处理机制独立于当前使用的具体数据库。</li>\n<li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li>\n</ul>\n<p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomSQLErrorCodeTranslator</span> <span class=\"keyword\">extends</span> <span class=\"title\">SQLErrorCodeSQLExceptionTranslator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> DataAccessException customTranslate</span><br><span class=\"line\">      (String task, String sql, SQLException sqlException) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sqlException.getErrorCode() == -<span class=\"number\">104</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DuplicateKeyException(<span class=\"string\">\"完整性约束冲突\"</span>, sqlException);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"十七、Spring面向切面编程(AOP模块)","date":"2019-08-27T14:48:36.000Z","_content":"\nAOP（Aspect Oriented Programming）：面向切面编程，\n它是面向对象基础上发展来的技术，是面向对象更高层次的应用，\n它可以在不修改原有代码的情况给组件增强功能。\n<!-- more -->\n\n1. [AOP涉及到的概念](#id1)\n2. [编写AOP程序步骤](#id2)\n3. [切点表达式](#id3)\n4. [通知的五种类型](#id4)\n5. [标注形式AOP步骤](#id5)\n6. [AOP 通知对应的标注](#id6)\n7. [@Around具体用法](#id7)\n8. [异常通知](#id8)\n\n\n<span id=\"id1\"><span>\n### 1. AOP涉及到的概念\n- Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。\n- JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）\n- Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点\n- Target：目标，要被切入共通业务逻辑的对象\n- Proxy：代理，被增强之后的目标对象就是代理\n- Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常\n\n\n<span id=\"id2\"><span>\n### 2. 编写AOP程序步骤\n1. 编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法\n2. 在不修改登录和注册原有代码的情况下，让两个方法调用前输出`******`\n    1. 添加aop的jar包到lib\n    2. 编写一个类，定义共同业务逻辑\n    3. 配置aplicationContext.xml，创建切面对象\n    4. 配置aop:config，切面-->通知-->切点\n\n\n<span id=\"id3\"><span>\n### 3. 切点表达式\n1. Bean限定表达式\n    - `bean(\"容器内组件id\")`，支持通配符*，如：`bean(\"*Dao\")`，`bean(\"acc*\")`\n2. 类型限定表达式\n    - `within(\"包名.类型\")`，要求表达式最后一部分必须是类型，如：`com.dao.impl.类型`，`com.dao.impl.*`，`com.dao..*`\n3. 方法限定表达式\n    - `execution(\"表达式\")`，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:`返回值类型 方法名()`\n\n\n<span id=\"id4\"><span>\n### 4. 通知的五种类型\n1. `<aop:before`：前置通知，目标方法执行之前调用\n2. `<aop:after-returning`：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）\n3. `<aop:after-throwing`：异常通知，目标方法出异常才调用\n4. `<aop:after`：最终通知，目标方法之后**一定**会执行\n5. `<aop:around`：环绕通知，目标方法执行前后都调用\n\n\n<span id=\"id5\"><span>\n### 5. 标注形式AOP步骤\n1. 建项目，添加jar包(ioc,aop)，src下添加配置文件\n2. 编写一个Sevice类，里面有登录和注册两个方法\n3. 开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑\n4. 定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象\n5. 开启标注形式aop：`<aop:aspectj-autoproxy proxy-target-class=\"true|false\" />`\n6. 使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： `@Aspect，@Before...`\n\n\n<span id=\"id6\"><span>\n### 6. AOP 通知对应的标注\n1. `@Before`：前置通知，目标方法执行之前调用\n2. `@AfterReturning`：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）\n3. `@AfterThrowing`：异常通知，目标方法出异常才调用\n4. `@After`：最终通知，目标方法之后**一定**会执行\n5. `@Around`：环绕通知，目标方法执行前后都调用\n\n\n<span id=\"id7\"><span>\n### 7. @Around具体用法\n@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；\n``` java\n@Around(\"within(com..*)\")\npublic Object showAfterDate(ProceedingJoinPoint pjp) throws Throwable {\n    System.out.println(\"开始时间：\" + new Date().getTime());\n    Object obj = pjp.proceed();\n    System.out.println(\"结束时间：\" + new Date().getTime());\n    System.out.println(\"执行时间：\"date2.getTime() - date.getTime());\n    return obj;\n}\n```\n>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。\n\n\n<span id=\"id8\"><span>\n### 8. 异常通知\nJoinPoint可以获取出异常的方法\n``` java\n@AfterThrowing(value=\"within(com..*)\", throwing=\"e\")\npublic void processException(JoinPoint jp, Exception e) {\n    System.out.println(\"捕获到异常\" + jp.getSignature() + \":\\n【\" + e +\"】\");\n}\n```","source":"_posts/17-Spring面向切面编程AOP.md","raw":"---\ntitle: 十七、Spring面向切面编程(AOP模块)\ndate: 2019-08-27 22:48:36\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nAOP（Aspect Oriented Programming）：面向切面编程，\n它是面向对象基础上发展来的技术，是面向对象更高层次的应用，\n它可以在不修改原有代码的情况给组件增强功能。\n<!-- more -->\n\n1. [AOP涉及到的概念](#id1)\n2. [编写AOP程序步骤](#id2)\n3. [切点表达式](#id3)\n4. [通知的五种类型](#id4)\n5. [标注形式AOP步骤](#id5)\n6. [AOP 通知对应的标注](#id6)\n7. [@Around具体用法](#id7)\n8. [异常通知](#id8)\n\n\n<span id=\"id1\"><span>\n### 1. AOP涉及到的概念\n- Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。\n- JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）\n- Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点\n- Target：目标，要被切入共通业务逻辑的对象\n- Proxy：代理，被增强之后的目标对象就是代理\n- Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常\n\n\n<span id=\"id2\"><span>\n### 2. 编写AOP程序步骤\n1. 编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法\n2. 在不修改登录和注册原有代码的情况下，让两个方法调用前输出`******`\n    1. 添加aop的jar包到lib\n    2. 编写一个类，定义共同业务逻辑\n    3. 配置aplicationContext.xml，创建切面对象\n    4. 配置aop:config，切面-->通知-->切点\n\n\n<span id=\"id3\"><span>\n### 3. 切点表达式\n1. Bean限定表达式\n    - `bean(\"容器内组件id\")`，支持通配符*，如：`bean(\"*Dao\")`，`bean(\"acc*\")`\n2. 类型限定表达式\n    - `within(\"包名.类型\")`，要求表达式最后一部分必须是类型，如：`com.dao.impl.类型`，`com.dao.impl.*`，`com.dao..*`\n3. 方法限定表达式\n    - `execution(\"表达式\")`，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:`返回值类型 方法名()`\n\n\n<span id=\"id4\"><span>\n### 4. 通知的五种类型\n1. `<aop:before`：前置通知，目标方法执行之前调用\n2. `<aop:after-returning`：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）\n3. `<aop:after-throwing`：异常通知，目标方法出异常才调用\n4. `<aop:after`：最终通知，目标方法之后**一定**会执行\n5. `<aop:around`：环绕通知，目标方法执行前后都调用\n\n\n<span id=\"id5\"><span>\n### 5. 标注形式AOP步骤\n1. 建项目，添加jar包(ioc,aop)，src下添加配置文件\n2. 编写一个Sevice类，里面有登录和注册两个方法\n3. 开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑\n4. 定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象\n5. 开启标注形式aop：`<aop:aspectj-autoproxy proxy-target-class=\"true|false\" />`\n6. 使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： `@Aspect，@Before...`\n\n\n<span id=\"id6\"><span>\n### 6. AOP 通知对应的标注\n1. `@Before`：前置通知，目标方法执行之前调用\n2. `@AfterReturning`：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）\n3. `@AfterThrowing`：异常通知，目标方法出异常才调用\n4. `@After`：最终通知，目标方法之后**一定**会执行\n5. `@Around`：环绕通知，目标方法执行前后都调用\n\n\n<span id=\"id7\"><span>\n### 7. @Around具体用法\n@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；\n``` java\n@Around(\"within(com..*)\")\npublic Object showAfterDate(ProceedingJoinPoint pjp) throws Throwable {\n    System.out.println(\"开始时间：\" + new Date().getTime());\n    Object obj = pjp.proceed();\n    System.out.println(\"结束时间：\" + new Date().getTime());\n    System.out.println(\"执行时间：\"date2.getTime() - date.getTime());\n    return obj;\n}\n```\n>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。\n\n\n<span id=\"id8\"><span>\n### 8. 异常通知\nJoinPoint可以获取出异常的方法\n``` java\n@AfterThrowing(value=\"within(com..*)\", throwing=\"e\")\npublic void processException(JoinPoint jp, Exception e) {\n    System.out.println(\"捕获到异常\" + jp.getSignature() + \":\\n【\" + e +\"】\");\n}\n```","slug":"17-Spring面向切面编程AOP","published":1,"updated":"2019-08-27T14:55:22.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo460006yot35ah1y69o","content":"<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">AOP涉及到的概念</a></li>\n<li><a href=\"#id2\">编写AOP程序步骤</a></li>\n<li><a href=\"#id3\">切点表达式</a></li>\n<li><a href=\"#id4\">通知的五种类型</a></li>\n<li><a href=\"#id5\">标注形式AOP步骤</a></li>\n<li><a href=\"#id6\">AOP 通知对应的标注</a></li>\n<li><a href=\"#id7\">@Around具体用法</a></li>\n<li><a href=\"#id8\">异常通知</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-AOP涉及到的概念\"><a href=\"#1-AOP涉及到的概念\" class=\"headerlink\" title=\"1. AOP涉及到的概念\"></a>1. AOP涉及到的概念</h3><ul>\n<li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li>\n<li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li>\n<li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li>\n<li>Target：目标，要被切入共通业务逻辑的对象</li>\n<li>Proxy：代理，被增强之后的目标对象就是代理</li>\n<li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-编写AOP程序步骤\"><a href=\"#2-编写AOP程序步骤\" class=\"headerlink\" title=\"2. 编写AOP程序步骤\"></a>2. 编写AOP程序步骤</h3><ol>\n<li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li>\n<li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol>\n<li>添加aop的jar包到lib</li>\n<li>编写一个类，定义共同业务逻辑</li>\n<li>配置aplicationContext.xml，创建切面对象</li>\n<li>配置aop:config，切面–&gt;通知–&gt;切点</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-切点表达式\"><a href=\"#3-切点表达式\" class=\"headerlink\" title=\"3. 切点表达式\"></a>3. 切点表达式</h3><ol>\n<li>Bean限定表达式<ul>\n<li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符<em>，如：<code>bean(&quot;*Dao&quot;)</code>，`bean(“acc</em>“)`</li>\n</ul>\n</li>\n<li>类型限定表达式<ul>\n<li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li>\n</ul>\n</li>\n<li>方法限定表达式<ul>\n<li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-通知的五种类型\"><a href=\"#4-通知的五种类型\" class=\"headerlink\" title=\"4. 通知的五种类型\"></a>4. 通知的五种类型</h3><ol>\n<li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li>\n<li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>\n<li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li>\n<li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>\n<li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-标注形式AOP步骤\"><a href=\"#5-标注形式AOP步骤\" class=\"headerlink\" title=\"5. 标注形式AOP步骤\"></a>5. 标注形式AOP步骤</h3><ol>\n<li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li>\n<li>编写一个Sevice类，里面有登录和注册两个方法</li>\n<li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li>\n<li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li>\n<li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li>\n<li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-AOP-通知对应的标注\"><a href=\"#6-AOP-通知对应的标注\" class=\"headerlink\" title=\"6. AOP 通知对应的标注\"></a>6. AOP 通知对应的标注</h3><ol>\n<li><code>@Before</code>：前置通知，目标方法执行之前调用</li>\n<li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>\n<li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li>\n<li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>\n<li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Around具体用法\"><a href=\"#7-Around具体用法\" class=\"headerlink\" title=\"7. @Around具体用法\"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Around</span>(<span class=\"string\">\"within(com..*)\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">showAfterDate</span><span class=\"params\">(ProceedingJoinPoint pjp)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始时间：\"</span> + <span class=\"keyword\">new</span> Date().getTime());</span><br><span class=\"line\">    Object obj = pjp.proceed();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"结束时间：\"</span> + <span class=\"keyword\">new</span> Date().getTime());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"执行时间：\"</span>date2.getTime() - date.getTime());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>\n</blockquote>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-异常通知\"><a href=\"#8-异常通知\" class=\"headerlink\" title=\"8. 异常通知\"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AfterThrowing</span>(value=<span class=\"string\">\"within(com..*)\"</span>, throwing=<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processException</span><span class=\"params\">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"捕获到异常\"</span> + jp.getSignature() + <span class=\"string\">\":\\n【\"</span> + e +<span class=\"string\">\"】\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p>","more":"<ol>\n<li><a href=\"#id1\">AOP涉及到的概念</a></li>\n<li><a href=\"#id2\">编写AOP程序步骤</a></li>\n<li><a href=\"#id3\">切点表达式</a></li>\n<li><a href=\"#id4\">通知的五种类型</a></li>\n<li><a href=\"#id5\">标注形式AOP步骤</a></li>\n<li><a href=\"#id6\">AOP 通知对应的标注</a></li>\n<li><a href=\"#id7\">@Around具体用法</a></li>\n<li><a href=\"#id8\">异常通知</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-AOP涉及到的概念\"><a href=\"#1-AOP涉及到的概念\" class=\"headerlink\" title=\"1. AOP涉及到的概念\"></a>1. AOP涉及到的概念</h3><ul>\n<li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li>\n<li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li>\n<li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li>\n<li>Target：目标，要被切入共通业务逻辑的对象</li>\n<li>Proxy：代理，被增强之后的目标对象就是代理</li>\n<li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-编写AOP程序步骤\"><a href=\"#2-编写AOP程序步骤\" class=\"headerlink\" title=\"2. 编写AOP程序步骤\"></a>2. 编写AOP程序步骤</h3><ol>\n<li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li>\n<li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol>\n<li>添加aop的jar包到lib</li>\n<li>编写一个类，定义共同业务逻辑</li>\n<li>配置aplicationContext.xml，创建切面对象</li>\n<li>配置aop:config，切面–&gt;通知–&gt;切点</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-切点表达式\"><a href=\"#3-切点表达式\" class=\"headerlink\" title=\"3. 切点表达式\"></a>3. 切点表达式</h3><ol>\n<li>Bean限定表达式<ul>\n<li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符<em>，如：<code>bean(&quot;*Dao&quot;)</code>，`bean(“acc</em>“)`</li>\n</ul>\n</li>\n<li>类型限定表达式<ul>\n<li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li>\n</ul>\n</li>\n<li>方法限定表达式<ul>\n<li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-通知的五种类型\"><a href=\"#4-通知的五种类型\" class=\"headerlink\" title=\"4. 通知的五种类型\"></a>4. 通知的五种类型</h3><ol>\n<li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li>\n<li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>\n<li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li>\n<li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>\n<li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-标注形式AOP步骤\"><a href=\"#5-标注形式AOP步骤\" class=\"headerlink\" title=\"5. 标注形式AOP步骤\"></a>5. 标注形式AOP步骤</h3><ol>\n<li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li>\n<li>编写一个Sevice类，里面有登录和注册两个方法</li>\n<li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li>\n<li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li>\n<li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li>\n<li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-AOP-通知对应的标注\"><a href=\"#6-AOP-通知对应的标注\" class=\"headerlink\" title=\"6. AOP 通知对应的标注\"></a>6. AOP 通知对应的标注</h3><ol>\n<li><code>@Before</code>：前置通知，目标方法执行之前调用</li>\n<li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li>\n<li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li>\n<li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li>\n<li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Around具体用法\"><a href=\"#7-Around具体用法\" class=\"headerlink\" title=\"7. @Around具体用法\"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Around</span>(<span class=\"string\">\"within(com..*)\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">showAfterDate</span><span class=\"params\">(ProceedingJoinPoint pjp)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"开始时间：\"</span> + <span class=\"keyword\">new</span> Date().getTime());</span><br><span class=\"line\">    Object obj = pjp.proceed();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"结束时间：\"</span> + <span class=\"keyword\">new</span> Date().getTime());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"执行时间：\"</span>date2.getTime() - date.getTime());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>\n</blockquote>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-异常通知\"><a href=\"#8-异常通知\" class=\"headerlink\" title=\"8. 异常通知\"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@AfterThrowing</span>(value=<span class=\"string\">\"within(com..*)\"</span>, throwing=<span class=\"string\">\"e\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">processException</span><span class=\"params\">(JoinPoint jp, Exception e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"捕获到异常\"</span> + jp.getSignature() + <span class=\"string\">\":\\n【\"</span> + e +<span class=\"string\">\"】\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","_content":"\n### 开始之前\n\n在安装[hexo](https://hexo.io/zh-cn/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n<!-- more --> \n#### 1.创建GitHub仓库\n注册[GitHub](https://github.com/)账号，创建一个以\"用户名.github.io\"命名的仓库，如我的用户名为chaooo,那我的仓库名为：[chaooo.github.io](https://github.com/chaooo/chaooo.github.io)，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n#### 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 3.本地Git与GitHub建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH\n``` bash\n$ ls -al ~/.ssh\n```\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。\n输入以下指令后，一路回车就好：\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n然后键入以下指令：\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n如果出现这个错误:`Could not open a connection to your authentication agent`，则先执行如下命令即可：\n``` bash\n$ ssh-agent bash\n```\n再重新输入指令：\n``` bash\n$ ssh-add ~/.ssh/id_rsa\n```\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：\n``` bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n在github上点击你的头像-->Your profile-->Edit profile-->SSH and GPG keys-->New SSH key\nTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。\n最后还是测试一下吧，键入以下命令：\n``` bash\n$ ssh -T git@github.com\n```\n你可能会看到有警告，没事，输入“yes”就好。\n#### 4.初始化hexo文件夹\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。\n在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop <刚复制的地址>\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n### Hexo安装配置\n\n#### 1.Hexo初始化\n进入Hexo-admin文件夹\n``` bash\n$ cd Hexo-admin\n```\n接下来只需要使用 npm 即可完成 Hexo 的安装:\n``` bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:\n``` bash\n$ hexo init\n$ npm install\n```\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。\n``` bash\n$ hexo generate\n$ hexo server\n```\n输入Ctrl+C停止服务。\n#### 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: \n  repository:\n```\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/chaooo/chaooo.github.io.git\n  branch: master\n```\n#### 3.完成部署\n最后一步，快要成功了，键入指令：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n输入弹出框的用户名与密码(首次使用git会弹出)。\nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[chaooo.github.io/](http://chaooo.github.io/)\n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：\n``` bash\n    To https://github.com/chaooo/chaooo.github.io.git\n       7f3b50a..128a10d  HEAD -> master\n    INFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n### 日常操作\n\n#### 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。 \n``` bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n然后用编辑器打开“文章标题.md”按照[Markdown语法](http://www.appinn.com/markdown/)书写文章。\n 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，\n 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md\n``` bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\n``` bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用\"将其包围。\n`请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。`\n#### 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。\n``` bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n然后才执行hexo generate -d发布网站到master分支上。\n``` bash\n$ hexo generate -d\n```\n#### 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n##### 3.1拷贝仓库\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git \n```\n##### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:\n``` bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n##### 小Tips:hexo 命令\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","source":"_posts/Hexo3-2-github搭建静态博客.md","raw":"---\ntitle: Hexo3.2+GitHub搭建静态博客\ndate: 2016-05-23 11:16:51\ntags: hexo\ncategories: hexo博客折腾\n---\n\n### 开始之前\n\n在安装[hexo](https://hexo.io/zh-cn/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n<!-- more --> \n#### 1.创建GitHub仓库\n注册[GitHub](https://github.com/)账号，创建一个以\"用户名.github.io\"命名的仓库，如我的用户名为chaooo,那我的仓库名为：[chaooo.github.io](https://github.com/chaooo/chaooo.github.io)，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n#### 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 3.本地Git与GitHub建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH\n``` bash\n$ ls -al ~/.ssh\n```\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。\n输入以下指令后，一路回车就好：\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n然后键入以下指令：\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n如果出现这个错误:`Could not open a connection to your authentication agent`，则先执行如下命令即可：\n``` bash\n$ ssh-agent bash\n```\n再重新输入指令：\n``` bash\n$ ssh-add ~/.ssh/id_rsa\n```\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：\n``` bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n在github上点击你的头像-->Your profile-->Edit profile-->SSH and GPG keys-->New SSH key\nTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。\n最后还是测试一下吧，键入以下命令：\n``` bash\n$ ssh -T git@github.com\n```\n你可能会看到有警告，没事，输入“yes”就好。\n#### 4.初始化hexo文件夹\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。\n在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop <刚复制的地址>\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n### Hexo安装配置\n\n#### 1.Hexo初始化\n进入Hexo-admin文件夹\n``` bash\n$ cd Hexo-admin\n```\n接下来只需要使用 npm 即可完成 Hexo 的安装:\n``` bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:\n``` bash\n$ hexo init\n$ npm install\n```\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。\n``` bash\n$ hexo generate\n$ hexo server\n```\n输入Ctrl+C停止服务。\n#### 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: \n  repository:\n```\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/chaooo/chaooo.github.io.git\n  branch: master\n```\n#### 3.完成部署\n最后一步，快要成功了，键入指令：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n输入弹出框的用户名与密码(首次使用git会弹出)。\nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[chaooo.github.io/](http://chaooo.github.io/)\n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：\n``` bash\n    To https://github.com/chaooo/chaooo.github.io.git\n       7f3b50a..128a10d  HEAD -> master\n    INFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n### 日常操作\n\n#### 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。 \n``` bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n然后用编辑器打开“文章标题.md”按照[Markdown语法](http://www.appinn.com/markdown/)书写文章。\n 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，\n 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md\n``` bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\n``` bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用\"将其包围。\n`请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。`\n#### 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。\n``` bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n然后才执行hexo generate -d发布网站到master分支上。\n``` bash\n$ hexo generate -d\n```\n#### 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n##### 3.1拷贝仓库\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git \n```\n##### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:\n``` bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n##### 小Tips:hexo 命令\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","slug":"Hexo3-2-github搭建静态博客","published":1,"updated":"2019-07-07T03:06:11.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4a0007yot3we83ldek","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<a id=\"more\"></a> \n<h4 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h4><p>注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href=\"https://github.com/chaooo/chaooo.github.io\" target=\"_blank\" rel=\"noopener\">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地Git与GitHub建立联系\"><a href=\"#3-本地Git与GitHub建立联系\" class=\"headerlink\" title=\"3.本地Git与GitHub建立联系\"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n\n<p>再重新输入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h4 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h3><h4 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>输入Ctrl+C停止服务。</p>\n<h4 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: </span><br><span class=\"line\">  repository:</span><br></pre></td></tr></table></figure>\n\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://chaooo.github.io/\">chaooo.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<h3 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h3><h4 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n\n<p>然后用编辑器打开“文章标题.md”按照<a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p>\n<h4 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n\n<p>然后才执行hexo generate -d发布网站到master分支上。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h5 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>","more":"<h4 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h4><p>注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href=\"https://github.com/chaooo/chaooo.github.io\" target=\"_blank\" rel=\"noopener\">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地Git与GitHub建立联系\"><a href=\"#3-本地Git与GitHub建立联系\" class=\"headerlink\" title=\"3.本地Git与GitHub建立联系\"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n\n<p>再重新输入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h4 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h3><h4 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>输入Ctrl+C停止服务。</p>\n<h4 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: </span><br><span class=\"line\">  repository:</span><br></pre></td></tr></table></figure>\n\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://chaooo.github.io/\">chaooo.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<h3 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h3><h4 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n\n<p>然后用编辑器打开“文章标题.md”按照<a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p>\n<h4 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n\n<p>然后才执行hexo generate -d发布网站到master分支上。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h5 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>"},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","_content":"\nBower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n<!-- more --> \n### 开始之前\n\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` bash\nnpm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。   \n``` bash\nbower help\n\nUsage:\n    bower <command> [<args>] [<options>]\nCommands:\n    cache                   Manage bower cache\n    help                    Display help information about Bower\n    home                    Opens a package homepage into your favorite browser\n    info                    Info of a particular package\n    init                    Interactively create a bower.json file\n    install                 Install a package locally\n    link                    Symlink a package folder\n    list                    List local packages - and possible updates\n    login                   Authenticate with GitHub and store credentials\n    lookup                  Look up a package URL by name\n    prune                   Removes local extraneous packages\n    register                Register a package\n    search                  Search for a package by name\n    update                  Update a local package\n    uninstall               Remove a local package\n    unregister              Remove a package from the registry\n    version                 Bump a package version\nOptions:\n    -f, --force             Makes various commands more forceful\n    -j, --json              Output consumable JSON\n    -l, --loglevel          What level of logs to report\n    -o, --offline           Do not hit the network\n    -q, --quiet             Only output important information\n    -s, --silent            Do not output anything, besides errors\n    -V, --verbose           Makes output more verbose\n    --allow-root            Allows running commands as root\n    -v, --version           Output Bower version\n    --no-color              Disable colors\nSee 'bower help <command>' for more information on a specific command.\n```\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\nbower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n安装选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Save installed packages into the project’s bower.json dependencies\n    -D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n    -E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行`bower install`就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上`--save`即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n``` html\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行`update`命令即可更新，例如：\n``` bash \nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Update dependencies in bower.json\n    -D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里:https://bower.io/search/](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n    -S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n    -D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```\n","source":"_posts/Web包管理器-Bower.md","raw":"---\ntitle: 好用的Web包管理器-Bower\ndate: 2016-08-12 15:32:41\ntags: bower\ncategories: 前端工具\n---\n\nBower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n<!-- more --> \n### 开始之前\n\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` bash\nnpm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。   \n``` bash\nbower help\n\nUsage:\n    bower <command> [<args>] [<options>]\nCommands:\n    cache                   Manage bower cache\n    help                    Display help information about Bower\n    home                    Opens a package homepage into your favorite browser\n    info                    Info of a particular package\n    init                    Interactively create a bower.json file\n    install                 Install a package locally\n    link                    Symlink a package folder\n    list                    List local packages - and possible updates\n    login                   Authenticate with GitHub and store credentials\n    lookup                  Look up a package URL by name\n    prune                   Removes local extraneous packages\n    register                Register a package\n    search                  Search for a package by name\n    update                  Update a local package\n    uninstall               Remove a local package\n    unregister              Remove a package from the registry\n    version                 Bump a package version\nOptions:\n    -f, --force             Makes various commands more forceful\n    -j, --json              Output consumable JSON\n    -l, --loglevel          What level of logs to report\n    -o, --offline           Do not hit the network\n    -q, --quiet             Only output important information\n    -s, --silent            Do not output anything, besides errors\n    -V, --verbose           Makes output more verbose\n    --allow-root            Allows running commands as root\n    -v, --version           Output Bower version\n    --no-color              Disable colors\nSee 'bower help <command>' for more information on a specific command.\n```\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\nbower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n安装选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Save installed packages into the project’s bower.json dependencies\n    -D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n    -E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行`bower install`就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上`--save`即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n``` html\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行`update`命令即可更新，例如：\n``` bash \nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Update dependencies in bower.json\n    -D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里:https://bower.io/search/](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n    -S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n    -D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```\n","slug":"Web包管理器-Bower","published":1,"updated":"2019-07-07T03:06:11.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4d000ayot3l7k2kakk","content":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>\n<a id=\"more\"></a> \n<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure>\n\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure>\n\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n\n<p>安装选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure>\n\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里:https://bower.io/search/</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>卸载选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>","more":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure>\n\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure>\n\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n\n<p>安装选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure>\n\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里:https://bower.io/search/</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>卸载选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-12-31 23:59:59\ntags: hexo\ncategories: hexo博客折腾\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-07-07T03:06:11.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4h000byot3myi9tohy","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"sublime text3个人习惯配置","date":"2016-06-29T01:41:48.000Z","_content":"\n### 1、安装\n\n分别在官网下载并安装 [nodejs](https://nodejs.org/en/download/) 和 [sublime text3](https://www.sublimetext.com/3)。\n\n### 2、sublime text3注册：\n<!-- more --> \n点击菜单【help】－>【Enter License】，粘贴注册码。\n\n### 3、安装package control组件，用于管理所有插件\n\n按ctrl + ~调出控制台(或点击菜单栏的【View】->【Show Console】)，在Console窗口中输入以下代码，按回车键：\n``` bash\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n等待安装完毕，重启Sublime Text3。\n按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：\n\n### 4、用Package Control安装插件\n\n按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）\n`Material Theme`\n`Emmet`\n`CSS Format`\n`CSScomb`\n`jsFormat`\n`AutoFileName`\n`Autoprefixer`\n`Doc Blockr`\n`SublimeLinter`\n`SublimeLinter-jshint`\n`SublimeLinter-csslint`\n`Color Highlighter`\n`BracketHighlighter`\n\n### 5、配置nodejs\n\n##### 方法1\n(1)下载sublime Text的[nodejs插件](https://github.com/tanepiper/SublimeText-Nodejs)\n(2)下载后解压:直接改名为nodejs 放到 Preferences–>浏览程序包Browse Packages所在的文件夹\n(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"cp1252\", \n  \"windows\": \n    { \n        \"cmd\": [\"taskkill /F /IM node.exe & node\", \"$file\"] \n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(4)修改为：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(5)完成:随便写一段nodejs代码，ctrl+B运行\n(6)注意：在手动解压sublime Text插件后，需要在preference->package settings->package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。\n\n##### 方法2\n首先需要先安装[nodejs](https://nodejs.org/en/download/)。\n(1)运行Sublime,菜单上找到Tools ---> Build System ---> new Build System\n(2)输入：\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    }\n}\n(3)保存文件为NodeJs.sublime-build\n(4)菜单上找到Tools ---> Build System --->选择 NodeJs\n(5)安装sublime插件 JavaScript & NodeJs Snippets\n(6)新建test.js文件，输入 console.log('Hello Node.js'); 按快捷键 Ctrl + B 运行，成功输出","source":"_posts/sublime-text3个人习惯配置-C.md","raw":"---\ntitle: sublime text3个人习惯配置\ndate: 2016-06-29 09:41:48\ntags: sublime\ncategories: 前端工具\n---\n\n### 1、安装\n\n分别在官网下载并安装 [nodejs](https://nodejs.org/en/download/) 和 [sublime text3](https://www.sublimetext.com/3)。\n\n### 2、sublime text3注册：\n<!-- more --> \n点击菜单【help】－>【Enter License】，粘贴注册码。\n\n### 3、安装package control组件，用于管理所有插件\n\n按ctrl + ~调出控制台(或点击菜单栏的【View】->【Show Console】)，在Console窗口中输入以下代码，按回车键：\n``` bash\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n等待安装完毕，重启Sublime Text3。\n按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：\n\n### 4、用Package Control安装插件\n\n按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）\n`Material Theme`\n`Emmet`\n`CSS Format`\n`CSScomb`\n`jsFormat`\n`AutoFileName`\n`Autoprefixer`\n`Doc Blockr`\n`SublimeLinter`\n`SublimeLinter-jshint`\n`SublimeLinter-csslint`\n`Color Highlighter`\n`BracketHighlighter`\n\n### 5、配置nodejs\n\n##### 方法1\n(1)下载sublime Text的[nodejs插件](https://github.com/tanepiper/SublimeText-Nodejs)\n(2)下载后解压:直接改名为nodejs 放到 Preferences–>浏览程序包Browse Packages所在的文件夹\n(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"cp1252\", \n  \"windows\": \n    { \n        \"cmd\": [\"taskkill /F /IM node.exe & node\", \"$file\"] \n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(4)修改为：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(5)完成:随便写一段nodejs代码，ctrl+B运行\n(6)注意：在手动解压sublime Text插件后，需要在preference->package settings->package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。\n\n##### 方法2\n首先需要先安装[nodejs](https://nodejs.org/en/download/)。\n(1)运行Sublime,菜单上找到Tools ---> Build System ---> new Build System\n(2)输入：\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    }\n}\n(3)保存文件为NodeJs.sublime-build\n(4)菜单上找到Tools ---> Build System --->选择 NodeJs\n(5)安装sublime插件 JavaScript & NodeJs Snippets\n(6)新建test.js文件，输入 console.log('Hello Node.js'); 按快捷键 Ctrl + B 运行，成功输出","slug":"sublime-text3个人习惯配置-C","published":1,"updated":"2019-07-08T02:02:31.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4m000fyot3mc39jr1o","content":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>分别在官网下载并安装 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a> 和 <a href=\"https://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">sublime text3</a>。</p>\n<h3 id=\"2、sublime-text3注册：\"><a href=\"#2、sublime-text3注册：\" class=\"headerlink\" title=\"2、sublime text3注册：\"></a>2、sublime text3注册：</h3><a id=\"more\"></a> \n<p>点击菜单【help】－&gt;【Enter License】，粘贴注册码。</p>\n<h3 id=\"3、安装package-control组件，用于管理所有插件\"><a href=\"#3、安装package-control组件，用于管理所有插件\" class=\"headerlink\" title=\"3、安装package control组件，用于管理所有插件\"></a>3、安装package control组件，用于管理所有插件</h3><p>按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.replace(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class=\"built_in\">print</span>(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> open(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>\n\n<p>等待安装完毕，重启Sublime Text3。<br>按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：</p>\n<h3 id=\"4、用Package-Control安装插件\"><a href=\"#4、用Package-Control安装插件\" class=\"headerlink\" title=\"4、用Package Control安装插件\"></a>4、用Package Control安装插件</h3><p>按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）<br><code>Material Theme</code><br><code>Emmet</code><br><code>CSS Format</code><br><code>CSScomb</code><br><code>jsFormat</code><br><code>AutoFileName</code><br><code>Autoprefixer</code><br><code>Doc Blockr</code><br><code>SublimeLinter</code><br><code>SublimeLinter-jshint</code><br><code>SublimeLinter-csslint</code><br><code>Color Highlighter</code><br><code>BracketHighlighter</code></p>\n<h3 id=\"5、配置nodejs\"><a href=\"#5、配置nodejs\" class=\"headerlink\" title=\"5、配置nodejs\"></a>5、配置nodejs</h3><h5 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h5><p>(1)下载sublime Text的<a href=\"https://github.com/tanepiper/SublimeText-Nodejs\" target=\"_blank\" rel=\"noopener\">nodejs插件</a><br>(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹<br>(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"cp1252\"</span>, </span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>: </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe &amp; node\"</span>, <span class=\"string\">\"$file\"</span>] </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(4)修改为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"utf-8\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe\"</span>, <span class=\"string\">\"\"</span>],</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(5)完成:随便写一段nodejs代码，ctrl+B运行<br>(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。</p>\n<h5 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h5><p>首先需要先安装<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a>。<br>(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System<br>(2)输入：<br>{<br>  “cmd”: [“node”, “$file”],<br>  “file_regex”: “^[ ]<em>File &quot;(…</em>?)&quot;, line ([0-9]*)”,<br>  “selector”: “source.js”,<br>  “shell”:true,<br>  “encoding”: “utf-8”,<br>  “windows”:<br>    {<br>      “cmd”: [“taskkill /F /IM node.exe”, “”],<br>      “cmd”: [“node”, “$file”]<br>    }<br>}<br>(3)保存文件为NodeJs.sublime-build<br>(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs<br>(5)安装sublime插件 JavaScript &amp; NodeJs Snippets<br>(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>分别在官网下载并安装 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a> 和 <a href=\"https://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">sublime text3</a>。</p>\n<h3 id=\"2、sublime-text3注册：\"><a href=\"#2、sublime-text3注册：\" class=\"headerlink\" title=\"2、sublime text3注册：\"></a>2、sublime text3注册：</h3>","more":"<p>点击菜单【help】－&gt;【Enter License】，粘贴注册码。</p>\n<h3 id=\"3、安装package-control组件，用于管理所有插件\"><a href=\"#3、安装package-control组件，用于管理所有插件\" class=\"headerlink\" title=\"3、安装package control组件，用于管理所有插件\"></a>3、安装package control组件，用于管理所有插件</h3><p>按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.replace(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class=\"built_in\">print</span>(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> open(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>\n\n<p>等待安装完毕，重启Sublime Text3。<br>按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：</p>\n<h3 id=\"4、用Package-Control安装插件\"><a href=\"#4、用Package-Control安装插件\" class=\"headerlink\" title=\"4、用Package Control安装插件\"></a>4、用Package Control安装插件</h3><p>按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）<br><code>Material Theme</code><br><code>Emmet</code><br><code>CSS Format</code><br><code>CSScomb</code><br><code>jsFormat</code><br><code>AutoFileName</code><br><code>Autoprefixer</code><br><code>Doc Blockr</code><br><code>SublimeLinter</code><br><code>SublimeLinter-jshint</code><br><code>SublimeLinter-csslint</code><br><code>Color Highlighter</code><br><code>BracketHighlighter</code></p>\n<h3 id=\"5、配置nodejs\"><a href=\"#5、配置nodejs\" class=\"headerlink\" title=\"5、配置nodejs\"></a>5、配置nodejs</h3><h5 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h5><p>(1)下载sublime Text的<a href=\"https://github.com/tanepiper/SublimeText-Nodejs\" target=\"_blank\" rel=\"noopener\">nodejs插件</a><br>(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹<br>(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"cp1252\"</span>, </span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>: </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe &amp; node\"</span>, <span class=\"string\">\"$file\"</span>] </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(4)修改为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"utf-8\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe\"</span>, <span class=\"string\">\"\"</span>],</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(5)完成:随便写一段nodejs代码，ctrl+B运行<br>(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。</p>\n<h5 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h5><p>首先需要先安装<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a>。<br>(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System<br>(2)输入：<br>{<br>  “cmd”: [“node”, “$file”],<br>  “file_regex”: “^[ ]<em>File &quot;(…</em>?)&quot;, line ([0-9]*)”,<br>  “selector”: “source.js”,<br>  “shell”:true,<br>  “encoding”: “utf-8”,<br>  “windows”:<br>    {<br>      “cmd”: [“taskkill /F /IM node.exe”, “”],<br>      “cmd”: [“node”, “$file”]<br>    }<br>}<br>(3)保存文件为NodeJs.sublime-build<br>(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs<br>(5)安装sublime插件 JavaScript &amp; NodeJs Snippets<br>(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出</p>"},{"title":"自定义HEXO站内搜索Javascript+json","date":"2016-11-09T01:24:56.000Z","_content":"\n### 开始之前\n\n目前很多[Hexo](https://hexo.io/)博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：\n    [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)生成`xml`格式的数据文件。\n    [hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content) 生成`json`格式的数据文件。 \n今天的主角是[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。\n<!-- more -->\n### 1.安装 \n\n``` bash \n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后执行`hexo generate`时会自动生成`content.json`文件，若使用默认设置，生成的数据结构如下 \n``` json\nmeta: {\n    title: hexo.config.title,\n    subtitle: hexo.config.subtitle,\n    description: hexo.config.description,\n    author: hexo.config.author,\n    url: hexo.config.url\n},\npages: [{ //-> all pages\n    title: page.title,\n    slug: page.slug,\n    date: page.date,\n    updated: page.updated,\n    comments: page.comments,\n    permalink: page.permalink,\n    path: page.path,\n    excerpt: page.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: page.content, //-> only text minified ;)\n    raw: page.raw, //-> original MD content\n    content: page.content //-> final HTML content\n}],\nposts: [{ //-> only published posts\n    title: post.title,\n    slug: post.slug,\n    date: post.date,\n    updated: post.updated,\n    comments: post.comments,\n    permalink: post.permalink,\n    path: post.path,\n    excerpt: post.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: post.content, //-> only text minified ;)\n    raw: post.raw, //-> original MD content\n    content: post.content, //-> final HTML content\n    categories: [{\n        name: category.name,\n        slug: category.slug,\n        permalink: category.permalink\n    }],\n    tags: [{\n        name: tag.name,\n        slug: tag.slug,\n        permalink: tag.permalink\n    }]\n}]\n```\n### 2.配置 \n\nhexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：\n``` yml\njsonContent:\n  meta: true\n  keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)\n  pages:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n  posts:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n    categories: true\n    tags: true\n```\n因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在`hexo/_config.yml`中加入：\n``` yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true #文章标题\n    date: true #发表日期\n    path: true #路径\n    text: true #文本字段\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true #标签\n```\n这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。\n例如：\n``` json\n{\n  \"title\": \"自定义HEXO站内搜索Javascript+json\",\n  \"date\": \"2016-11-09T01:24:56.000Z\",\n  \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\",\n  \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\",\n  \"tags\": [{\n    \"name\": \"javascript,hexo\",\n    \"slug\": \"javascript-hexo\",\n    \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\"\n  }]\n}\n```\n### 3.JavaScript实现代码\n\n接下来就是用JS实现查询方法并把结果渲染到页面。\n#### 3.1 xhr加载数据\n``` javascript\nvar searchData;\nfunction loadData(success) {\n    if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', '/content.json', true);\n        xhr.onload = function() {\n            if (this.status >= 200 && this.status < 300) {\n                var res = JSON.parse(this.response || this.responseText);\n                searchData = res instanceof Array ? res : res.posts;\n                success(searchData);\n            } else {\n                console.error(this.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            console.error(this.statusText);\n        };\n        xhr.send();\n    } else {\n        success(searchData);\n    }\n}\n```\n#### 3.2 匹配文章内容返回结果\n``` javascript\nfunction matcher(post, regExp) {\n    // 匹配优先级：title > tags > text\n    return regtest(post.title, regExp) || post.tags.some(function(tag) {\n        return regtest(tag.name, regExp);\n    }) || regtest(post.text, regExp);\n}\nfunction regtest(raw, regExp) {\n    regExp.lastIndex = 0;\n    return regExp.test(raw);\n}\n```\n#### 3.3 结果渲染到页面\n``` javascript\nfunction render(data) {\n    var html = '';\n    if (data.length) {\n        html = data.map(function(post) {\n            return tpl(searchTpl, {\n                title: post.title,\n                path: post.path,\n                date: new Date(post.date).toLocaleDateString(),\n                tags: post.tags.map(function(tag) {\n                    return '<span>' + tag.name + '</span>';\n                }).join('')\n            });\n        }).join('');\n    } \n}\n```\n#### 3.3 查询匹配\n``` javascript\nfunction search(key) {\n    // 关键字 => 正则，空格隔开的看作多个关键字\n    // a b c => /a|b|c/gmi\n    var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi');\n    loadData(function(data) {\n        var result = data.filter(function(post) {\n            return matcher(post, regExp);\n        });\n        render(result);\n    });\n}\n```","source":"_posts/自定义HEXO站内搜索Javascript-json.md","raw":"---\ntitle: 自定义HEXO站内搜索Javascript+json\ndate: 2016-11-09 09:24:56\ntags: [javascript,hexo]\ncategories: hexo博客折腾\n---\n\n### 开始之前\n\n目前很多[Hexo](https://hexo.io/)博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：\n    [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)生成`xml`格式的数据文件。\n    [hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content) 生成`json`格式的数据文件。 \n今天的主角是[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。\n<!-- more -->\n### 1.安装 \n\n``` bash \n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后执行`hexo generate`时会自动生成`content.json`文件，若使用默认设置，生成的数据结构如下 \n``` json\nmeta: {\n    title: hexo.config.title,\n    subtitle: hexo.config.subtitle,\n    description: hexo.config.description,\n    author: hexo.config.author,\n    url: hexo.config.url\n},\npages: [{ //-> all pages\n    title: page.title,\n    slug: page.slug,\n    date: page.date,\n    updated: page.updated,\n    comments: page.comments,\n    permalink: page.permalink,\n    path: page.path,\n    excerpt: page.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: page.content, //-> only text minified ;)\n    raw: page.raw, //-> original MD content\n    content: page.content //-> final HTML content\n}],\nposts: [{ //-> only published posts\n    title: post.title,\n    slug: post.slug,\n    date: post.date,\n    updated: post.updated,\n    comments: post.comments,\n    permalink: post.permalink,\n    path: post.path,\n    excerpt: post.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: post.content, //-> only text minified ;)\n    raw: post.raw, //-> original MD content\n    content: post.content, //-> final HTML content\n    categories: [{\n        name: category.name,\n        slug: category.slug,\n        permalink: category.permalink\n    }],\n    tags: [{\n        name: tag.name,\n        slug: tag.slug,\n        permalink: tag.permalink\n    }]\n}]\n```\n### 2.配置 \n\nhexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：\n``` yml\njsonContent:\n  meta: true\n  keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)\n  pages:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n  posts:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n    categories: true\n    tags: true\n```\n因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在`hexo/_config.yml`中加入：\n``` yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true #文章标题\n    date: true #发表日期\n    path: true #路径\n    text: true #文本字段\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true #标签\n```\n这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。\n例如：\n``` json\n{\n  \"title\": \"自定义HEXO站内搜索Javascript+json\",\n  \"date\": \"2016-11-09T01:24:56.000Z\",\n  \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\",\n  \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\",\n  \"tags\": [{\n    \"name\": \"javascript,hexo\",\n    \"slug\": \"javascript-hexo\",\n    \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\"\n  }]\n}\n```\n### 3.JavaScript实现代码\n\n接下来就是用JS实现查询方法并把结果渲染到页面。\n#### 3.1 xhr加载数据\n``` javascript\nvar searchData;\nfunction loadData(success) {\n    if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', '/content.json', true);\n        xhr.onload = function() {\n            if (this.status >= 200 && this.status < 300) {\n                var res = JSON.parse(this.response || this.responseText);\n                searchData = res instanceof Array ? res : res.posts;\n                success(searchData);\n            } else {\n                console.error(this.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            console.error(this.statusText);\n        };\n        xhr.send();\n    } else {\n        success(searchData);\n    }\n}\n```\n#### 3.2 匹配文章内容返回结果\n``` javascript\nfunction matcher(post, regExp) {\n    // 匹配优先级：title > tags > text\n    return regtest(post.title, regExp) || post.tags.some(function(tag) {\n        return regtest(tag.name, regExp);\n    }) || regtest(post.text, regExp);\n}\nfunction regtest(raw, regExp) {\n    regExp.lastIndex = 0;\n    return regExp.test(raw);\n}\n```\n#### 3.3 结果渲染到页面\n``` javascript\nfunction render(data) {\n    var html = '';\n    if (data.length) {\n        html = data.map(function(post) {\n            return tpl(searchTpl, {\n                title: post.title,\n                path: post.path,\n                date: new Date(post.date).toLocaleDateString(),\n                tags: post.tags.map(function(tag) {\n                    return '<span>' + tag.name + '</span>';\n                }).join('')\n            });\n        }).join('');\n    } \n}\n```\n#### 3.3 查询匹配\n``` javascript\nfunction search(key) {\n    // 关键字 => 正则，空格隔开的看作多个关键字\n    // a b c => /a|b|c/gmi\n    var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi');\n    loadData(function(data) {\n        var result = data.filter(function(post) {\n            return matcher(post, regExp);\n        });\n        render(result);\n    });\n}\n```","slug":"自定义HEXO站内搜索Javascript-json","published":1,"updated":"2019-07-07T03:06:11.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4q000hyot39t1w2q44","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>目前很多<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href=\"https://github.com/PaicHyperionDev/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta: &#123;</span><br><span class=\"line\">    title: hexo.config.title,</span><br><span class=\"line\">    subtitle: hexo.config.subtitle,</span><br><span class=\"line\">    description: hexo.config.description,</span><br><span class=\"line\">    author: hexo.config.author,</span><br><span class=\"line\">    url: hexo.config.url</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">pages: [&#123; //-&gt; all pages</span><br><span class=\"line\">    title: page.title,</span><br><span class=\"line\">    slug: page.slug,</span><br><span class=\"line\">    date: page.date,</span><br><span class=\"line\">    updated: page.updated,</span><br><span class=\"line\">    comments: page.comments,</span><br><span class=\"line\">    permalink: page.permalink,</span><br><span class=\"line\">    path: page.path,</span><br><span class=\"line\">    excerpt: page.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: page.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: page.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: page.content //-&gt; final HTML content</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\">posts: [&#123; //-&gt; only published posts</span><br><span class=\"line\">    title: post.title,</span><br><span class=\"line\">    slug: post.slug,</span><br><span class=\"line\">    date: post.date,</span><br><span class=\"line\">    updated: post.updated,</span><br><span class=\"line\">    comments: post.comments,</span><br><span class=\"line\">    permalink: post.permalink,</span><br><span class=\"line\">    path: post.path,</span><br><span class=\"line\">    excerpt: post.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: post.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: post.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: post.content, //-&gt; final HTML content</span><br><span class=\"line\">    categories: [&#123;</span><br><span class=\"line\">        name: category.name,</span><br><span class=\"line\">        slug: category.slug,</span><br><span class=\"line\">        permalink: category.permalink</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tags: [&#123;</span><br><span class=\"line\">        name: tag.name,</span><br><span class=\"line\">        slug: tag.slug,</span><br><span class=\"line\">        permalink: tag.permalink</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2.配置\"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  keywords:</span> <span class=\"literal\">false</span> <span class=\"comment\"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文章标题</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span> <span class=\"comment\">#发表日期</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span> <span class=\"comment\">#路径</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文本字段</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span> <span class=\"comment\">#标签</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"自定义HEXO站内搜索Javascript+json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"date\"</span>: <span class=\"string\">\"2016-11-09T01:24:56.000Z\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"2016/11/09/自定义HEXO站内搜索Javascript-json.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"tags\"</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"javascript,hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"slug\"</span>: <span class=\"string\">\"javascript-hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"permalink\"</span>: <span class=\"string\">\"http://chaoo.oschina.io/tags/javascript-hexo/\"</span></span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-JavaScript实现代码\"><a href=\"#3-JavaScript实现代码\" class=\"headerlink\" title=\"3.JavaScript实现代码\"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p>\n<h4 id=\"3-1-xhr加载数据\"><a href=\"#3-1-xhr加载数据\" class=\"headerlink\" title=\"3.1 xhr加载数据\"></a>3.1 xhr加载数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchData;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span>(<span class=\"params\">success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!searchData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'/content.json'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(<span class=\"keyword\">this</span>.response || <span class=\"keyword\">this</span>.responseText);</span><br><span class=\"line\">                searchData = res <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? res : res.posts;</span><br><span class=\"line\">                success(searchData);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.send();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        success(searchData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-匹配文章内容返回结果\"><a href=\"#3-2-匹配文章内容返回结果\" class=\"headerlink\" title=\"3.2 匹配文章内容返回结果\"></a>3.2 匹配文章内容返回结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matcher</span>(<span class=\"params\">post, regExp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regtest(post.title, regExp) || post.tags.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regtest(tag.name, regExp);</span><br><span class=\"line\">    &#125;) || regtest(post.text, regExp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">regtest</span>(<span class=\"params\">raw, regExp</span>) </span>&#123;</span><br><span class=\"line\">    regExp.lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.test(raw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-结果渲染到页面\"><a href=\"#3-3-结果渲染到页面\" class=\"headerlink\" title=\"3.3 结果渲染到页面\"></a>3.3 结果渲染到页面</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> html = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length) &#123;</span><br><span class=\"line\">        html = data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tpl(searchTpl, &#123;</span><br><span class=\"line\">                title: post.title,</span><br><span class=\"line\">                path: post.path,</span><br><span class=\"line\">                date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(post.date).toLocaleDateString(),</span><br><span class=\"line\">                tags: post.tags.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span&gt;'</span> + tag.name + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">                &#125;).join(<span class=\"string\">''</span>)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-查询匹配\"><a href=\"#3-3-查询匹配\" class=\"headerlink\" title=\"3.3 查询匹配\"></a>3.3 查询匹配</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">search</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class=\"line\">    <span class=\"comment\">// a b c =&gt; /a|b|c/gmi</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> regExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(key.replace(<span class=\"regexp\">/[ ]/g</span>, <span class=\"string\">'|'</span>), <span class=\"string\">'gmi'</span>);</span><br><span class=\"line\">    loadData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> matcher(post, regExp);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        render(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>目前很多<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href=\"https://github.com/PaicHyperionDev/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p>","more":"<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta: &#123;</span><br><span class=\"line\">    title: hexo.config.title,</span><br><span class=\"line\">    subtitle: hexo.config.subtitle,</span><br><span class=\"line\">    description: hexo.config.description,</span><br><span class=\"line\">    author: hexo.config.author,</span><br><span class=\"line\">    url: hexo.config.url</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">pages: [&#123; //-&gt; all pages</span><br><span class=\"line\">    title: page.title,</span><br><span class=\"line\">    slug: page.slug,</span><br><span class=\"line\">    date: page.date,</span><br><span class=\"line\">    updated: page.updated,</span><br><span class=\"line\">    comments: page.comments,</span><br><span class=\"line\">    permalink: page.permalink,</span><br><span class=\"line\">    path: page.path,</span><br><span class=\"line\">    excerpt: page.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: page.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: page.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: page.content //-&gt; final HTML content</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\">posts: [&#123; //-&gt; only published posts</span><br><span class=\"line\">    title: post.title,</span><br><span class=\"line\">    slug: post.slug,</span><br><span class=\"line\">    date: post.date,</span><br><span class=\"line\">    updated: post.updated,</span><br><span class=\"line\">    comments: post.comments,</span><br><span class=\"line\">    permalink: post.permalink,</span><br><span class=\"line\">    path: post.path,</span><br><span class=\"line\">    excerpt: post.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: post.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: post.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: post.content, //-&gt; final HTML content</span><br><span class=\"line\">    categories: [&#123;</span><br><span class=\"line\">        name: category.name,</span><br><span class=\"line\">        slug: category.slug,</span><br><span class=\"line\">        permalink: category.permalink</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tags: [&#123;</span><br><span class=\"line\">        name: tag.name,</span><br><span class=\"line\">        slug: tag.slug,</span><br><span class=\"line\">        permalink: tag.permalink</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2.配置\"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  keywords:</span> <span class=\"literal\">false</span> <span class=\"comment\"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文章标题</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span> <span class=\"comment\">#发表日期</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span> <span class=\"comment\">#路径</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文本字段</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span> <span class=\"comment\">#标签</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"自定义HEXO站内搜索Javascript+json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"date\"</span>: <span class=\"string\">\"2016-11-09T01:24:56.000Z\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"2016/11/09/自定义HEXO站内搜索Javascript-json.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"tags\"</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"javascript,hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"slug\"</span>: <span class=\"string\">\"javascript-hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"permalink\"</span>: <span class=\"string\">\"http://chaoo.oschina.io/tags/javascript-hexo/\"</span></span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-JavaScript实现代码\"><a href=\"#3-JavaScript实现代码\" class=\"headerlink\" title=\"3.JavaScript实现代码\"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p>\n<h4 id=\"3-1-xhr加载数据\"><a href=\"#3-1-xhr加载数据\" class=\"headerlink\" title=\"3.1 xhr加载数据\"></a>3.1 xhr加载数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchData;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span>(<span class=\"params\">success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!searchData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'/content.json'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(<span class=\"keyword\">this</span>.response || <span class=\"keyword\">this</span>.responseText);</span><br><span class=\"line\">                searchData = res <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? res : res.posts;</span><br><span class=\"line\">                success(searchData);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.send();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        success(searchData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-匹配文章内容返回结果\"><a href=\"#3-2-匹配文章内容返回结果\" class=\"headerlink\" title=\"3.2 匹配文章内容返回结果\"></a>3.2 匹配文章内容返回结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matcher</span>(<span class=\"params\">post, regExp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regtest(post.title, regExp) || post.tags.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regtest(tag.name, regExp);</span><br><span class=\"line\">    &#125;) || regtest(post.text, regExp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">regtest</span>(<span class=\"params\">raw, regExp</span>) </span>&#123;</span><br><span class=\"line\">    regExp.lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.test(raw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-结果渲染到页面\"><a href=\"#3-3-结果渲染到页面\" class=\"headerlink\" title=\"3.3 结果渲染到页面\"></a>3.3 结果渲染到页面</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> html = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length) &#123;</span><br><span class=\"line\">        html = data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tpl(searchTpl, &#123;</span><br><span class=\"line\">                title: post.title,</span><br><span class=\"line\">                path: post.path,</span><br><span class=\"line\">                date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(post.date).toLocaleDateString(),</span><br><span class=\"line\">                tags: post.tags.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span&gt;'</span> + tag.name + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">                &#125;).join(<span class=\"string\">''</span>)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-查询匹配\"><a href=\"#3-3-查询匹配\" class=\"headerlink\" title=\"3.3 查询匹配\"></a>3.3 查询匹配</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">search</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class=\"line\">    <span class=\"comment\">// a b c =&gt; /a|b|c/gmi</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> regExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(key.replace(<span class=\"regexp\">/[ ]/g</span>, <span class=\"string\">'|'</span>), <span class=\"string\">'gmi'</span>);</span><br><span class=\"line\">    loadData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> matcher(post, regExp);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        render(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"谈谈开源","date":"2019-07-11T12:13:15.000Z","_content":"\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","source":"_posts/谈谈开源.md","raw":"---\ntitle: 谈谈开源\ndate: 2019-07-11 20:13:15\ntags: 开源\ncategories: 杂谈\n---\n\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","slug":"谈谈开源","published":1,"updated":"2019-08-27T15:02:02.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo4w000myot31udo3vdg","content":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>\n<a id=\"more\"></a>\n<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>","more":"<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>"},{"title":"一、JavaSE语法基础","date":"2019-07-07T09:33:54.000Z","_content":"\n这是**javaSE知识梳理**的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。\n<!-- more -->\n\n1. [数据类型](#id1)\n2. [变量与常量](#id2)\n3. [数据类型之间的转换](#id3)\n4. [运算符](#id4)\n5. [循环](#id5)\n6. [数组](#id6)\n7. [函数](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 数据类型\n#### 1.1 分为两大类：\n1. 基本数据类型：byte，short，int，long，float，double，boolean，char\n2. 引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface\n\n> 注：`单个字节`表示`8位二进制`位，最左边表示符号位（0：正，1：负）。\n\n#### 1.2 整数类型（byte，short，int，long）\n1. **byte**： 1个字节，范围`-2^7~2^7-1`，即`-128~127`。\n2. **short**：2个字节，范围`-2^15~2^15-1`，即`-32768~32767`。\n3. **int**:   4个字节，范围`-2^31~2^31-1`，即`正负21亿`之间。\n4. **long**： 8个字节，范围`-2^63~2^63-1`，比int更大。如果要表示long直接量，需要`L`或`l`结尾。\n\n#### 1.3 浮点类型（float，double）\n1. **float**： 4个字节，单精度浮点数，取到`小数点后7`位有效数字。如果要表示float直接量，需要`F`或`f`结尾\n2. **double**：8个字节，双精度浮点数，取到`小数点后15`位有效数字。\n\n> 扩展：浮点运算有时会有误差，为了实现精确运算可使用`java.math.BigDecimal`类型加以描述。\n\n#### 1.4 布尔类型（boolean）\n1. **boolean**：1个字节（未明确规定），值只有`true`和`false`。\n\n#### 1.5 字符类型（char）\n1. **char**：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：'a','1','中' 等。\n- 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号\"\"引起来。\n- 需记住的ASII码字符：'a':97，'A':65，'0':48，空格:32，换行符:10\n- 常用转义符(逃逸字符)：`\\t`:制表符，`\\n`:换行，`\\\"`，`\\'`，`\\\\`:反斜杠本身，`\\b`:回退一格，`\\r`:回车\n- 字符类型计算\n  * 一个字符加一个数字，得到Unicode码表中那个数之后的字符\n  * 两个字符相减得到它们在表中的距离\n  * char也可以和int之间相互赋值\n\n\n<span id=\"id2\"><span>\n### 2. 变量与常量\n#### 2.1 常量\n- 常量是一个值，在程序运行的过程中不能再次发生改变\n- 基本类型的值都可以认为是常量   4  3.4  'a'  true，String类(引用数据类型)值\"abc\"视为常量\n- 常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit--int   64bit--double\n\n#### 2.2 变量\n- 变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的\n- 变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字\n- 变量空间   里面只能存储一个内容(值/引用)\n- 空间内的内容的类型与定义时一致 内容可以改变 \n- 内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值\n\n#### 2.3 标识符（变量）命名规则\n1. 必须字母，数字，下划线以及美元$等组成，且首位非数字。\n2. 不能使用Java语言中的关键字，如class，static，void，int等。\n3. 区分大小写，长度无限制，但不能过长，尽量见名知意。\n\n#### 2.3 命名的规约\n- 类名字：首字母大写，如果两个以上的单词，所有首字母都大写\n- 变量名：首字母小写，如果两个以上的单词，之后的首字母大写\n- 遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性\n\n\n<span id=\"id3\"><span>\n### 3. 数据类型之间的转换\n#### 3.1 基本数据类型之间转换\n1. 自动类型转换：从小类型到大类型自动转换\n\n```\nbyte --> short --> int --> long --> float --> double\n          char -----^\n```\n\n2. 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出\n\n```\nlong big = 1024L\\*1024\\*1024;\nint i = (int)big;\n```\n\n#### 3.2其他数据类型之间转换\n- 同种大数据类型之间才能发生转换\n- 类型转换之前，保证大前提：同种大数据类型一致\n    * 基本--基本   可以直接转换(自动 强制)\n    * 引用--引用   可以直接转化(自动 强制 -- 上转型 下转型)\n    * 基本--引用   不可以直接进行转化(间接-桥梁-包装类)\n- 保证大数据类型一致的前提下(都是基本类型)\n* 小数据类型一致:整型-->整型 / 浮点-->浮点\n    + 比较内存空间的大小\n    + 大数据类型空间可以直接接受小数据类型的值(自动转换)\n    + 小数据类型空间不可以直接接受大数据类型的值(强制类型转换)\n    + 强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据\n    ```\n    byte a = 1;   int b = a;//自动直接转化就可以\n    int a = 1;  byte b = (byte)a;//需要强制类型转换\n    float x = 3.4F;   double y = x;//自动直接转化\n    double x = 3.4; float y = (float)x;//强制转换\n    ```\n* 小数据类型不一致:整型-->浮点\n    + 比较精确程度\n    + 浮点型的精确程度更高\n    + 任何一个浮点型空间都可以直接接受一个整型的值\n    + 反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)\n    ```\n    int a = 1;  float b = a;//自动直接转化\n    float a =1.0F;  int b = (int)a;//强制类型转换\n    ```\n* 整型-->字符\n    + 每一个字符都对应这一个Unicode码   a--97\n    ```\n    char x = 'a';  int y = x;//自动转化  y--97\n    int x = 97; char y = (char)x;//强制的转化\n    ```\n* 布尔类型很特殊\n    + 不能与其他基本类型之间发生转化\n\n\n<span id=\"id4\"><span>\n### 4. 运算符\n1. 算术运算符： `+`，`-`，`*`，`/`，`%`\n2. 关系运算符： `>`，`<`，`>=`，`<=`，`==`，`!=`\n3. 自增减运算符： `++`，`--`\n4. 逻辑运算符： `&&`，`||`，`！`（短路特性：逻辑与`&&`运算，若第一个条件为假,跳过第二个条件；逻辑或`||`运算，若第一个条件为真，跳过第二个条件）\n5. 三目运算符： 条件 ? 表达式1 ： 表达式2\n6. 赋值运算符：`=`，`+=`，`-=`，`*=`，`=` \n\n<span id=\"id5\"><span>\n### 5. 循环\n1. while循环和for循环完全可以互换。\n2. while循环主要用于明确循环条件，但不明确循环次数的场合\n3. for循环主要用于明确次数或范围的场合\n4. while(true) 等价于 for(;;)，表示无限循环。\n\n<span id=\"id6\"><span>\n### 6. 数组\n#### 6.1 一维数组\n- `数组类型[] 数组名 = new 数据类型[长度]` ：动态方式\n\n``` java\n数组类型[] 数组名 = new 数据类型[长度] //动态方式\nint[] arr = new int[5];\n```\n\n``` java\n数组类型[] 数组名 = {初始值1, 初始值1, 初始值1, ...} //静态方式\nint[] arr = {10, 20, 30, 40};\n/*特殊方式：*/ int[] arr = new int[]{10, 20, 30};\n```\n\n#### 6.2 二维数组\n\n``` java\n数组类型[][] 数组名 = new 数据类型[行数][列数]\nint[][] arr = new int[5][6];\n```\n\n``` java\n数组类型[][] 数组名 = {{初始值1, 初始值1, 初始值1},{值2,...} ...}\nint[] arr = {{10, 20, 30}, {01, 5, 3}, {8, 20, 6}};\n```\n\n> 二维数组arr.length表示行数，arr[0].length表示此行的长度\n\n\n<span id=\"id7\"><span>\n### 7. 函数\n- 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。\n\n``` java\npublic static int sum(int a, int b){\n  int i;\n  int sum=0;\n  for(i=a; i<=b; i++){\n    sum += i;\n  }\n  System.out.println(a +\"到\"+ b +\"的和是\"+ sum);\n  return sum;\n}\n```\n\n- 函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序\n- 函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用\n","source":"_posts/01_JavaSE语法基础.md","raw":"---\ntitle: 一、JavaSE语法基础\ndate: 2019-07-07 17:33:54\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n这是**javaSE知识梳理**的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。\n<!-- more -->\n\n1. [数据类型](#id1)\n2. [变量与常量](#id2)\n3. [数据类型之间的转换](#id3)\n4. [运算符](#id4)\n5. [循环](#id5)\n6. [数组](#id6)\n7. [函数](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 数据类型\n#### 1.1 分为两大类：\n1. 基本数据类型：byte，short，int，long，float，double，boolean，char\n2. 引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface\n\n> 注：`单个字节`表示`8位二进制`位，最左边表示符号位（0：正，1：负）。\n\n#### 1.2 整数类型（byte，short，int，long）\n1. **byte**： 1个字节，范围`-2^7~2^7-1`，即`-128~127`。\n2. **short**：2个字节，范围`-2^15~2^15-1`，即`-32768~32767`。\n3. **int**:   4个字节，范围`-2^31~2^31-1`，即`正负21亿`之间。\n4. **long**： 8个字节，范围`-2^63~2^63-1`，比int更大。如果要表示long直接量，需要`L`或`l`结尾。\n\n#### 1.3 浮点类型（float，double）\n1. **float**： 4个字节，单精度浮点数，取到`小数点后7`位有效数字。如果要表示float直接量，需要`F`或`f`结尾\n2. **double**：8个字节，双精度浮点数，取到`小数点后15`位有效数字。\n\n> 扩展：浮点运算有时会有误差，为了实现精确运算可使用`java.math.BigDecimal`类型加以描述。\n\n#### 1.4 布尔类型（boolean）\n1. **boolean**：1个字节（未明确规定），值只有`true`和`false`。\n\n#### 1.5 字符类型（char）\n1. **char**：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：'a','1','中' 等。\n- 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号\"\"引起来。\n- 需记住的ASII码字符：'a':97，'A':65，'0':48，空格:32，换行符:10\n- 常用转义符(逃逸字符)：`\\t`:制表符，`\\n`:换行，`\\\"`，`\\'`，`\\\\`:反斜杠本身，`\\b`:回退一格，`\\r`:回车\n- 字符类型计算\n  * 一个字符加一个数字，得到Unicode码表中那个数之后的字符\n  * 两个字符相减得到它们在表中的距离\n  * char也可以和int之间相互赋值\n\n\n<span id=\"id2\"><span>\n### 2. 变量与常量\n#### 2.1 常量\n- 常量是一个值，在程序运行的过程中不能再次发生改变\n- 基本类型的值都可以认为是常量   4  3.4  'a'  true，String类(引用数据类型)值\"abc\"视为常量\n- 常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit--int   64bit--double\n\n#### 2.2 变量\n- 变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的\n- 变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字\n- 变量空间   里面只能存储一个内容(值/引用)\n- 空间内的内容的类型与定义时一致 内容可以改变 \n- 内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值\n\n#### 2.3 标识符（变量）命名规则\n1. 必须字母，数字，下划线以及美元$等组成，且首位非数字。\n2. 不能使用Java语言中的关键字，如class，static，void，int等。\n3. 区分大小写，长度无限制，但不能过长，尽量见名知意。\n\n#### 2.3 命名的规约\n- 类名字：首字母大写，如果两个以上的单词，所有首字母都大写\n- 变量名：首字母小写，如果两个以上的单词，之后的首字母大写\n- 遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性\n\n\n<span id=\"id3\"><span>\n### 3. 数据类型之间的转换\n#### 3.1 基本数据类型之间转换\n1. 自动类型转换：从小类型到大类型自动转换\n\n```\nbyte --> short --> int --> long --> float --> double\n          char -----^\n```\n\n2. 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出\n\n```\nlong big = 1024L\\*1024\\*1024;\nint i = (int)big;\n```\n\n#### 3.2其他数据类型之间转换\n- 同种大数据类型之间才能发生转换\n- 类型转换之前，保证大前提：同种大数据类型一致\n    * 基本--基本   可以直接转换(自动 强制)\n    * 引用--引用   可以直接转化(自动 强制 -- 上转型 下转型)\n    * 基本--引用   不可以直接进行转化(间接-桥梁-包装类)\n- 保证大数据类型一致的前提下(都是基本类型)\n* 小数据类型一致:整型-->整型 / 浮点-->浮点\n    + 比较内存空间的大小\n    + 大数据类型空间可以直接接受小数据类型的值(自动转换)\n    + 小数据类型空间不可以直接接受大数据类型的值(强制类型转换)\n    + 强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据\n    ```\n    byte a = 1;   int b = a;//自动直接转化就可以\n    int a = 1;  byte b = (byte)a;//需要强制类型转换\n    float x = 3.4F;   double y = x;//自动直接转化\n    double x = 3.4; float y = (float)x;//强制转换\n    ```\n* 小数据类型不一致:整型-->浮点\n    + 比较精确程度\n    + 浮点型的精确程度更高\n    + 任何一个浮点型空间都可以直接接受一个整型的值\n    + 反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)\n    ```\n    int a = 1;  float b = a;//自动直接转化\n    float a =1.0F;  int b = (int)a;//强制类型转换\n    ```\n* 整型-->字符\n    + 每一个字符都对应这一个Unicode码   a--97\n    ```\n    char x = 'a';  int y = x;//自动转化  y--97\n    int x = 97; char y = (char)x;//强制的转化\n    ```\n* 布尔类型很特殊\n    + 不能与其他基本类型之间发生转化\n\n\n<span id=\"id4\"><span>\n### 4. 运算符\n1. 算术运算符： `+`，`-`，`*`，`/`，`%`\n2. 关系运算符： `>`，`<`，`>=`，`<=`，`==`，`!=`\n3. 自增减运算符： `++`，`--`\n4. 逻辑运算符： `&&`，`||`，`！`（短路特性：逻辑与`&&`运算，若第一个条件为假,跳过第二个条件；逻辑或`||`运算，若第一个条件为真，跳过第二个条件）\n5. 三目运算符： 条件 ? 表达式1 ： 表达式2\n6. 赋值运算符：`=`，`+=`，`-=`，`*=`，`=` \n\n<span id=\"id5\"><span>\n### 5. 循环\n1. while循环和for循环完全可以互换。\n2. while循环主要用于明确循环条件，但不明确循环次数的场合\n3. for循环主要用于明确次数或范围的场合\n4. while(true) 等价于 for(;;)，表示无限循环。\n\n<span id=\"id6\"><span>\n### 6. 数组\n#### 6.1 一维数组\n- `数组类型[] 数组名 = new 数据类型[长度]` ：动态方式\n\n``` java\n数组类型[] 数组名 = new 数据类型[长度] //动态方式\nint[] arr = new int[5];\n```\n\n``` java\n数组类型[] 数组名 = {初始值1, 初始值1, 初始值1, ...} //静态方式\nint[] arr = {10, 20, 30, 40};\n/*特殊方式：*/ int[] arr = new int[]{10, 20, 30};\n```\n\n#### 6.2 二维数组\n\n``` java\n数组类型[][] 数组名 = new 数据类型[行数][列数]\nint[][] arr = new int[5][6];\n```\n\n``` java\n数组类型[][] 数组名 = {{初始值1, 初始值1, 初始值1},{值2,...} ...}\nint[] arr = {{10, 20, 30}, {01, 5, 3}, {8, 20, 6}};\n```\n\n> 二维数组arr.length表示行数，arr[0].length表示此行的长度\n\n\n<span id=\"id7\"><span>\n### 7. 函数\n- 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。\n\n``` java\npublic static int sum(int a, int b){\n  int i;\n  int sum=0;\n  for(i=a; i<=b; i++){\n    sum += i;\n  }\n  System.out.println(a +\"到\"+ b +\"的和是\"+ sum);\n  return sum;\n}\n```\n\n- 函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序\n- 函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用\n","slug":"01_JavaSE语法基础","published":1,"updated":"2019-07-20T14:45:38.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo5s001vyot35wyaqwsa","content":"<p>这是<strong>javaSE知识梳理</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">数据类型</a></li>\n<li><a href=\"#id2\">变量与常量</a></li>\n<li><a href=\"#id3\">数据类型之间的转换</a></li>\n<li><a href=\"#id4\">运算符</a></li>\n<li><a href=\"#id5\">循环</a></li>\n<li><a href=\"#id6\">数组</a></li>\n<li><a href=\"#id7\">函数</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><h4 id=\"1-1-分为两大类：\"><a href=\"#1-1-分为两大类：\" class=\"headerlink\" title=\"1.1 分为两大类：\"></a>1.1 分为两大类：</h4><ol>\n<li>基本数据类型：byte，short，int，long，float，double，boolean，char</li>\n<li>引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface</li>\n</ol>\n<blockquote>\n<p>注：<code>单个字节</code>表示<code>8位二进制</code>位，最左边表示符号位（0：正，1：负）。</p>\n</blockquote>\n<h4 id=\"1-2-整数类型（byte，short，int，long）\"><a href=\"#1-2-整数类型（byte，short，int，long）\" class=\"headerlink\" title=\"1.2 整数类型（byte，short，int，long）\"></a>1.2 整数类型（byte，short，int，long）</h4><ol>\n<li><strong>byte</strong>： 1个字节，范围<code>-2^7~2^7-1</code>，即<code>-128~127</code>。</li>\n<li><strong>short</strong>：2个字节，范围<code>-2^15~2^15-1</code>，即<code>-32768~32767</code>。</li>\n<li><strong>int</strong>:   4个字节，范围<code>-2^31~2^31-1</code>，即<code>正负21亿</code>之间。</li>\n<li><strong>long</strong>： 8个字节，范围<code>-2^63~2^63-1</code>，比int更大。如果要表示long直接量，需要<code>L</code>或<code>l</code>结尾。</li>\n</ol>\n<h4 id=\"1-3-浮点类型（float，double）\"><a href=\"#1-3-浮点类型（float，double）\" class=\"headerlink\" title=\"1.3 浮点类型（float，double）\"></a>1.3 浮点类型（float，double）</h4><ol>\n<li><strong>float</strong>： 4个字节，单精度浮点数，取到<code>小数点后7</code>位有效数字。如果要表示float直接量，需要<code>F</code>或<code>f</code>结尾</li>\n<li><strong>double</strong>：8个字节，双精度浮点数，取到<code>小数点后15</code>位有效数字。</li>\n</ol>\n<blockquote>\n<p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p>\n</blockquote>\n<h4 id=\"1-4-布尔类型（boolean）\"><a href=\"#1-4-布尔类型（boolean）\" class=\"headerlink\" title=\"1.4 布尔类型（boolean）\"></a>1.4 布尔类型（boolean）</h4><ol>\n<li><strong>boolean</strong>：1个字节（未明确规定），值只有<code>true</code>和<code>false</code>。</li>\n</ol>\n<h4 id=\"1-5-字符类型（char）\"><a href=\"#1-5-字符类型（char）\" class=\"headerlink\" title=\"1.5 字符类型（char）\"></a>1.5 字符类型（char）</h4><ol>\n<li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。</li>\n</ol>\n<ul>\n<li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。</li>\n<li>需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10</li>\n<li>常用转义符(逃逸字符)：<code>\\t</code>:制表符，<code>\\n</code>:换行，<code>\\&quot;</code>，<code>\\&#39;</code>，<code>\\\\</code>:反斜杠本身，<code>\\b</code>:回退一格，<code>\\r</code>:回车</li>\n<li>字符类型计算<ul>\n<li>一个字符加一个数字，得到Unicode码表中那个数之后的字符</li>\n<li>两个字符相减得到它们在表中的距离</li>\n<li>char也可以和int之间相互赋值</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-变量与常量\"><a href=\"#2-变量与常量\" class=\"headerlink\" title=\"2. 变量与常量\"></a>2. 变量与常量</h3><h4 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h4><ul>\n<li>常量是一个值，在程序运行的过程中不能再次发生改变</li>\n<li>基本类型的值都可以认为是常量   4  3.4  ‘a’  true，String类(引用数据类型)值”abc”视为常量</li>\n<li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit–int   64bit–double</li>\n</ul>\n<h4 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h4><ul>\n<li>变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的</li>\n<li>变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字</li>\n<li>变量空间   里面只能存储一个内容(值/引用)</li>\n<li>空间内的内容的类型与定义时一致 内容可以改变 </li>\n<li>内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值</li>\n</ul>\n<h4 id=\"2-3-标识符（变量）命名规则\"><a href=\"#2-3-标识符（变量）命名规则\" class=\"headerlink\" title=\"2.3 标识符（变量）命名规则\"></a>2.3 标识符（变量）命名规则</h4><ol>\n<li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li>\n<li>不能使用Java语言中的关键字，如class，static，void，int等。</li>\n<li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li>\n</ol>\n<h4 id=\"2-3-命名的规约\"><a href=\"#2-3-命名的规约\" class=\"headerlink\" title=\"2.3 命名的规约\"></a>2.3 命名的规约</h4><ul>\n<li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li>\n<li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li>\n<li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数据类型之间的转换\"><a href=\"#3-数据类型之间的转换\" class=\"headerlink\" title=\"3. 数据类型之间的转换\"></a>3. 数据类型之间的转换</h3><h4 id=\"3-1-基本数据类型之间转换\"><a href=\"#3-1-基本数据类型之间转换\" class=\"headerlink\" title=\"3.1 基本数据类型之间转换\"></a>3.1 基本数据类型之间转换</h4><ol>\n<li>自动类型转换：从小类型到大类型自动转换</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class=\"line\">          char -----^</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long big = 1024L\\*1024\\*1024;</span><br><span class=\"line\">int i = (int)big;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2其他数据类型之间转换\"><a href=\"#3-2其他数据类型之间转换\" class=\"headerlink\" title=\"3.2其他数据类型之间转换\"></a>3.2其他数据类型之间转换</h4><ul>\n<li>同种大数据类型之间才能发生转换</li>\n<li>类型转换之前，保证大前提：同种大数据类型一致<ul>\n<li>基本–基本   可以直接转换(自动 强制)</li>\n<li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li>\n<li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li>\n</ul>\n</li>\n<li>保证大数据类型一致的前提下(都是基本类型)</li>\n</ul>\n<ul>\n<li><p>小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点</p>\n<ul>\n<li>比较内存空间的大小</li>\n<li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li>\n<li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li>\n<li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class=\"line\">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class=\"line\">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class=\"line\">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>小数据类型不一致:整型–&gt;浮点</p>\n<ul>\n<li>比较精确程度</li>\n<li>浮点型的精确程度更高</li>\n<li>任何一个浮点型空间都可以直接接受一个整型的值</li>\n<li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 1;  float b = a;//自动直接转化</span><br><span class=\"line\">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>整型–&gt;字符</p>\n<ul>\n<li>每一个字符都对应这一个Unicode码   a–97<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char x = &apos;a&apos;;  int y = x;//自动转化  y--97</span><br><span class=\"line\">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>布尔类型很特殊</p>\n<ul>\n<li>不能与其他基本类型之间发生转化</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4. 运算符\"></a>4. 运算符</h3><ol>\n<li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>\n<li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>\n<li>自增减运算符： <code>++</code>，<code>--</code></li>\n<li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li>\n<li>三目运算符： 条件 ? 表达式1 ： 表达式2</li>\n<li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code> </li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-循环\"><a href=\"#5-循环\" class=\"headerlink\" title=\"5. 循环\"></a>5. 循环</h3><ol>\n<li>while循环和for循环完全可以互换。</li>\n<li>while循环主要用于明确循环条件，但不明确循环次数的场合</li>\n<li>for循环主要用于明确次数或范围的场合</li>\n<li>while(true) 等价于 for(;;)，表示无限循环。</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h3><h4 id=\"6-1-一维数组\"><a href=\"#6-1-一维数组\" class=\"headerlink\" title=\"6.1 一维数组\"></a>6.1 一维数组</h4><ul>\n<li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = <span class=\"keyword\">new</span> 数据类型[长度] <span class=\"comment\">//动态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = &#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, ...&#125; <span class=\"comment\">//静态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*特殊方式：*/</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-二维数组\"><a href=\"#6-2-二维数组\" class=\"headerlink\" title=\"6.2 二维数组\"></a>6.2 二维数组</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = <span class=\"keyword\">new</span> 数据类型[行数][列数]</span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>][<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = &#123;&#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>&#125;,&#123;值<span class=\"number\">2</span>,...&#125; ...&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"number\">01</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">8</span>, <span class=\"number\">20</span>, <span class=\"number\">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二维数组arr.length表示行数，arr[0].length表示此行的长度</p>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h3><ul>\n<li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(a +<span class=\"string\">\"到\"</span>+ b +<span class=\"string\">\"的和是\"</span>+ sum);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li>\n<li>函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这是<strong>javaSE知识梳理</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p>","more":"<ol>\n<li><a href=\"#id1\">数据类型</a></li>\n<li><a href=\"#id2\">变量与常量</a></li>\n<li><a href=\"#id3\">数据类型之间的转换</a></li>\n<li><a href=\"#id4\">运算符</a></li>\n<li><a href=\"#id5\">循环</a></li>\n<li><a href=\"#id6\">数组</a></li>\n<li><a href=\"#id7\">函数</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><h4 id=\"1-1-分为两大类：\"><a href=\"#1-1-分为两大类：\" class=\"headerlink\" title=\"1.1 分为两大类：\"></a>1.1 分为两大类：</h4><ol>\n<li>基本数据类型：byte，short，int，long，float，double，boolean，char</li>\n<li>引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface</li>\n</ol>\n<blockquote>\n<p>注：<code>单个字节</code>表示<code>8位二进制</code>位，最左边表示符号位（0：正，1：负）。</p>\n</blockquote>\n<h4 id=\"1-2-整数类型（byte，short，int，long）\"><a href=\"#1-2-整数类型（byte，short，int，long）\" class=\"headerlink\" title=\"1.2 整数类型（byte，short，int，long）\"></a>1.2 整数类型（byte，short，int，long）</h4><ol>\n<li><strong>byte</strong>： 1个字节，范围<code>-2^7~2^7-1</code>，即<code>-128~127</code>。</li>\n<li><strong>short</strong>：2个字节，范围<code>-2^15~2^15-1</code>，即<code>-32768~32767</code>。</li>\n<li><strong>int</strong>:   4个字节，范围<code>-2^31~2^31-1</code>，即<code>正负21亿</code>之间。</li>\n<li><strong>long</strong>： 8个字节，范围<code>-2^63~2^63-1</code>，比int更大。如果要表示long直接量，需要<code>L</code>或<code>l</code>结尾。</li>\n</ol>\n<h4 id=\"1-3-浮点类型（float，double）\"><a href=\"#1-3-浮点类型（float，double）\" class=\"headerlink\" title=\"1.3 浮点类型（float，double）\"></a>1.3 浮点类型（float，double）</h4><ol>\n<li><strong>float</strong>： 4个字节，单精度浮点数，取到<code>小数点后7</code>位有效数字。如果要表示float直接量，需要<code>F</code>或<code>f</code>结尾</li>\n<li><strong>double</strong>：8个字节，双精度浮点数，取到<code>小数点后15</code>位有效数字。</li>\n</ol>\n<blockquote>\n<p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p>\n</blockquote>\n<h4 id=\"1-4-布尔类型（boolean）\"><a href=\"#1-4-布尔类型（boolean）\" class=\"headerlink\" title=\"1.4 布尔类型（boolean）\"></a>1.4 布尔类型（boolean）</h4><ol>\n<li><strong>boolean</strong>：1个字节（未明确规定），值只有<code>true</code>和<code>false</code>。</li>\n</ol>\n<h4 id=\"1-5-字符类型（char）\"><a href=\"#1-5-字符类型（char）\" class=\"headerlink\" title=\"1.5 字符类型（char）\"></a>1.5 字符类型（char）</h4><ol>\n<li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。</li>\n</ol>\n<ul>\n<li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。</li>\n<li>需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10</li>\n<li>常用转义符(逃逸字符)：<code>\\t</code>:制表符，<code>\\n</code>:换行，<code>\\&quot;</code>，<code>\\&#39;</code>，<code>\\\\</code>:反斜杠本身，<code>\\b</code>:回退一格，<code>\\r</code>:回车</li>\n<li>字符类型计算<ul>\n<li>一个字符加一个数字，得到Unicode码表中那个数之后的字符</li>\n<li>两个字符相减得到它们在表中的距离</li>\n<li>char也可以和int之间相互赋值</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-变量与常量\"><a href=\"#2-变量与常量\" class=\"headerlink\" title=\"2. 变量与常量\"></a>2. 变量与常量</h3><h4 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h4><ul>\n<li>常量是一个值，在程序运行的过程中不能再次发生改变</li>\n<li>基本类型的值都可以认为是常量   4  3.4  ‘a’  true，String类(引用数据类型)值”abc”视为常量</li>\n<li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit–int   64bit–double</li>\n</ul>\n<h4 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h4><ul>\n<li>变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的</li>\n<li>变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字</li>\n<li>变量空间   里面只能存储一个内容(值/引用)</li>\n<li>空间内的内容的类型与定义时一致 内容可以改变 </li>\n<li>内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值</li>\n</ul>\n<h4 id=\"2-3-标识符（变量）命名规则\"><a href=\"#2-3-标识符（变量）命名规则\" class=\"headerlink\" title=\"2.3 标识符（变量）命名规则\"></a>2.3 标识符（变量）命名规则</h4><ol>\n<li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li>\n<li>不能使用Java语言中的关键字，如class，static，void，int等。</li>\n<li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li>\n</ol>\n<h4 id=\"2-3-命名的规约\"><a href=\"#2-3-命名的规约\" class=\"headerlink\" title=\"2.3 命名的规约\"></a>2.3 命名的规约</h4><ul>\n<li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li>\n<li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li>\n<li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数据类型之间的转换\"><a href=\"#3-数据类型之间的转换\" class=\"headerlink\" title=\"3. 数据类型之间的转换\"></a>3. 数据类型之间的转换</h3><h4 id=\"3-1-基本数据类型之间转换\"><a href=\"#3-1-基本数据类型之间转换\" class=\"headerlink\" title=\"3.1 基本数据类型之间转换\"></a>3.1 基本数据类型之间转换</h4><ol>\n<li>自动类型转换：从小类型到大类型自动转换</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class=\"line\">          char -----^</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long big = 1024L\\*1024\\*1024;</span><br><span class=\"line\">int i = (int)big;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2其他数据类型之间转换\"><a href=\"#3-2其他数据类型之间转换\" class=\"headerlink\" title=\"3.2其他数据类型之间转换\"></a>3.2其他数据类型之间转换</h4><ul>\n<li>同种大数据类型之间才能发生转换</li>\n<li>类型转换之前，保证大前提：同种大数据类型一致<ul>\n<li>基本–基本   可以直接转换(自动 强制)</li>\n<li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li>\n<li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li>\n</ul>\n</li>\n<li>保证大数据类型一致的前提下(都是基本类型)</li>\n</ul>\n<ul>\n<li><p>小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点</p>\n<ul>\n<li>比较内存空间的大小</li>\n<li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li>\n<li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li>\n<li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class=\"line\">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class=\"line\">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class=\"line\">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>小数据类型不一致:整型–&gt;浮点</p>\n<ul>\n<li>比较精确程度</li>\n<li>浮点型的精确程度更高</li>\n<li>任何一个浮点型空间都可以直接接受一个整型的值</li>\n<li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 1;  float b = a;//自动直接转化</span><br><span class=\"line\">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>整型–&gt;字符</p>\n<ul>\n<li>每一个字符都对应这一个Unicode码   a–97<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char x = &apos;a&apos;;  int y = x;//自动转化  y--97</span><br><span class=\"line\">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>布尔类型很特殊</p>\n<ul>\n<li>不能与其他基本类型之间发生转化</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4. 运算符\"></a>4. 运算符</h3><ol>\n<li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>\n<li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>\n<li>自增减运算符： <code>++</code>，<code>--</code></li>\n<li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li>\n<li>三目运算符： 条件 ? 表达式1 ： 表达式2</li>\n<li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code> </li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-循环\"><a href=\"#5-循环\" class=\"headerlink\" title=\"5. 循环\"></a>5. 循环</h3><ol>\n<li>while循环和for循环完全可以互换。</li>\n<li>while循环主要用于明确循环条件，但不明确循环次数的场合</li>\n<li>for循环主要用于明确次数或范围的场合</li>\n<li>while(true) 等价于 for(;;)，表示无限循环。</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h3><h4 id=\"6-1-一维数组\"><a href=\"#6-1-一维数组\" class=\"headerlink\" title=\"6.1 一维数组\"></a>6.1 一维数组</h4><ul>\n<li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = <span class=\"keyword\">new</span> 数据类型[长度] <span class=\"comment\">//动态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = &#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, ...&#125; <span class=\"comment\">//静态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*特殊方式：*/</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-二维数组\"><a href=\"#6-2-二维数组\" class=\"headerlink\" title=\"6.2 二维数组\"></a>6.2 二维数组</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = <span class=\"keyword\">new</span> 数据类型[行数][列数]</span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>][<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = &#123;&#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>&#125;,&#123;值<span class=\"number\">2</span>,...&#125; ...&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"number\">01</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">8</span>, <span class=\"number\">20</span>, <span class=\"number\">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二维数组arr.length表示行数，arr[0].length表示此行的长度</p>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h3><ul>\n<li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(a +<span class=\"string\">\"到\"</span>+ b +<span class=\"string\">\"的和是\"</span>+ sum);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li>\n<li>函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用</li>\n</ul>"},{"title":"八、JavaSE反射机制","date":"2019-07-10T07:47:15.000Z","_content":"\n反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [Class类](#id2)\n3. [Constructor类](#id3)\n4. [Field类](#id4)\n5. [Method类](#id5)\n6. [原始方式与反射方式构造对象实例](#id6)\n7. [注解(Annotation)](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 基本概念\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；\n类是用来描述一组对象，反射机制可以理解为是用来描述一组类\n\n通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。\n\n#### 1.1 相关类及描述\n- Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n- Package：用来描述类所属的包\n- Field：用来描述类中的属性\n- Method：用来描述类中的方法\n- Constructor：用来描述类中的构造方法\n- Annotation：用来描述类中的注解\n\n\n<span id=\"id2\"><span>\n### 2. Class类\njava.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n\n#### 2.1 获取Class类型对象的三种方式\n``` java\nClass clazz = Class.forName(\"包名.类名\");//用的最多，但可能抛出ClassNotFoundException异常\nClass clazz = 类名.class;//任何类都有一个隐含的静态成员变量class\nClass clazz = 对象.getClass();//Object类中的方法\nClass clazz = 包装类.TYPE;//获取对应基本数据类型的class对象\n```\n\n#### 2.2 常用方法\n- static Class<?> forName(String className)\n    * 用于获取参数指定对应的Class对象并返回\n- T newInstance()\n    * 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n- Constructor<T> getConstructor(Class<?>... parameterTypes)\n    * 用于获取此Class对象所表示类型中参数指定的公共构造方法。\n- Constructor<?>[] getConstructors()\n    * 用于获取此Class对象所表示类型中所有的公共构造方法\n- Field getDeclaredField(String name)\n    * 用于获取此Class对象所表示类中参数指定的单个成员变量信息\n- Field[] fs = getDeclaredFields()\n    * 用于获取此Class对象所表示类中所有成员变量信息\n- Method getMethod(String name, Class<?>... parameterTypes)\n    * 用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法\n- Method[] getMethods()\n    * 用于获取该Class对象表示类中所有公共成员方法。\n- 获取私有相关方法\n    * getDeclaredConstructor(Class<?>... parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)\n    * getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)\n    * getDeclaredMethod(String name, Class<?>... parameterTypes) 获取一个方法(自己类 公有 私有)\n    * getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)\n\n\n#### 2.3 其他方法\n1. int result = getModifiers(); 获取类的修饰符(权限+特征)\n    * 每一个修饰符 用一个整数来进行表示：0--默认不写，1--public，2--private，4--protected，-static， 16--final，32--synchronized，64volatile，128--transient，256--native，512--interface，1024--abstract\n2. String name = getName(); 获取类的全名(包名.类名)\n3. String name = getSimpleName(); 获取类简单名(只有类名 缺少包)\n4. Package p = getPackage(); 获取当前类所属的包\n    * p.getName(); 获取包名(Package类中的方法)\n5. Class sclazz = getSuperClass(); 获取超类(父类)对应Class\n6. Class[] classes = getInterface(); 获取当前类父亲接口\n7. Class[] classes = getClasses(); 获取类中的内部类\n8. Object obj = **newInstance()**; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n9. Field f = getField(\"属性名\"); 获取类中的属性(公有的 自己类+父类)\n10. Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)\n11. getDeclaredField(\"属性\"); 获取当前类中的属性(公有+私有 自己类)\n12. Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)\n\n\n<span id=\"id3\"><span>\n### 3. Constructor类\njava.lang.reflect.Constructor类主要用于描述获取到的构造方法信息\n\n#### 3.1 Constructor类中的常用方法\n- T newInstance(Object... initargs)\n    * 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。\n\n#### 3.2 其他方法\n- con.getModifiers();\n- con.getName();\n- con.getParameterTypes();\n- con.getExceptionTypes();\n- 如何操作构造方法\n    * 执行一次,创建对象\n    * Object = newInstance(执行构造方法时的所有参数);\n    * con.setAccessible(true);\n\n\n<span id=\"id4\"><span>\n### 4. Field类\njava.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。\n\n#### 4.1 Field类中的常用方法\n- Object get(Object obj)\n    * 调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。\n- Object set(Object obj, Object value)\n    * 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。\n- void setAccessible(boolean flag)\n    * 当实参传递true时，则反射的对象在使用时应该取消java语言访问检查\n\n\n#### 4.2 其他方法\n1. int = getModifiers(); 获取属性修饰符(权限+特征)\n2. Class = getType(); 获取属性的类型对应的那个class\n3. String = getName(); 获取属性的名字\n4. 操作属性: set(对象,值); Object = get(对象);\n    * 如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入\n\n\n<span id=\"id5\"><span>\n### 5. Method类\njava.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。\n\n#### 5.1 Method类中的常用方法\n- Object invoke(Object obj, Object... args)\n    * 使用对象obj来调用此Method对象所表示的成员方法，实参传递args。\n\n#### 5.2 其他方法\n- int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)\n- Class mrt = m.getReturnType(); 获取返回值数据类型\n- String mn = m.getName(); 获取方法的名字\n- Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型\n- Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型\n- 如何操作方法\n- 调用方法   让他执行一次\n- Object result = invoke(对象,执行方法需要传递的所有参数...);\n- 若方法是私有的方法  不允许操作\n- 可以设置setAccessable(true)   设置方法使用权  准入\n\n\n<span id=\"id6\"><span>\n### 6. 原始方式与反射方式构造对象实例\n1. 使用原始方式来构造对象\n\n``` java\n  //1.采用无参的方式构造Person对象并打印\nPerson p = new Person();\nSystem.out.println(p); //null 0\n  //2.使用有参方式来构造Person对象\nPerson p2 = new Person(\"zhangfei\", 30);\nSystem.out.println(p2); //zhangfei 30\n  //3.修改与获取属性(成员变量)，调用get,set方法\np2.setName(\"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + p2.getName()); //guanyu\n```\n\n2. 使用反射机制来构造对象\n\n``` java\n    //1.使用获取到的Class对象来构造Person对象并打印\nClass c1 = Class.forName(\"myproject.Person\");//不可省略包名\nSystem.out.println(c1.newInstance());//null 0\n    //2.使用有参方式来构造对象\nClass c2 = Class.forName(\"myproject.Person\");\nConstructor ct2 = c2.getConstructor(String.class, int.class);\nObject obj = ct2.newInstance(\"zhangfei\", 30);\nSystem.out.println(obj);//zhangfei 30\n    //3.修改与获取属性(成员变量)\nField f2 = c2.getDeclaredField(\"name\");\nf2.setAccessible(true);//暴力反射，设置使用权\nf2.set(obj, \"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + f2.get(obj)); //guanyu\n    //4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来\nMethod m1 = c2.getMethod(\"getName\");\nSystem.out.println(\"获取到的姓名是：\" + m1.invoke(obj)); //zhangfei\n    //5.成员方法setName，调用getMethod方法来修改姓名并打印出来\nMethod m2 = c2.getMethod(\"setName\", String.class);\nObject res = m2.invoke(obj, \"guanyu\");\nSystem.out.println(\"方法调用的返回值是：\" + res); //null\nSystem.out.println(\"修改后的姓名是：\" + m1.invoke(obj)); //guanyu\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 注解(Annotation)\n#### 7.1 注解相关概念\n- 注释\n    * 单行注释：`//`\n    * 多行注释：`/*   */`\n    * 文档注释：`/**   */`\n- 注解的写法\n    * `@XXX [(一些信息)]`\n- 注解位置\n    * 类的上面，属性上面，方法上面，构造方法上面，参数前面\n- 注解的作用\n    1. 用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated\n    2. 用来做代码的检测(验证)，@Override\n    3. *可以携带一些信息(内容)，文件.properties/.xml，注解\n- 常用的注解\n    * @Deprecated：用来说明方法是废弃的\n    * @Override：用来做代码检测   检测此方法是否是一个重写\n    * @SuppressWarnings(String[])：{\"\"}，如果数组内的元素只有一个长度，可以省略{}\n        + unused：变量定义后未被使用\n        + serial：类实现了序列化接口  不添加序列化ID号\n        + rawtypes：集合没有定义泛型\n        + deprecation：方法以废弃    \n        + *unchecked：出现了泛型的问题  可以不检测\n        + all：包含了以上所有(不推荐)\n- 注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：\n    1. 基本数据类型\n    2. String类型\n    3. 枚举类型enum\n    4. 注解类型@\n    5. 数组类型[]，数组的内部需要是如上的四种类型\n- 注解的分类\n    1. 按运行机制分：源码注解，编译时注解，运行时注解\n    2. 按照来源分：来自JDK的注解，来自第三方的注解，自定义注解\n    \n\n#### 7.2 自定义注解类型的语法要求：\n1. 使用@interface关键字定义注解\n2. 成员以**无参无异常**方式声明\n3. 可以用default为成员指定一个默认值\n4. 成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration\n5. 如果注解只有一个成员，则成员名必须取名**value()**,在使用时可以忽略成员名和赋值号(=)\n6. 注解类可以没有成员，没有成员的注解称为标识注解\n7. 需要元注解来描述说明\n    + @Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)\n    + @Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)--->编译--->字节码文件(CLASS)--->加载--->内存执行(RUNTIME)\n    + @Inherited：允许子类继承\n    + @Document：当前注解是否能被文档(javadoc)所记录\n\n``` java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 18;\n}\n```\n\n#### 7.3 使用自定义注解：\n* @<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n\n``` java\n@Description(desc=\"I am eyeColor\", author=\"Chao\", age=18)\npublic String eyeColor(){\n    return \"red\";\n}\n```\n\n> 如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字\n\n``` java\n@Description(\"I am class annotation\")\npublic class Child implements Person{\n    @Override\n    @Description(\"I am method annotation\")\n    public String name(){\n        return null;\n    }\n    @Override\n    public int age(){\n        return 0;\n    }\n    @Override\n    public void sing(){ }\n}\n```\n\n#### 7.4 解析注解\n通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。\n\n1. 使用类加载器加载类\n    * `Class c=Class.forName（\"com.ann.test.Child\")`\n2. 找到类上面的注解\n    * `isAnnotationPresent（类类型）`：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。\n3. 拿到注解实例，需要强制类型转换。\n    * `Description d=（Description）c.getAnnotation(Description.class);`\n4. 找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。\n\n``` java\npublic class ParseAnn{\n  public static void main(String[]){\n    try{//1. 使用类加载器加载类\n      Class c=Class.forName（\"com.ann.test.Child\")\n      //2. 找到类上面的注解\n      boolean isExist = c.isAnnotationPresent(Description.class);\n      if(isExist){\n        //3. 拿到注解实例\n        Description d=（Description）c.getAnnotation(Description.class);\n        System.out.println(d.value());\n      }\n      //4.找到方法上的注解\n      Method[] ms = c.getMethods();\n      for(Method m:ms){\n        boolean isMExist = m.isAnnotationPresent(Description.class);\n        if(isMExist){\n          Description md=（Description）c.getAnnotation(Description.class);\n          System.out.println(md.value());\n        }\n      }\n    }catch(ClassNotFoundException e){\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n* 另一种解析方法上的注解:\n    + 获取这个方法的所有注解，`Annotation [] as=m.getAnnotations();`然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。\n\n``` java\nfor(Method m:ms){\n  Annotation [] as=m.getAnnotations();\n  for(Annotation a:as){\n    if(a instanceof Description){\n      Description md = (Description)a;\n      System.out.println(md.value());\n    }\n  }\n}\n```\n\n> @Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 \n\n","source":"_posts/08_JavaSE反射机制.md","raw":"---\ntitle: 八、JavaSE反射机制\ndate: 2019-07-10 15:47:15\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [Class类](#id2)\n3. [Constructor类](#id3)\n4. [Field类](#id4)\n5. [Method类](#id5)\n6. [原始方式与反射方式构造对象实例](#id6)\n7. [注解(Annotation)](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 基本概念\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；\n类是用来描述一组对象，反射机制可以理解为是用来描述一组类\n\n通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。\n\n#### 1.1 相关类及描述\n- Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n- Package：用来描述类所属的包\n- Field：用来描述类中的属性\n- Method：用来描述类中的方法\n- Constructor：用来描述类中的构造方法\n- Annotation：用来描述类中的注解\n\n\n<span id=\"id2\"><span>\n### 2. Class类\njava.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n\n#### 2.1 获取Class类型对象的三种方式\n``` java\nClass clazz = Class.forName(\"包名.类名\");//用的最多，但可能抛出ClassNotFoundException异常\nClass clazz = 类名.class;//任何类都有一个隐含的静态成员变量class\nClass clazz = 对象.getClass();//Object类中的方法\nClass clazz = 包装类.TYPE;//获取对应基本数据类型的class对象\n```\n\n#### 2.2 常用方法\n- static Class<?> forName(String className)\n    * 用于获取参数指定对应的Class对象并返回\n- T newInstance()\n    * 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n- Constructor<T> getConstructor(Class<?>... parameterTypes)\n    * 用于获取此Class对象所表示类型中参数指定的公共构造方法。\n- Constructor<?>[] getConstructors()\n    * 用于获取此Class对象所表示类型中所有的公共构造方法\n- Field getDeclaredField(String name)\n    * 用于获取此Class对象所表示类中参数指定的单个成员变量信息\n- Field[] fs = getDeclaredFields()\n    * 用于获取此Class对象所表示类中所有成员变量信息\n- Method getMethod(String name, Class<?>... parameterTypes)\n    * 用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法\n- Method[] getMethods()\n    * 用于获取该Class对象表示类中所有公共成员方法。\n- 获取私有相关方法\n    * getDeclaredConstructor(Class<?>... parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)\n    * getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)\n    * getDeclaredMethod(String name, Class<?>... parameterTypes) 获取一个方法(自己类 公有 私有)\n    * getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)\n\n\n#### 2.3 其他方法\n1. int result = getModifiers(); 获取类的修饰符(权限+特征)\n    * 每一个修饰符 用一个整数来进行表示：0--默认不写，1--public，2--private，4--protected，-static， 16--final，32--synchronized，64volatile，128--transient，256--native，512--interface，1024--abstract\n2. String name = getName(); 获取类的全名(包名.类名)\n3. String name = getSimpleName(); 获取类简单名(只有类名 缺少包)\n4. Package p = getPackage(); 获取当前类所属的包\n    * p.getName(); 获取包名(Package类中的方法)\n5. Class sclazz = getSuperClass(); 获取超类(父类)对应Class\n6. Class[] classes = getInterface(); 获取当前类父亲接口\n7. Class[] classes = getClasses(); 获取类中的内部类\n8. Object obj = **newInstance()**; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n9. Field f = getField(\"属性名\"); 获取类中的属性(公有的 自己类+父类)\n10. Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)\n11. getDeclaredField(\"属性\"); 获取当前类中的属性(公有+私有 自己类)\n12. Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)\n\n\n<span id=\"id3\"><span>\n### 3. Constructor类\njava.lang.reflect.Constructor类主要用于描述获取到的构造方法信息\n\n#### 3.1 Constructor类中的常用方法\n- T newInstance(Object... initargs)\n    * 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。\n\n#### 3.2 其他方法\n- con.getModifiers();\n- con.getName();\n- con.getParameterTypes();\n- con.getExceptionTypes();\n- 如何操作构造方法\n    * 执行一次,创建对象\n    * Object = newInstance(执行构造方法时的所有参数);\n    * con.setAccessible(true);\n\n\n<span id=\"id4\"><span>\n### 4. Field类\njava.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。\n\n#### 4.1 Field类中的常用方法\n- Object get(Object obj)\n    * 调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。\n- Object set(Object obj, Object value)\n    * 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。\n- void setAccessible(boolean flag)\n    * 当实参传递true时，则反射的对象在使用时应该取消java语言访问检查\n\n\n#### 4.2 其他方法\n1. int = getModifiers(); 获取属性修饰符(权限+特征)\n2. Class = getType(); 获取属性的类型对应的那个class\n3. String = getName(); 获取属性的名字\n4. 操作属性: set(对象,值); Object = get(对象);\n    * 如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入\n\n\n<span id=\"id5\"><span>\n### 5. Method类\njava.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。\n\n#### 5.1 Method类中的常用方法\n- Object invoke(Object obj, Object... args)\n    * 使用对象obj来调用此Method对象所表示的成员方法，实参传递args。\n\n#### 5.2 其他方法\n- int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)\n- Class mrt = m.getReturnType(); 获取返回值数据类型\n- String mn = m.getName(); 获取方法的名字\n- Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型\n- Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型\n- 如何操作方法\n- 调用方法   让他执行一次\n- Object result = invoke(对象,执行方法需要传递的所有参数...);\n- 若方法是私有的方法  不允许操作\n- 可以设置setAccessable(true)   设置方法使用权  准入\n\n\n<span id=\"id6\"><span>\n### 6. 原始方式与反射方式构造对象实例\n1. 使用原始方式来构造对象\n\n``` java\n  //1.采用无参的方式构造Person对象并打印\nPerson p = new Person();\nSystem.out.println(p); //null 0\n  //2.使用有参方式来构造Person对象\nPerson p2 = new Person(\"zhangfei\", 30);\nSystem.out.println(p2); //zhangfei 30\n  //3.修改与获取属性(成员变量)，调用get,set方法\np2.setName(\"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + p2.getName()); //guanyu\n```\n\n2. 使用反射机制来构造对象\n\n``` java\n    //1.使用获取到的Class对象来构造Person对象并打印\nClass c1 = Class.forName(\"myproject.Person\");//不可省略包名\nSystem.out.println(c1.newInstance());//null 0\n    //2.使用有参方式来构造对象\nClass c2 = Class.forName(\"myproject.Person\");\nConstructor ct2 = c2.getConstructor(String.class, int.class);\nObject obj = ct2.newInstance(\"zhangfei\", 30);\nSystem.out.println(obj);//zhangfei 30\n    //3.修改与获取属性(成员变量)\nField f2 = c2.getDeclaredField(\"name\");\nf2.setAccessible(true);//暴力反射，设置使用权\nf2.set(obj, \"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + f2.get(obj)); //guanyu\n    //4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来\nMethod m1 = c2.getMethod(\"getName\");\nSystem.out.println(\"获取到的姓名是：\" + m1.invoke(obj)); //zhangfei\n    //5.成员方法setName，调用getMethod方法来修改姓名并打印出来\nMethod m2 = c2.getMethod(\"setName\", String.class);\nObject res = m2.invoke(obj, \"guanyu\");\nSystem.out.println(\"方法调用的返回值是：\" + res); //null\nSystem.out.println(\"修改后的姓名是：\" + m1.invoke(obj)); //guanyu\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 注解(Annotation)\n#### 7.1 注解相关概念\n- 注释\n    * 单行注释：`//`\n    * 多行注释：`/*   */`\n    * 文档注释：`/**   */`\n- 注解的写法\n    * `@XXX [(一些信息)]`\n- 注解位置\n    * 类的上面，属性上面，方法上面，构造方法上面，参数前面\n- 注解的作用\n    1. 用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated\n    2. 用来做代码的检测(验证)，@Override\n    3. *可以携带一些信息(内容)，文件.properties/.xml，注解\n- 常用的注解\n    * @Deprecated：用来说明方法是废弃的\n    * @Override：用来做代码检测   检测此方法是否是一个重写\n    * @SuppressWarnings(String[])：{\"\"}，如果数组内的元素只有一个长度，可以省略{}\n        + unused：变量定义后未被使用\n        + serial：类实现了序列化接口  不添加序列化ID号\n        + rawtypes：集合没有定义泛型\n        + deprecation：方法以废弃    \n        + *unchecked：出现了泛型的问题  可以不检测\n        + all：包含了以上所有(不推荐)\n- 注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：\n    1. 基本数据类型\n    2. String类型\n    3. 枚举类型enum\n    4. 注解类型@\n    5. 数组类型[]，数组的内部需要是如上的四种类型\n- 注解的分类\n    1. 按运行机制分：源码注解，编译时注解，运行时注解\n    2. 按照来源分：来自JDK的注解，来自第三方的注解，自定义注解\n    \n\n#### 7.2 自定义注解类型的语法要求：\n1. 使用@interface关键字定义注解\n2. 成员以**无参无异常**方式声明\n3. 可以用default为成员指定一个默认值\n4. 成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration\n5. 如果注解只有一个成员，则成员名必须取名**value()**,在使用时可以忽略成员名和赋值号(=)\n6. 注解类可以没有成员，没有成员的注解称为标识注解\n7. 需要元注解来描述说明\n    + @Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)\n    + @Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)--->编译--->字节码文件(CLASS)--->加载--->内存执行(RUNTIME)\n    + @Inherited：允许子类继承\n    + @Document：当前注解是否能被文档(javadoc)所记录\n\n``` java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 18;\n}\n```\n\n#### 7.3 使用自定义注解：\n* @<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n\n``` java\n@Description(desc=\"I am eyeColor\", author=\"Chao\", age=18)\npublic String eyeColor(){\n    return \"red\";\n}\n```\n\n> 如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字\n\n``` java\n@Description(\"I am class annotation\")\npublic class Child implements Person{\n    @Override\n    @Description(\"I am method annotation\")\n    public String name(){\n        return null;\n    }\n    @Override\n    public int age(){\n        return 0;\n    }\n    @Override\n    public void sing(){ }\n}\n```\n\n#### 7.4 解析注解\n通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。\n\n1. 使用类加载器加载类\n    * `Class c=Class.forName（\"com.ann.test.Child\")`\n2. 找到类上面的注解\n    * `isAnnotationPresent（类类型）`：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。\n3. 拿到注解实例，需要强制类型转换。\n    * `Description d=（Description）c.getAnnotation(Description.class);`\n4. 找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。\n\n``` java\npublic class ParseAnn{\n  public static void main(String[]){\n    try{//1. 使用类加载器加载类\n      Class c=Class.forName（\"com.ann.test.Child\")\n      //2. 找到类上面的注解\n      boolean isExist = c.isAnnotationPresent(Description.class);\n      if(isExist){\n        //3. 拿到注解实例\n        Description d=（Description）c.getAnnotation(Description.class);\n        System.out.println(d.value());\n      }\n      //4.找到方法上的注解\n      Method[] ms = c.getMethods();\n      for(Method m:ms){\n        boolean isMExist = m.isAnnotationPresent(Description.class);\n        if(isMExist){\n          Description md=（Description）c.getAnnotation(Description.class);\n          System.out.println(md.value());\n        }\n      }\n    }catch(ClassNotFoundException e){\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n* 另一种解析方法上的注解:\n    + 获取这个方法的所有注解，`Annotation [] as=m.getAnnotations();`然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。\n\n``` java\nfor(Method m:ms){\n  Annotation [] as=m.getAnnotations();\n  for(Annotation a:as){\n    if(a instanceof Description){\n      Description md = (Description)a;\n      System.out.println(md.value());\n    }\n  }\n}\n```\n\n> @Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 \n\n","slug":"08_JavaSE反射机制","published":1,"updated":"2019-07-20T14:56:40.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo5t001wyot3kug0u8j7","content":"<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">Class类</a></li>\n<li><a href=\"#id3\">Constructor类</a></li>\n<li><a href=\"#id4\">Field类</a></li>\n<li><a href=\"#id5\">Method类</a></li>\n<li><a href=\"#id6\">原始方式与反射方式构造对象实例</a></li>\n<li><a href=\"#id7\">注解(Annotation)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>\n<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>\n<h4 id=\"1-1-相关类及描述\"><a href=\"#1-1-相关类及描述\" class=\"headerlink\" title=\"1.1 相关类及描述\"></a>1.1 相关类及描述</h4><ul>\n<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>\n<li>Package：用来描述类所属的包</li>\n<li>Field：用来描述类中的属性</li>\n<li>Method：用来描述类中的方法</li>\n<li>Constructor：用来描述类中的构造方法</li>\n<li>Annotation：用来描述类中的注解</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Class类\"><a href=\"#2-Class类\" class=\"headerlink\" title=\"2. Class类\"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>\n<h4 id=\"2-1-获取Class类型对象的三种方式\"><a href=\"#2-1-获取Class类型对象的三种方式\" class=\"headerlink\" title=\"2.1 获取Class类型对象的三种方式\"></a>2.1 获取Class类型对象的三种方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"包名.类名\"</span>);<span class=\"comment\">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class=\"line\">Class clazz = 类名.class;<span class=\"comment\">//任何类都有一个隐含的静态成员变量class</span></span><br><span class=\"line\">Class clazz = 对象.getClass();<span class=\"comment\">//Object类中的方法</span></span><br><span class=\"line\">Class clazz = 包装类.TYPE;<span class=\"comment\">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-常用方法\"><a href=\"#2-2-常用方法\" class=\"headerlink\" title=\"2.2 常用方法\"></a>2.2 常用方法</h4><ul>\n<li>static Class&lt;?&gt; forName(String className)<ul>\n<li>用于获取参数指定对应的Class对象并返回</li>\n</ul>\n</li>\n<li>T newInstance()<ul>\n<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n</ul>\n</li>\n<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>\n</ul>\n</t></li>\n<li>Constructor&lt;?&gt;[] getConstructors()<ul>\n<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>\n</ul>\n</li>\n<li>Field getDeclaredField(String name)<ul>\n<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>\n</ul>\n</li>\n<li>Field[] fs = getDeclaredFields()<ul>\n<li>用于获取此Class对象所表示类中所有成员变量信息</li>\n</ul>\n</li>\n<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>\n</ul>\n</li>\n<li>Method[] getMethods()<ul>\n<li>用于获取该Class对象表示类中所有公共成员方法。</li>\n</ul>\n</li>\n<li>获取私有相关方法<ul>\n<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>\n<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>\n<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>\n<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-其他方法\"><a href=\"#2-3-其他方法\" class=\"headerlink\" title=\"2.3 其他方法\"></a>2.3 其他方法</h4><ol>\n<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>\n<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>\n</ul>\n</li>\n<li>String name = getName(); 获取类的全名(包名.类名)</li>\n<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>\n<li>Package p = getPackage(); 获取当前类所属的包<ul>\n<li>p.getName(); 获取包名(Package类中的方法)</li>\n</ul>\n</li>\n<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>\n<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>\n<li>Class[] classes = getClasses(); 获取类中的内部类</li>\n<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>\n<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>\n<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>\n<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Constructor类\"><a href=\"#3-Constructor类\" class=\"headerlink\" title=\"3. Constructor类\"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>\n<h4 id=\"3-1-Constructor类中的常用方法\"><a href=\"#3-1-Constructor类中的常用方法\" class=\"headerlink\" title=\"3.1 Constructor类中的常用方法\"></a>3.1 Constructor类中的常用方法</h4><ul>\n<li>T newInstance(Object… initargs)<ul>\n<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-其他方法\"><a href=\"#3-2-其他方法\" class=\"headerlink\" title=\"3.2 其他方法\"></a>3.2 其他方法</h4><ul>\n<li>con.getModifiers();</li>\n<li>con.getName();</li>\n<li>con.getParameterTypes();</li>\n<li>con.getExceptionTypes();</li>\n<li>如何操作构造方法<ul>\n<li>执行一次,创建对象</li>\n<li>Object = newInstance(执行构造方法时的所有参数);</li>\n<li>con.setAccessible(true);</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Field类\"><a href=\"#4-Field类\" class=\"headerlink\" title=\"4. Field类\"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>\n<h4 id=\"4-1-Field类中的常用方法\"><a href=\"#4-1-Field类中的常用方法\" class=\"headerlink\" title=\"4.1 Field类中的常用方法\"></a>4.1 Field类中的常用方法</h4><ul>\n<li>Object get(Object obj)<ul>\n<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>\n</ul>\n</li>\n<li>Object set(Object obj, Object value)<ul>\n<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>\n</ul>\n</li>\n<li>void setAccessible(boolean flag)<ul>\n<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-其他方法\"><a href=\"#4-2-其他方法\" class=\"headerlink\" title=\"4.2 其他方法\"></a>4.2 其他方法</h4><ol>\n<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>\n<li>Class = getType(); 获取属性的类型对应的那个class</li>\n<li>String = getName(); 获取属性的名字</li>\n<li>操作属性: set(对象,值); Object = get(对象);<ul>\n<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-Method类\"><a href=\"#5-Method类\" class=\"headerlink\" title=\"5. Method类\"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>\n<h4 id=\"5-1-Method类中的常用方法\"><a href=\"#5-1-Method类中的常用方法\" class=\"headerlink\" title=\"5.1 Method类中的常用方法\"></a>5.1 Method类中的常用方法</h4><ul>\n<li>Object invoke(Object obj, Object… args)<ul>\n<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-其他方法\"><a href=\"#5-2-其他方法\" class=\"headerlink\" title=\"5.2 其他方法\"></a>5.2 其他方法</h4><ul>\n<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>\n<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>\n<li>String mn = m.getName(); 获取方法的名字</li>\n<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>\n<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>\n<li>如何操作方法</li>\n<li>调用方法   让他执行一次</li>\n<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>\n<li>若方法是私有的方法  不允许操作</li>\n<li>可以设置setAccessable(true)   设置方法使用权  准入</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-原始方式与反射方式构造对象实例\"><a href=\"#6-原始方式与反射方式构造对象实例\" class=\"headerlink\" title=\"6. 原始方式与反射方式构造对象实例\"></a>6. 原始方式与反射方式构造对象实例</h3><ol>\n<li>使用原始方式来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//1.采用无参的方式构造Person对象并打印</span></span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p); <span class=\"comment\">//null 0</span></span><br><span class=\"line\">  <span class=\"comment\">//2.使用有参方式来构造Person对象</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(p2); <span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">  <span class=\"comment\">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class=\"line\">p2.setName(<span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + p2.getName()); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用反射机制来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class=\"line\">Class c1 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);<span class=\"comment\">//不可省略包名</span></span><br><span class=\"line\">System.out.println(c1.newInstance());<span class=\"comment\">//null 0</span></span><br><span class=\"line\">    <span class=\"comment\">//2.使用有参方式来构造对象</span></span><br><span class=\"line\">Class c2 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);</span><br><span class=\"line\">Constructor ct2 = c2.getConstructor(String.class, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Object obj = ct2.newInstance(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(obj);<span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">    <span class=\"comment\">//3.修改与获取属性(成员变量)</span></span><br><span class=\"line\">Field f2 = c2.getDeclaredField(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">f2.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//暴力反射，设置使用权</span></span><br><span class=\"line\">f2.set(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + f2.get(obj)); <span class=\"comment\">//guanyu</span></span><br><span class=\"line\">    <span class=\"comment\">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class=\"line\">Method m1 = c2.getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"获取到的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//zhangfei</span></span><br><span class=\"line\">    <span class=\"comment\">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class=\"line\">Method m2 = c2.getMethod(<span class=\"string\">\"setName\"</span>, String.class);</span><br><span class=\"line\">Object res = m2.invoke(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"方法调用的返回值是：\"</span> + res); <span class=\"comment\">//null</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-注解-Annotation\"><a href=\"#7-注解-Annotation\" class=\"headerlink\" title=\"7. 注解(Annotation)\"></a>7. 注解(Annotation)</h3><h4 id=\"7-1-注解相关概念\"><a href=\"#7-1-注解相关概念\" class=\"headerlink\" title=\"7.1 注解相关概念\"></a>7.1 注解相关概念</h4><ul>\n<li>注释<ul>\n<li>单行注释：<code>//</code></li>\n<li>多行注释：<code>/*   */</code></li>\n<li>文档注释：<code>/**   */</code></li>\n</ul>\n</li>\n<li>注解的写法<ul>\n<li><code>@XXX [(一些信息)]</code></li>\n</ul>\n</li>\n<li>注解位置<ul>\n<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>\n</ul>\n</li>\n<li>注解的作用<ol>\n<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>\n<li>用来做代码的检测(验证)，@Override</li>\n<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>\n</ol>\n</li>\n<li>常用的注解<ul>\n<li>@Deprecated：用来说明方法是废弃的</li>\n<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>\n<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>\n<li>unused：变量定义后未被使用</li>\n<li>serial：类实现了序列化接口  不添加序列化ID号</li>\n<li>rawtypes：集合没有定义泛型</li>\n<li>deprecation：方法以废弃    </li>\n<li>*unchecked：出现了泛型的问题  可以不检测</li>\n<li>all：包含了以上所有(不推荐)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>\n<li>基本数据类型</li>\n<li>String类型</li>\n<li>枚举类型enum</li>\n<li>注解类型@</li>\n<li>数组类型[]，数组的内部需要是如上的四种类型</li>\n</ol>\n</li>\n<li>注解的分类<ol>\n<li>按运行机制分：源码注解，编译时注解，运行时注解</li>\n<li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-2-自定义注解类型的语法要求：\"><a href=\"#7-2-自定义注解类型的语法要求：\" class=\"headerlink\" title=\"7.2 自定义注解类型的语法要求：\"></a>7.2 自定义注解类型的语法要求：</h4><ol>\n<li>使用@interface关键字定义注解</li>\n<li>成员以<strong>无参无异常</strong>方式声明</li>\n<li>可以用default为成员指定一个默认值</li>\n<li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li>\n<li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li>\n<li>注解类可以没有成员，没有成员的注解称为标识注解</li>\n<li>需要元注解来描述说明<ul>\n<li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li>\n<li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>\n<li>@Inherited：允许子类继承</li>\n<li>@Document：当前注解是否能被文档(javadoc)所记录</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-使用自定义注解：\"><a href=\"#7-3-使用自定义注解：\" class=\"headerlink\" title=\"7.3 使用自定义注解：\"></a>7.3 使用自定义注解：</h4><ul>\n<li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(desc=<span class=\"string\">\"I am eyeColor\"</span>, author=<span class=\"string\">\"Chao\"</span>, age=<span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">eyeColor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(<span class=\"string\">\"I am class annotation\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Description</span>(<span class=\"string\">\"I am method annotation\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-解析注解\"><a href=\"#7-4-解析注解\" class=\"headerlink\" title=\"7.4 解析注解\"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p>\n<ol>\n<li>使用类加载器加载类<ul>\n<li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li>\n</ul>\n</li>\n<li>找到类上面的注解<ul>\n<li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li>\n</ul>\n</li>\n<li>拿到注解实例，需要强制类型转换。<ul>\n<li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li>\n</ul>\n</li>\n<li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseAnn</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;<span class=\"comment\">//1. 使用类加载器加载类</span></span><br><span class=\"line\">      Class c=Class.forName（<span class=\"string\">\"com.ann.test.Child\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//2. 找到类上面的注解</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isExist)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3. 拿到注解实例</span></span><br><span class=\"line\">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">        System.out.println(d.value());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//4.找到方法上的注解</span></span><br><span class=\"line\">      Method[] ms = c.getMethods();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isMExist)&#123;</span><br><span class=\"line\">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">          System.out.println(md.value());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种解析方法上的注解:<ul>\n<li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">  Annotation [] as=m.getAnnotations();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">      Description md = (Description)a;</span><br><span class=\"line\">      System.out.println(md.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">Class类</a></li>\n<li><a href=\"#id3\">Constructor类</a></li>\n<li><a href=\"#id4\">Field类</a></li>\n<li><a href=\"#id5\">Method类</a></li>\n<li><a href=\"#id6\">原始方式与反射方式构造对象实例</a></li>\n<li><a href=\"#id7\">注解(Annotation)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>\n<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>\n<h4 id=\"1-1-相关类及描述\"><a href=\"#1-1-相关类及描述\" class=\"headerlink\" title=\"1.1 相关类及描述\"></a>1.1 相关类及描述</h4><ul>\n<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>\n<li>Package：用来描述类所属的包</li>\n<li>Field：用来描述类中的属性</li>\n<li>Method：用来描述类中的方法</li>\n<li>Constructor：用来描述类中的构造方法</li>\n<li>Annotation：用来描述类中的注解</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Class类\"><a href=\"#2-Class类\" class=\"headerlink\" title=\"2. Class类\"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>\n<h4 id=\"2-1-获取Class类型对象的三种方式\"><a href=\"#2-1-获取Class类型对象的三种方式\" class=\"headerlink\" title=\"2.1 获取Class类型对象的三种方式\"></a>2.1 获取Class类型对象的三种方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"包名.类名\"</span>);<span class=\"comment\">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class=\"line\">Class clazz = 类名.class;<span class=\"comment\">//任何类都有一个隐含的静态成员变量class</span></span><br><span class=\"line\">Class clazz = 对象.getClass();<span class=\"comment\">//Object类中的方法</span></span><br><span class=\"line\">Class clazz = 包装类.TYPE;<span class=\"comment\">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-常用方法\"><a href=\"#2-2-常用方法\" class=\"headerlink\" title=\"2.2 常用方法\"></a>2.2 常用方法</h4><ul>\n<li>static Class&lt;?&gt; forName(String className)<ul>\n<li>用于获取参数指定对应的Class对象并返回</li>\n</ul>\n</li>\n<li>T newInstance()<ul>\n<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n</ul>\n</li>\n<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>\n</ul>\n</t></li>\n<li>Constructor&lt;?&gt;[] getConstructors()<ul>\n<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>\n</ul>\n</li>\n<li>Field getDeclaredField(String name)<ul>\n<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>\n</ul>\n</li>\n<li>Field[] fs = getDeclaredFields()<ul>\n<li>用于获取此Class对象所表示类中所有成员变量信息</li>\n</ul>\n</li>\n<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>\n</ul>\n</li>\n<li>Method[] getMethods()<ul>\n<li>用于获取该Class对象表示类中所有公共成员方法。</li>\n</ul>\n</li>\n<li>获取私有相关方法<ul>\n<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>\n<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>\n<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>\n<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-其他方法\"><a href=\"#2-3-其他方法\" class=\"headerlink\" title=\"2.3 其他方法\"></a>2.3 其他方法</h4><ol>\n<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>\n<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>\n</ul>\n</li>\n<li>String name = getName(); 获取类的全名(包名.类名)</li>\n<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>\n<li>Package p = getPackage(); 获取当前类所属的包<ul>\n<li>p.getName(); 获取包名(Package类中的方法)</li>\n</ul>\n</li>\n<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>\n<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>\n<li>Class[] classes = getClasses(); 获取类中的内部类</li>\n<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>\n<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>\n<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>\n<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Constructor类\"><a href=\"#3-Constructor类\" class=\"headerlink\" title=\"3. Constructor类\"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>\n<h4 id=\"3-1-Constructor类中的常用方法\"><a href=\"#3-1-Constructor类中的常用方法\" class=\"headerlink\" title=\"3.1 Constructor类中的常用方法\"></a>3.1 Constructor类中的常用方法</h4><ul>\n<li>T newInstance(Object… initargs)<ul>\n<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-其他方法\"><a href=\"#3-2-其他方法\" class=\"headerlink\" title=\"3.2 其他方法\"></a>3.2 其他方法</h4><ul>\n<li>con.getModifiers();</li>\n<li>con.getName();</li>\n<li>con.getParameterTypes();</li>\n<li>con.getExceptionTypes();</li>\n<li>如何操作构造方法<ul>\n<li>执行一次,创建对象</li>\n<li>Object = newInstance(执行构造方法时的所有参数);</li>\n<li>con.setAccessible(true);</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Field类\"><a href=\"#4-Field类\" class=\"headerlink\" title=\"4. Field类\"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>\n<h4 id=\"4-1-Field类中的常用方法\"><a href=\"#4-1-Field类中的常用方法\" class=\"headerlink\" title=\"4.1 Field类中的常用方法\"></a>4.1 Field类中的常用方法</h4><ul>\n<li>Object get(Object obj)<ul>\n<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>\n</ul>\n</li>\n<li>Object set(Object obj, Object value)<ul>\n<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>\n</ul>\n</li>\n<li>void setAccessible(boolean flag)<ul>\n<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-其他方法\"><a href=\"#4-2-其他方法\" class=\"headerlink\" title=\"4.2 其他方法\"></a>4.2 其他方法</h4><ol>\n<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>\n<li>Class = getType(); 获取属性的类型对应的那个class</li>\n<li>String = getName(); 获取属性的名字</li>\n<li>操作属性: set(对象,值); Object = get(对象);<ul>\n<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-Method类\"><a href=\"#5-Method类\" class=\"headerlink\" title=\"5. Method类\"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>\n<h4 id=\"5-1-Method类中的常用方法\"><a href=\"#5-1-Method类中的常用方法\" class=\"headerlink\" title=\"5.1 Method类中的常用方法\"></a>5.1 Method类中的常用方法</h4><ul>\n<li>Object invoke(Object obj, Object… args)<ul>\n<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-其他方法\"><a href=\"#5-2-其他方法\" class=\"headerlink\" title=\"5.2 其他方法\"></a>5.2 其他方法</h4><ul>\n<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>\n<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>\n<li>String mn = m.getName(); 获取方法的名字</li>\n<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>\n<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>\n<li>如何操作方法</li>\n<li>调用方法   让他执行一次</li>\n<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>\n<li>若方法是私有的方法  不允许操作</li>\n<li>可以设置setAccessable(true)   设置方法使用权  准入</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-原始方式与反射方式构造对象实例\"><a href=\"#6-原始方式与反射方式构造对象实例\" class=\"headerlink\" title=\"6. 原始方式与反射方式构造对象实例\"></a>6. 原始方式与反射方式构造对象实例</h3><ol>\n<li>使用原始方式来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//1.采用无参的方式构造Person对象并打印</span></span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p); <span class=\"comment\">//null 0</span></span><br><span class=\"line\">  <span class=\"comment\">//2.使用有参方式来构造Person对象</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(p2); <span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">  <span class=\"comment\">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class=\"line\">p2.setName(<span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + p2.getName()); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用反射机制来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class=\"line\">Class c1 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);<span class=\"comment\">//不可省略包名</span></span><br><span class=\"line\">System.out.println(c1.newInstance());<span class=\"comment\">//null 0</span></span><br><span class=\"line\">    <span class=\"comment\">//2.使用有参方式来构造对象</span></span><br><span class=\"line\">Class c2 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);</span><br><span class=\"line\">Constructor ct2 = c2.getConstructor(String.class, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Object obj = ct2.newInstance(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(obj);<span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">    <span class=\"comment\">//3.修改与获取属性(成员变量)</span></span><br><span class=\"line\">Field f2 = c2.getDeclaredField(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">f2.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//暴力反射，设置使用权</span></span><br><span class=\"line\">f2.set(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + f2.get(obj)); <span class=\"comment\">//guanyu</span></span><br><span class=\"line\">    <span class=\"comment\">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class=\"line\">Method m1 = c2.getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"获取到的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//zhangfei</span></span><br><span class=\"line\">    <span class=\"comment\">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class=\"line\">Method m2 = c2.getMethod(<span class=\"string\">\"setName\"</span>, String.class);</span><br><span class=\"line\">Object res = m2.invoke(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"方法调用的返回值是：\"</span> + res); <span class=\"comment\">//null</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-注解-Annotation\"><a href=\"#7-注解-Annotation\" class=\"headerlink\" title=\"7. 注解(Annotation)\"></a>7. 注解(Annotation)</h3><h4 id=\"7-1-注解相关概念\"><a href=\"#7-1-注解相关概念\" class=\"headerlink\" title=\"7.1 注解相关概念\"></a>7.1 注解相关概念</h4><ul>\n<li>注释<ul>\n<li>单行注释：<code>//</code></li>\n<li>多行注释：<code>/*   */</code></li>\n<li>文档注释：<code>/**   */</code></li>\n</ul>\n</li>\n<li>注解的写法<ul>\n<li><code>@XXX [(一些信息)]</code></li>\n</ul>\n</li>\n<li>注解位置<ul>\n<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>\n</ul>\n</li>\n<li>注解的作用<ol>\n<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>\n<li>用来做代码的检测(验证)，@Override</li>\n<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>\n</ol>\n</li>\n<li>常用的注解<ul>\n<li>@Deprecated：用来说明方法是废弃的</li>\n<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>\n<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>\n<li>unused：变量定义后未被使用</li>\n<li>serial：类实现了序列化接口  不添加序列化ID号</li>\n<li>rawtypes：集合没有定义泛型</li>\n<li>deprecation：方法以废弃    </li>\n<li>*unchecked：出现了泛型的问题  可以不检测</li>\n<li>all：包含了以上所有(不推荐)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>\n<li>基本数据类型</li>\n<li>String类型</li>\n<li>枚举类型enum</li>\n<li>注解类型@</li>\n<li>数组类型[]，数组的内部需要是如上的四种类型</li>\n</ol>\n</li>\n<li>注解的分类<ol>\n<li>按运行机制分：源码注解，编译时注解，运行时注解</li>\n<li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-2-自定义注解类型的语法要求：\"><a href=\"#7-2-自定义注解类型的语法要求：\" class=\"headerlink\" title=\"7.2 自定义注解类型的语法要求：\"></a>7.2 自定义注解类型的语法要求：</h4><ol>\n<li>使用@interface关键字定义注解</li>\n<li>成员以<strong>无参无异常</strong>方式声明</li>\n<li>可以用default为成员指定一个默认值</li>\n<li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li>\n<li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li>\n<li>注解类可以没有成员，没有成员的注解称为标识注解</li>\n<li>需要元注解来描述说明<ul>\n<li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li>\n<li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>\n<li>@Inherited：允许子类继承</li>\n<li>@Document：当前注解是否能被文档(javadoc)所记录</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-使用自定义注解：\"><a href=\"#7-3-使用自定义注解：\" class=\"headerlink\" title=\"7.3 使用自定义注解：\"></a>7.3 使用自定义注解：</h4><ul>\n<li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(desc=<span class=\"string\">\"I am eyeColor\"</span>, author=<span class=\"string\">\"Chao\"</span>, age=<span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">eyeColor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(<span class=\"string\">\"I am class annotation\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Description</span>(<span class=\"string\">\"I am method annotation\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-解析注解\"><a href=\"#7-4-解析注解\" class=\"headerlink\" title=\"7.4 解析注解\"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p>\n<ol>\n<li>使用类加载器加载类<ul>\n<li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li>\n</ul>\n</li>\n<li>找到类上面的注解<ul>\n<li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li>\n</ul>\n</li>\n<li>拿到注解实例，需要强制类型转换。<ul>\n<li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li>\n</ul>\n</li>\n<li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseAnn</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;<span class=\"comment\">//1. 使用类加载器加载类</span></span><br><span class=\"line\">      Class c=Class.forName（<span class=\"string\">\"com.ann.test.Child\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//2. 找到类上面的注解</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isExist)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3. 拿到注解实例</span></span><br><span class=\"line\">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">        System.out.println(d.value());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//4.找到方法上的注解</span></span><br><span class=\"line\">      Method[] ms = c.getMethods();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isMExist)&#123;</span><br><span class=\"line\">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">          System.out.println(md.value());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种解析方法上的注解:<ul>\n<li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">  Annotation [] as=m.getAnnotations();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">      Description md = (Description)a;</span><br><span class=\"line\">      System.out.println(md.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p>\n</blockquote>"},{"title":"九、JavaSE网络编程","date":"2019-07-12T03:59:46.000Z","_content":"\n\n网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\njava.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n<!-- more -->\n\n1. [网络编程常识](#id1)\n2. [基于tcp协议的编程模型](#id2)\n3. [基于udp协议的编程模型](#id3)\n\n\n<span id=\"id1\"><span>\n### 1. 网络编程常识\n#### 1.1 七层网络模型\n为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：\n<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n- 当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；\n- 当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；\n\n#### 1.2 IP地址 \n- IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。\n- 日常生活中采用**点分十进制**表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1\n\n#### 1.3 端口号\n- 根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。\n- 网络编程需要提供：IP地址 和 端口号\n- 端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。\n\n#### 1.4 tcp协议与udp协议\n- TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。\n- UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。\n- tcp协议与udp协议比较：\n\n|tcp协议                         | udp协议|\n|--------|-------|\n|传输控制协议，面向连接           |用户数据报协议，非面向连接|\n|通信过程全程保持连接             |通信过程不需要全程连接|\n|保证了数据传输的可靠性和有序性    |不保证数据传输的可靠性和有序性|\n|全双工的字节流的通信方式         |全双工的数据报的通信方式|\n|服务器的资源消耗多，压力大，效率低|服务器资源消耗少，压力小，效率高|\n\n\n<span id=\"id2\"><span>\n### 2. 基于tcp协议的编程模型\n#### 2.1 编程模型\n```\n服务器端                         客户端\n\n创建监听服务\n等待连接    <----建立连接------  连接服务器           \n进行通讯    <----进行通讯----->  进行通讯\n关闭连接                        关闭连接\n\n```\n- 服务器：\n    1. 创建ServerSocket类型的对象并提供端口号；\n    2. 等待客户端的连接请求，调用accept方法；\n    3. 使用输入输出流进行通信；\n    4. 关闭Socket；\n- 客户端：\n    1. 创建Socket类型的对象并提供服务器的通信地址和端口号；\n    2. 使用输入输出流进行通信；\n    3. 关闭Socket；\n\n#### 2.2 ServerSocket类和Socket类\n- java.net.ServerSocket类主要用于描述服务器套接字信息。\n\n|常用方法||\n|----|----|\n|ServerSocket(int port)|根据参数指定的端口号来构造对象|\n|Socket accept()|监听并接收到此套接字的连接请求|\n|void close()|用于关闭套接字|\n\n- java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。\n\n|常用方法||\n|----|----|\n|Socket(String host, int port)|根据指定主机名和端口号来构造对象|\n|InputStream getInputStream()|用于获取当前套接字的输入流|\n|OutputStream getOutputStream()|用于获取当前套接字的输出流|\n|void close()|用于关闭套接字|\n\n\n\n<span id=\"id3\"><span>\n### 3.客户端与服务端通信演示：\n\n``` java\n//服务端线程\npublic class ServerThread extends Thread {\n  private Socket s;\n  public ServerThread(Socket s) {\n    this.s = s;\n  }\n  @Override\n  public void run() {\n    try {\n      // 3.使用输入输出流进行通信\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      while(true) {\n        // 实现服务器接收到字符串内容后打印出来\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        //System.out.println(\"服务器接收到的数据是：\" + str);\n        // 当服务器接收到\"bye\"后，则聊天结束\n        if(\"bye\".equalsIgnoreCase(str)) {\n          System.out.println(\"客户端\" + s.getInetAddress() + \"已下线！\");\n          break;\n        }\n        System.out.println(\"客户端\" + s.getInetAddress() \n          + \"发来的消息是：\" + str);  \n        // 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"\n        ps.println(\"I received!\");\n        //System.out.println(\"服务器发送数据成功！\");\n      } \n      // 4.关闭Socket\n      ps.close();\n      br.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//服务端测试\npublic class ServerStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建ServerSocket类型的对象并提供端口号\n      ServerSocket ss = new ServerSocket(8888);\n      // 2.等待客户端的连接请求，调用accept方法\n      while(true) {\n        System.out.println(\"等待客户端的连接请求...\");\n        // 当没有客户端连接时，阻塞在accept方法的调用这里\n        Socket s = ss.accept();\n        // 获取连接成功的客户端通信地址\n        System.out.println(\"客户端\" + s.getInetAddress() + \"连接成功！\");\n        // 当有客户端连接成功后，则启动一个新的线程为之服务\n        new ServerThread(s).start();\n      }\n      //ss.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//客户端测试\npublic class ClientStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建Socket类型的对象并提供服务器的通信地址和端口号\n      Socket s = new Socket(\"XDL-20170621QCO\", 8888);\n      System.out.println(\"连接服务器成功！\");\n      // 2.使用输入输出流进行通信\n      Scanner sc = new Scanner(System.in);\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      while(true) {\n        // 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞\n        //Thread.sleep(10000);\n        // 练习：实现客户端向服务器发送的内容由用户从键盘输入\n        System.out.println(\"请输入要发送的内容：\");\n        //String msg = sc.next(); // 读取字符串内容时，遇到空格停止\n        String msg = sc.nextLine();\n        // 实现客户端向服务器发送字符串内容\"hello\"\n        //ps.println(\"hello\");\n        ps.println(msg);\n        System.out.println(\"客户端发送数据成功！\");\n        // 判断客户端发送的内容是否为\"bye\"，若是则聊天结束\n        if(\"bye\".equalsIgnoreCase(msg)) {\n          System.out.println(\"聊天结束！\");\n          break;\n        }\n        // 实现服务器回发消息的接收\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        System.out.println(\"客户端接收到的数据是：\" + str);\n      }\n      // 3.关闭Socket\n      br.close();\n      sc.close();\n      ps.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 基于udp协议的编程模型\n#### 4.1 编程模型\n- 主机A(接收方):\n    1. 创建DatagramSocket类型的对象，并提供端口号；\n    2. 创建DatagramPacket类型的对象，用于接收发来的数据；\n    3. 从Socket中接收数据，调用**receive()**方法；\n    4. 关闭Socket并释放有关的资源；\n- 主机B(发送方)\n    1. 创建DatagramSocket类型的对象；\n    2. 创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；\n    3. 通过Socket发送数据，调用**send()**方法；\n    4. 关闭Socket并释放有关的资源；\n\n#### 4.2 DatagramSocket类\n- java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);\n\n|常用方法||\n|----|----|\n|DatagramSocket()              |无参的方式构造对象。|\n|DatagramSocket(int port)      |根据参数指定的端口号来构造对象。|\n|void receive(DatagramPacket p)|用于接收数据并存放到参数指定的变量中。|\n|void send(DatagramPacket p)   |用于将参数指定的数据发送出去。|\n|void close()                  | |\n\n\n#### 4.3 DatagramPacket类\n- java.net.DatagramPacket类用于描述数据报信息(信件)；\n\n|常用方法||\n|----|----|\n|DatagramPacket(byte[] buf, int length) |用于接收数据包并记录到参数变量中； |\n|DatagramPacket(byte[] buf, int length, InetAddress address, int port) |用于将参数指定的数据发送到参数指定的位置|\n|InetAddress getAddress()               |用于获取发送方或接收方的通信地址信息。|\n|int getPort()                          |用于获取发送方或接收方的端口信息。|\n|int getLength()                        |用于获取发送或接收数据的长度。|\n\n#### 4.4 InetAddress类\n- java.net.InetAddress类用于描述互联网协议地址。\n\n|常用方法||\n|----|----|\n|static InetAddress getLocalHost()         |用于获取本地主机的通信地址信息。|\n|static InetAddress getByName(String host) |根据参数指定的主机名来获取通信地址。|\n|String getHostName()                      |用于获取通信地址中的主机名信息。|\n|String getHostAddress()                   |用于获取通信地址中的IP地址信息。|\n\n","source":"_posts/09_JavaSE网络编程.md","raw":"---\ntitle: 九、JavaSE网络编程\ndate: 2019-07-12 11:59:46\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\njava.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n<!-- more -->\n\n1. [网络编程常识](#id1)\n2. [基于tcp协议的编程模型](#id2)\n3. [基于udp协议的编程模型](#id3)\n\n\n<span id=\"id1\"><span>\n### 1. 网络编程常识\n#### 1.1 七层网络模型\n为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：\n<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n- 当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；\n- 当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；\n\n#### 1.2 IP地址 \n- IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。\n- 日常生活中采用**点分十进制**表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1\n\n#### 1.3 端口号\n- 根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。\n- 网络编程需要提供：IP地址 和 端口号\n- 端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。\n\n#### 1.4 tcp协议与udp协议\n- TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。\n- UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。\n- tcp协议与udp协议比较：\n\n|tcp协议                         | udp协议|\n|--------|-------|\n|传输控制协议，面向连接           |用户数据报协议，非面向连接|\n|通信过程全程保持连接             |通信过程不需要全程连接|\n|保证了数据传输的可靠性和有序性    |不保证数据传输的可靠性和有序性|\n|全双工的字节流的通信方式         |全双工的数据报的通信方式|\n|服务器的资源消耗多，压力大，效率低|服务器资源消耗少，压力小，效率高|\n\n\n<span id=\"id2\"><span>\n### 2. 基于tcp协议的编程模型\n#### 2.1 编程模型\n```\n服务器端                         客户端\n\n创建监听服务\n等待连接    <----建立连接------  连接服务器           \n进行通讯    <----进行通讯----->  进行通讯\n关闭连接                        关闭连接\n\n```\n- 服务器：\n    1. 创建ServerSocket类型的对象并提供端口号；\n    2. 等待客户端的连接请求，调用accept方法；\n    3. 使用输入输出流进行通信；\n    4. 关闭Socket；\n- 客户端：\n    1. 创建Socket类型的对象并提供服务器的通信地址和端口号；\n    2. 使用输入输出流进行通信；\n    3. 关闭Socket；\n\n#### 2.2 ServerSocket类和Socket类\n- java.net.ServerSocket类主要用于描述服务器套接字信息。\n\n|常用方法||\n|----|----|\n|ServerSocket(int port)|根据参数指定的端口号来构造对象|\n|Socket accept()|监听并接收到此套接字的连接请求|\n|void close()|用于关闭套接字|\n\n- java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。\n\n|常用方法||\n|----|----|\n|Socket(String host, int port)|根据指定主机名和端口号来构造对象|\n|InputStream getInputStream()|用于获取当前套接字的输入流|\n|OutputStream getOutputStream()|用于获取当前套接字的输出流|\n|void close()|用于关闭套接字|\n\n\n\n<span id=\"id3\"><span>\n### 3.客户端与服务端通信演示：\n\n``` java\n//服务端线程\npublic class ServerThread extends Thread {\n  private Socket s;\n  public ServerThread(Socket s) {\n    this.s = s;\n  }\n  @Override\n  public void run() {\n    try {\n      // 3.使用输入输出流进行通信\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      while(true) {\n        // 实现服务器接收到字符串内容后打印出来\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        //System.out.println(\"服务器接收到的数据是：\" + str);\n        // 当服务器接收到\"bye\"后，则聊天结束\n        if(\"bye\".equalsIgnoreCase(str)) {\n          System.out.println(\"客户端\" + s.getInetAddress() + \"已下线！\");\n          break;\n        }\n        System.out.println(\"客户端\" + s.getInetAddress() \n          + \"发来的消息是：\" + str);  \n        // 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"\n        ps.println(\"I received!\");\n        //System.out.println(\"服务器发送数据成功！\");\n      } \n      // 4.关闭Socket\n      ps.close();\n      br.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//服务端测试\npublic class ServerStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建ServerSocket类型的对象并提供端口号\n      ServerSocket ss = new ServerSocket(8888);\n      // 2.等待客户端的连接请求，调用accept方法\n      while(true) {\n        System.out.println(\"等待客户端的连接请求...\");\n        // 当没有客户端连接时，阻塞在accept方法的调用这里\n        Socket s = ss.accept();\n        // 获取连接成功的客户端通信地址\n        System.out.println(\"客户端\" + s.getInetAddress() + \"连接成功！\");\n        // 当有客户端连接成功后，则启动一个新的线程为之服务\n        new ServerThread(s).start();\n      }\n      //ss.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//客户端测试\npublic class ClientStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建Socket类型的对象并提供服务器的通信地址和端口号\n      Socket s = new Socket(\"XDL-20170621QCO\", 8888);\n      System.out.println(\"连接服务器成功！\");\n      // 2.使用输入输出流进行通信\n      Scanner sc = new Scanner(System.in);\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      while(true) {\n        // 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞\n        //Thread.sleep(10000);\n        // 练习：实现客户端向服务器发送的内容由用户从键盘输入\n        System.out.println(\"请输入要发送的内容：\");\n        //String msg = sc.next(); // 读取字符串内容时，遇到空格停止\n        String msg = sc.nextLine();\n        // 实现客户端向服务器发送字符串内容\"hello\"\n        //ps.println(\"hello\");\n        ps.println(msg);\n        System.out.println(\"客户端发送数据成功！\");\n        // 判断客户端发送的内容是否为\"bye\"，若是则聊天结束\n        if(\"bye\".equalsIgnoreCase(msg)) {\n          System.out.println(\"聊天结束！\");\n          break;\n        }\n        // 实现服务器回发消息的接收\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        System.out.println(\"客户端接收到的数据是：\" + str);\n      }\n      // 3.关闭Socket\n      br.close();\n      sc.close();\n      ps.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 基于udp协议的编程模型\n#### 4.1 编程模型\n- 主机A(接收方):\n    1. 创建DatagramSocket类型的对象，并提供端口号；\n    2. 创建DatagramPacket类型的对象，用于接收发来的数据；\n    3. 从Socket中接收数据，调用**receive()**方法；\n    4. 关闭Socket并释放有关的资源；\n- 主机B(发送方)\n    1. 创建DatagramSocket类型的对象；\n    2. 创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；\n    3. 通过Socket发送数据，调用**send()**方法；\n    4. 关闭Socket并释放有关的资源；\n\n#### 4.2 DatagramSocket类\n- java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);\n\n|常用方法||\n|----|----|\n|DatagramSocket()              |无参的方式构造对象。|\n|DatagramSocket(int port)      |根据参数指定的端口号来构造对象。|\n|void receive(DatagramPacket p)|用于接收数据并存放到参数指定的变量中。|\n|void send(DatagramPacket p)   |用于将参数指定的数据发送出去。|\n|void close()                  | |\n\n\n#### 4.3 DatagramPacket类\n- java.net.DatagramPacket类用于描述数据报信息(信件)；\n\n|常用方法||\n|----|----|\n|DatagramPacket(byte[] buf, int length) |用于接收数据包并记录到参数变量中； |\n|DatagramPacket(byte[] buf, int length, InetAddress address, int port) |用于将参数指定的数据发送到参数指定的位置|\n|InetAddress getAddress()               |用于获取发送方或接收方的通信地址信息。|\n|int getPort()                          |用于获取发送方或接收方的端口信息。|\n|int getLength()                        |用于获取发送或接收数据的长度。|\n\n#### 4.4 InetAddress类\n- java.net.InetAddress类用于描述互联网协议地址。\n\n|常用方法||\n|----|----|\n|static InetAddress getLocalHost()         |用于获取本地主机的通信地址信息。|\n|static InetAddress getByName(String host) |根据参数指定的主机名来获取通信地址。|\n|String getHostName()                      |用于获取通信地址中的主机名信息。|\n|String getHostAddress()                   |用于获取通信地址中的IP地址信息。|\n\n","slug":"09_JavaSE网络编程","published":1,"updated":"2019-07-20T15:01:52.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo5v001yyot32p5tj7fu","content":"<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">网络编程常识</a></li>\n<li><a href=\"#id2\">基于tcp协议的编程模型</a></li>\n<li><a href=\"#id3\">基于udp协议的编程模型</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-网络编程常识\"><a href=\"#1-网络编程常识\" class=\"headerlink\" title=\"1. 网络编程常识\"></a>1. 网络编程常识</h3><h4 id=\"1-1-七层网络模型\"><a href=\"#1-1-七层网络模型\" class=\"headerlink\" title=\"1.1 七层网络模型\"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>\n<ul>\n<li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li>\n<li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li>\n</ul>\n<h4 id=\"1-2-IP地址\"><a href=\"#1-2-IP地址\" class=\"headerlink\" title=\"1.2 IP地址\"></a>1.2 IP地址</h4><ul>\n<li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li>\n<li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li>\n</ul>\n<h4 id=\"1-3-端口号\"><a href=\"#1-3-端口号\" class=\"headerlink\" title=\"1.3 端口号\"></a>1.3 端口号</h4><ul>\n<li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li>\n<li>网络编程需要提供：IP地址 和 端口号</li>\n<li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li>\n</ul>\n<h4 id=\"1-4-tcp协议与udp协议\"><a href=\"#1-4-tcp协议与udp协议\" class=\"headerlink\" title=\"1.4 tcp协议与udp协议\"></a>1.4 tcp协议与udp协议</h4><ul>\n<li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li>\n<li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>\n<li>tcp协议与udp协议比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>tcp协议</th>\n<th>udp协议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输控制协议，面向连接</td>\n<td>用户数据报协议，非面向连接</td>\n</tr>\n<tr>\n<td>通信过程全程保持连接</td>\n<td>通信过程不需要全程连接</td>\n</tr>\n<tr>\n<td>保证了数据传输的可靠性和有序性</td>\n<td>不保证数据传输的可靠性和有序性</td>\n</tr>\n<tr>\n<td>全双工的字节流的通信方式</td>\n<td>全双工的数据报的通信方式</td>\n</tr>\n<tr>\n<td>服务器的资源消耗多，压力大，效率低</td>\n<td>服务器资源消耗少，压力小，效率高</td>\n</tr>\n</tbody></table>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-基于tcp协议的编程模型\"><a href=\"#2-基于tcp协议的编程模型\" class=\"headerlink\" title=\"2. 基于tcp协议的编程模型\"></a>2. 基于tcp协议的编程模型</h3><h4 id=\"2-1-编程模型\"><a href=\"#2-1-编程模型\" class=\"headerlink\" title=\"2.1 编程模型\"></a>2.1 编程模型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器端                         客户端</span><br><span class=\"line\"></span><br><span class=\"line\">创建监听服务</span><br><span class=\"line\">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class=\"line\">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class=\"line\">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>服务器：<ol>\n<li>创建ServerSocket类型的对象并提供端口号；</li>\n<li>等待客户端的连接请求，调用accept方法；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n<li>客户端：<ol>\n<li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-2-ServerSocket类和Socket类\"><a href=\"#2-2-ServerSocket类和Socket类\" class=\"headerlink\" title=\"2.2 ServerSocket类和Socket类\"></a>2.2 ServerSocket类和Socket类</h4><ul>\n<li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ServerSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象</td>\n</tr>\n<tr>\n<td>Socket accept()</td>\n<td>监听并接收到此套接字的连接请求</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<ul>\n<li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket(String host, int port)</td>\n<td>根据指定主机名和端口号来构造对象</td>\n</tr>\n<tr>\n<td>InputStream getInputStream()</td>\n<td>用于获取当前套接字的输入流</td>\n</tr>\n<tr>\n<td>OutputStream getOutputStream()</td>\n<td>用于获取当前套接字的输出流</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-客户端与服务端通信演示：\"><a href=\"#3-客户端与服务端通信演示：\" class=\"headerlink\" title=\"3.客户端与服务端通信演示：\"></a>3.客户端与服务端通信演示：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Socket s;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3.使用输入输出流进行通信</span></span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器接收到的数据是：\" + str);</span></span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到\"bye\"后，则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"已下线！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() </span><br><span class=\"line\">          + <span class=\"string\">\"发来的消息是：\"</span> + str);  </span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"</span></span><br><span class=\"line\">        ps.println(<span class=\"string\">\"I received!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器发送数据成功！\");</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"comment\">// 4.关闭Socket</span></span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//服务端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class=\"line\">      ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"等待客户端的连接请求...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class=\"line\">        Socket s = ss.accept();</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接成功的客户端通信地址</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"连接成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ServerThread(s).start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//ss.close();</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//客户端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class=\"line\">      Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"XDL-20170621QCO\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"连接服务器成功！\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.使用输入输出流进行通信</span></span><br><span class=\"line\">      Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class=\"line\">        <span class=\"comment\">//Thread.sleep(10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入要发送的内容：\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class=\"line\">        String msg = sc.nextLine();</span><br><span class=\"line\">        <span class=\"comment\">// 实现客户端向服务器发送字符串内容\"hello\"</span></span><br><span class=\"line\">        <span class=\"comment\">//ps.println(\"hello\");</span></span><br><span class=\"line\">        ps.println(msg);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送数据成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 判断客户端发送的内容是否为\"bye\"，若是则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"聊天结束！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器回发消息的接收</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端接收到的数据是：\"</span> + str);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 3.关闭Socket</span></span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      sc.close();</span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-基于udp协议的编程模型\"><a href=\"#4-基于udp协议的编程模型\" class=\"headerlink\" title=\"4. 基于udp协议的编程模型\"></a>4. 基于udp协议的编程模型</h3><h4 id=\"4-1-编程模型\"><a href=\"#4-1-编程模型\" class=\"headerlink\" title=\"4.1 编程模型\"></a>4.1 编程模型</h4><ul>\n<li>主机A(接收方):<ol>\n<li>创建DatagramSocket类型的对象，并提供端口号；</li>\n<li>创建DatagramPacket类型的对象，用于接收发来的数据；</li>\n<li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n<li>主机B(发送方)<ol>\n<li>创建DatagramSocket类型的对象；</li>\n<li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li>\n<li>通过Socket发送数据，调用<strong>send()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-2-DatagramSocket类\"><a href=\"#4-2-DatagramSocket类\" class=\"headerlink\" title=\"4.2 DatagramSocket类\"></a>4.2 DatagramSocket类</h4><ul>\n<li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramSocket()</td>\n<td>无参的方式构造对象。</td>\n</tr>\n<tr>\n<td>DatagramSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象。</td>\n</tr>\n<tr>\n<td>void receive(DatagramPacket p)</td>\n<td>用于接收数据并存放到参数指定的变量中。</td>\n</tr>\n<tr>\n<td>void send(DatagramPacket p)</td>\n<td>用于将参数指定的数据发送出去。</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"4-3-DatagramPacket类\"><a href=\"#4-3-DatagramPacket类\" class=\"headerlink\" title=\"4.3 DatagramPacket类\"></a>4.3 DatagramPacket类</h4><ul>\n<li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramPacket(byte[] buf, int length)</td>\n<td>用于接收数据包并记录到参数变量中；</td>\n</tr>\n<tr>\n<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>\n<td>用于将参数指定的数据发送到参数指定的位置</td>\n</tr>\n<tr>\n<td>InetAddress getAddress()</td>\n<td>用于获取发送方或接收方的通信地址信息。</td>\n</tr>\n<tr>\n<td>int getPort()</td>\n<td>用于获取发送方或接收方的端口信息。</td>\n</tr>\n<tr>\n<td>int getLength()</td>\n<td>用于获取发送或接收数据的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-4-InetAddress类\"><a href=\"#4-4-InetAddress类\" class=\"headerlink\" title=\"4.4 InetAddress类\"></a>4.4 InetAddress类</h4><ul>\n<li>java.net.InetAddress类用于描述互联网协议地址。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static InetAddress getLocalHost()</td>\n<td>用于获取本地主机的通信地址信息。</td>\n</tr>\n<tr>\n<td>static InetAddress getByName(String host)</td>\n<td>根据参数指定的主机名来获取通信地址。</td>\n</tr>\n<tr>\n<td>String getHostName()</td>\n<td>用于获取通信地址中的主机名信息。</td>\n</tr>\n<tr>\n<td>String getHostAddress()</td>\n<td>用于获取通信地址中的IP地址信息。</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>","more":"<ol>\n<li><a href=\"#id1\">网络编程常识</a></li>\n<li><a href=\"#id2\">基于tcp协议的编程模型</a></li>\n<li><a href=\"#id3\">基于udp协议的编程模型</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-网络编程常识\"><a href=\"#1-网络编程常识\" class=\"headerlink\" title=\"1. 网络编程常识\"></a>1. 网络编程常识</h3><h4 id=\"1-1-七层网络模型\"><a href=\"#1-1-七层网络模型\" class=\"headerlink\" title=\"1.1 七层网络模型\"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>\n<ul>\n<li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li>\n<li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li>\n</ul>\n<h4 id=\"1-2-IP地址\"><a href=\"#1-2-IP地址\" class=\"headerlink\" title=\"1.2 IP地址\"></a>1.2 IP地址</h4><ul>\n<li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li>\n<li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li>\n</ul>\n<h4 id=\"1-3-端口号\"><a href=\"#1-3-端口号\" class=\"headerlink\" title=\"1.3 端口号\"></a>1.3 端口号</h4><ul>\n<li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li>\n<li>网络编程需要提供：IP地址 和 端口号</li>\n<li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li>\n</ul>\n<h4 id=\"1-4-tcp协议与udp协议\"><a href=\"#1-4-tcp协议与udp协议\" class=\"headerlink\" title=\"1.4 tcp协议与udp协议\"></a>1.4 tcp协议与udp协议</h4><ul>\n<li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li>\n<li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>\n<li>tcp协议与udp协议比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>tcp协议</th>\n<th>udp协议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输控制协议，面向连接</td>\n<td>用户数据报协议，非面向连接</td>\n</tr>\n<tr>\n<td>通信过程全程保持连接</td>\n<td>通信过程不需要全程连接</td>\n</tr>\n<tr>\n<td>保证了数据传输的可靠性和有序性</td>\n<td>不保证数据传输的可靠性和有序性</td>\n</tr>\n<tr>\n<td>全双工的字节流的通信方式</td>\n<td>全双工的数据报的通信方式</td>\n</tr>\n<tr>\n<td>服务器的资源消耗多，压力大，效率低</td>\n<td>服务器资源消耗少，压力小，效率高</td>\n</tr>\n</tbody></table>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-基于tcp协议的编程模型\"><a href=\"#2-基于tcp协议的编程模型\" class=\"headerlink\" title=\"2. 基于tcp协议的编程模型\"></a>2. 基于tcp协议的编程模型</h3><h4 id=\"2-1-编程模型\"><a href=\"#2-1-编程模型\" class=\"headerlink\" title=\"2.1 编程模型\"></a>2.1 编程模型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器端                         客户端</span><br><span class=\"line\"></span><br><span class=\"line\">创建监听服务</span><br><span class=\"line\">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class=\"line\">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class=\"line\">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>服务器：<ol>\n<li>创建ServerSocket类型的对象并提供端口号；</li>\n<li>等待客户端的连接请求，调用accept方法；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n<li>客户端：<ol>\n<li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-2-ServerSocket类和Socket类\"><a href=\"#2-2-ServerSocket类和Socket类\" class=\"headerlink\" title=\"2.2 ServerSocket类和Socket类\"></a>2.2 ServerSocket类和Socket类</h4><ul>\n<li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ServerSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象</td>\n</tr>\n<tr>\n<td>Socket accept()</td>\n<td>监听并接收到此套接字的连接请求</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<ul>\n<li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket(String host, int port)</td>\n<td>根据指定主机名和端口号来构造对象</td>\n</tr>\n<tr>\n<td>InputStream getInputStream()</td>\n<td>用于获取当前套接字的输入流</td>\n</tr>\n<tr>\n<td>OutputStream getOutputStream()</td>\n<td>用于获取当前套接字的输出流</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-客户端与服务端通信演示：\"><a href=\"#3-客户端与服务端通信演示：\" class=\"headerlink\" title=\"3.客户端与服务端通信演示：\"></a>3.客户端与服务端通信演示：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Socket s;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3.使用输入输出流进行通信</span></span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器接收到的数据是：\" + str);</span></span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到\"bye\"后，则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"已下线！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() </span><br><span class=\"line\">          + <span class=\"string\">\"发来的消息是：\"</span> + str);  </span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"</span></span><br><span class=\"line\">        ps.println(<span class=\"string\">\"I received!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器发送数据成功！\");</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"comment\">// 4.关闭Socket</span></span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//服务端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class=\"line\">      ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"等待客户端的连接请求...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class=\"line\">        Socket s = ss.accept();</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接成功的客户端通信地址</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"连接成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ServerThread(s).start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//ss.close();</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//客户端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class=\"line\">      Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"XDL-20170621QCO\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"连接服务器成功！\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.使用输入输出流进行通信</span></span><br><span class=\"line\">      Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class=\"line\">        <span class=\"comment\">//Thread.sleep(10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入要发送的内容：\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class=\"line\">        String msg = sc.nextLine();</span><br><span class=\"line\">        <span class=\"comment\">// 实现客户端向服务器发送字符串内容\"hello\"</span></span><br><span class=\"line\">        <span class=\"comment\">//ps.println(\"hello\");</span></span><br><span class=\"line\">        ps.println(msg);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送数据成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 判断客户端发送的内容是否为\"bye\"，若是则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"聊天结束！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器回发消息的接收</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端接收到的数据是：\"</span> + str);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 3.关闭Socket</span></span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      sc.close();</span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-基于udp协议的编程模型\"><a href=\"#4-基于udp协议的编程模型\" class=\"headerlink\" title=\"4. 基于udp协议的编程模型\"></a>4. 基于udp协议的编程模型</h3><h4 id=\"4-1-编程模型\"><a href=\"#4-1-编程模型\" class=\"headerlink\" title=\"4.1 编程模型\"></a>4.1 编程模型</h4><ul>\n<li>主机A(接收方):<ol>\n<li>创建DatagramSocket类型的对象，并提供端口号；</li>\n<li>创建DatagramPacket类型的对象，用于接收发来的数据；</li>\n<li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n<li>主机B(发送方)<ol>\n<li>创建DatagramSocket类型的对象；</li>\n<li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li>\n<li>通过Socket发送数据，调用<strong>send()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-2-DatagramSocket类\"><a href=\"#4-2-DatagramSocket类\" class=\"headerlink\" title=\"4.2 DatagramSocket类\"></a>4.2 DatagramSocket类</h4><ul>\n<li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramSocket()</td>\n<td>无参的方式构造对象。</td>\n</tr>\n<tr>\n<td>DatagramSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象。</td>\n</tr>\n<tr>\n<td>void receive(DatagramPacket p)</td>\n<td>用于接收数据并存放到参数指定的变量中。</td>\n</tr>\n<tr>\n<td>void send(DatagramPacket p)</td>\n<td>用于将参数指定的数据发送出去。</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"4-3-DatagramPacket类\"><a href=\"#4-3-DatagramPacket类\" class=\"headerlink\" title=\"4.3 DatagramPacket类\"></a>4.3 DatagramPacket类</h4><ul>\n<li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramPacket(byte[] buf, int length)</td>\n<td>用于接收数据包并记录到参数变量中；</td>\n</tr>\n<tr>\n<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>\n<td>用于将参数指定的数据发送到参数指定的位置</td>\n</tr>\n<tr>\n<td>InetAddress getAddress()</td>\n<td>用于获取发送方或接收方的通信地址信息。</td>\n</tr>\n<tr>\n<td>int getPort()</td>\n<td>用于获取发送方或接收方的端口信息。</td>\n</tr>\n<tr>\n<td>int getLength()</td>\n<td>用于获取发送或接收数据的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-4-InetAddress类\"><a href=\"#4-4-InetAddress类\" class=\"headerlink\" title=\"4.4 InetAddress类\"></a>4.4 InetAddress类</h4><ul>\n<li>java.net.InetAddress类用于描述互联网协议地址。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static InetAddress getLocalHost()</td>\n<td>用于获取本地主机的通信地址信息。</td>\n</tr>\n<tr>\n<td>static InetAddress getByName(String host)</td>\n<td>根据参数指定的主机名来获取通信地址。</td>\n</tr>\n<tr>\n<td>String getHostName()</td>\n<td>用于获取通信地址中的主机名信息。</td>\n</tr>\n<tr>\n<td>String getHostAddress()</td>\n<td>用于获取通信地址中的IP地址信息。</td>\n</tr>\n</tbody></table>"},{"title":"十、JavaSE常用设计模式","date":"2019-07-15T00:34:55.000Z","_content":"\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\n<!-- more -->\n\n1. [常用的设计原则](#id1)\n2. [设计模式分类](#id2)\n3. [单例模式](#id3)\n4. [模板模式](#id4)\n5. [工厂模式](#id5)\n6. [适配器模式](#id6)\n\n\n<span id=\"id1\"><span>\n### 1.常用的设计原则\n- **开闭原则**：对扩展开发，对修改方便\n- **里氏代换原则**：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）\n- **依赖倒转原则**：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性\n- **接口隔离原则**：尽量多依赖小接口而不是大接口\n- **迪米特法则**（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。\n- **合成复用原则**：尽量多使用合成/聚合的方式，而不是继承的方式。\n\n\n<span id=\"id2\"><span>\n### 2.设计模式分类\n#### 2.1 基本概念\n- 设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。\n- 设计模式用来解决某些特定场景下的某一类问题-->通用的解决方案。\n- 设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性\n\n#### 2.2 具体分类\n1. **创建型模式**：*用于对象创建的过程*\n  - **单例模式**、**工厂方法模式**、抽象工厂模式、建造者模式(生成器模式)、原型模式\n2. **结构型模式**：*用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构*\n  - 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)\n3. **行为型模式**：*用于解决类或对象之间的交互，更合理的优化类或对象之间的关系*\n  - 责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、**模板模式**、访问者模式、备忘录模式、\n4. JEE 设计模式\n  - 数据访问对象模式 \n\n\n<span id=\"id3\"><span>\n### 3.单例模式（Singleton）\n#### 3.1 实现流程：\n1. 私有的构造方法\n2. 私有的静态的当前类的对象作为属性\n3. 共有的静态方法返回当前对象\n#### 3.1 实现方式：\n1. 饿汉式：立即加载，对象启动时就加载\n2. 懒汉式：延迟加载，对象什么时候用到时才会加载\n3. 生命周期托管：单例对象交给别人处理\n\n\n<span id=\"id4\"><span>\n### 4.模板模式\n在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。\n\n- eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。\n\n``` java\n  // 抽象类\nabstract class Software {\n   abstract void initialize();\n   abstract void start();\n   abstract void end();\n   public final void play(){\n      initialize();\n      start();\n      end();\n   }\n}\n  // 不同子类以不同方法实现抽象类的的方法\nclass Browser extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Browser Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Browser Initialized!.\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Browser Started.\");\n   }\n}\nclass Editor extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Editor Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Editor Initialized!\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Editor Started!\");\n   }\n}\n// 使用\npublic class Main {\n   public static void main(String[] args) {\n      Software s1 = new Browser();\n      s1.play();\n      s1 = new Editor();\n      s1.play();    \n   }\n}\n```\n\n#### 4.1 模式模式优缺点：\n1. 优点\n  - 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。\n2. 缺点\n  - 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。\n3. 适用场景\n  - 在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。\n\n\n<span id=\"id5\"><span>\n### 5. 工厂模式\n1. 简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；\n2. 工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；\n3. 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。\n\n#### 5.1 简单工厂模式的实现：\n``` java\n  // 产品接口\npublic interface Fruit { void whatIm(); }\n  // 具体类\npublic class Apple implements Fruit {\n  @Override\n  public void whatIm() { /*苹果*/}\n}\npublic class Pear implements Fruit {\n    @Override\n    public void whatIm() { /* 梨 */ }\n}\n  // 工厂\npublic class FruitFactory {\n    public Fruit createFruit(String type) {\n        if (type.equals(\"apple\")) {//生产苹果\n            return new Apple();\n        } else if (type.equals(\"pear\")) {//生产梨\n            return new Pear();\n        }\n        return null;\n    }\n}\n  // 使用\nFruitFactory mFactory = new FruitFactory();\nApple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果\nPear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨\n```\n> 简单工厂只适合于产品对象较少，且产品固定的需求\n\n\n#### 5.2 工厂方法模式实现：\n``` java\n  // 工厂接口\npublic interface FruitFactory {\n    Fruit createFruit();//生产水果\n}\n  // 具体工厂\npublic class AppleFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Apple();\n    }\n}\npublic class PearFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Pear();\n    }\n}\n  // 使用\nAppleFactory appleFactory = new AppleFactory();\nPearFactory pearFactory = new PearFactory();\nApple apple = (Apple) appleFactory.createFruit();//获得苹果\nPear pear = (Pear) pearFactory.createFruit();//获得梨\n```\n> 工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂\n\n#### 5.3 抽象工厂模式实现：\n  - 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；\n  - eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：\n\n``` java\n // cpu接口和实现类\npublic interface Cpu {\n    void run();\n    class Cpu650 implements Cpu {\n        @Override\n        public void run() {/* 625 也厉害 */ }\n    }\n    class Cpu825 implements Cpu {\n        @Override\n        public void run() { /* 825 处理更强劲 */ }\n    }\n}\n  // 屏幕接口和实现类\npublic interface Screen {\n    void size();\n    class Screen5 implements Screen {\n        @Override\n        public void size() {/* 5寸 */}\n    }\n    class Screen6 implements Screen {\n        @Override\n        public void size() { /* 6寸 */ }\n    }\n}\n  // 工厂接口\npublic interface PhoneFactory {\n    Cpu getCpu();//使用的cpu\n    Screen getScreen();//使用的屏幕\n}\n  // 具体工厂实现类\npublic class XiaoMiFactory implements PhoneFactory {\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu825();//高性能处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen6();//6寸大屏\n    }\n}\npublic class HongMiFactory implements PhoneFactory {\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu650();//高效处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen5();//小屏手机\n    }\n}\n```\n> 对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；\n\n#### 5.4 三种工厂方式总结：\n1. 对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；\n2. 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；\n\n\n<span id=\"id6\"><span>\n### 6.适配器模式（Adapter）\n- 适配器模式Adapter是结构型模式的一种，分为**类适配器模式**，**对象适配器模式**，**缺省适配器模式**。\n  * 类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；\n  * 对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。\n\n> 适配器模式的缺点\n<br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。\n\n#### 6.1 缺省适配器模式\n- 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。\n- 缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)\n- 适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。\n\n","source":"_posts/10_JavaSE常用设计模式.md","raw":"---\ntitle: 十、JavaSE常用设计模式\ndate: 2019-07-15 08:34:55\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\n<!-- more -->\n\n1. [常用的设计原则](#id1)\n2. [设计模式分类](#id2)\n3. [单例模式](#id3)\n4. [模板模式](#id4)\n5. [工厂模式](#id5)\n6. [适配器模式](#id6)\n\n\n<span id=\"id1\"><span>\n### 1.常用的设计原则\n- **开闭原则**：对扩展开发，对修改方便\n- **里氏代换原则**：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）\n- **依赖倒转原则**：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性\n- **接口隔离原则**：尽量多依赖小接口而不是大接口\n- **迪米特法则**（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。\n- **合成复用原则**：尽量多使用合成/聚合的方式，而不是继承的方式。\n\n\n<span id=\"id2\"><span>\n### 2.设计模式分类\n#### 2.1 基本概念\n- 设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。\n- 设计模式用来解决某些特定场景下的某一类问题-->通用的解决方案。\n- 设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性\n\n#### 2.2 具体分类\n1. **创建型模式**：*用于对象创建的过程*\n  - **单例模式**、**工厂方法模式**、抽象工厂模式、建造者模式(生成器模式)、原型模式\n2. **结构型模式**：*用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构*\n  - 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)\n3. **行为型模式**：*用于解决类或对象之间的交互，更合理的优化类或对象之间的关系*\n  - 责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、**模板模式**、访问者模式、备忘录模式、\n4. JEE 设计模式\n  - 数据访问对象模式 \n\n\n<span id=\"id3\"><span>\n### 3.单例模式（Singleton）\n#### 3.1 实现流程：\n1. 私有的构造方法\n2. 私有的静态的当前类的对象作为属性\n3. 共有的静态方法返回当前对象\n#### 3.1 实现方式：\n1. 饿汉式：立即加载，对象启动时就加载\n2. 懒汉式：延迟加载，对象什么时候用到时才会加载\n3. 生命周期托管：单例对象交给别人处理\n\n\n<span id=\"id4\"><span>\n### 4.模板模式\n在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。\n\n- eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。\n\n``` java\n  // 抽象类\nabstract class Software {\n   abstract void initialize();\n   abstract void start();\n   abstract void end();\n   public final void play(){\n      initialize();\n      start();\n      end();\n   }\n}\n  // 不同子类以不同方法实现抽象类的的方法\nclass Browser extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Browser Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Browser Initialized!.\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Browser Started.\");\n   }\n}\nclass Editor extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Editor Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Editor Initialized!\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Editor Started!\");\n   }\n}\n// 使用\npublic class Main {\n   public static void main(String[] args) {\n      Software s1 = new Browser();\n      s1.play();\n      s1 = new Editor();\n      s1.play();    \n   }\n}\n```\n\n#### 4.1 模式模式优缺点：\n1. 优点\n  - 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。\n2. 缺点\n  - 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。\n3. 适用场景\n  - 在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。\n\n\n<span id=\"id5\"><span>\n### 5. 工厂模式\n1. 简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；\n2. 工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；\n3. 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。\n\n#### 5.1 简单工厂模式的实现：\n``` java\n  // 产品接口\npublic interface Fruit { void whatIm(); }\n  // 具体类\npublic class Apple implements Fruit {\n  @Override\n  public void whatIm() { /*苹果*/}\n}\npublic class Pear implements Fruit {\n    @Override\n    public void whatIm() { /* 梨 */ }\n}\n  // 工厂\npublic class FruitFactory {\n    public Fruit createFruit(String type) {\n        if (type.equals(\"apple\")) {//生产苹果\n            return new Apple();\n        } else if (type.equals(\"pear\")) {//生产梨\n            return new Pear();\n        }\n        return null;\n    }\n}\n  // 使用\nFruitFactory mFactory = new FruitFactory();\nApple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果\nPear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨\n```\n> 简单工厂只适合于产品对象较少，且产品固定的需求\n\n\n#### 5.2 工厂方法模式实现：\n``` java\n  // 工厂接口\npublic interface FruitFactory {\n    Fruit createFruit();//生产水果\n}\n  // 具体工厂\npublic class AppleFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Apple();\n    }\n}\npublic class PearFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Pear();\n    }\n}\n  // 使用\nAppleFactory appleFactory = new AppleFactory();\nPearFactory pearFactory = new PearFactory();\nApple apple = (Apple) appleFactory.createFruit();//获得苹果\nPear pear = (Pear) pearFactory.createFruit();//获得梨\n```\n> 工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂\n\n#### 5.3 抽象工厂模式实现：\n  - 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；\n  - eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：\n\n``` java\n // cpu接口和实现类\npublic interface Cpu {\n    void run();\n    class Cpu650 implements Cpu {\n        @Override\n        public void run() {/* 625 也厉害 */ }\n    }\n    class Cpu825 implements Cpu {\n        @Override\n        public void run() { /* 825 处理更强劲 */ }\n    }\n}\n  // 屏幕接口和实现类\npublic interface Screen {\n    void size();\n    class Screen5 implements Screen {\n        @Override\n        public void size() {/* 5寸 */}\n    }\n    class Screen6 implements Screen {\n        @Override\n        public void size() { /* 6寸 */ }\n    }\n}\n  // 工厂接口\npublic interface PhoneFactory {\n    Cpu getCpu();//使用的cpu\n    Screen getScreen();//使用的屏幕\n}\n  // 具体工厂实现类\npublic class XiaoMiFactory implements PhoneFactory {\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu825();//高性能处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen6();//6寸大屏\n    }\n}\npublic class HongMiFactory implements PhoneFactory {\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu650();//高效处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen5();//小屏手机\n    }\n}\n```\n> 对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；\n\n#### 5.4 三种工厂方式总结：\n1. 对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；\n2. 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；\n\n\n<span id=\"id6\"><span>\n### 6.适配器模式（Adapter）\n- 适配器模式Adapter是结构型模式的一种，分为**类适配器模式**，**对象适配器模式**，**缺省适配器模式**。\n  * 类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；\n  * 对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。\n\n> 适配器模式的缺点\n<br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。\n\n#### 6.1 缺省适配器模式\n- 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。\n- 缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)\n- 适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。\n\n","slug":"10_JavaSE常用设计模式","published":1,"updated":"2019-07-20T15:03:36.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo5x0020yot3i961o30j","content":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">常用的设计原则</a></li>\n<li><a href=\"#id2\">设计模式分类</a></li>\n<li><a href=\"#id3\">单例模式</a></li>\n<li><a href=\"#id4\">模板模式</a></li>\n<li><a href=\"#id5\">工厂模式</a></li>\n<li><a href=\"#id6\">适配器模式</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-常用的设计原则\"><a href=\"#1-常用的设计原则\" class=\"headerlink\" title=\"1.常用的设计原则\"></a>1.常用的设计原则</h3><ul>\n<li><strong>开闭原则</strong>：对扩展开发，对修改方便</li>\n<li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li>\n<li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>\n<li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li>\n<li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li>\n<li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-设计模式分类\"><a href=\"#2-设计模式分类\" class=\"headerlink\" title=\"2.设计模式分类\"></a>2.设计模式分类</h3><h4 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h4><ul>\n<li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li>\n<li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li>\n<li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li>\n</ul>\n<h4 id=\"2-2-具体分类\"><a href=\"#2-2-具体分类\" class=\"headerlink\" title=\"2.2 具体分类\"></a>2.2 具体分类</h4><ol>\n<li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul>\n<li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li>\n</ul>\n</li>\n<li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul>\n<li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li>\n</ul>\n</li>\n<li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul>\n<li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li>\n</ul>\n</li>\n<li>JEE 设计模式<ul>\n<li>数据访问对象模式 </li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-单例模式（Singleton）\"><a href=\"#3-单例模式（Singleton）\" class=\"headerlink\" title=\"3.单例模式（Singleton）\"></a>3.单例模式（Singleton）</h3><h4 id=\"3-1-实现流程：\"><a href=\"#3-1-实现流程：\" class=\"headerlink\" title=\"3.1 实现流程：\"></a>3.1 实现流程：</h4><ol>\n<li>私有的构造方法</li>\n<li>私有的静态的当前类的对象作为属性</li>\n<li>共有的静态方法返回当前对象<h4 id=\"3-1-实现方式：\"><a href=\"#3-1-实现方式：\" class=\"headerlink\" title=\"3.1 实现方式：\"></a>3.1 实现方式：</h4></li>\n<li>饿汉式：立即加载，对象启动时就加载</li>\n<li>懒汉式：延迟加载，对象什么时候用到时才会加载</li>\n<li>生命周期托管：单例对象交给别人处理</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-模板模式\"><a href=\"#4-模板模式\" class=\"headerlink\" title=\"4.模板模式\"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p>\n<ul>\n<li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      initialize();</span><br><span class=\"line\">      start();</span><br><span class=\"line\">      end();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Browser</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Initialized!.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Started.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Initialized!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Started!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      Software s1 = <span class=\"keyword\">new</span> Browser();</span><br><span class=\"line\">      s1.play();</span><br><span class=\"line\">      s1 = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\">      s1.play();    </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-模式模式优缺点：\"><a href=\"#4-1-模式模式优缺点：\" class=\"headerlink\" title=\"4.1 模式模式优缺点：\"></a>4.1 模式模式优缺点：</h4><ol>\n<li>优点<ul>\n<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>\n</ul>\n</li>\n<li>适用场景<ul>\n<li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-工厂模式\"><a href=\"#5-工厂模式\" class=\"headerlink\" title=\"5. 工厂模式\"></a>5. 工厂模式</h3><ol>\n<li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li>\n<li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li>\n<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li>\n</ol>\n<h4 id=\"5-1-简单工厂模式的实现：\"><a href=\"#5-1-简单工厂模式的实现：\" class=\"headerlink\" title=\"5.1 简单工厂模式的实现：\"></a>5.1 简单工厂模式的实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 产品接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fruit</span> </span>&#123; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span></span>; &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*苹果*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pear</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 梨 */</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"apple\"</span>)) &#123;<span class=\"comment\">//生产苹果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"pear\"</span>)) &#123;<span class=\"comment\">//生产梨</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">FruitFactory mFactory = <span class=\"keyword\">new</span> FruitFactory();</span><br><span class=\"line\">Apple apple = (Apple) mFactory.createFruit(<span class=\"string\">\"apple\"</span>);<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) mFactory.createFruit(<span class=\"string\">\"pear\"</span>);<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>简单工厂只适合于产品对象较少，且产品固定的需求</p>\n</blockquote>\n<h4 id=\"5-2-工厂方法模式实现：\"><a href=\"#5-2-工厂方法模式实现：\" class=\"headerlink\" title=\"5.2 工厂方法模式实现：\"></a>5.2 工厂方法模式实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span></span>;<span class=\"comment\">//生产水果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppleFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PearFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">AppleFactory appleFactory = <span class=\"keyword\">new</span> AppleFactory();</span><br><span class=\"line\">PearFactory pearFactory = <span class=\"keyword\">new</span> PearFactory();</span><br><span class=\"line\">Apple apple = (Apple) appleFactory.createFruit();<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) pearFactory.createFruit();<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p>\n</blockquote>\n<h4 id=\"5-3-抽象工厂模式实现：\"><a href=\"#5-3-抽象工厂模式实现：\" class=\"headerlink\" title=\"5.3 抽象工厂模式实现：\"></a>5.3 抽象工厂模式实现：</h4><ul>\n<li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li>\n<li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// cpu接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu650</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 625 也厉害 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu825</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 825 处理更强劲 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏幕接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen5</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 5寸 */</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen6</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 6寸 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的cpu</span></span><br><span class=\"line\">    <span class=\"function\">Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的屏幕</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu825();<span class=\"comment\">//高性能处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen6();<span class=\"comment\">//6寸大屏</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HongMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu650();<span class=\"comment\">//高效处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen5();<span class=\"comment\">//小屏手机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p>\n</blockquote>\n<h4 id=\"5-4-三种工厂方式总结：\"><a href=\"#5-4-三种工厂方式总结：\" class=\"headerlink\" title=\"5.4 三种工厂方式总结：\"></a>5.4 三种工厂方式总结：</h4><ol>\n<li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li>\n<li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-适配器模式（Adapter）\"><a href=\"#6-适配器模式（Adapter）\" class=\"headerlink\" title=\"6.适配器模式（Adapter）\"></a>6.适配器模式（Adapter）</h3><ul>\n<li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul>\n<li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li>\n<li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>\n</blockquote>\n<h4 id=\"6-1-缺省适配器模式\"><a href=\"#6-1-缺省适配器模式\" class=\"headerlink\" title=\"6.1 缺省适配器模式\"></a>6.1 缺省适配器模式</h4><ul>\n<li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li>\n<li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li>\n<li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>","more":"<ol>\n<li><a href=\"#id1\">常用的设计原则</a></li>\n<li><a href=\"#id2\">设计模式分类</a></li>\n<li><a href=\"#id3\">单例模式</a></li>\n<li><a href=\"#id4\">模板模式</a></li>\n<li><a href=\"#id5\">工厂模式</a></li>\n<li><a href=\"#id6\">适配器模式</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-常用的设计原则\"><a href=\"#1-常用的设计原则\" class=\"headerlink\" title=\"1.常用的设计原则\"></a>1.常用的设计原则</h3><ul>\n<li><strong>开闭原则</strong>：对扩展开发，对修改方便</li>\n<li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li>\n<li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>\n<li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li>\n<li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li>\n<li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-设计模式分类\"><a href=\"#2-设计模式分类\" class=\"headerlink\" title=\"2.设计模式分类\"></a>2.设计模式分类</h3><h4 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h4><ul>\n<li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li>\n<li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li>\n<li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li>\n</ul>\n<h4 id=\"2-2-具体分类\"><a href=\"#2-2-具体分类\" class=\"headerlink\" title=\"2.2 具体分类\"></a>2.2 具体分类</h4><ol>\n<li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul>\n<li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li>\n</ul>\n</li>\n<li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul>\n<li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li>\n</ul>\n</li>\n<li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul>\n<li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li>\n</ul>\n</li>\n<li>JEE 设计模式<ul>\n<li>数据访问对象模式 </li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-单例模式（Singleton）\"><a href=\"#3-单例模式（Singleton）\" class=\"headerlink\" title=\"3.单例模式（Singleton）\"></a>3.单例模式（Singleton）</h3><h4 id=\"3-1-实现流程：\"><a href=\"#3-1-实现流程：\" class=\"headerlink\" title=\"3.1 实现流程：\"></a>3.1 实现流程：</h4><ol>\n<li>私有的构造方法</li>\n<li>私有的静态的当前类的对象作为属性</li>\n<li>共有的静态方法返回当前对象<h4 id=\"3-1-实现方式：\"><a href=\"#3-1-实现方式：\" class=\"headerlink\" title=\"3.1 实现方式：\"></a>3.1 实现方式：</h4></li>\n<li>饿汉式：立即加载，对象启动时就加载</li>\n<li>懒汉式：延迟加载，对象什么时候用到时才会加载</li>\n<li>生命周期托管：单例对象交给别人处理</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-模板模式\"><a href=\"#4-模板模式\" class=\"headerlink\" title=\"4.模板模式\"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p>\n<ul>\n<li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      initialize();</span><br><span class=\"line\">      start();</span><br><span class=\"line\">      end();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Browser</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Initialized!.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Started.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Initialized!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Started!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      Software s1 = <span class=\"keyword\">new</span> Browser();</span><br><span class=\"line\">      s1.play();</span><br><span class=\"line\">      s1 = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\">      s1.play();    </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-模式模式优缺点：\"><a href=\"#4-1-模式模式优缺点：\" class=\"headerlink\" title=\"4.1 模式模式优缺点：\"></a>4.1 模式模式优缺点：</h4><ol>\n<li>优点<ul>\n<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>\n</ul>\n</li>\n<li>适用场景<ul>\n<li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-工厂模式\"><a href=\"#5-工厂模式\" class=\"headerlink\" title=\"5. 工厂模式\"></a>5. 工厂模式</h3><ol>\n<li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li>\n<li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li>\n<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li>\n</ol>\n<h4 id=\"5-1-简单工厂模式的实现：\"><a href=\"#5-1-简单工厂模式的实现：\" class=\"headerlink\" title=\"5.1 简单工厂模式的实现：\"></a>5.1 简单工厂模式的实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 产品接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fruit</span> </span>&#123; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span></span>; &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*苹果*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pear</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 梨 */</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"apple\"</span>)) &#123;<span class=\"comment\">//生产苹果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"pear\"</span>)) &#123;<span class=\"comment\">//生产梨</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">FruitFactory mFactory = <span class=\"keyword\">new</span> FruitFactory();</span><br><span class=\"line\">Apple apple = (Apple) mFactory.createFruit(<span class=\"string\">\"apple\"</span>);<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) mFactory.createFruit(<span class=\"string\">\"pear\"</span>);<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>简单工厂只适合于产品对象较少，且产品固定的需求</p>\n</blockquote>\n<h4 id=\"5-2-工厂方法模式实现：\"><a href=\"#5-2-工厂方法模式实现：\" class=\"headerlink\" title=\"5.2 工厂方法模式实现：\"></a>5.2 工厂方法模式实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span></span>;<span class=\"comment\">//生产水果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppleFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PearFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">AppleFactory appleFactory = <span class=\"keyword\">new</span> AppleFactory();</span><br><span class=\"line\">PearFactory pearFactory = <span class=\"keyword\">new</span> PearFactory();</span><br><span class=\"line\">Apple apple = (Apple) appleFactory.createFruit();<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) pearFactory.createFruit();<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p>\n</blockquote>\n<h4 id=\"5-3-抽象工厂模式实现：\"><a href=\"#5-3-抽象工厂模式实现：\" class=\"headerlink\" title=\"5.3 抽象工厂模式实现：\"></a>5.3 抽象工厂模式实现：</h4><ul>\n<li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li>\n<li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// cpu接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu650</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 625 也厉害 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu825</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 825 处理更强劲 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏幕接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen5</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 5寸 */</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen6</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 6寸 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的cpu</span></span><br><span class=\"line\">    <span class=\"function\">Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的屏幕</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu825();<span class=\"comment\">//高性能处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen6();<span class=\"comment\">//6寸大屏</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HongMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu650();<span class=\"comment\">//高效处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen5();<span class=\"comment\">//小屏手机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p>\n</blockquote>\n<h4 id=\"5-4-三种工厂方式总结：\"><a href=\"#5-4-三种工厂方式总结：\" class=\"headerlink\" title=\"5.4 三种工厂方式总结：\"></a>5.4 三种工厂方式总结：</h4><ol>\n<li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li>\n<li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-适配器模式（Adapter）\"><a href=\"#6-适配器模式（Adapter）\" class=\"headerlink\" title=\"6.适配器模式（Adapter）\"></a>6.适配器模式（Adapter）</h3><ul>\n<li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul>\n<li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li>\n<li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>\n</blockquote>\n<h4 id=\"6-1-缺省适配器模式\"><a href=\"#6-1-缺省适配器模式\" class=\"headerlink\" title=\"6.1 缺省适配器模式\"></a>6.1 缺省适配器模式</h4><ul>\n<li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li>\n<li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li>\n<li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li>\n</ul>"},{"title":"十一、JavaSE数据结构与算法入门","date":"2019-07-15T10:12:38.000Z","_content":"\n数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。\n<!-- more -->\n\n1. [Java数据结构](#id1)\n2. [时间复杂度与空间复杂度](#id2)\n3. [算法的基本概念](#id3)\n\n\n<span id=\"id1\"><span>\n### 1.Java数据结构(Data Structure)\n#### 1.1 数据结构\n1. 数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n2. 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。\n3. 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。\n\n#### 1.2 Java数据结构\n- 数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。\n  1. 线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。\n  2. 非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。\n- 按数据的存储结构分为：顺序存储结构和链式存储结构\n  1. 顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 \n  2. 链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。\n\n#### 1.2.1 线性数据结构\n常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。\n\n1. 一维数组\n  - 在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。\n  - ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。\n  - 数组的插入/更新/删除效率比较低，而**查询效率非常高**,查询效率时间复杂度是1。\n2. 线性表\n  - 线性表是有序的储存结构、链式的储存结构。\n  - 链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。\n  - 常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。\n  - 线性表**插入效率比较高**，而查询效率就比较低（add(),get()）。\n3. 栈Stack\n  - 栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。\n4. 队列\n  - 队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。\n  - Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。\n  - 使用场景也非常多，如线程池，mq，连接池等。\n5. 串\n  - 串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）\n\n#### 1.2.2 非线性数据结构\n常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。\n\n1. 多维数组\n  - Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。\n2. 集合\n  - 由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。\n3. 树\n  - 在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。\n  - 除了根节点，其他结点有且只有一个直接父节点\n  - 每个结点可以有任意多个直接子节点。\n  - 树的数据结构又分为：\n    1. 自由树/普通树：对子节点没有任何约束。\n    2. 二叉树：每个节点最多含有两个子节点的树称为二叉树。\n    3. 二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）\n    4. B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。\n    5. B+tree：又称B+。是B-树的变体，也是一种多路搜索树。\n4. Hash\n  - Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）\n  - 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\n  - Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。\n  - Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。\n  - 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。\n5. 图\n  - 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\n\n\n### 2. 时间复杂度与空间复杂度\n#### 2.1 时间复杂度\n一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为**语句频度或时间频度**。记为**T(n)**\n\n在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。\n\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称**时间复杂度**。\n\n有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。\n\n常见的算法的时间 复杂度之间的关系为：`O(1)<O(logn)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)`\n\n\n#### 2.2 空间复杂度\n空间复杂度：算法所需存储空间的度量，记作：`S(n)=O( f(n) )`，其中 n 为问题的规模。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。\n\n算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。\n\n> - 空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。\n> - 时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。\n> - 稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。\n\n### 3.算法的基本概念\n- 算法: 简单来说就是解决问题的步骤。\n- 算法的五个特征:有穷性，确定性，可行性，有输入，有输出\n  1. 有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。\n  2. 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。\n  3. 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。\n  4. 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。\n  5. 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。\n- 算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求\n  * 描述算法的速度必须要和数据项的个数联系起来。\n  * 算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；\n  * 一个算法的效率越高越好，而存储量是越低越好。\n\n\n### 4. 常用的查找算法\n#### 4.1 线性（顺序）查找算法\n1. 使用目标元素与样本数列中第一个元素起依次进行比较\n2. 若目标元素等于样本元素，则表示查找成功\n3. 若目标元素与样本元素比较完毕也不相等，则表示查找失败\n\n#### 4.2 二分查找算法\n二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。\n\n- 普通循环实现二分查找算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 28));\n}\n/**\n * 二分查找普通循环实现\n *\n * @param srcArray 有序数组\n * @param key 查找元素\n * @return\n */\npublic static int binSearch(int srcArray[], int key) {\n    int mid = srcArray.length / 2;\n    if (key == srcArray[mid]) return mid;\n    int start = 0;\n    int end = srcArray.length - 1;\n    while (start <= end) {\n        mid = (end - start) / 2 + start;\n        if (key < srcArray[mid]) {\n            end = mid - 1;\n        } else if (key > srcArray[mid]) {\n            start = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n> 二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。\n\n\n- 递归实现二分查找递归实现算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 0,15,28));\n}\n/**\n * 二分查找递归实现\n *\n * @param srcArray  有序数组\n * @param start 数组低地址下标\n * @param end   数组高地址下标\n * @param key  查找元素\n * @return 查找元素不存在返回-1\n */\npublic static int binSearch(int srcArray[], int start, int end, int key) {\n    int mid = (end - start) / 2 + start;\n    if (srcArray[mid] == key) {\n        return mid;\n    }\n    if (start >= end) {\n        return -1;\n    } else if (key > srcArray[mid]) {\n        return binSearch(srcArray, mid + 1, end, key);\n    } else if (key < srcArray[mid]) {\n        return binSearch(srcArray, start, mid - 1, key);\n    }\n    return -1;\n}\n```\n> 递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。\n\n\n### 4. 常用的排序算法\n- 八大排序算法\n  * 一、直接插入排序（Insertion Sort）\n  * 二、希尔排序（Shell Sort）\n  * 三、选择排序（Selection Sort）\n  * 四、堆排序（Heap Sort）\n  * 五、冒泡排序（Bubble Sort）\n  * 六、快速排序（Quick Sort）\n  * 七、归并排序（Merging Sort）\n  * 八、基数排序（Radix Sort）\n\n#### 4.1 冒泡排序算法\n冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n- 算法描述：\n  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n  3. 针对所有的元素重复以上的步骤，除了最后一个。\n  4. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。\n\n- 代码实现：\n``` java\npublic static void bubbleSort(int[] arr){\n    for (int i=1; i<arr.length; i++){\n      boolean flag = true;//声明标志位\n      for(int j=0; j<arr.length-i; j++){\n        if(arr[j] > arr[j+1]){\n          int temp = arr[j+1];\n          arr[j] = arr[j+1];\n          arr[j++1] = temp;\n          flag = false;\n        }\n      }\n      //若此轮结束flag还是为true,则证明已经有序\n      if(flag) break;\n    }\n}\n```\n\n- 冒泡排序算法复杂度:\n  * 平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)\n  * 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).\n\n> Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。\n\n\n\n","source":"_posts/11_JavaSE数据结构与算法入门.md","raw":"---\ntitle: 十一、JavaSE数据结构与算法入门\ndate: 2019-07-15 18:12:38\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。\n<!-- more -->\n\n1. [Java数据结构](#id1)\n2. [时间复杂度与空间复杂度](#id2)\n3. [算法的基本概念](#id3)\n\n\n<span id=\"id1\"><span>\n### 1.Java数据结构(Data Structure)\n#### 1.1 数据结构\n1. 数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n2. 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。\n3. 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。\n\n#### 1.2 Java数据结构\n- 数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。\n  1. 线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。\n  2. 非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。\n- 按数据的存储结构分为：顺序存储结构和链式存储结构\n  1. 顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 \n  2. 链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。\n\n#### 1.2.1 线性数据结构\n常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。\n\n1. 一维数组\n  - 在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。\n  - ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。\n  - 数组的插入/更新/删除效率比较低，而**查询效率非常高**,查询效率时间复杂度是1。\n2. 线性表\n  - 线性表是有序的储存结构、链式的储存结构。\n  - 链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。\n  - 常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。\n  - 线性表**插入效率比较高**，而查询效率就比较低（add(),get()）。\n3. 栈Stack\n  - 栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。\n4. 队列\n  - 队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。\n  - Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。\n  - 使用场景也非常多，如线程池，mq，连接池等。\n5. 串\n  - 串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）\n\n#### 1.2.2 非线性数据结构\n常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。\n\n1. 多维数组\n  - Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。\n2. 集合\n  - 由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。\n3. 树\n  - 在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。\n  - 除了根节点，其他结点有且只有一个直接父节点\n  - 每个结点可以有任意多个直接子节点。\n  - 树的数据结构又分为：\n    1. 自由树/普通树：对子节点没有任何约束。\n    2. 二叉树：每个节点最多含有两个子节点的树称为二叉树。\n    3. 二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）\n    4. B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。\n    5. B+tree：又称B+。是B-树的变体，也是一种多路搜索树。\n4. Hash\n  - Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）\n  - 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\n  - Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。\n  - Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。\n  - 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。\n5. 图\n  - 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\n\n\n### 2. 时间复杂度与空间复杂度\n#### 2.1 时间复杂度\n一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为**语句频度或时间频度**。记为**T(n)**\n\n在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。\n\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称**时间复杂度**。\n\n有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。\n\n常见的算法的时间 复杂度之间的关系为：`O(1)<O(logn)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)`\n\n\n#### 2.2 空间复杂度\n空间复杂度：算法所需存储空间的度量，记作：`S(n)=O( f(n) )`，其中 n 为问题的规模。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。\n\n算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。\n\n> - 空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。\n> - 时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。\n> - 稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。\n\n### 3.算法的基本概念\n- 算法: 简单来说就是解决问题的步骤。\n- 算法的五个特征:有穷性，确定性，可行性，有输入，有输出\n  1. 有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。\n  2. 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。\n  3. 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。\n  4. 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。\n  5. 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。\n- 算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求\n  * 描述算法的速度必须要和数据项的个数联系起来。\n  * 算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；\n  * 一个算法的效率越高越好，而存储量是越低越好。\n\n\n### 4. 常用的查找算法\n#### 4.1 线性（顺序）查找算法\n1. 使用目标元素与样本数列中第一个元素起依次进行比较\n2. 若目标元素等于样本元素，则表示查找成功\n3. 若目标元素与样本元素比较完毕也不相等，则表示查找失败\n\n#### 4.2 二分查找算法\n二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。\n\n- 普通循环实现二分查找算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 28));\n}\n/**\n * 二分查找普通循环实现\n *\n * @param srcArray 有序数组\n * @param key 查找元素\n * @return\n */\npublic static int binSearch(int srcArray[], int key) {\n    int mid = srcArray.length / 2;\n    if (key == srcArray[mid]) return mid;\n    int start = 0;\n    int end = srcArray.length - 1;\n    while (start <= end) {\n        mid = (end - start) / 2 + start;\n        if (key < srcArray[mid]) {\n            end = mid - 1;\n        } else if (key > srcArray[mid]) {\n            start = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n> 二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。\n\n\n- 递归实现二分查找递归实现算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 0,15,28));\n}\n/**\n * 二分查找递归实现\n *\n * @param srcArray  有序数组\n * @param start 数组低地址下标\n * @param end   数组高地址下标\n * @param key  查找元素\n * @return 查找元素不存在返回-1\n */\npublic static int binSearch(int srcArray[], int start, int end, int key) {\n    int mid = (end - start) / 2 + start;\n    if (srcArray[mid] == key) {\n        return mid;\n    }\n    if (start >= end) {\n        return -1;\n    } else if (key > srcArray[mid]) {\n        return binSearch(srcArray, mid + 1, end, key);\n    } else if (key < srcArray[mid]) {\n        return binSearch(srcArray, start, mid - 1, key);\n    }\n    return -1;\n}\n```\n> 递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。\n\n\n### 4. 常用的排序算法\n- 八大排序算法\n  * 一、直接插入排序（Insertion Sort）\n  * 二、希尔排序（Shell Sort）\n  * 三、选择排序（Selection Sort）\n  * 四、堆排序（Heap Sort）\n  * 五、冒泡排序（Bubble Sort）\n  * 六、快速排序（Quick Sort）\n  * 七、归并排序（Merging Sort）\n  * 八、基数排序（Radix Sort）\n\n#### 4.1 冒泡排序算法\n冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n- 算法描述：\n  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n  3. 针对所有的元素重复以上的步骤，除了最后一个。\n  4. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。\n\n- 代码实现：\n``` java\npublic static void bubbleSort(int[] arr){\n    for (int i=1; i<arr.length; i++){\n      boolean flag = true;//声明标志位\n      for(int j=0; j<arr.length-i; j++){\n        if(arr[j] > arr[j+1]){\n          int temp = arr[j+1];\n          arr[j] = arr[j+1];\n          arr[j++1] = temp;\n          flag = false;\n        }\n      }\n      //若此轮结束flag还是为true,则证明已经有序\n      if(flag) break;\n    }\n}\n```\n\n- 冒泡排序算法复杂度:\n  * 平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)\n  * 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).\n\n> Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。\n\n\n\n","slug":"11_JavaSE数据结构与算法入门","published":1,"updated":"2019-07-20T15:08:05.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo600023yot3psrfgvcu","content":"<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Java数据结构</a></li>\n<li><a href=\"#id2\">时间复杂度与空间复杂度</a></li>\n<li><a href=\"#id3\">算法的基本概念</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Java数据结构-Data-Structure\"><a href=\"#1-Java数据结构-Data-Structure\" class=\"headerlink\" title=\"1.Java数据结构(Data Structure)\"></a>1.Java数据结构(Data Structure)</h3><h4 id=\"1-1-数据结构\"><a href=\"#1-1-数据结构\" class=\"headerlink\" title=\"1.1 数据结构\"></a>1.1 数据结构</h4><ol>\n<li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li>\n<li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li>\n<li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li>\n</ol>\n<h4 id=\"1-2-Java数据结构\"><a href=\"#1-2-Java数据结构\" class=\"headerlink\" title=\"1.2 Java数据结构\"></a>1.2 Java数据结构</h4><ul>\n<li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol>\n<li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li>\n<li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li>\n</ol>\n</li>\n<li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol>\n<li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li>\n<li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-1-线性数据结构\"><a href=\"#1-2-1-线性数据结构\" class=\"headerlink\" title=\"1.2.1 线性数据结构\"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p>\n<ol>\n<li>一维数组<ul>\n<li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li>\n<li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li>\n<li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li>\n</ul>\n</li>\n<li>线性表<ul>\n<li>线性表是有序的储存结构、链式的储存结构。</li>\n<li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li>\n<li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li>\n<li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li>\n</ul>\n</li>\n<li>栈Stack<ul>\n<li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li>\n<li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li>\n<li>使用场景也非常多，如线程池，mq，连接池等。</li>\n</ul>\n</li>\n<li>串<ul>\n<li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-2-非线性数据结构\"><a href=\"#1-2-2-非线性数据结构\" class=\"headerlink\" title=\"1.2.2 非线性数据结构\"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p>\n<ol>\n<li>多维数组<ul>\n<li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li>\n</ul>\n</li>\n<li>集合<ul>\n<li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li>\n</ul>\n</li>\n<li>树<ul>\n<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>\n<li>除了根节点，其他结点有且只有一个直接父节点</li>\n<li>每个结点可以有任意多个直接子节点。</li>\n<li>树的数据结构又分为：<ol>\n<li>自由树/普通树：对子节点没有任何约束。</li>\n<li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li>\n<li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li>\n<li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li>\n<li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Hash<ul>\n<li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li>\n<li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>\n<li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li>\n<li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li>\n<li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-时间复杂度与空间复杂度\"><a href=\"#2-时间复杂度与空间复杂度\" class=\"headerlink\" title=\"2. 时间复杂度与空间复杂度\"></a>2. 时间复杂度与空间复杂度</h3><h4 id=\"2-1-时间复杂度\"><a href=\"#2-1-时间复杂度\" class=\"headerlink\" title=\"2.1 时间复杂度\"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p>\n<p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p>\n<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p>\n<p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p>\n<p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p>\n<h4 id=\"2-2-空间复杂度\"><a href=\"#2-2-空间复杂度\" class=\"headerlink\" title=\"2.2 空间复杂度\"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p>\n<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>\n<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>\n<blockquote>\n<ul>\n<li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li>\n<li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li>\n<li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-算法的基本概念\"><a href=\"#3-算法的基本概念\" class=\"headerlink\" title=\"3.算法的基本概念\"></a>3.算法的基本概念</h3><ul>\n<li>算法: 简单来说就是解决问题的步骤。</li>\n<li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol>\n<li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li>\n<li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li>\n<li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li>\n<li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li>\n<li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li>\n</ol>\n</li>\n<li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul>\n<li>描述算法的速度必须要和数据项的个数联系起来。</li>\n<li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li>\n<li>一个算法的效率越高越好，而存储量是越低越好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-常用的查找算法\"><a href=\"#4-常用的查找算法\" class=\"headerlink\" title=\"4. 常用的查找算法\"></a>4. 常用的查找算法</h3><h4 id=\"4-1-线性（顺序）查找算法\"><a href=\"#4-1-线性（顺序）查找算法\" class=\"headerlink\" title=\"4.1 线性（顺序）查找算法\"></a>4.1 线性（顺序）查找算法</h4><ol>\n<li>使用目标元素与样本数列中第一个元素起依次进行比较</li>\n<li>若目标元素等于样本元素，则表示查找成功</li>\n<li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li>\n</ol>\n<h4 id=\"4-2-二分查找算法\"><a href=\"#4-2-二分查找算法\" class=\"headerlink\" title=\"4.2 二分查找算法\"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p>\n<ul>\n<li>普通循环实现二分查找算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找普通循环实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray 有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key 查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = srcArray.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == srcArray[mid]) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">        mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>\n</blockquote>\n<ul>\n<li>递归实现二分查找递归实现算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">0</span>,<span class=\"number\">15</span>,<span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray  有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 数组低地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end   数组高地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key  查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 查找元素不存在返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcArray[mid] == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, mid + <span class=\"number\">1</span>, end, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, start, mid - <span class=\"number\">1</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>\n</blockquote>\n<h3 id=\"4-常用的排序算法\"><a href=\"#4-常用的排序算法\" class=\"headerlink\" title=\"4. 常用的排序算法\"></a>4. 常用的排序算法</h3><ul>\n<li>八大排序算法<ul>\n<li>一、直接插入排序（Insertion Sort）</li>\n<li>二、希尔排序（Shell Sort）</li>\n<li>三、选择排序（Selection Sort）</li>\n<li>四、堆排序（Heap Sort）</li>\n<li>五、冒泡排序（Bubble Sort）</li>\n<li>六、快速排序（Quick Sort）</li>\n<li>七、归并排序（Merging Sort）</li>\n<li>八、基数排序（Radix Sort）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-冒泡排序算法\"><a href=\"#4-1-冒泡排序算法\" class=\"headerlink\" title=\"4.1 冒泡排序算法\"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<ul>\n<li><p>算法描述：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li>\n</ol>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;<span class=\"comment\">//声明标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> temp = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j++<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">          flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>冒泡排序算法复杂度:</p>\n<ul>\n<li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li>\n<li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p>","more":"<ol>\n<li><a href=\"#id1\">Java数据结构</a></li>\n<li><a href=\"#id2\">时间复杂度与空间复杂度</a></li>\n<li><a href=\"#id3\">算法的基本概念</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Java数据结构-Data-Structure\"><a href=\"#1-Java数据结构-Data-Structure\" class=\"headerlink\" title=\"1.Java数据结构(Data Structure)\"></a>1.Java数据结构(Data Structure)</h3><h4 id=\"1-1-数据结构\"><a href=\"#1-1-数据结构\" class=\"headerlink\" title=\"1.1 数据结构\"></a>1.1 数据结构</h4><ol>\n<li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li>\n<li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li>\n<li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li>\n</ol>\n<h4 id=\"1-2-Java数据结构\"><a href=\"#1-2-Java数据结构\" class=\"headerlink\" title=\"1.2 Java数据结构\"></a>1.2 Java数据结构</h4><ul>\n<li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol>\n<li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li>\n<li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li>\n</ol>\n</li>\n<li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol>\n<li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li>\n<li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-1-线性数据结构\"><a href=\"#1-2-1-线性数据结构\" class=\"headerlink\" title=\"1.2.1 线性数据结构\"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p>\n<ol>\n<li>一维数组<ul>\n<li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li>\n<li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li>\n<li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li>\n</ul>\n</li>\n<li>线性表<ul>\n<li>线性表是有序的储存结构、链式的储存结构。</li>\n<li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li>\n<li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li>\n<li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li>\n</ul>\n</li>\n<li>栈Stack<ul>\n<li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li>\n<li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li>\n<li>使用场景也非常多，如线程池，mq，连接池等。</li>\n</ul>\n</li>\n<li>串<ul>\n<li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-2-非线性数据结构\"><a href=\"#1-2-2-非线性数据结构\" class=\"headerlink\" title=\"1.2.2 非线性数据结构\"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p>\n<ol>\n<li>多维数组<ul>\n<li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li>\n</ul>\n</li>\n<li>集合<ul>\n<li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li>\n</ul>\n</li>\n<li>树<ul>\n<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>\n<li>除了根节点，其他结点有且只有一个直接父节点</li>\n<li>每个结点可以有任意多个直接子节点。</li>\n<li>树的数据结构又分为：<ol>\n<li>自由树/普通树：对子节点没有任何约束。</li>\n<li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li>\n<li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li>\n<li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li>\n<li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Hash<ul>\n<li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li>\n<li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>\n<li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li>\n<li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li>\n<li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-时间复杂度与空间复杂度\"><a href=\"#2-时间复杂度与空间复杂度\" class=\"headerlink\" title=\"2. 时间复杂度与空间复杂度\"></a>2. 时间复杂度与空间复杂度</h3><h4 id=\"2-1-时间复杂度\"><a href=\"#2-1-时间复杂度\" class=\"headerlink\" title=\"2.1 时间复杂度\"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p>\n<p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p>\n<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p>\n<p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p>\n<p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p>\n<h4 id=\"2-2-空间复杂度\"><a href=\"#2-2-空间复杂度\" class=\"headerlink\" title=\"2.2 空间复杂度\"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p>\n<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>\n<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>\n<blockquote>\n<ul>\n<li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li>\n<li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li>\n<li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-算法的基本概念\"><a href=\"#3-算法的基本概念\" class=\"headerlink\" title=\"3.算法的基本概念\"></a>3.算法的基本概念</h3><ul>\n<li>算法: 简单来说就是解决问题的步骤。</li>\n<li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol>\n<li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li>\n<li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li>\n<li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li>\n<li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li>\n<li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li>\n</ol>\n</li>\n<li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul>\n<li>描述算法的速度必须要和数据项的个数联系起来。</li>\n<li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li>\n<li>一个算法的效率越高越好，而存储量是越低越好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-常用的查找算法\"><a href=\"#4-常用的查找算法\" class=\"headerlink\" title=\"4. 常用的查找算法\"></a>4. 常用的查找算法</h3><h4 id=\"4-1-线性（顺序）查找算法\"><a href=\"#4-1-线性（顺序）查找算法\" class=\"headerlink\" title=\"4.1 线性（顺序）查找算法\"></a>4.1 线性（顺序）查找算法</h4><ol>\n<li>使用目标元素与样本数列中第一个元素起依次进行比较</li>\n<li>若目标元素等于样本元素，则表示查找成功</li>\n<li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li>\n</ol>\n<h4 id=\"4-2-二分查找算法\"><a href=\"#4-2-二分查找算法\" class=\"headerlink\" title=\"4.2 二分查找算法\"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p>\n<ul>\n<li>普通循环实现二分查找算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找普通循环实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray 有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key 查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = srcArray.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == srcArray[mid]) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">        mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>\n</blockquote>\n<ul>\n<li>递归实现二分查找递归实现算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">0</span>,<span class=\"number\">15</span>,<span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray  有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 数组低地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end   数组高地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key  查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 查找元素不存在返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcArray[mid] == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, mid + <span class=\"number\">1</span>, end, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, start, mid - <span class=\"number\">1</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>\n</blockquote>\n<h3 id=\"4-常用的排序算法\"><a href=\"#4-常用的排序算法\" class=\"headerlink\" title=\"4. 常用的排序算法\"></a>4. 常用的排序算法</h3><ul>\n<li>八大排序算法<ul>\n<li>一、直接插入排序（Insertion Sort）</li>\n<li>二、希尔排序（Shell Sort）</li>\n<li>三、选择排序（Selection Sort）</li>\n<li>四、堆排序（Heap Sort）</li>\n<li>五、冒泡排序（Bubble Sort）</li>\n<li>六、快速排序（Quick Sort）</li>\n<li>七、归并排序（Merging Sort）</li>\n<li>八、基数排序（Radix Sort）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-冒泡排序算法\"><a href=\"#4-1-冒泡排序算法\" class=\"headerlink\" title=\"4.1 冒泡排序算法\"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<ul>\n<li><p>算法描述：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li>\n</ol>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;<span class=\"comment\">//声明标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> temp = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j++<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">          flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>冒泡排序算法复杂度:</p>\n<ul>\n<li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li>\n<li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p>\n</blockquote>"},{"title":"十六、Spring事务管理","date":"2019-08-27T14:47:30.000Z","_content":"\n事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。\n<!-- more -->\n\n1. [事务的特性(ACID)](#id1)\n2. [Spring提供事务管理的3个接口](#id2)\n3. [TransactionDefinition接口](#id3)\n4. [TransactionStatus接口](#id4)\n5. [PlatformTransactionManager接口（事务管理器）](#id5)\n6. [基于AspectJ的xml方式的声明式事务管理](#id6)\n7. [基于注解的声明式事务管理](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 事务的特性(ACID)\n+ 事务的特性：**原子性、一致性、隔离性、持久性**。\n+ 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n+ 一致性（Consistency）：事务前后数据的完整性必须保持一致。\n+ 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。\n+ 持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。\n\n\n<span id=\"id2\"><span>\n### 2. Spring提供事务管理的3个接口：\n1. **PlatformTransactionManager**：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。\n2. **TransactionDefinition**：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。\n3. **TransactionStatus**：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。\n\n> Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。\n\n\n<span id=\"id3\"><span>\n### 3. TransactionDefinition接口\nTransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)\n+ 如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。\n+ 事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。\n\n\n#### 3.1 安全问题\n1. 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。\n2. 不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。\n3. 幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。\n\n\n#### 3.2 事务的隔离级别(Isolation)：\n1. **`READ_UNCOMMITED`**(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。\n2. **`READ_COMMITED`**(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。\n3. **`REPEATABLE_READ`**(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。\n4. **`SERIALIZABLE`**(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。\n5. `DEFAULT`(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用`REPEATABLE_READ`隔离级别，Oracle默认采用`READ_COMMITTED`隔离级别）。\n\n\n#### 3.3 事务的传播特性(Propagation)：\n1. 第一类：运行在同一个事务\n    + **`REQUIRED`**：默认，支持当前事务，如果当前没有事务，就新建一个事务。\n    + `SUPPORTS`：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)\n    + `MANDATORY`：支持当前事务，如果当前没有事务，就抛出异常\n2. 第二类：运行在不同事务\n    + **`REQUIRES_NEW`**：新建事务，如果当前存在事务，把当前事务挂起\n    + `NOT_SUPPORTED`：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n    + `NEVER`：以非事务方式执行，如果当前存在事务，则抛出异常\n3. 第三类：嵌套执行--即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态\n    + **`NESTED`**：如果当前事务存在，则嵌套事务执行\n\n\n\n<span id=\"id4\"><span>\n### 4. TransactionStatus接口\n平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。\n\n\n\n<span id=\"id5\"><span>\n### 5. PlatformTransactionManager接口（事务管理器）\n该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。\n\n\n#### 5.1 Spring支持两种方式事务管理：\n1. 编程式事务管理\n    + 手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）\n2. 声明式事务管理\n    + 基于TransactionProxyFactoryBean的方式（很少使用）\n    + 基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）\n    + 基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加`@Transactional`注解（经常使用）\n\n\n<span id=\"id6\"><span>\n### 6. 基于AspectJ的xml方式的声明式事务管理\n``` xml\n<!-- 配置事务管理器 -->\n<bean id=\"transactionManager\"\n    class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbc连接池对象id\"/>\n</bean>\n<!-- 配置事务的通知（事务的增强） -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>    \n        <!-- propagation:事务传播行为\n            isolation:事务的隔离级别\n            read-only:只读\n            rollback-for:发生哪些异常回滚\n            no-rollback-for:发生哪些异常不回滚\n            timeout:过期信息    --> \n        <tx:method name=\"transfer\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" rollback-for=\"\" timeout=\"\" no-rollback-for=\"\"/>\n    </tx:attributes>\n</tx:advice>\n<!-- 配置切面 -->\n<aop:config>\n    <!-- 配置切入点 -->\n    <aop:pointcut id=\"pointcut1\" expression=\"execution(*cn.muke.spring.demo3.AccountService+.*(.))\"/>\n    <!-- 配置切面 -->\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/>\n</aop:config>\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 基于注解的声明式事务管理\n1. 配置事务管理器\n``` xml\n<!-- 1.创建一个事务管理器对象 -->\n<bean id=\"事务管理器id\" \nclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbc连接池对象id\"/>\n</bean>\n<!-- 2.开启声明式事务 -->\n<tx:annotation-driven transaction-manager=\"事务管理器id\" proxy-target-class=\"true|false\" />\n```\n\n    - **transaction-manager**：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)\n    - **proxy-target-class**：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。\n\n\n2. 使用，在类上或者方法上标注`@Transactional`\n``` java\n@Transactional(\n        rollbackFor={Exception.class}, \n        readOnly=false, \n        isolation=Isolation.DEFAULT,\n        propagation=Propagation.REQUIRED)\npublic void transfer(){..}\n```\n\n    - @Transactional的属性\n        + **rollbackFor**：设置检查异常也回滚\n        + **noRollbackFor**：指定运行时异常不回滚\n        + **readOnly**： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。\n        + **isolation**：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)\n        + **propagation**：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)\n    - Spring中事务管理器默认值针对**运行时异常**回滚，对**检查异常**不回滚。\n\n\n","source":"_posts/16-Spring事务管理.md","raw":"---\ntitle: 十六、Spring事务管理\ndate: 2019-08-27 22:47:30\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\n事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。\n<!-- more -->\n\n1. [事务的特性(ACID)](#id1)\n2. [Spring提供事务管理的3个接口](#id2)\n3. [TransactionDefinition接口](#id3)\n4. [TransactionStatus接口](#id4)\n5. [PlatformTransactionManager接口（事务管理器）](#id5)\n6. [基于AspectJ的xml方式的声明式事务管理](#id6)\n7. [基于注解的声明式事务管理](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 事务的特性(ACID)\n+ 事务的特性：**原子性、一致性、隔离性、持久性**。\n+ 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n+ 一致性（Consistency）：事务前后数据的完整性必须保持一致。\n+ 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。\n+ 持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。\n\n\n<span id=\"id2\"><span>\n### 2. Spring提供事务管理的3个接口：\n1. **PlatformTransactionManager**：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。\n2. **TransactionDefinition**：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。\n3. **TransactionStatus**：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。\n\n> Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。\n\n\n<span id=\"id3\"><span>\n### 3. TransactionDefinition接口\nTransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)\n+ 如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。\n+ 事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。\n\n\n#### 3.1 安全问题\n1. 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。\n2. 不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。\n3. 幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。\n\n\n#### 3.2 事务的隔离级别(Isolation)：\n1. **`READ_UNCOMMITED`**(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。\n2. **`READ_COMMITED`**(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。\n3. **`REPEATABLE_READ`**(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。\n4. **`SERIALIZABLE`**(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。\n5. `DEFAULT`(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用`REPEATABLE_READ`隔离级别，Oracle默认采用`READ_COMMITTED`隔离级别）。\n\n\n#### 3.3 事务的传播特性(Propagation)：\n1. 第一类：运行在同一个事务\n    + **`REQUIRED`**：默认，支持当前事务，如果当前没有事务，就新建一个事务。\n    + `SUPPORTS`：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)\n    + `MANDATORY`：支持当前事务，如果当前没有事务，就抛出异常\n2. 第二类：运行在不同事务\n    + **`REQUIRES_NEW`**：新建事务，如果当前存在事务，把当前事务挂起\n    + `NOT_SUPPORTED`：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\n    + `NEVER`：以非事务方式执行，如果当前存在事务，则抛出异常\n3. 第三类：嵌套执行--即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态\n    + **`NESTED`**：如果当前事务存在，则嵌套事务执行\n\n\n\n<span id=\"id4\"><span>\n### 4. TransactionStatus接口\n平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。\n\n\n\n<span id=\"id5\"><span>\n### 5. PlatformTransactionManager接口（事务管理器）\n该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。\n\n\n#### 5.1 Spring支持两种方式事务管理：\n1. 编程式事务管理\n    + 手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）\n2. 声明式事务管理\n    + 基于TransactionProxyFactoryBean的方式（很少使用）\n    + 基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）\n    + 基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加`@Transactional`注解（经常使用）\n\n\n<span id=\"id6\"><span>\n### 6. 基于AspectJ的xml方式的声明式事务管理\n``` xml\n<!-- 配置事务管理器 -->\n<bean id=\"transactionManager\"\n    class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbc连接池对象id\"/>\n</bean>\n<!-- 配置事务的通知（事务的增强） -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>    \n        <!-- propagation:事务传播行为\n            isolation:事务的隔离级别\n            read-only:只读\n            rollback-for:发生哪些异常回滚\n            no-rollback-for:发生哪些异常不回滚\n            timeout:过期信息    --> \n        <tx:method name=\"transfer\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" rollback-for=\"\" timeout=\"\" no-rollback-for=\"\"/>\n    </tx:attributes>\n</tx:advice>\n<!-- 配置切面 -->\n<aop:config>\n    <!-- 配置切入点 -->\n    <aop:pointcut id=\"pointcut1\" expression=\"execution(*cn.muke.spring.demo3.AccountService+.*(.))\"/>\n    <!-- 配置切面 -->\n    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/>\n</aop:config>\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 基于注解的声明式事务管理\n1. 配置事务管理器\n``` xml\n<!-- 1.创建一个事务管理器对象 -->\n<bean id=\"事务管理器id\" \nclass=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"jdbc连接池对象id\"/>\n</bean>\n<!-- 2.开启声明式事务 -->\n<tx:annotation-driven transaction-manager=\"事务管理器id\" proxy-target-class=\"true|false\" />\n```\n\n    - **transaction-manager**：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)\n    - **proxy-target-class**：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。\n\n\n2. 使用，在类上或者方法上标注`@Transactional`\n``` java\n@Transactional(\n        rollbackFor={Exception.class}, \n        readOnly=false, \n        isolation=Isolation.DEFAULT,\n        propagation=Propagation.REQUIRED)\npublic void transfer(){..}\n```\n\n    - @Transactional的属性\n        + **rollbackFor**：设置检查异常也回滚\n        + **noRollbackFor**：指定运行时异常不回滚\n        + **readOnly**： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。\n        + **isolation**：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)\n        + **propagation**：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)\n    - Spring中事务管理器默认值针对**运行时异常**回滚，对**检查异常**不回滚。\n\n\n","slug":"16-Spring事务管理","published":1,"updated":"2019-08-27T14:55:34.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo630026yot32cgkhae7","content":"<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">事务的特性(ACID)</a></li>\n<li><a href=\"#id2\">Spring提供事务管理的3个接口</a></li>\n<li><a href=\"#id3\">TransactionDefinition接口</a></li>\n<li><a href=\"#id4\">TransactionStatus接口</a></li>\n<li><a href=\"#id5\">PlatformTransactionManager接口（事务管理器）</a></li>\n<li><a href=\"#id6\">基于AspectJ的xml方式的声明式事务管理</a></li>\n<li><a href=\"#id7\">基于注解的声明式事务管理</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-事务的特性-ACID\"><a href=\"#1-事务的特性-ACID\" class=\"headerlink\" title=\"1. 事务的特性(ACID)\"></a>1. 事务的特性(ACID)</h3><ul>\n<li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li>\n<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>\n<li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li>\n<li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li>\n<li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring提供事务管理的3个接口：\"><a href=\"#2-Spring提供事务管理的3个接口：\" class=\"headerlink\" title=\"2. Spring提供事务管理的3个接口：\"></a>2. Spring提供事务管理的3个接口：</h3><ol>\n<li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li>\n<li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li>\n<li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li>\n</ol>\n<blockquote>\n<p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-TransactionDefinition接口\"><a href=\"#3-TransactionDefinition接口\" class=\"headerlink\" title=\"3. TransactionDefinition接口\"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p>\n<ul>\n<li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li>\n<li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li>\n</ul>\n<h4 id=\"3-1-安全问题\"><a href=\"#3-1-安全问题\" class=\"headerlink\" title=\"3.1 安全问题\"></a>3.1 安全问题</h4><ol>\n<li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li>\n<li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li>\n<li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li>\n</ol>\n<h4 id=\"3-2-事务的隔离级别-Isolation-：\"><a href=\"#3-2-事务的隔离级别-Isolation-：\" class=\"headerlink\" title=\"3.2 事务的隔离级别(Isolation)：\"></a>3.2 事务的隔离级别(Isolation)：</h4><ol>\n<li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li>\n<li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li>\n<li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li>\n<li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li>\n<li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li>\n</ol>\n<h4 id=\"3-3-事务的传播特性-Propagation-：\"><a href=\"#3-3-事务的传播特性-Propagation-：\" class=\"headerlink\" title=\"3.3 事务的传播特性(Propagation)：\"></a>3.3 事务的传播特性(Propagation)：</h4><ol>\n<li>第一类：运行在同一个事务<ul>\n<li><strong><code>REQUIRED</code></strong>：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li>\n<li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li>\n<li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li>\n</ul>\n</li>\n<li>第二类：运行在不同事务<ul>\n<li><strong><code>REQUIRES_NEW</code></strong>：新建事务，如果当前存在事务，把当前事务挂起</li>\n<li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>\n<li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li>\n</ul>\n</li>\n<li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul>\n<li><strong><code>NESTED</code></strong>：如果当前事务存在，则嵌套事务执行</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-TransactionStatus接口\"><a href=\"#4-TransactionStatus接口\" class=\"headerlink\" title=\"4. TransactionStatus接口\"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-PlatformTransactionManager接口（事务管理器）\"><a href=\"#5-PlatformTransactionManager接口（事务管理器）\" class=\"headerlink\" title=\"5. PlatformTransactionManager接口（事务管理器）\"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p>\n<h4 id=\"5-1-Spring支持两种方式事务管理：\"><a href=\"#5-1-Spring支持两种方式事务管理：\" class=\"headerlink\" title=\"5.1 Spring支持两种方式事务管理：\"></a>5.1 Spring支持两种方式事务管理：</h4><ol>\n<li>编程式事务管理<ul>\n<li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li>\n</ul>\n</li>\n<li>声明式事务管理<ul>\n<li>基于TransactionProxyFactoryBean的方式（很少使用）</li>\n<li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li>\n<li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-基于AspectJ的xml方式的声明式事务管理\"><a href=\"#6-基于AspectJ的xml方式的声明式事务管理\" class=\"headerlink\" title=\"6. 基于AspectJ的xml方式的声明式事务管理\"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbc连接池对象id\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span>    </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- propagation:事务传播行为</span></span><br><span class=\"line\"><span class=\"comment\">            isolation:事务的隔离级别</span></span><br><span class=\"line\"><span class=\"comment\">            read-only:只读</span></span><br><span class=\"line\"><span class=\"comment\">            rollback-for:发生哪些异常回滚</span></span><br><span class=\"line\"><span class=\"comment\">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class=\"line\"><span class=\"comment\">            timeout:过期信息    --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transfer\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span> <span class=\"attr\">isolation</span>=<span class=\"string\">\"DEFAULT\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">rollback-for</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">timeout</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">no-rollback-for</span>=<span class=\"string\">\"\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置切面 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置切入点 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pointcut1\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(*cn.muke.spring.demo3.AccountService+.*(.))\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置切面 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"pointcut1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-基于注解的声明式事务管理\"><a href=\"#7-基于注解的声明式事务管理\" class=\"headerlink\" title=\"7. 基于注解的声明式事务管理\"></a>7. 基于注解的声明式事务管理</h3><ol>\n<li><p>配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"事务管理器id\"</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbc连接池对象id\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"事务管理器id\"</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true|false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li>\n<li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>使用，在类上或者方法上标注<code>@Transactional</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(</span><br><span class=\"line\">        rollbackFor=&#123;Exception.class&#125;, </span><br><span class=\"line\">        readOnly=<span class=\"keyword\">false</span>, </span><br><span class=\"line\">        isolation=Isolation.DEFAULT,</span><br><span class=\"line\">        propagation=Propagation.REQUIRED)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">()</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@Transactional的属性<ul>\n<li><strong>rollbackFor</strong>：设置检查异常也回滚</li>\n<li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li>\n<li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li>\n<li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li>\n<li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li>\n</ul>\n</li>\n<li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p>","more":"<ol>\n<li><a href=\"#id1\">事务的特性(ACID)</a></li>\n<li><a href=\"#id2\">Spring提供事务管理的3个接口</a></li>\n<li><a href=\"#id3\">TransactionDefinition接口</a></li>\n<li><a href=\"#id4\">TransactionStatus接口</a></li>\n<li><a href=\"#id5\">PlatformTransactionManager接口（事务管理器）</a></li>\n<li><a href=\"#id6\">基于AspectJ的xml方式的声明式事务管理</a></li>\n<li><a href=\"#id7\">基于注解的声明式事务管理</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-事务的特性-ACID\"><a href=\"#1-事务的特性-ACID\" class=\"headerlink\" title=\"1. 事务的特性(ACID)\"></a>1. 事务的特性(ACID)</h3><ul>\n<li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li>\n<li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li>\n<li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li>\n<li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li>\n<li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring提供事务管理的3个接口：\"><a href=\"#2-Spring提供事务管理的3个接口：\" class=\"headerlink\" title=\"2. Spring提供事务管理的3个接口：\"></a>2. Spring提供事务管理的3个接口：</h3><ol>\n<li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li>\n<li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li>\n<li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li>\n</ol>\n<blockquote>\n<p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-TransactionDefinition接口\"><a href=\"#3-TransactionDefinition接口\" class=\"headerlink\" title=\"3. TransactionDefinition接口\"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p>\n<ul>\n<li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li>\n<li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li>\n</ul>\n<h4 id=\"3-1-安全问题\"><a href=\"#3-1-安全问题\" class=\"headerlink\" title=\"3.1 安全问题\"></a>3.1 安全问题</h4><ol>\n<li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li>\n<li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li>\n<li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li>\n</ol>\n<h4 id=\"3-2-事务的隔离级别-Isolation-：\"><a href=\"#3-2-事务的隔离级别-Isolation-：\" class=\"headerlink\" title=\"3.2 事务的隔离级别(Isolation)：\"></a>3.2 事务的隔离级别(Isolation)：</h4><ol>\n<li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li>\n<li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li>\n<li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li>\n<li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li>\n<li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li>\n</ol>\n<h4 id=\"3-3-事务的传播特性-Propagation-：\"><a href=\"#3-3-事务的传播特性-Propagation-：\" class=\"headerlink\" title=\"3.3 事务的传播特性(Propagation)：\"></a>3.3 事务的传播特性(Propagation)：</h4><ol>\n<li>第一类：运行在同一个事务<ul>\n<li><strong><code>REQUIRED</code></strong>：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li>\n<li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li>\n<li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li>\n</ul>\n</li>\n<li>第二类：运行在不同事务<ul>\n<li><strong><code>REQUIRES_NEW</code></strong>：新建事务，如果当前存在事务，把当前事务挂起</li>\n<li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>\n<li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li>\n</ul>\n</li>\n<li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul>\n<li><strong><code>NESTED</code></strong>：如果当前事务存在，则嵌套事务执行</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-TransactionStatus接口\"><a href=\"#4-TransactionStatus接口\" class=\"headerlink\" title=\"4. TransactionStatus接口\"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-PlatformTransactionManager接口（事务管理器）\"><a href=\"#5-PlatformTransactionManager接口（事务管理器）\" class=\"headerlink\" title=\"5. PlatformTransactionManager接口（事务管理器）\"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p>\n<h4 id=\"5-1-Spring支持两种方式事务管理：\"><a href=\"#5-1-Spring支持两种方式事务管理：\" class=\"headerlink\" title=\"5.1 Spring支持两种方式事务管理：\"></a>5.1 Spring支持两种方式事务管理：</h4><ol>\n<li>编程式事务管理<ul>\n<li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li>\n</ul>\n</li>\n<li>声明式事务管理<ul>\n<li>基于TransactionProxyFactoryBean的方式（很少使用）</li>\n<li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li>\n<li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-基于AspectJ的xml方式的声明式事务管理\"><a href=\"#6-基于AspectJ的xml方式的声明式事务管理\" class=\"headerlink\" title=\"6. 基于AspectJ的xml方式的声明式事务管理\"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbc连接池对象id\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span>    </span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- propagation:事务传播行为</span></span><br><span class=\"line\"><span class=\"comment\">            isolation:事务的隔离级别</span></span><br><span class=\"line\"><span class=\"comment\">            read-only:只读</span></span><br><span class=\"line\"><span class=\"comment\">            rollback-for:发生哪些异常回滚</span></span><br><span class=\"line\"><span class=\"comment\">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class=\"line\"><span class=\"comment\">            timeout:过期信息    --&gt;</span> </span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"transfer\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span> <span class=\"attr\">isolation</span>=<span class=\"string\">\"DEFAULT\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"false\"</span> <span class=\"attr\">rollback-for</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">timeout</span>=<span class=\"string\">\"\"</span> <span class=\"attr\">no-rollback-for</span>=<span class=\"string\">\"\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置切面 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置切入点 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pointcut1\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(*cn.muke.spring.demo3.AccountService+.*(.))\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置切面 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"txAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"pointcut1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-基于注解的声明式事务管理\"><a href=\"#7-基于注解的声明式事务管理\" class=\"headerlink\" title=\"7. 基于注解的声明式事务管理\"></a>7. 基于注解的声明式事务管理</h3><ol>\n<li><p>配置事务管理器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"事务管理器id\"</span> </span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbc连接池对象id\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"事务管理器id\"</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true|false\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li>\n<li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>使用，在类上或者方法上标注<code>@Transactional</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(</span><br><span class=\"line\">        rollbackFor=&#123;Exception.class&#125;, </span><br><span class=\"line\">        readOnly=<span class=\"keyword\">false</span>, </span><br><span class=\"line\">        isolation=Isolation.DEFAULT,</span><br><span class=\"line\">        propagation=Propagation.REQUIRED)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">()</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@Transactional的属性<ul>\n<li><strong>rollbackFor</strong>：设置检查异常也回滚</li>\n<li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li>\n<li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li>\n<li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li>\n<li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li>\n</ul>\n</li>\n<li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li>\n</ul>\n</li>\n</ol>"},{"title":"十九、Java持久层框架Mybatis","date":"2019-08-27T14:51:34.000Z","_content":"\nMybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射--以面向对象思想访问数据库)，是一个基于Java的持久层框架。\n<!-- more -->\nMyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。\n\n1. [Mybatis框架的构成](#id1)\n2. [使用Mybatis访问数据库](#id2)\n3. [Mybatis的CRUD操作](#id3)\n4. [Mapper映射器](#id4)\n5. [向mapper传多个参数](#id5)\n6. [结果集列名和属性名不一致的解决方法](#id6)\n7. [类型的别名和日志输出](#id7)\n8. [JdbcType](#id8)\n\n\n<span id=\"id1\"><span> \n### 1. Mybatis框架的构成\n- 实体类 ： 封装记录信息（JavaBean）\n- SQL定义文件 ：定义sql语句（编写SQL语句的XML）\n- 主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML\n- 框架API ：用于实现数据库增删改查操作（主要通过SqlSession）\n\n\n<span id=\"id2\"><span>\n### 2. 使用Mybatis访问数据库\n以员工表`Emp(id,name,salary)`为例\n1. 准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）\n2. 根据表建立对应的实体类：`Emp(id,name,salary)`\n3. 在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等\n``` xml\n<configuration>\n    <environments default=\"environment\">\n        <environment id=\"environment\">\n            <transactionManager type=\"JDBC\" />\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" \n                    value=\"com.mysql.cj.jdbc.Driver\" />\n                <property name=\"url\"\n                    value=\"jdbc:mysql://localhost:3306/test\"/>\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"123456\" />\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/mapper/EmpMapper.xml\" />\n    </mappers>\n</configuration> \n```\n\n4. 在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql\n``` xml\n<mapper namespace=\"com.mapper.EmpMapper\">\n    <!-- 定义SQL语句 -->\t\n    <select id=\"findById\" parameterType=\"int\" \n      resultType=\"com.mapper.Emp\">\n         select * from emp32 where id = #{id}\n    </select>\n    <select id=\"findByName\" parameterType=\"String\" \n      resultType=\"com.mapper.Emp\">\n         select * from emp32 where name = #{name}\n    </select>\n</mapper>\n```\n> - parameterType：要求输入参数的类型\n> - resultType：输出的类型\n\n5. 封装工具类获取SQLSession\n``` java\npublic class SqlSessionUtil {\n    public static SqlSessionFactory ssf;\n    static {\n        // 先构建SQLSession工厂构建器\n        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n        // 构建SqlSessionFactory关联主配置文件\n        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(\"mybatis-config.xml\");\n        ssf = ssfb.build(inputStream);\n    }\n     // 获取SQLSession\n    public static SqlSession getSqlSession() {\n        // 通过SqlSession 工厂对象 来获取SqlSession\n        return ssf.openSession();\n    }\n}\n```\n\n6. 编写测试类\n``` java\npublic class EmpTest {\n    public static void main(String[] args) {\n        SqlSession ss =SqlSessionUtil.getSqlSession();\n        Emp emp = ss.selectOne(\"findById\", 6);\n        System.out.println(emp);\n    }\n}\n```\n\n> 基本原理\n- 应用程序找 MyBatis 要数据\n- MyBatis 从数据库中找来数据\n- 通过 mybatis-config.xml 定位哪个数据库\n- 通过 EmpMapper.xml 执行对应的 sql 语句\n- 基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中\n- 返回一个 Emp 对象\n\n\n<span id=\"id3\"><span>\n### 3. Mybatis的CRUD操作\n以员工表`Emp(id,name,salary)`为例\n1. 第一步：配置EmpMapper.xml\n\n``` xml\n<insert id=\"insertEmp\" parameterType=\"com.mapper.Emp\">\n    insert into emp32(name, salary) values(#{name}, #{salary})\n</insert>\n<delete id=\"deleteEmpById\" parameterType=\"int\">\n    delete from emp32 where id=#{id}\n</delete>\n<update id=\"updateEmpById\" parameterType=\"com.mapper.Emp\">\n    update emp32 set name=#{name} where id=#{id}\n</update>\n<select id=\"findById\" parameterType=\"int\" resultType=\"com.mapper.Emp\">\n     select * from emp32 where id = #{id}\n</select>\n<select id=\"findAll\" resultType=\"com.mapper.Emp\">\n    select * from emp32\n</select>\n```\n> - parameterType：要求输入参数的类型\n> - resultType：输出的类型\n\n\n2. 第二步：SQLSession实现增删改查\n\n``` java\n// 先构建SQLSession工厂构建器\nSqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n// 构建SqlSessionFactory关联主配置文件\nInputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(\"sqlmap-config.xml\");\nSqlSessionFactory ssf = ssfb.build(inputStream);\n// 通过SqlSession 工厂对象 来获取SqlSession\nSqlSession ss = ssf.openSession();\n\n//增加\nEmp emp = new Emp(0,\"ef2\",50000);\nint addRows = ss.insert(\"insertEmp\", emp);\n//删除\nint delRows = ss.delete(\"deleteEmpById\", 12);\n//更新\nEmp emp2 = new Emp(1,\"hello\",0);\nint updateRows = ss.update(\"updateEmpById\", emp2);\n//查找\nEmp emp3 = ss.selectOne(\"findById\", 6);\nList<Emp> empList = ss.selectList(\"findAll\");\n\nss.commit();\n```\n> SqlSession对象的操作方法如下：\n- insert(..) 插入操作\n- update(..) 更新操作\n- delete(..) 删除操作\n- selectOne(..) 单行查询操作\n- selectList(..) 多行查询操作\n- 通过 session.commit() 来提交事务，也可以简单理解为更新到数据库\n\n\n<span id=\"id4\"><span>\n### 4. Mapper映射器\n使用规则：\n1. 接口的方法名和SQL定义文件中的id保持一致\n2. 接口方法的返回值类型 要和resultType 保持一致\n    - 单行：`resultType`\n    - 多行：`List<resultType>`\n    - 增删改返回值，推荐int，也可以是void\n3. 接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意\n4. SQL定义文件中的namespace必须包名.接口名\n\n\n<span id=\"id5\"><span>\n### 5. 向mapper传多个参数\n#### 5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}\nDAO层的函数方法 \n``` java\npublic Emp findByIdAndName(int id, String name);\n```\n\n对应的Mapper.xml\n``` xml  \n<select id=\"findByIdAndName\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{0} and name = #{1}\n</select>\n```\n其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。\n也可以用#{param1} 和 #{param2}实现同意效果。\n\n\n#### 5.2 第二种方案@param\nDao层的函数方法\n``` java\npublic Emp findByIdAndName(@param(\"id\")int id, @param(\"name\")String name);\n```\n\n对应的Mapper.xml\n``` xml\n<select id=\"findByIdAndName\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n```\n\n\n#### 5.3 第三种方案：采用对象或Map传多参数\nDao层的函数方法\n``` java\npublic Emp findByIdAndName(Emp emp);\npublic Emp findByIdAndName2(Map<String, Object> params);\n```\n\n对应的Mapper.xml\n``` xml\n<select id=\"findByIdAndName\" parameterType=\"com.bean.Emp\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n\n<select id=\"findByIdAndName2\" parameterType=\"map\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n```\n\n\n\n<span id=\"id6\"><span>\n### 6. 结果集列名和属性名不一致的解决方法\n在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。\n解决方法：\n1. 使用别名，select语句使用与属性一致的别名\n2. 使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系\n\n``` xml\n<!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系\n    type:resultMap最终所映射的Java对象类型，可以使用别名\n    id:对resultMap的唯一标识 \n-->\n<resultMap type=\"com.bean.Emp\" id=\"empMap\">\n    <!-- id表示查询结果集中唯一标识 \n        column:查询出的列名\n        property:type所指定的类中的属性名 \n    -->\n    <id column=\"e_id\" property=\"id\"/>\n    <!-- 对普通列的映射定义 -->\n    <result  column=\"salary\"  property=\"sal\"/>\n</resultMap>\n\n<!-- 使用resultMap -->\n<select id=\"findEmpById\" parameterType=\"int\" resultMap=\"empMap\">\n         select * from  emp32 where id = #{id}\n</select>\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 类型的别名和日志输出\n在mybatis-config.xml中自定义类型的别名\n``` xml\n<typeAliases>\n    <typeAlias alias=\"emp\" type=\"com.bean.Emp\"/>\n</typeAliases>\n```\n\n在EmpMapper.xml中使用别名 resultType=\"emp\"\n``` xml\n<select id=\"findById\" parameterType=\"int\" resultType=\"emp\">\n    select id,name,salary sal from emp32 where id = #{id}\n</select>\n```\n\n\n设置MyBatis的日志输出到控制台\n``` xml\n<settings>\n    <!--设置是否允许缓存-->\n    <setting name=\"cacheEnabled\" value=\"true\"/>\n    <!--设置日志输出的目标-->\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. JdbcType\n在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。\n- 所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。\n- 一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。\n- MyBatis包含的JdbcType类型，主要有下面这些：\n    + BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR\n\n``` xml\n<select id=\"findByName\" parameterType=\"String\" resultType=\"com.bean.Emp\">\n    select * from emp32 where name = #{name, jdbcType=VARCHAR}\n</select>\n```\n\n\n<span id=\"id9\"><span>\n### 9. Mabatis中#{}和${}的区别\n1. `${}`是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）\n    - 支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号\n2. `#{}`是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）\n    - 不支持表名、排序方式等的占位，默认会将其当成字符串\n\n\n\n### 10. 分页\n1. 在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）\n\n``` xml\n<!-- 配置分页拦截器 -->\n<plugins>\n    <plugin interceptor=\"com.github.pagehelper.PageHelper\"></plugin>\n</plugins>\n```\n\n2. 查询前使用分页API\n\n``` xml\nPageHelper.startPage(2, 2);\nList<Emp> emps = dao.orderBySalary();\nfor(Emp emp: emps) {\n    System.out.println(emp);\n}\n```\n\n\n\n### 11. Spring+MyBatis整合\nSpring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:\n1. SqlSessionFactoryBean\n    + 创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源\n    + 依赖于dataSource 和加载SQL定义文件\n2. MapperFactoryBean\n    + 根据指定的某一个Mapper接口生成Bean实例\n    + 依赖于SqlSessionFactory 和 MApper接口\n3. MapperScannerConfigurer\n    + 根据指定包批量扫描Mapper接口并生成实例\n4. SqlSessionTemplate\n    + 类似于JdbcTemplate，便于程序员自己编写Mapper实现类\n\n### 12. Spring+MyBatis完成sql操作\n**第一步**：使用Mybatis（同上）\n+ 导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口\n\n**第二步**：配置SqlSessionFactoryBean\n+ 导入jar包（mabatis-spring/ioc/aop/dao/连接池）\n+ 配置SqlSessionFactoryBean注入dataSource和指定sql定义文件\n\n``` xml\n<!-- 配置SqlSessionFactory -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <property name=\"mapperLocations\" value=\"classpath:com/mapper/*.xml\"></property>\n</bean>\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n```\n\n**第三步**：\n1. 方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory\n    + 最终产生Mapper接口的 实现类，注意这是实现类\n\n``` xml\n<!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  -->\n<bean id=\"empDao\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\">\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    <property name=\"mapperInterface\" value=\"com.dao.EmpDao\"></property>\n</bean>\n<bean id=\"empDao2\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\">\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    <property name=\"mapperInterface\" value=\"com.dao.EmpDao2\"></property>\n</bean> \n```\n\n2. 方式二： MapperScannerConfigurer\n    + MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类\n\n``` xml\n<!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 -->\n<bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property> -->\n    <property name=\"basePackage\" value=\"com.dao\"></property>\n    <!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 -->\n    <property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"></property>\n</bean>\n```\n\n### 13. 使用SqlSessionTemplate模板来完成DAO接口的实现类\n1. 使用Mybatis（同上）\n2. 配置SqlSessionFactoryBean（同上）\n3. 编写DAO接口的实现类\n    + 开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory\n    + 使用SqlSessionTemplate对应API完成增删改查\n\n``` xml\n<!-- 开启组件扫描 -->\n<context:component-scan base-package=\"com.mapper\"></context:component-scan>\n<!-- 创建SqlSessionTemplate -->\n<bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n    <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"></constructor-arg>\n</bean>\n```\n\n``` java\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private SqlSessionTemplate sqlSessionTemplate;\n    @Override\n    public Emp findById(int id) {\n        return sqlSessionTemplate.selectOne(\"findById\", id);\n    }\n}\n```","source":"_posts/19-Java持久层框架Mybatis.md","raw":"---\ntitle: 十九、Java持久层框架Mybatis\ndate: 2019-08-27 22:51:34\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nMybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射--以面向对象思想访问数据库)，是一个基于Java的持久层框架。\n<!-- more -->\nMyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。\n\n1. [Mybatis框架的构成](#id1)\n2. [使用Mybatis访问数据库](#id2)\n3. [Mybatis的CRUD操作](#id3)\n4. [Mapper映射器](#id4)\n5. [向mapper传多个参数](#id5)\n6. [结果集列名和属性名不一致的解决方法](#id6)\n7. [类型的别名和日志输出](#id7)\n8. [JdbcType](#id8)\n\n\n<span id=\"id1\"><span> \n### 1. Mybatis框架的构成\n- 实体类 ： 封装记录信息（JavaBean）\n- SQL定义文件 ：定义sql语句（编写SQL语句的XML）\n- 主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML\n- 框架API ：用于实现数据库增删改查操作（主要通过SqlSession）\n\n\n<span id=\"id2\"><span>\n### 2. 使用Mybatis访问数据库\n以员工表`Emp(id,name,salary)`为例\n1. 准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）\n2. 根据表建立对应的实体类：`Emp(id,name,salary)`\n3. 在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等\n``` xml\n<configuration>\n    <environments default=\"environment\">\n        <environment id=\"environment\">\n            <transactionManager type=\"JDBC\" />\n            <dataSource type=\"POOLED\">\n                <property name=\"driver\" \n                    value=\"com.mysql.cj.jdbc.Driver\" />\n                <property name=\"url\"\n                    value=\"jdbc:mysql://localhost:3306/test\"/>\n                <property name=\"username\" value=\"root\" />\n                <property name=\"password\" value=\"123456\" />\n            </dataSource>\n        </environment>\n    </environments>\n    <mappers>\n        <mapper resource=\"com/mapper/EmpMapper.xml\" />\n    </mappers>\n</configuration> \n```\n\n4. 在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql\n``` xml\n<mapper namespace=\"com.mapper.EmpMapper\">\n    <!-- 定义SQL语句 -->\t\n    <select id=\"findById\" parameterType=\"int\" \n      resultType=\"com.mapper.Emp\">\n         select * from emp32 where id = #{id}\n    </select>\n    <select id=\"findByName\" parameterType=\"String\" \n      resultType=\"com.mapper.Emp\">\n         select * from emp32 where name = #{name}\n    </select>\n</mapper>\n```\n> - parameterType：要求输入参数的类型\n> - resultType：输出的类型\n\n5. 封装工具类获取SQLSession\n``` java\npublic class SqlSessionUtil {\n    public static SqlSessionFactory ssf;\n    static {\n        // 先构建SQLSession工厂构建器\n        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n        // 构建SqlSessionFactory关联主配置文件\n        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(\"mybatis-config.xml\");\n        ssf = ssfb.build(inputStream);\n    }\n     // 获取SQLSession\n    public static SqlSession getSqlSession() {\n        // 通过SqlSession 工厂对象 来获取SqlSession\n        return ssf.openSession();\n    }\n}\n```\n\n6. 编写测试类\n``` java\npublic class EmpTest {\n    public static void main(String[] args) {\n        SqlSession ss =SqlSessionUtil.getSqlSession();\n        Emp emp = ss.selectOne(\"findById\", 6);\n        System.out.println(emp);\n    }\n}\n```\n\n> 基本原理\n- 应用程序找 MyBatis 要数据\n- MyBatis 从数据库中找来数据\n- 通过 mybatis-config.xml 定位哪个数据库\n- 通过 EmpMapper.xml 执行对应的 sql 语句\n- 基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中\n- 返回一个 Emp 对象\n\n\n<span id=\"id3\"><span>\n### 3. Mybatis的CRUD操作\n以员工表`Emp(id,name,salary)`为例\n1. 第一步：配置EmpMapper.xml\n\n``` xml\n<insert id=\"insertEmp\" parameterType=\"com.mapper.Emp\">\n    insert into emp32(name, salary) values(#{name}, #{salary})\n</insert>\n<delete id=\"deleteEmpById\" parameterType=\"int\">\n    delete from emp32 where id=#{id}\n</delete>\n<update id=\"updateEmpById\" parameterType=\"com.mapper.Emp\">\n    update emp32 set name=#{name} where id=#{id}\n</update>\n<select id=\"findById\" parameterType=\"int\" resultType=\"com.mapper.Emp\">\n     select * from emp32 where id = #{id}\n</select>\n<select id=\"findAll\" resultType=\"com.mapper.Emp\">\n    select * from emp32\n</select>\n```\n> - parameterType：要求输入参数的类型\n> - resultType：输出的类型\n\n\n2. 第二步：SQLSession实现增删改查\n\n``` java\n// 先构建SQLSession工厂构建器\nSqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();\n// 构建SqlSessionFactory关联主配置文件\nInputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(\"sqlmap-config.xml\");\nSqlSessionFactory ssf = ssfb.build(inputStream);\n// 通过SqlSession 工厂对象 来获取SqlSession\nSqlSession ss = ssf.openSession();\n\n//增加\nEmp emp = new Emp(0,\"ef2\",50000);\nint addRows = ss.insert(\"insertEmp\", emp);\n//删除\nint delRows = ss.delete(\"deleteEmpById\", 12);\n//更新\nEmp emp2 = new Emp(1,\"hello\",0);\nint updateRows = ss.update(\"updateEmpById\", emp2);\n//查找\nEmp emp3 = ss.selectOne(\"findById\", 6);\nList<Emp> empList = ss.selectList(\"findAll\");\n\nss.commit();\n```\n> SqlSession对象的操作方法如下：\n- insert(..) 插入操作\n- update(..) 更新操作\n- delete(..) 删除操作\n- selectOne(..) 单行查询操作\n- selectList(..) 多行查询操作\n- 通过 session.commit() 来提交事务，也可以简单理解为更新到数据库\n\n\n<span id=\"id4\"><span>\n### 4. Mapper映射器\n使用规则：\n1. 接口的方法名和SQL定义文件中的id保持一致\n2. 接口方法的返回值类型 要和resultType 保持一致\n    - 单行：`resultType`\n    - 多行：`List<resultType>`\n    - 增删改返回值，推荐int，也可以是void\n3. 接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意\n4. SQL定义文件中的namespace必须包名.接口名\n\n\n<span id=\"id5\"><span>\n### 5. 向mapper传多个参数\n#### 5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}\nDAO层的函数方法 \n``` java\npublic Emp findByIdAndName(int id, String name);\n```\n\n对应的Mapper.xml\n``` xml  \n<select id=\"findByIdAndName\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{0} and name = #{1}\n</select>\n```\n其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。\n也可以用#{param1} 和 #{param2}实现同意效果。\n\n\n#### 5.2 第二种方案@param\nDao层的函数方法\n``` java\npublic Emp findByIdAndName(@param(\"id\")int id, @param(\"name\")String name);\n```\n\n对应的Mapper.xml\n``` xml\n<select id=\"findByIdAndName\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n```\n\n\n#### 5.3 第三种方案：采用对象或Map传多参数\nDao层的函数方法\n``` java\npublic Emp findByIdAndName(Emp emp);\npublic Emp findByIdAndName2(Map<String, Object> params);\n```\n\n对应的Mapper.xml\n``` xml\n<select id=\"findByIdAndName\" parameterType=\"com.bean.Emp\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n\n<select id=\"findByIdAndName2\" parameterType=\"map\" resultType=\"com.bean.Emp\">\n    select * from emp32 where id = #{id} and name = #{name}\n</select>\n```\n\n\n\n<span id=\"id6\"><span>\n### 6. 结果集列名和属性名不一致的解决方法\n在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。\n解决方法：\n1. 使用别名，select语句使用与属性一致的别名\n2. 使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系\n\n``` xml\n<!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系\n    type:resultMap最终所映射的Java对象类型，可以使用别名\n    id:对resultMap的唯一标识 \n-->\n<resultMap type=\"com.bean.Emp\" id=\"empMap\">\n    <!-- id表示查询结果集中唯一标识 \n        column:查询出的列名\n        property:type所指定的类中的属性名 \n    -->\n    <id column=\"e_id\" property=\"id\"/>\n    <!-- 对普通列的映射定义 -->\n    <result  column=\"salary\"  property=\"sal\"/>\n</resultMap>\n\n<!-- 使用resultMap -->\n<select id=\"findEmpById\" parameterType=\"int\" resultMap=\"empMap\">\n         select * from  emp32 where id = #{id}\n</select>\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 类型的别名和日志输出\n在mybatis-config.xml中自定义类型的别名\n``` xml\n<typeAliases>\n    <typeAlias alias=\"emp\" type=\"com.bean.Emp\"/>\n</typeAliases>\n```\n\n在EmpMapper.xml中使用别名 resultType=\"emp\"\n``` xml\n<select id=\"findById\" parameterType=\"int\" resultType=\"emp\">\n    select id,name,salary sal from emp32 where id = #{id}\n</select>\n```\n\n\n设置MyBatis的日志输出到控制台\n``` xml\n<settings>\n    <!--设置是否允许缓存-->\n    <setting name=\"cacheEnabled\" value=\"true\"/>\n    <!--设置日志输出的目标-->\n    <setting name=\"logImpl\" value=\"STDOUT_LOGGING\"/>\n</settings>\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. JdbcType\n在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。\n- 所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。\n- 一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。\n- MyBatis包含的JdbcType类型，主要有下面这些：\n    + BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR\n\n``` xml\n<select id=\"findByName\" parameterType=\"String\" resultType=\"com.bean.Emp\">\n    select * from emp32 where name = #{name, jdbcType=VARCHAR}\n</select>\n```\n\n\n<span id=\"id9\"><span>\n### 9. Mabatis中#{}和${}的区别\n1. `${}`是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）\n    - 支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号\n2. `#{}`是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）\n    - 不支持表名、排序方式等的占位，默认会将其当成字符串\n\n\n\n### 10. 分页\n1. 在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）\n\n``` xml\n<!-- 配置分页拦截器 -->\n<plugins>\n    <plugin interceptor=\"com.github.pagehelper.PageHelper\"></plugin>\n</plugins>\n```\n\n2. 查询前使用分页API\n\n``` xml\nPageHelper.startPage(2, 2);\nList<Emp> emps = dao.orderBySalary();\nfor(Emp emp: emps) {\n    System.out.println(emp);\n}\n```\n\n\n\n### 11. Spring+MyBatis整合\nSpring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:\n1. SqlSessionFactoryBean\n    + 创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源\n    + 依赖于dataSource 和加载SQL定义文件\n2. MapperFactoryBean\n    + 根据指定的某一个Mapper接口生成Bean实例\n    + 依赖于SqlSessionFactory 和 MApper接口\n3. MapperScannerConfigurer\n    + 根据指定包批量扫描Mapper接口并生成实例\n4. SqlSessionTemplate\n    + 类似于JdbcTemplate，便于程序员自己编写Mapper实现类\n\n### 12. Spring+MyBatis完成sql操作\n**第一步**：使用Mybatis（同上）\n+ 导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口\n\n**第二步**：配置SqlSessionFactoryBean\n+ 导入jar包（mabatis-spring/ioc/aop/dao/连接池）\n+ 配置SqlSessionFactoryBean注入dataSource和指定sql定义文件\n\n``` xml\n<!-- 配置SqlSessionFactory -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <property name=\"mapperLocations\" value=\"classpath:com/mapper/*.xml\"></property>\n</bean>\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n```\n\n**第三步**：\n1. 方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory\n    + 最终产生Mapper接口的 实现类，注意这是实现类\n\n``` xml\n<!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  -->\n<bean id=\"empDao\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\">\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    <property name=\"mapperInterface\" value=\"com.dao.EmpDao\"></property>\n</bean>\n<bean id=\"empDao2\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\">\n    <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property>\n    <property name=\"mapperInterface\" value=\"com.dao.EmpDao2\"></property>\n</bean> \n```\n\n2. 方式二： MapperScannerConfigurer\n    + MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类\n\n``` xml\n<!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 -->\n<bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property> -->\n    <property name=\"basePackage\" value=\"com.dao\"></property>\n    <!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 -->\n    <property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"></property>\n</bean>\n```\n\n### 13. 使用SqlSessionTemplate模板来完成DAO接口的实现类\n1. 使用Mybatis（同上）\n2. 配置SqlSessionFactoryBean（同上）\n3. 编写DAO接口的实现类\n    + 开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory\n    + 使用SqlSessionTemplate对应API完成增删改查\n\n``` xml\n<!-- 开启组件扫描 -->\n<context:component-scan base-package=\"com.mapper\"></context:component-scan>\n<!-- 创建SqlSessionTemplate -->\n<bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n    <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"></constructor-arg>\n</bean>\n```\n\n``` java\n@Repository(\"empDao\")\npublic class EmpDaoImpl implements EmpDao {\n    @Autowired\n    private SqlSessionTemplate sqlSessionTemplate;\n    @Override\n    public Emp findById(int id) {\n        return sqlSessionTemplate.selectOne(\"findById\", id);\n    }\n}\n```","slug":"19-Java持久层框架Mybatis","published":1,"updated":"2019-08-27T14:55:08.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo650029yot3mq6l7gqq","content":"<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p>\n<a id=\"more\"></a>\n<p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p>\n<ol>\n<li><a href=\"#id1\">Mybatis框架的构成</a></li>\n<li><a href=\"#id2\">使用Mybatis访问数据库</a></li>\n<li><a href=\"#id3\">Mybatis的CRUD操作</a></li>\n<li><a href=\"#id4\">Mapper映射器</a></li>\n<li><a href=\"#id5\">向mapper传多个参数</a></li>\n<li><a href=\"#id6\">结果集列名和属性名不一致的解决方法</a></li>\n<li><a href=\"#id7\">类型的别名和日志输出</a></li>\n<li><a href=\"#id8\">JdbcType</a></li>\n</ol>\n<p><span id=\"id1\"><span> </span></span></p>\n<h3 id=\"1-Mybatis框架的构成\"><a href=\"#1-Mybatis框架的构成\" class=\"headerlink\" title=\"1. Mybatis框架的构成\"></a>1. Mybatis框架的构成</h3><ul>\n<li>实体类 ： 封装记录信息（JavaBean）</li>\n<li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li>\n<li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li>\n<li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-使用Mybatis访问数据库\"><a href=\"#2-使用Mybatis访问数据库\" class=\"headerlink\" title=\"2. 使用Mybatis访问数据库\"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>\n<ol>\n<li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p>\n</li>\n<li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p>\n</li>\n<li><p>在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"environment\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"environment\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/mapper/EmpMapper.xml\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.mapper.EmpMapper\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义SQL语句 --&gt;</span>\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">         select * from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"String\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">         select * from emp32 where name = #&#123;name&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>parameterType：要求输入参数的类型</li>\n<li>resultType：输出的类型</li>\n</ul>\n</blockquote>\n<ol start=\"5\">\n<li><p>封装工具类获取SQLSession</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlSessionUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SqlSessionFactory ssf;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先构建SQLSession工厂构建器</span></span><br><span class=\"line\">        SqlSessionFactoryBuilder ssfb = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder();</span><br><span class=\"line\">        <span class=\"comment\">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class=\"line\">        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class=\"string\">\"mybatis-config.xml\"</span>);</span><br><span class=\"line\">        ssf = ssfb.build(inputStream);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 获取SQLSession</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SqlSession <span class=\"title\">getSqlSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ssf.openSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SqlSession ss =SqlSessionUtil.getSqlSession();</span><br><span class=\"line\">        Emp emp = ss.selectOne(<span class=\"string\">\"findById\"</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">        System.out.println(emp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>基本原理</p>\n<ul>\n<li>应用程序找 MyBatis 要数据</li>\n<li>MyBatis 从数据库中找来数据</li>\n<li>通过 mybatis-config.xml 定位哪个数据库</li>\n<li>通过 EmpMapper.xml 执行对应的 sql 语句</li>\n<li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li>\n<li>返回一个 Emp 对象</li>\n</ul>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Mybatis的CRUD操作\"><a href=\"#3-Mybatis的CRUD操作\" class=\"headerlink\" title=\"3. Mybatis的CRUD操作\"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>\n<ol>\n<li>第一步：配置EmpMapper.xml</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">\"insertEmp\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deleteEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span>&gt;</span></span><br><span class=\"line\">    delete from emp32 where id=#&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">delete</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">update</span> <span class=\"attr\">id</span>=<span class=\"string\">\"updateEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">update</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">     select * from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>parameterType：要求输入参数的类型</li>\n<li>resultType：输出的类型</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>第二步：SQLSession实现增删改查</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先构建SQLSession工厂构建器</span></span><br><span class=\"line\">SqlSessionFactoryBuilder ssfb = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder();</span><br><span class=\"line\"><span class=\"comment\">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class=\"line\">InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(<span class=\"string\">\"sqlmap-config.xml\"</span>);</span><br><span class=\"line\">SqlSessionFactory ssf = ssfb.build(inputStream);</span><br><span class=\"line\"><span class=\"comment\">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class=\"line\">SqlSession ss = ssf.openSession();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//增加</span></span><br><span class=\"line\">Emp emp = <span class=\"keyword\">new</span> Emp(<span class=\"number\">0</span>,<span class=\"string\">\"ef2\"</span>,<span class=\"number\">50000</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> addRows = ss.insert(<span class=\"string\">\"insertEmp\"</span>, emp);</span><br><span class=\"line\"><span class=\"comment\">//删除</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> delRows = ss.delete(<span class=\"string\">\"deleteEmpById\"</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//更新</span></span><br><span class=\"line\">Emp emp2 = <span class=\"keyword\">new</span> Emp(<span class=\"number\">1</span>,<span class=\"string\">\"hello\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> updateRows = ss.update(<span class=\"string\">\"updateEmpById\"</span>, emp2);</span><br><span class=\"line\"><span class=\"comment\">//查找</span></span><br><span class=\"line\">Emp emp3 = ss.selectOne(<span class=\"string\">\"findById\"</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">List&lt;Emp&gt; empList = ss.selectList(<span class=\"string\">\"findAll\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ss.commit();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>SqlSession对象的操作方法如下：</p>\n<ul>\n<li>insert(..) 插入操作</li>\n<li>update(..) 更新操作</li>\n<li>delete(..) 删除操作</li>\n<li>selectOne(..) 单行查询操作</li>\n<li>selectList(..) 多行查询操作</li>\n<li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li>\n</ul>\n</blockquote>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Mapper映射器\"><a href=\"#4-Mapper映射器\" class=\"headerlink\" title=\"4. Mapper映射器\"></a>4. Mapper映射器</h3><p>使用规则：</p>\n<ol>\n<li>接口的方法名和SQL定义文件中的id保持一致</li>\n<li>接口方法的返回值类型 要和resultType 保持一致<ul>\n<li>单行：<code>resultType</code></li>\n<li>多行：<code>List&lt;resultType&gt;</code></li>\n<li>增删改返回值，推荐int，也可以是void</li>\n</ul>\n</li>\n<li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li>\n<li>SQL定义文件中的namespace必须包名.接口名</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-向mapper传多个参数\"><a href=\"#5-向mapper传多个参数\" class=\"headerlink\" title=\"5. 向mapper传多个参数\"></a>5. 向mapper传多个参数</h3><h4 id=\"5-1-第一种方案：-0-，-1-param1-和-param2\"><a href=\"#5-1-第一种方案：-0-，-1-param1-和-param2\" class=\"headerlink\" title=\"5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}\"></a>5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p>\n<h4 id=\"5-2-第二种方案-param\"><a href=\"#5-2-第二种方案-param\" class=\"headerlink\" title=\"5.2 第二种方案@param\"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(@param(<span class=\"string\">\"id\"</span>)</span><span class=\"keyword\">int</span> id, @<span class=\"title\">param</span><span class=\"params\">(<span class=\"string\">\"name\"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-第三种方案：采用对象或Map传多参数\"><a href=\"#5-3-第三种方案：采用对象或Map传多参数\" class=\"headerlink\" title=\"5.3 第三种方案：采用对象或Map传多参数\"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(Emp emp)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName2</span><span class=\"params\">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.bean.Emp\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName2\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"map\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-结果集列名和属性名不一致的解决方法\"><a href=\"#6-结果集列名和属性名不一致的解决方法\" class=\"headerlink\" title=\"6. 结果集列名和属性名不一致的解决方法\"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p>\n<ol>\n<li>使用别名，select语句使用与属性一致的别名</li>\n<li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class=\"line\"><span class=\"comment\">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class=\"line\"><span class=\"comment\">    id:对resultMap的唯一标识 </span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">type</span>=<span class=\"string\">\"com.bean.Emp\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empMap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class=\"line\"><span class=\"comment\">        column:查询出的列名</span></span><br><span class=\"line\"><span class=\"comment\">        property:type所指定的类中的属性名 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">\"e_id\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"id\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">result</span>  <span class=\"attr\">column</span>=<span class=\"string\">\"salary\"</span>  <span class=\"attr\">property</span>=<span class=\"string\">\"sal\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用resultMap --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">\"empMap\"</span>&gt;</span></span><br><span class=\"line\">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-类型的别名和日志输出\"><a href=\"#7-类型的别名和日志输出\" class=\"headerlink\" title=\"7. 类型的别名和日志输出\"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAlias</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"emp\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"com.bean.Emp\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在EmpMapper.xml中使用别名 resultType=”emp”</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"emp\"</span>&gt;</span></span><br><span class=\"line\">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置MyBatis的日志输出到控制台</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheEnabled\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"logImpl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"STDOUT_LOGGING\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-JdbcType\"><a href=\"#8-JdbcType\" class=\"headerlink\" title=\"8. JdbcType\"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p>\n<ul>\n<li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li>\n<li>一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li>\n<li>MyBatis包含的JdbcType类型，主要有下面这些：<ul>\n<li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"String\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Mabatis中-和-的区别\"><a href=\"#9-Mabatis中-和-的区别\" class=\"headerlink\" title=\"9. Mabatis中#{}和${}的区别\"></a>9. Mabatis中#{}和${}的区别</h3><ol>\n<li><code>${}</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul>\n<li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li>\n</ul>\n</li>\n<li><code>#{}</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul>\n<li>不支持表名、排序方式等的占位，默认会将其当成字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"10-分页\"><a href=\"#10-分页\" class=\"headerlink\" title=\"10. 分页\"></a>10. 分页</h3><ol>\n<li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugin</span> <span class=\"attr\">interceptor</span>=<span class=\"string\">\"com.github.pagehelper.PageHelper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查询前使用分页API</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PageHelper.startPage(2, 2);</span><br><span class=\"line\">List<span class=\"tag\">&lt;<span class=\"name\">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class=\"line\">for(Emp emp: emps) &#123;</span><br><span class=\"line\">    System.out.println(emp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-Spring-MyBatis整合\"><a href=\"#11-Spring-MyBatis整合\" class=\"headerlink\" title=\"11. Spring+MyBatis整合\"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p>\n<ol>\n<li>SqlSessionFactoryBean<ul>\n<li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li>\n<li>依赖于dataSource 和加载SQL定义文件</li>\n</ul>\n</li>\n<li>MapperFactoryBean<ul>\n<li>根据指定的某一个Mapper接口生成Bean实例</li>\n<li>依赖于SqlSessionFactory 和 MApper接口</li>\n</ul>\n</li>\n<li>MapperScannerConfigurer<ul>\n<li>根据指定包批量扫描Mapper接口并生成实例</li>\n</ul>\n</li>\n<li>SqlSessionTemplate<ul>\n<li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"12-Spring-MyBatis完成sql操作\"><a href=\"#12-Spring-MyBatis完成sql操作\" class=\"headerlink\" title=\"12. Spring+MyBatis完成sql操作\"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p>\n<ul>\n<li>导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li>\n</ul>\n<p><strong>第二步</strong>：配置SqlSessionFactoryBean</p>\n<ul>\n<li>导入jar包（mabatis-spring/ioc/aop/dao/连接池）</li>\n<li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/mapper/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第三步</strong>：</p>\n<ol>\n<li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul>\n<li>最终产生Mapper接口的 实现类，注意这是实现类</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperInterface\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao.EmpDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empDao2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperInterface\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao.EmpDao2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>方式二： MapperScannerConfigurer<ul>\n<li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mapperScanner\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"annotationClass\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.annotation.MyAnnotation\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-使用SqlSessionTemplate模板来完成DAO接口的实现类\"><a href=\"#13-使用SqlSessionTemplate模板来完成DAO接口的实现类\" class=\"headerlink\" title=\"13. 使用SqlSessionTemplate模板来完成DAO接口的实现类\"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol>\n<li>使用Mybatis（同上）</li>\n<li>配置SqlSessionFactoryBean（同上）</li>\n<li>编写DAO接口的实现类<ul>\n<li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li>\n<li>使用SqlSessionTemplate对应API完成增删改查</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.mapper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqlSessionTemplate.selectOne(<span class=\"string\">\"findById\"</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p>","more":"<p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p>\n<ol>\n<li><a href=\"#id1\">Mybatis框架的构成</a></li>\n<li><a href=\"#id2\">使用Mybatis访问数据库</a></li>\n<li><a href=\"#id3\">Mybatis的CRUD操作</a></li>\n<li><a href=\"#id4\">Mapper映射器</a></li>\n<li><a href=\"#id5\">向mapper传多个参数</a></li>\n<li><a href=\"#id6\">结果集列名和属性名不一致的解决方法</a></li>\n<li><a href=\"#id7\">类型的别名和日志输出</a></li>\n<li><a href=\"#id8\">JdbcType</a></li>\n</ol>\n<p><span id=\"id1\"><span> </span></span></p>\n<h3 id=\"1-Mybatis框架的构成\"><a href=\"#1-Mybatis框架的构成\" class=\"headerlink\" title=\"1. Mybatis框架的构成\"></a>1. Mybatis框架的构成</h3><ul>\n<li>实体类 ： 封装记录信息（JavaBean）</li>\n<li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li>\n<li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li>\n<li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-使用Mybatis访问数据库\"><a href=\"#2-使用Mybatis访问数据库\" class=\"headerlink\" title=\"2. 使用Mybatis访问数据库\"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>\n<ol>\n<li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p>\n</li>\n<li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p>\n</li>\n<li><p>在【src】目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">environments</span> <span class=\"attr\">default</span>=<span class=\"string\">\"environment\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">environment</span> <span class=\"attr\">id</span>=<span class=\"string\">\"environment\"</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">transactionManager</span> <span class=\"attr\">type</span>=<span class=\"string\">\"JDBC\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">type</span>=<span class=\"string\">\"POOLED\"</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driver\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span></span></span><br><span class=\"line\"><span class=\"tag\">                    <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span> /&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span> /&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dataSource</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">environment</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">environments</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">resource</span>=<span class=\"string\">\"com/mapper/EmpMapper.xml\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mappers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在【src】包路径下创建配置文件（com/mapper/EmpMapper.xml）,然后根据需求定义sql</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.mapper.EmpMapper\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义SQL语句 --&gt;</span>\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">         select * from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"String\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">         select * from emp32 where name = #&#123;name&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<ul>\n<li>parameterType：要求输入参数的类型</li>\n<li>resultType：输出的类型</li>\n</ul>\n</blockquote>\n<ol start=\"5\">\n<li><p>封装工具类获取SQLSession</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlSessionUtil</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SqlSessionFactory ssf;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先构建SQLSession工厂构建器</span></span><br><span class=\"line\">        SqlSessionFactoryBuilder ssfb = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder();</span><br><span class=\"line\">        <span class=\"comment\">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class=\"line\">        InputStream inputStream = SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class=\"string\">\"mybatis-config.xml\"</span>);</span><br><span class=\"line\">        ssf = ssfb.build(inputStream);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 获取SQLSession</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SqlSession <span class=\"title\">getSqlSession</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ssf.openSession();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写测试类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SqlSession ss =SqlSessionUtil.getSqlSession();</span><br><span class=\"line\">        Emp emp = ss.selectOne(<span class=\"string\">\"findById\"</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">        System.out.println(emp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>基本原理</p>\n<ul>\n<li>应用程序找 MyBatis 要数据</li>\n<li>MyBatis 从数据库中找来数据</li>\n<li>通过 mybatis-config.xml 定位哪个数据库</li>\n<li>通过 EmpMapper.xml 执行对应的 sql 语句</li>\n<li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li>\n<li>返回一个 Emp 对象</li>\n</ul>\n</blockquote>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Mybatis的CRUD操作\"><a href=\"#3-Mybatis的CRUD操作\" class=\"headerlink\" title=\"3. Mybatis的CRUD操作\"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p>\n<ol>\n<li>第一步：配置EmpMapper.xml</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">\"insertEmp\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">delete</span> <span class=\"attr\">id</span>=<span class=\"string\">\"deleteEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span>&gt;</span></span><br><span class=\"line\">    delete from emp32 where id=#&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">delete</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">update</span> <span class=\"attr\">id</span>=<span class=\"string\">\"updateEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">update</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">     select * from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findAll\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.mapper.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>parameterType：要求输入参数的类型</li>\n<li>resultType：输出的类型</li>\n</ul>\n</blockquote>\n<ol start=\"2\">\n<li>第二步：SQLSession实现增删改查</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先构建SQLSession工厂构建器</span></span><br><span class=\"line\">SqlSessionFactoryBuilder ssfb = <span class=\"keyword\">new</span> SqlSessionFactoryBuilder();</span><br><span class=\"line\"><span class=\"comment\">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class=\"line\">InputStream inputStream = EmpTest.class.getClassLoader().getResourceAsStream(<span class=\"string\">\"sqlmap-config.xml\"</span>);</span><br><span class=\"line\">SqlSessionFactory ssf = ssfb.build(inputStream);</span><br><span class=\"line\"><span class=\"comment\">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class=\"line\">SqlSession ss = ssf.openSession();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//增加</span></span><br><span class=\"line\">Emp emp = <span class=\"keyword\">new</span> Emp(<span class=\"number\">0</span>,<span class=\"string\">\"ef2\"</span>,<span class=\"number\">50000</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> addRows = ss.insert(<span class=\"string\">\"insertEmp\"</span>, emp);</span><br><span class=\"line\"><span class=\"comment\">//删除</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> delRows = ss.delete(<span class=\"string\">\"deleteEmpById\"</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"comment\">//更新</span></span><br><span class=\"line\">Emp emp2 = <span class=\"keyword\">new</span> Emp(<span class=\"number\">1</span>,<span class=\"string\">\"hello\"</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> updateRows = ss.update(<span class=\"string\">\"updateEmpById\"</span>, emp2);</span><br><span class=\"line\"><span class=\"comment\">//查找</span></span><br><span class=\"line\">Emp emp3 = ss.selectOne(<span class=\"string\">\"findById\"</span>, <span class=\"number\">6</span>);</span><br><span class=\"line\">List&lt;Emp&gt; empList = ss.selectList(<span class=\"string\">\"findAll\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ss.commit();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>SqlSession对象的操作方法如下：</p>\n<ul>\n<li>insert(..) 插入操作</li>\n<li>update(..) 更新操作</li>\n<li>delete(..) 删除操作</li>\n<li>selectOne(..) 单行查询操作</li>\n<li>selectList(..) 多行查询操作</li>\n<li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li>\n</ul>\n</blockquote>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Mapper映射器\"><a href=\"#4-Mapper映射器\" class=\"headerlink\" title=\"4. Mapper映射器\"></a>4. Mapper映射器</h3><p>使用规则：</p>\n<ol>\n<li>接口的方法名和SQL定义文件中的id保持一致</li>\n<li>接口方法的返回值类型 要和resultType 保持一致<ul>\n<li>单行：<code>resultType</code></li>\n<li>多行：<code>List&lt;resultType&gt;</code></li>\n<li>增删改返回值，推荐int，也可以是void</li>\n</ul>\n</li>\n<li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li>\n<li>SQL定义文件中的namespace必须包名.接口名</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-向mapper传多个参数\"><a href=\"#5-向mapper传多个参数\" class=\"headerlink\" title=\"5. 向mapper传多个参数\"></a>5. 向mapper传多个参数</h3><h4 id=\"5-1-第一种方案：-0-，-1-param1-和-param2\"><a href=\"#5-1-第一种方案：-0-，-1-param1-和-param2\" class=\"headerlink\" title=\"5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}\"></a>5.1 第一种方案：#{0}，#{1} / #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(<span class=\"keyword\">int</span> id, String name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p>\n<h4 id=\"5-2-第二种方案-param\"><a href=\"#5-2-第二种方案-param\" class=\"headerlink\" title=\"5.2 第二种方案@param\"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(@param(<span class=\"string\">\"id\"</span>)</span><span class=\"keyword\">int</span> id, @<span class=\"title\">param</span><span class=\"params\">(<span class=\"string\">\"name\"</span>)</span>String name)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-第三种方案：采用对象或Map传多参数\"><a href=\"#5-3-第三种方案：采用对象或Map传多参数\" class=\"headerlink\" title=\"5.3 第三种方案：采用对象或Map传多参数\"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName</span><span class=\"params\">(Emp emp)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findByIdAndName2</span><span class=\"params\">(Map&lt;String, Object&gt; params)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Mapper.xml</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"com.bean.Emp\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByIdAndName2\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"map\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-结果集列名和属性名不一致的解决方法\"><a href=\"#6-结果集列名和属性名不一致的解决方法\" class=\"headerlink\" title=\"6. 结果集列名和属性名不一致的解决方法\"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p>\n<ol>\n<li>使用别名，select语句使用与属性一致的别名</li>\n<li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class=\"line\"><span class=\"comment\">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class=\"line\"><span class=\"comment\">    id:对resultMap的唯一标识 </span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">type</span>=<span class=\"string\">\"com.bean.Emp\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empMap\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class=\"line\"><span class=\"comment\">        column:查询出的列名</span></span><br><span class=\"line\"><span class=\"comment\">        property:type所指定的类中的属性名 </span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">column</span>=<span class=\"string\">\"e_id\"</span> <span class=\"attr\">property</span>=<span class=\"string\">\"id\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">result</span>  <span class=\"attr\">column</span>=<span class=\"string\">\"salary\"</span>  <span class=\"attr\">property</span>=<span class=\"string\">\"sal\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用resultMap --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findEmpById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultMap</span>=<span class=\"string\">\"empMap\"</span>&gt;</span></span><br><span class=\"line\">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-类型的别名和日志输出\"><a href=\"#7-类型的别名和日志输出\" class=\"headerlink\" title=\"7. 类型的别名和日志输出\"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">typeAliases</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">typeAlias</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"emp\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"com.bean.Emp\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在EmpMapper.xml中使用别名 resultType=”emp”</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findById\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"int\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"emp\"</span>&gt;</span></span><br><span class=\"line\">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置MyBatis的日志输出到控制台</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"cacheEnabled\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">setting</span> <span class=\"attr\">name</span>=<span class=\"string\">\"logImpl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"STDOUT_LOGGING\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-JdbcType\"><a href=\"#8-JdbcType\" class=\"headerlink\" title=\"8. JdbcType\"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p>\n<ul>\n<li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li>\n<li>一般情况下，我们没有必要按个字段去识别/判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li>\n<li>MyBatis包含的JdbcType类型，主要有下面这些：<ul>\n<li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByName\"</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">\"String\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.bean.Emp\"</span>&gt;</span></span><br><span class=\"line\">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Mabatis中-和-的区别\"><a href=\"#9-Mabatis中-和-的区别\" class=\"headerlink\" title=\"9. Mabatis中#{}和${}的区别\"></a>9. Mabatis中#{}和${}的区别</h3><ol>\n<li><code>${}</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul>\n<li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li>\n</ul>\n</li>\n<li><code>#{}</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul>\n<li>不支持表名、排序方式等的占位，默认会将其当成字符串</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"10-分页\"><a href=\"#10-分页\" class=\"headerlink\" title=\"10. 分页\"></a>10. 分页</h3><ol>\n<li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugin</span> <span class=\"attr\">interceptor</span>=<span class=\"string\">\"com.github.pagehelper.PageHelper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查询前使用分页API</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PageHelper.startPage(2, 2);</span><br><span class=\"line\">List<span class=\"tag\">&lt;<span class=\"name\">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class=\"line\">for(Emp emp: emps) &#123;</span><br><span class=\"line\">    System.out.println(emp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-Spring-MyBatis整合\"><a href=\"#11-Spring-MyBatis整合\" class=\"headerlink\" title=\"11. Spring+MyBatis整合\"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p>\n<ol>\n<li>SqlSessionFactoryBean<ul>\n<li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li>\n<li>依赖于dataSource 和加载SQL定义文件</li>\n</ul>\n</li>\n<li>MapperFactoryBean<ul>\n<li>根据指定的某一个Mapper接口生成Bean实例</li>\n<li>依赖于SqlSessionFactory 和 MApper接口</li>\n</ul>\n</li>\n<li>MapperScannerConfigurer<ul>\n<li>根据指定包批量扫描Mapper接口并生成实例</li>\n</ul>\n</li>\n<li>SqlSessionTemplate<ul>\n<li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"12-Spring-MyBatis完成sql操作\"><a href=\"#12-Spring-MyBatis完成sql操作\" class=\"headerlink\" title=\"12. Spring+MyBatis完成sql操作\"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p>\n<ul>\n<li>导jar包(mybatis包/数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li>\n</ul>\n<p><strong>第二步</strong>：配置SqlSessionFactoryBean</p>\n<ul>\n<li>导入jar包（mabatis-spring/ioc/aop/dao/连接池）</li>\n<li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/mapper/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第三步</strong>：</p>\n<ol>\n<li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul>\n<li>最终产生Mapper接口的 实现类，注意这是实现类</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperInterface\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao.EmpDao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"empDao2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperInterface\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao.EmpDao2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>方式二： MapperScannerConfigurer<ul>\n<li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mapperScanner\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.dao\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"annotationClass\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.annotation.MyAnnotation\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-使用SqlSessionTemplate模板来完成DAO接口的实现类\"><a href=\"#13-使用SqlSessionTemplate模板来完成DAO接口的实现类\" class=\"headerlink\" title=\"13. 使用SqlSessionTemplate模板来完成DAO接口的实现类\"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol>\n<li>使用Mybatis（同上）</li>\n<li>配置SqlSessionFactoryBean（同上）</li>\n<li>编写DAO接口的实现类<ul>\n<li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li>\n<li>使用SqlSessionTemplate对应API完成增删改查</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.mapper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">context:component-scan</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionTemplate\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">index</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"sqlSessionFactory\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repository</span>(<span class=\"string\">\"empDao\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmpDaoImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">EmpDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Emp <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqlSessionTemplate.selectOne(<span class=\"string\">\"findById\"</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"二十、SSM框架整合(Spring+SpringMVC+MyBatis)","date":"2019-08-27T14:52:55.000Z","_content":"\nSSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<!-- more -->\n- 使用spring MVC负责请求的转发和视图管理\n- spring实现业务对象管理\n- mybatis作为数据对象的持久化引擎\n\n### 1.搭建SSM架构步骤：\n1. 设计数据库\n2. 先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。\n3. 编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。\n4. 编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。\n5. 配置spring和mybatis框架的整合(applicationContext.xml)\n6. 编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。\n7. 配置SpringMVC(web.xml)\n8. 编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。\n9. 编写JSP页面调用，请求哪些参数，需要获取什么数据。\n\n>DataBase --> Entity --> Mapper.xml --> Mapper.Java(DAO) --> Service.java --> Controller.java --> Jsp\n\n\n### 2.搭建SSM架构实例（管理员登录）\n\n#### 1. 设计数据库(以MySql为例)\n建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行\n``` sql\nCREATE DATABASE exam_sys;\n/** 管理员表 */\nDROP TABLE admin;\nCREATE TABLE admin(\n    id INT AUTO_INCREMENT COMMENT '管理员ID',\n    name VARCHAR(30) NOT NULL COMMENT '管理员账号',\n    password VARCHAR(30) COMMENT '管理员密码',\n    CONSTRAINT et_admin_id_pk PRIMARY KEY(id),\n    CONSTRAINT et_admin_name_uk UNIQUE(NAME)\n);\n/** 插入数据 */\nINSERT INTO admin (name, password) VALUES('admin', '123456');\nSELECT * FROM admin;\nCOMMIT;\n```\n\n\n#### 2. 先写实体类entity，定义对象的属性\n参照数据库中表的字段来设置\n``` javaScript\npackage com.exam.entity;\n\npublic class Admin {\n    private int id;\n    private String name;\n    private String password;\n    /** 添加 getter/setter方法\n     *  添加 无参，有参构造\n     *  重写toString()以便于测试\n     */\n    // ...\n}\n```\n\n\n#### 3. 编写AdminMapper.xml（Mybatis），定义功能\n对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\">\n<!-- namespace指定和哪个Mapper映射器接口对应 -->\n<mapper namespace=\"com.exam.mapper.AdminDao\">\n    <!-- 定义SQL语句 -->\t\n    <select id=\"findByNameAndPassword\" resultType=\"com.exam.entity.Admin\">\n        select * from admin where name=#{name, jdbcType=VARCHAR} and password=#{password, jdbcType=VARCHAR}\n    </select>\n</mapper>\n```\n\n\n#### 4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。\n导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)\n``` javaScript\npackage com.exam.mapper;\n\nimport org.apache.ibatis.annotations.Param;\nimport com.exam.entity.Admin;\n\npublic interface AdminDao {\n    public Admin findByNameAndPassword(@Param(\"name\") String name, @Param(\"password\") String password);\n}\n```\n\n\n#### 5. 配置spring和mybatis框架的整合\n导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。\n``` xml\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/exam_sys\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n<!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory\n        属性dataSource：注入连接池对象\n        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置\n        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名\n -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <property name=\"mapperLocations\" value=\"classpath:com/exam/mapper/*.xml\"></property>\n    <!-- <property name=\"typeAliasesPackage\" value=\"com.exam.entity\"></property> -->\n</bean>\n\n<!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 -->\n<bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property> -->\n    <property name=\"basePackage\" value=\"com.exam.mapper\"></property>\n    <!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 -->\n    <!-- <property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"></property> -->\n</bean>\n<!-- 开启服务层组件扫描 -->\n<context:component-scan base-package=\"com.exam.service\"/>\n```\n\n\n#### 6. 编写Service.java，为控制层提供服务\n接受控制层的参数，完成相应的功能，并返回给控制层。\n``` javaScript\npackage com.exam.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport com.exam.mapper.AdminDao;\n\n@Service(\"adminService\")\npublic class AdminService {\n    @Autowired\n    private AdminDao dao;\n    \n    public boolean Login(String name, String password) {\n        try {\n            return dao.findByNameAndPassword(name, password)!=null?true:false;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n```\n\n#### 7. 配置SpringMVC\n导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。\n``` xml\n<!-- 配置编码过滤器 -->\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/</url-pattern>\n</filter-mapping>\n<!-- 配置DispatcherServlet分发请求 -->\n<servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n<!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler-->\n```\n\n在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。\n``` xml\n<!-- 开启控制器组件扫描 -->\n<context:component-scan base-package=\"com.exam.controller\"/>\n<!-- 开启标注形式mvc -->\n<mvc:annotation-driven />\n<!-- 配置视图处理器 -->\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n<!-- 对静态资源进行放行 -->\n<mvc:default-servlet-handler/>\n```\n\n\n#### 8. 编写Controller.java，连接页面请求和服务层\n获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）\n``` javaScript\npackage com.exam.controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport com.exam.entity.Admin;\nimport com.exam.service.AdminService;\n\n@Controller\n@RequestMapping(\"/admin\")\npublic class AdminController {\n    @Autowired\n    private AdminService as;\n    \n    @RequestMapping(\"/tologin\")\n    public String toLogin() {\n        return \"admin/login\";\n    }\n    @RequestMapping(value=\"/login\",method=RequestMethod.POST)\n    @ResponseBody\n    public boolean addUser(Admin admin, HttpServletRequest request) {\n        System.out.println(\"add:\"+admin);\n        System.out.println(admin.getName()+\"---\"+admin.getPassword());\n        boolean bl = as.Login(admin.getName(), admin.getPassword());\n        if(bl) {\n            //登录成功的逻辑\n            request.getSession().setAttribute(\"admin\", admin);\n            return true;\n        }\n        //登录失败的逻辑\n        request.setAttribute(\"msg\", \"登录失败\");\n        return false;\n    }\n}\n```\n\n\n#### 9. 编写JSP页面调用\n``` html\n<form>\n    管理员: <input id=\"aName\"  type=\"text\"><br>\n    密码:<input id=\"aPassword\"  type=\"text\"><br>\n    <input id=\"loginBtn\"  type=\"button\"  value=\"登录\">\n</form>\n<script src=\"js/jquery.min.js\"></script>\n<script>\n$(\"#loginBtn\").on(\"click\", function(){\n    $.ajax({\n        url: \"admin/login\",\n        type: \"post\",\n        data: {\n            name: $(\"#aName\").val(),\n            password: $(\"#aPassword\").val()\n        },\n        success: function(res){\n            alert(res);\n        }\n    });\n});\n</script>\n```\n\n\n\n\n","source":"_posts/20-SSM框架整合.md","raw":"---\ntitle: 二十、SSM框架整合(Spring+SpringMVC+MyBatis)\ndate: 2019-08-27 22:52:55\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nSSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<!-- more -->\n- 使用spring MVC负责请求的转发和视图管理\n- spring实现业务对象管理\n- mybatis作为数据对象的持久化引擎\n\n### 1.搭建SSM架构步骤：\n1. 设计数据库\n2. 先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。\n3. 编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。\n4. 编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。\n5. 配置spring和mybatis框架的整合(applicationContext.xml)\n6. 编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。\n7. 配置SpringMVC(web.xml)\n8. 编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。\n9. 编写JSP页面调用，请求哪些参数，需要获取什么数据。\n\n>DataBase --> Entity --> Mapper.xml --> Mapper.Java(DAO) --> Service.java --> Controller.java --> Jsp\n\n\n### 2.搭建SSM架构实例（管理员登录）\n\n#### 1. 设计数据库(以MySql为例)\n建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行\n``` sql\nCREATE DATABASE exam_sys;\n/** 管理员表 */\nDROP TABLE admin;\nCREATE TABLE admin(\n    id INT AUTO_INCREMENT COMMENT '管理员ID',\n    name VARCHAR(30) NOT NULL COMMENT '管理员账号',\n    password VARCHAR(30) COMMENT '管理员密码',\n    CONSTRAINT et_admin_id_pk PRIMARY KEY(id),\n    CONSTRAINT et_admin_name_uk UNIQUE(NAME)\n);\n/** 插入数据 */\nINSERT INTO admin (name, password) VALUES('admin', '123456');\nSELECT * FROM admin;\nCOMMIT;\n```\n\n\n#### 2. 先写实体类entity，定义对象的属性\n参照数据库中表的字段来设置\n``` javaScript\npackage com.exam.entity;\n\npublic class Admin {\n    private int id;\n    private String name;\n    private String password;\n    /** 添加 getter/setter方法\n     *  添加 无参，有参构造\n     *  重写toString()以便于测试\n     */\n    // ...\n}\n```\n\n\n#### 3. 编写AdminMapper.xml（Mybatis），定义功能\n对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>  \n<!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\">\n<!-- namespace指定和哪个Mapper映射器接口对应 -->\n<mapper namespace=\"com.exam.mapper.AdminDao\">\n    <!-- 定义SQL语句 -->\t\n    <select id=\"findByNameAndPassword\" resultType=\"com.exam.entity.Admin\">\n        select * from admin where name=#{name, jdbcType=VARCHAR} and password=#{password, jdbcType=VARCHAR}\n    </select>\n</mapper>\n```\n\n\n#### 4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。\n导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)\n``` javaScript\npackage com.exam.mapper;\n\nimport org.apache.ibatis.annotations.Param;\nimport com.exam.entity.Admin;\n\npublic interface AdminDao {\n    public Admin findByNameAndPassword(@Param(\"name\") String name, @Param(\"password\") String password);\n}\n```\n\n\n#### 5. 配置spring和mybatis框架的整合\n导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。\n``` xml\n<!-- 配置连接池对象 -->\n<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\">\n    <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"></property>\n    <property name=\"url\" value=\"jdbc:mysql://localhost:3306/exam_sys\"></property>\n    <property name=\"username\" value=\"root\"></property>\n    <property name=\"password\" value=\"123456\"></property>\n</bean>\n<!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory\n        属性dataSource：注入连接池对象\n        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置\n        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名\n -->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n    <property name=\"mapperLocations\" value=\"classpath:com/exam/mapper/*.xml\"></property>\n    <!-- <property name=\"typeAliasesPackage\" value=\"com.exam.entity\"></property> -->\n</bean>\n\n<!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 -->\n<bean id=\"mapperScanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!-- <property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"></property> -->\n    <property name=\"basePackage\" value=\"com.exam.mapper\"></property>\n    <!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 -->\n    <!-- <property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"></property> -->\n</bean>\n<!-- 开启服务层组件扫描 -->\n<context:component-scan base-package=\"com.exam.service\"/>\n```\n\n\n#### 6. 编写Service.java，为控制层提供服务\n接受控制层的参数，完成相应的功能，并返回给控制层。\n``` javaScript\npackage com.exam.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport com.exam.mapper.AdminDao;\n\n@Service(\"adminService\")\npublic class AdminService {\n    @Autowired\n    private AdminDao dao;\n    \n    public boolean Login(String name, String password) {\n        try {\n            return dao.findByNameAndPassword(name, password)!=null?true:false;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n```\n\n#### 7. 配置SpringMVC\n导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。\n``` xml\n<!-- 配置编码过滤器 -->\n<filter>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>CharacterEncodingFilter</filter-name>\n    <url-pattern>/</url-pattern>\n</filter-mapping>\n<!-- 配置DispatcherServlet分发请求 -->\n<servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n<!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler-->\n```\n\n在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。\n``` xml\n<!-- 开启控制器组件扫描 -->\n<context:component-scan base-package=\"com.exam.controller\"/>\n<!-- 开启标注形式mvc -->\n<mvc:annotation-driven />\n<!-- 配置视图处理器 -->\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n</bean>\n<!-- 对静态资源进行放行 -->\n<mvc:default-servlet-handler/>\n```\n\n\n#### 8. 编写Controller.java，连接页面请求和服务层\n获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）\n``` javaScript\npackage com.exam.controller;\n\nimport javax.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport com.exam.entity.Admin;\nimport com.exam.service.AdminService;\n\n@Controller\n@RequestMapping(\"/admin\")\npublic class AdminController {\n    @Autowired\n    private AdminService as;\n    \n    @RequestMapping(\"/tologin\")\n    public String toLogin() {\n        return \"admin/login\";\n    }\n    @RequestMapping(value=\"/login\",method=RequestMethod.POST)\n    @ResponseBody\n    public boolean addUser(Admin admin, HttpServletRequest request) {\n        System.out.println(\"add:\"+admin);\n        System.out.println(admin.getName()+\"---\"+admin.getPassword());\n        boolean bl = as.Login(admin.getName(), admin.getPassword());\n        if(bl) {\n            //登录成功的逻辑\n            request.getSession().setAttribute(\"admin\", admin);\n            return true;\n        }\n        //登录失败的逻辑\n        request.setAttribute(\"msg\", \"登录失败\");\n        return false;\n    }\n}\n```\n\n\n#### 9. 编写JSP页面调用\n``` html\n<form>\n    管理员: <input id=\"aName\"  type=\"text\"><br>\n    密码:<input id=\"aPassword\"  type=\"text\"><br>\n    <input id=\"loginBtn\"  type=\"button\"  value=\"登录\">\n</form>\n<script src=\"js/jquery.min.js\"></script>\n<script>\n$(\"#loginBtn\").on(\"click\", function(){\n    $.ajax({\n        url: \"admin/login\",\n        type: \"post\",\n        data: {\n            name: $(\"#aName\").val(),\n            password: $(\"#aPassword\").val()\n        },\n        success: function(res){\n            alert(res);\n        }\n    });\n});\n</script>\n```\n\n\n\n\n","slug":"20-SSM框架整合","published":1,"updated":"2019-08-27T14:56:39.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo67002cyot3o635mc00","content":"<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<a id=\"more\"></a></p>\n<ul>\n<li>使用spring MVC负责请求的转发和视图管理</li>\n<li>spring实现业务对象管理</li>\n<li>mybatis作为数据对象的持久化引擎</li>\n</ul>\n<h3 id=\"1-搭建SSM架构步骤：\"><a href=\"#1-搭建SSM架构步骤：\" class=\"headerlink\" title=\"1.搭建SSM架构步骤：\"></a>1.搭建SSM架构步骤：</h3><ol>\n<li>设计数据库</li>\n<li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li>\n<li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li>\n<li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li>\n<li>配置spring和mybatis框架的整合(applicationContext.xml)</li>\n<li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li>\n<li>配置SpringMVC(web.xml)</li>\n<li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li>\n<li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li>\n</ol>\n<blockquote>\n<p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p>\n</blockquote>\n<h3 id=\"2-搭建SSM架构实例（管理员登录）\"><a href=\"#2-搭建SSM架构实例（管理员登录）\" class=\"headerlink\" title=\"2.搭建SSM架构实例（管理员登录）\"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id=\"1-设计数据库-以MySql为例\"><a href=\"#1-设计数据库-以MySql为例\" class=\"headerlink\" title=\"1. 设计数据库(以MySql为例)\"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> exam_sys;</span><br><span class=\"line\"><span class=\"comment\">/** 管理员表 */</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">admin</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">admin</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员ID'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员账号'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员密码'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class=\"keyword\">KEY</span>(<span class=\"keyword\">id</span>),</span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> et_admin_name_uk <span class=\"keyword\">UNIQUE</span>(<span class=\"keyword\">NAME</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">/** 插入数据 */</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">admin</span> (<span class=\"keyword\">name</span>, <span class=\"keyword\">password</span>) <span class=\"keyword\">VALUES</span>(<span class=\"string\">'admin'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">admin</span>;</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-先写实体类entity，定义对象的属性\"><a href=\"#2-先写实体类entity，定义对象的属性\" class=\"headerlink\" title=\"2. 先写实体类entity，定义对象的属性\"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Admin</span> </span>&#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    private <span class=\"built_in\">String</span> password;</span><br><span class=\"line\">    <span class=\"comment\">/** 添加 getter/setter方法</span></span><br><span class=\"line\"><span class=\"comment\">     *  添加 无参，有参构造</span></span><br><span class=\"line\"><span class=\"comment\">     *  重写toString()以便于测试</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-编写AdminMapper-xml（Mybatis），定义功能\"><a href=\"#3-编写AdminMapper-xml（Mybatis），定义功能\" class=\"headerlink\" title=\"3. 编写AdminMapper.xml（Mybatis），定义功能\"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span>  </span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.exam.mapper.AdminDao\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义SQL语句 --&gt;</span>\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByNameAndPassword\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.exam.entity.Admin\"</span>&gt;</span></span><br><span class=\"line\">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。\"><a href=\"#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。\" class=\"headerlink\" title=\"4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。\"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.entity.Admin;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface AdminDao &#123;</span><br><span class=\"line\">    public Admin findByNameAndPassword(@Param(<span class=\"string\">\"name\"</span>) <span class=\"built_in\">String</span> name, @Param(<span class=\"string\">\"password\"</span>) <span class=\"built_in\">String</span> password);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-配置spring和mybatis框架的整合\"><a href=\"#5-配置spring和mybatis框架的整合\" class=\"headerlink\" title=\"5. 配置spring和mybatis框架的整合\"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/exam_sys\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class=\"line\"><span class=\"comment\">        属性dataSource：注入连接池对象</span></span><br><span class=\"line\"><span class=\"comment\">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class=\"line\"><span class=\"comment\">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/exam/mapper/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"typeAliasesPackage\" value=\"com.exam.entity\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mapperScanner\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.exam.mapper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.exam.service\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-编写Service-java，为控制层提供服务\"><a href=\"#6-编写Service-java，为控制层提供服务\" class=\"headerlink\" title=\"6. 编写Service.java，为控制层提供服务\"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.mapper.AdminDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(<span class=\"string\">\"adminService\"</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminService</span> </span>&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AdminDao dao;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public boolean Login(<span class=\"built_in\">String</span> name, <span class=\"built_in\">String</span> password) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dao.findByNameAndPassword(name, password)!=<span class=\"literal\">null</span>?<span class=\"literal\">true</span>:<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-配置SpringMVC\"><a href=\"#7-配置SpringMVC\" class=\"headerlink\" title=\"7. 配置SpringMVC\"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.exam.controller\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-编写Controller-java，连接页面请求和服务层\"><a href=\"#8-编写Controller-java，连接页面请求和服务层\" class=\"headerlink\" title=\"8. 编写Controller.java，连接页面请求和服务层\"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.entity.Admin;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.service.AdminService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(<span class=\"string\">\"/admin\"</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminController</span> </span>&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AdminService <span class=\"keyword\">as</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @RequestMapping(<span class=\"string\">\"/tologin\"</span>)</span><br><span class=\"line\">    public <span class=\"built_in\">String</span> toLogin() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"admin/login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @RequestMapping(value=<span class=\"string\">\"/login\"</span>,method=RequestMethod.POST)</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add:\"</span>+admin);</span><br><span class=\"line\">        System.out.println(admin.getName()+<span class=\"string\">\"---\"</span>+admin.getPassword());</span><br><span class=\"line\">        boolean bl = <span class=\"keyword\">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bl) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//登录成功的逻辑</span></span><br><span class=\"line\">            request.getSession().setAttribute(<span class=\"string\">\"admin\"</span>, admin);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//登录失败的逻辑</span></span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">\"msg\"</span>, <span class=\"string\">\"登录失败\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-编写JSP页面调用\"><a href=\"#9-编写JSP页面调用\" class=\"headerlink\" title=\"9. 编写JSP页面调用\"></a>9. 编写JSP页面调用</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    管理员: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"aName\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"aPassword\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"loginBtn\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#loginBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"admin/login\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"post\"</span>,</span></span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\"><span class=\"javascript\">            name: $(<span class=\"string\">\"#aName\"</span>).val(),</span></span><br><span class=\"line\"><span class=\"javascript\">            password: $(<span class=\"string\">\"#aPassword\"</span>).val()</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。","more":"</p>\n<ul>\n<li>使用spring MVC负责请求的转发和视图管理</li>\n<li>spring实现业务对象管理</li>\n<li>mybatis作为数据对象的持久化引擎</li>\n</ul>\n<h3 id=\"1-搭建SSM架构步骤：\"><a href=\"#1-搭建SSM架构步骤：\" class=\"headerlink\" title=\"1.搭建SSM架构步骤：\"></a>1.搭建SSM架构步骤：</h3><ol>\n<li>设计数据库</li>\n<li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li>\n<li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li>\n<li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li>\n<li>配置spring和mybatis框架的整合(applicationContext.xml)</li>\n<li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li>\n<li>配置SpringMVC(web.xml)</li>\n<li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li>\n<li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li>\n</ol>\n<blockquote>\n<p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p>\n</blockquote>\n<h3 id=\"2-搭建SSM架构实例（管理员登录）\"><a href=\"#2-搭建SSM架构实例（管理员登录）\" class=\"headerlink\" title=\"2.搭建SSM架构实例（管理员登录）\"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id=\"1-设计数据库-以MySql为例\"><a href=\"#1-设计数据库-以MySql为例\" class=\"headerlink\" title=\"1. 设计数据库(以MySql为例)\"></a>1. 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> exam_sys;</span><br><span class=\"line\"><span class=\"comment\">/** 管理员表 */</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">admin</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">admin</span>(</span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"built_in\">INT</span> AUTO_INCREMENT <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员ID'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">name</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员账号'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">password</span> <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">30</span>) <span class=\"keyword\">COMMENT</span> <span class=\"string\">'管理员密码'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> et_admin_id_pk PRIMARY <span class=\"keyword\">KEY</span>(<span class=\"keyword\">id</span>),</span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> et_admin_name_uk <span class=\"keyword\">UNIQUE</span>(<span class=\"keyword\">NAME</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">/** 插入数据 */</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"keyword\">admin</span> (<span class=\"keyword\">name</span>, <span class=\"keyword\">password</span>) <span class=\"keyword\">VALUES</span>(<span class=\"string\">'admin'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">admin</span>;</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-先写实体类entity，定义对象的属性\"><a href=\"#2-先写实体类entity，定义对象的属性\" class=\"headerlink\" title=\"2. 先写实体类entity，定义对象的属性\"></a>2. 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.entity;</span><br><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Admin</span> </span>&#123;</span><br><span class=\"line\">    private int id;</span><br><span class=\"line\">    private <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    private <span class=\"built_in\">String</span> password;</span><br><span class=\"line\">    <span class=\"comment\">/** 添加 getter/setter方法</span></span><br><span class=\"line\"><span class=\"comment\">     *  添加 无参，有参构造</span></span><br><span class=\"line\"><span class=\"comment\">     *  重写toString()以便于测试</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-编写AdminMapper-xml（Mybatis），定义功能\"><a href=\"#3-编写AdminMapper-xml（Mybatis），定义功能\" class=\"headerlink\" title=\"3. 编写AdminMapper.xml（Mybatis），定义功能\"></a>3. 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;</span>  </span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE mapper PUBLIC \"-//ibatis.apache.org//DTD Mapper 3.0//EN\" \"http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd\"&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">\"com.exam.mapper.AdminDao\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义SQL语句 --&gt;</span>\t</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findByNameAndPassword\"</span> <span class=\"attr\">resultType</span>=<span class=\"string\">\"com.exam.entity.Admin\"</span>&gt;</span></span><br><span class=\"line\">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。\"><a href=\"#4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。\" class=\"headerlink\" title=\"4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。\"></a>4. 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.entity.Admin;</span><br><span class=\"line\"></span><br><span class=\"line\">public interface AdminDao &#123;</span><br><span class=\"line\">    public Admin findByNameAndPassword(@Param(<span class=\"string\">\"name\"</span>) <span class=\"built_in\">String</span> name, @Param(<span class=\"string\">\"password\"</span>) <span class=\"built_in\">String</span> password);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-配置spring和mybatis框架的整合\"><a href=\"#5-配置spring和mybatis框架的整合\" class=\"headerlink\" title=\"5. 配置spring和mybatis框架的整合\"></a>5. 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc/aop/dao/连接池；添加Spring配置文件（applicationContext.xml）到src下。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.commons.dbcp.BasicDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.cj.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://localhost:3306/exam_sys\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"root\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"123456\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class=\"line\"><span class=\"comment\">        属性dataSource：注入连接池对象</span></span><br><span class=\"line\"><span class=\"comment\">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class=\"line\"><span class=\"comment\">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class=\"line\"><span class=\"comment\"> --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath:com/exam/mapper/*.xml\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"typeAliasesPackage\" value=\"com.exam.entity\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"mapperScanner\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.exam.mapper\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- &lt;property name=\"annotationClass\" value=\"com.annotation.MyAnnotation\"&gt;&lt;/property&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.exam.service\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-编写Service-java，为控制层提供服务\"><a href=\"#6-编写Service-java，为控制层提供服务\" class=\"headerlink\" title=\"6. 编写Service.java，为控制层提供服务\"></a>6. 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.service;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Service;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.mapper.AdminDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service(<span class=\"string\">\"adminService\"</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminService</span> </span>&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AdminDao dao;</span><br><span class=\"line\">    </span><br><span class=\"line\">    public boolean Login(<span class=\"built_in\">String</span> name, <span class=\"built_in\">String</span> password) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dao.findByNameAndPassword(name, password)!=<span class=\"literal\">null</span>?<span class=\"literal\">true</span>:<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-配置SpringMVC\"><a href=\"#7-配置SpringMVC\" class=\"headerlink\" title=\"7. 配置SpringMVC\"></a>7. 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"com.exam.controller\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-编写Controller-java，连接页面请求和服务层\"><a href=\"#8-编写Controller-java，连接页面请求和服务层\" class=\"headerlink\" title=\"8. 编写Controller.java，连接页面请求和服务层\"></a>8. 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.exam.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.entity.Admin;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.exam.service.AdminService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(<span class=\"string\">\"/admin\"</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminController</span> </span>&#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private AdminService <span class=\"keyword\">as</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @RequestMapping(<span class=\"string\">\"/tologin\"</span>)</span><br><span class=\"line\">    public <span class=\"built_in\">String</span> toLogin() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"admin/login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @RequestMapping(value=<span class=\"string\">\"/login\"</span>,method=RequestMethod.POST)</span><br><span class=\"line\">    @ResponseBody</span><br><span class=\"line\">    public boolean addUser(Admin admin, HttpServletRequest request) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add:\"</span>+admin);</span><br><span class=\"line\">        System.out.println(admin.getName()+<span class=\"string\">\"---\"</span>+admin.getPassword());</span><br><span class=\"line\">        boolean bl = <span class=\"keyword\">as</span>.Login(admin.getName(), admin.getPassword());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(bl) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//登录成功的逻辑</span></span><br><span class=\"line\">            request.getSession().setAttribute(<span class=\"string\">\"admin\"</span>, admin);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//登录失败的逻辑</span></span><br><span class=\"line\">        request.setAttribute(<span class=\"string\">\"msg\"</span>, <span class=\"string\">\"登录失败\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-编写JSP页面调用\"><a href=\"#9-编写JSP页面调用\" class=\"headerlink\" title=\"9. 编写JSP页面调用\"></a>9. 编写JSP页面调用</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    管理员: <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"aName\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"aPassword\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"loginBtn\"</span>  <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>  <span class=\"attr\">value</span>=<span class=\"string\">\"登录\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#loginBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"admin/login\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"post\"</span>,</span></span><br><span class=\"line\">        data: &#123;</span><br><span class=\"line\"><span class=\"javascript\">            name: $(<span class=\"string\">\"#aName\"</span>).val(),</span></span><br><span class=\"line\"><span class=\"javascript\">            password: $(<span class=\"string\">\"#aPassword\"</span>).val()</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"BlueLake博客主题的详细配置","date":"2016-12-29T03:25:33.000Z","top":9,"_content":"### 开始之前\n\n[BlueLake主题](https://github.com/chaooo/hexo-theme-BlueLake)写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。\n<!-- more -->\n在阅读本文之前，假定您已经成功安装了[Hexo](https://hexo.io/zh-cn/)，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n> 需要特别注意的是Hexo有两个`_config.yml`配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为**`根_config.yml`**；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为**`主题_config.yml`**。\n\n### 1. 安装\n\n您可以直接到[BlueLake发布页](https://github.com/chaooo/hexo-theme-BlueLake)下载，然后解压拷贝到`themes`目录下，修改配置即可。\n不过我还是推荐使用`GIT`来checkout代码，之后也可以通过`git pull`来快速更新。\n\n#### 1.1 安装主题\n\n在根目录下打开终端窗口：\n``` bash git bash\n$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake\n```\n\n#### 1.2 安装主题渲染器\n\nBlueLake是基于`jade`和`stylus`写的，所以需要安装`hexo-renderer-jade`和`hexo-renderer-stylus`来渲染。\n``` bash git bash\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n#### 1.3 启用主题\n\n打开`根_config.yml`配置文件，找到theme字段，将其值改为`BlueLake`(先确认主题文件夹名称是否为BlueLake)。\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntheme: BlueLake\n```\n\n#### 1.4 验证\n\n首先启动 Hexo 本地站点，并开启调试模式：\n``` bash git bash\n$ hexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：`INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n此时即可使用浏览器访问 `http://localhost:4000`，检查站点是否正确运行。\n\n#### 1.5 更新主题\n\n今后若主题添加了新功能正是您需要的，您可以直接`git pull`来更新主题。\n``` bash git bash\ncd themes/BlueLake\ngit pull\n```\n\n### 2. 配置\n\n#### 2.1 配置网站头部显示文字\n\n打开`根_config.yml`，找到：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntitle: \nsubtitle: \ndescription: \nauthor: \n```\n`title`和`subtitle`分别是网站主标题和副标题，会显示在网站头部；`description`在网站界面不会显示，内容会加入网站源码的`meta`标签中，主要用于SEO；`author`就填写网站所有者的名字，会在网站底部的`Copyright`处有所显示。\n\n#### 2.2 设置语言\n\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在`根_config.yml`配置如下：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\nlanguage: zh-CN\n```\n\n#### 2.3 设置菜单\n\n打开`主题_config.yml`，找到：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即`主页home`，`归档archive`，`关于about`，`订阅RSS`；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n每个页面底部的`footer`中`联系博主`的三个图标分别是`邮箱`，`微博主页链接地址`，`GitHUb个人页链接地址`，直接使用`主题_config.yml`中`about页面`的配置，若不需要about页面，只需要如下配置就好：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n##### 2.3.1 添加about页\n\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n``` bash git bash\n$ hexo new page 'about'\n```\n打开`主题_config.yml`，补全关于我页面的详细信息：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改`layout/page.jade`模板就好。\n\n##### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n\n在根目录下打开命令行窗口：\n``` bash git bash\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加`主题_config.yml`配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\n\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n#### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)来创建JSON数据文件：\n``` bash git bash\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在`根_config.yml`添加配置：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在`主题_config.yml`添加配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nlocal_search: true\n```\n\n#### 2.5 修改站点图标\n\n站点图标存放在主题的`Source`目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为** favicon.ico **，请将其放入hexo目录的`source`文件夹，建议大小：32px X 32px。\n您需要为苹果设备添加网站徽标，请命名为** apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n#### 2.6 添加站点关键字\n\n请在hexo目录的`根_config.yml`中添加keywords字段，如：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n\n#### 2.7 首页添加文章置顶\n\n在根目录下打开命令行窗口安装：\n``` bash git bash\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n然后在需要置顶的文章的Front-matter中加上top: true即可。\n``` md\n---\ntitle: BlueLake博客主题的详细配置\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: true\n---\n```\n\n#### 2.8 更换主题背景和添加文章版权信息\n更换主题背景为深色\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\ndark: true #true/false\n```\n添加文章版权信息\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\n#Copyright\ncopyright: \n  enable: true #true/false  \n  describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述\n```\n\n#### 2.9 其他配置\n`主题_config.yml`的其他配置\n1. `show_category_count`——是否显示分类下的文章数。\n2. `widgets_on_small_screens`——是否在小屏显示侧边栏，若`true`,则侧边栏挂件将显示在底部。\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nshow_category_count: true \nwidgets_on_small_screens: true \n```\n\n### 3.集成第三方服务\n\n#### 3.1 添加评论\n\n目前主题集成六种第三方评论，分别是[多说评论](http://duoshuo.com)、[Disqus评论](https://disqus.com)、[来必力评论](https://livere.com)、[友言评论](http://www.uyan.cc/)、[网易云跟帖评论](https://gentie.163.com/info.html)、[畅言评论](http://changyan.kuaizhan.com)，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。\n1. 注册并获得代码。\n  - 若使用[多说评论](http://duoshuo.com)，注册多说后获得short_name。\n  - 若使用[Disqus评论](https://disqus.com)，注册Disqus后获得short_name。\n  - 若使用[来必力评论](https://livere.com)，注册来必力,获得data-uid。\n  - 若使用[友言评论](http://www.uyan.cc/)，注册友言,获得uid。\n  - 若使用[网易云跟帖评论](https://gentie.163.com/info.html)，注册网易云跟帖,获得productKey。\n  - 若使用[畅言评论](http://changyan.kuaizhan.com)，注册畅言，获得appid，appkey。\n2. 配置`主题_config.yml`：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n\n#### 3.2 百度统计\n\n1. 登录[百度统计](http://tongji.baidu.com/)，定位到站点的代码获取页面。\n2. 复制`//hm.baidu.com/hm.js?`后面那串统计脚本id(假设为：8006843039519956000)\n3. 配置`主题_config.yml`:\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nbaidu_analytics: 8006843039519956000\n```\n> 注意： `baidu_analytics`不是你的百度`id`或者百度统计`id`\n如若使用谷歌统计，配置方法与百度统计类似。\n\n#### 3.3 卜算子阅读次数统计\n\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nbusuanzi: true\n```\n若设置为`true`将计算文章的阅读量(Hits)，并显示在文章标题下的`小手图标`旁。\n\n#### 3.4 微博秀\n\n微博秀挂件的代码放在`layout/_widget/weibo.jade`下，需要您去[微博开放平台](http://open.weibo.com/)获取您自己的微博秀代码来替换。\n1. 登录[微博开放平台](http://open.weibo.com/)，选择微博秀。\n2. 为了与主题风格统一，作如下配置\n  - 基础设置：高`400px`；勾选宽度自适应；颜色选择`白色`；\n  - 样式设置：主字色`#333`；链接色`#40759b`；鼠标悬停色`#f7f8f8`；\n  - 模块设置：去掉`标题`、`边框`、`粉丝`的勾选框，只留`微博`。\n3. 复制代码里`src=\"\"`里引号包裹的内容，替换到`layout/_widget/weibo.jade`\n{% codeblock weibo.jade lang:stylus mark:1,7-8,10 https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade layout/_widget/weibo.jade %}\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\n  iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n{% endcodeblock %}\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n> 注意：最主要是是要把`src`里`uid=`和`verifier=`后面的字段替换为您自己代码里的就好。","source":"_posts/BlueLake博客主题的详细配置.md","raw":"---\ntitle: BlueLake博客主题的详细配置\ndate: 2016-12-29 11:25:33\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: 9\n---\n### 开始之前\n\n[BlueLake主题](https://github.com/chaooo/hexo-theme-BlueLake)写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。\n<!-- more -->\n在阅读本文之前，假定您已经成功安装了[Hexo](https://hexo.io/zh-cn/)，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n> 需要特别注意的是Hexo有两个`_config.yml`配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为**`根_config.yml`**；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为**`主题_config.yml`**。\n\n### 1. 安装\n\n您可以直接到[BlueLake发布页](https://github.com/chaooo/hexo-theme-BlueLake)下载，然后解压拷贝到`themes`目录下，修改配置即可。\n不过我还是推荐使用`GIT`来checkout代码，之后也可以通过`git pull`来快速更新。\n\n#### 1.1 安装主题\n\n在根目录下打开终端窗口：\n``` bash git bash\n$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake\n```\n\n#### 1.2 安装主题渲染器\n\nBlueLake是基于`jade`和`stylus`写的，所以需要安装`hexo-renderer-jade`和`hexo-renderer-stylus`来渲染。\n``` bash git bash\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n#### 1.3 启用主题\n\n打开`根_config.yml`配置文件，找到theme字段，将其值改为`BlueLake`(先确认主题文件夹名称是否为BlueLake)。\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntheme: BlueLake\n```\n\n#### 1.4 验证\n\n首先启动 Hexo 本地站点，并开启调试模式：\n``` bash git bash\n$ hexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：`INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n此时即可使用浏览器访问 `http://localhost:4000`，检查站点是否正确运行。\n\n#### 1.5 更新主题\n\n今后若主题添加了新功能正是您需要的，您可以直接`git pull`来更新主题。\n``` bash git bash\ncd themes/BlueLake\ngit pull\n```\n\n### 2. 配置\n\n#### 2.1 配置网站头部显示文字\n\n打开`根_config.yml`，找到：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntitle: \nsubtitle: \ndescription: \nauthor: \n```\n`title`和`subtitle`分别是网站主标题和副标题，会显示在网站头部；`description`在网站界面不会显示，内容会加入网站源码的`meta`标签中，主要用于SEO；`author`就填写网站所有者的名字，会在网站底部的`Copyright`处有所显示。\n\n#### 2.2 设置语言\n\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在`根_config.yml`配置如下：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\nlanguage: zh-CN\n```\n\n#### 2.3 设置菜单\n\n打开`主题_config.yml`，找到：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即`主页home`，`归档archive`，`关于about`，`订阅RSS`；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n每个页面底部的`footer`中`联系博主`的三个图标分别是`邮箱`，`微博主页链接地址`，`GitHUb个人页链接地址`，直接使用`主题_config.yml`中`about页面`的配置，若不需要about页面，只需要如下配置就好：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n##### 2.3.1 添加about页\n\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n``` bash git bash\n$ hexo new page 'about'\n```\n打开`主题_config.yml`，补全关于我页面的详细信息：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改`layout/page.jade`模板就好。\n\n##### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n\n在根目录下打开命令行窗口：\n``` bash git bash\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加`主题_config.yml`配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\n\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n#### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)来创建JSON数据文件：\n``` bash git bash\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在`根_config.yml`添加配置：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在`主题_config.yml`添加配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nlocal_search: true\n```\n\n#### 2.5 修改站点图标\n\n站点图标存放在主题的`Source`目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为** favicon.ico **，请将其放入hexo目录的`source`文件夹，建议大小：32px X 32px。\n您需要为苹果设备添加网站徽标，请命名为** apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n#### 2.6 添加站点关键字\n\n请在hexo目录的`根_config.yml`中添加keywords字段，如：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n\n#### 2.7 首页添加文章置顶\n\n在根目录下打开命令行窗口安装：\n``` bash git bash\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n然后在需要置顶的文章的Front-matter中加上top: true即可。\n``` md\n---\ntitle: BlueLake博客主题的详细配置\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: true\n---\n```\n\n#### 2.8 更换主题背景和添加文章版权信息\n更换主题背景为深色\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\ndark: true #true/false\n```\n添加文章版权信息\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\n#Copyright\ncopyright: \n  enable: true #true/false  \n  describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述\n```\n\n#### 2.9 其他配置\n`主题_config.yml`的其他配置\n1. `show_category_count`——是否显示分类下的文章数。\n2. `widgets_on_small_screens`——是否在小屏显示侧边栏，若`true`,则侧边栏挂件将显示在底部。\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nshow_category_count: true \nwidgets_on_small_screens: true \n```\n\n### 3.集成第三方服务\n\n#### 3.1 添加评论\n\n目前主题集成六种第三方评论，分别是[多说评论](http://duoshuo.com)、[Disqus评论](https://disqus.com)、[来必力评论](https://livere.com)、[友言评论](http://www.uyan.cc/)、[网易云跟帖评论](https://gentie.163.com/info.html)、[畅言评论](http://changyan.kuaizhan.com)，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。\n1. 注册并获得代码。\n  - 若使用[多说评论](http://duoshuo.com)，注册多说后获得short_name。\n  - 若使用[Disqus评论](https://disqus.com)，注册Disqus后获得short_name。\n  - 若使用[来必力评论](https://livere.com)，注册来必力,获得data-uid。\n  - 若使用[友言评论](http://www.uyan.cc/)，注册友言,获得uid。\n  - 若使用[网易云跟帖评论](https://gentie.163.com/info.html)，注册网易云跟帖,获得productKey。\n  - 若使用[畅言评论](http://changyan.kuaizhan.com)，注册畅言，获得appid，appkey。\n2. 配置`主题_config.yml`：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n\n#### 3.2 百度统计\n\n1. 登录[百度统计](http://tongji.baidu.com/)，定位到站点的代码获取页面。\n2. 复制`//hm.baidu.com/hm.js?`后面那串统计脚本id(假设为：8006843039519956000)\n3. 配置`主题_config.yml`:\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nbaidu_analytics: 8006843039519956000\n```\n> 注意： `baidu_analytics`不是你的百度`id`或者百度统计`id`\n如若使用谷歌统计，配置方法与百度统计类似。\n\n#### 3.3 卜算子阅读次数统计\n\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nbusuanzi: true\n```\n若设置为`true`将计算文章的阅读量(Hits)，并显示在文章标题下的`小手图标`旁。\n\n#### 3.4 微博秀\n\n微博秀挂件的代码放在`layout/_widget/weibo.jade`下，需要您去[微博开放平台](http://open.weibo.com/)获取您自己的微博秀代码来替换。\n1. 登录[微博开放平台](http://open.weibo.com/)，选择微博秀。\n2. 为了与主题风格统一，作如下配置\n  - 基础设置：高`400px`；勾选宽度自适应；颜色选择`白色`；\n  - 样式设置：主字色`#333`；链接色`#40759b`；鼠标悬停色`#f7f8f8`；\n  - 模块设置：去掉`标题`、`边框`、`粉丝`的勾选框，只留`微博`。\n3. 复制代码里`src=\"\"`里引号包裹的内容，替换到`layout/_widget/weibo.jade`\n{% codeblock weibo.jade lang:stylus mark:1,7-8,10 https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade layout/_widget/weibo.jade %}\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\n  iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n{% endcodeblock %}\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n> 注意：最主要是是要把`src`里`uid=`和`verifier=`后面的字段替换为您自己代码里的就好。","slug":"BlueLake博客主题的详细配置","published":1,"updated":"2019-07-20T14:09:22.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo6a002fyot3m18vjdbo","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p><a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake主题</a>写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>\n<a id=\"more\"></a>\n<p>在阅读本文之前，假定您已经成功安装了<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<blockquote>\n<p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>您可以直接到<a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p>\n<h4 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">BlueLake</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\n<h4 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><h4 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> </span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> </span><br><span class=\"line\"><span class=\"attr\">description:</span> </span><br><span class=\"line\"><span class=\"attr\">author:</span></span><br></pre></td></tr></table></figure>\n\n<p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p>\n<h4 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">archives/</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># - page: about</span></span><br><span class=\"line\">  <span class=\"comment\">#   directory: about/</span></span><br><span class=\"line\">  <span class=\"comment\">#   icon: fa-user</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">rss</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></table></figure>\n\n<p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">'about'</span></span><br></pre></td></tr></table></figure>\n\n<p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  photo_url:</span> <span class=\"comment\">## 头像的链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  weibo_name:</span> <span class=\"comment\">## 微博用户名 </span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_name:</span> <span class=\"comment\">## github用户名</span></span><br></pre></td></tr></table></figure>\n\n<p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p>\n<h5 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n\n<p>添加<code>主题_config.yml</code>配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Plugins:</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-feed</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-sitemap</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-baidu-sitemap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">atom</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">  limit:</span> <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>来创建JSON数据文件：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>根_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后在<code>主题_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">local_search:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为** favicon.ico <strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为</strong> apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h4 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站简要描述,如：Charles·Zheng's</span> <span class=\"string\">blog.</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站关键字,</span> <span class=\"string\">key,</span> <span class=\"string\">key1,</span> <span class=\"string\">key2,</span> <span class=\"string\">key3</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Charles</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-7-首页添加文章置顶\"><a href=\"#2-7-首页添加文章置顶\" class=\"headerlink\" title=\"2.7 首页添加文章置顶\"></a>2.7 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm uninstall hexo-generator-index --save</span><br><span class=\"line\">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: BlueLake博客主题的详细配置</span><br><span class=\"line\">tags: [hexo,BlueLake]</span><br><span class=\"line\">categories: hexo博客折腾</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-8-更换主题背景和添加文章版权信息\"><a href=\"#2-8-更换主题背景和添加文章版权信息\" class=\"headerlink\" title=\"2.8 更换主题背景和添加文章版权信息\"></a>2.8 更换主题背景和添加文章版权信息</h4><p>更换主题背景为深色</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"attr\">dark:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false</span></span><br></pre></td></tr></table></figure>\n\n<p>添加文章版权信息</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"comment\">#Copyright</span></span><br><span class=\"line\"><span class=\"attr\">copyright:</span> </span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false  </span></span><br><span class=\"line\"><span class=\"attr\">  describe:</span> <span class=\"string\">转载请注明出处(必须保留原文作者署名原文链接)</span> <span class=\"comment\">#自定义描述替换默认描述</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-9-其他配置\"><a href=\"#2-9-其他配置\" class=\"headerlink\" title=\"2.9 其他配置\"></a>2.9 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p>\n<ol>\n<li><code>show_category_count</code>——是否显示分类下的文章数。</li>\n<li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">show_category_count:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"attr\">widgets_on_small_screens:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h3><h4 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>、<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>、<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>、<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>、<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>、<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。</p>\n<ol>\n<li>注册并获得代码。<ul>\n<li>若使用<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>，注册多说后获得short_name。</li>\n<li>若使用<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>，注册Disqus后获得short_name。</li>\n<li>若使用<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>，注册来必力,获得data-uid。</li>\n<li>若使用<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>，注册友言,获得uid。</li>\n<li>若使用<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li>\n<li>若使用<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，注册畅言，获得appid，appkey。</li>\n</ul>\n</li>\n<li>配置<code>主题_config.yml</code>：<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Cmments</span></span><br><span class=\"line\"><span class=\"attr\">comment:</span></span><br><span class=\"line\"><span class=\"attr\">  duoshuo:</span> <span class=\"comment\">## duoshuo_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  disqus:</span> <span class=\"comment\">## disqus_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  livere:</span> <span class=\"comment\">## 来必力(data-uid)</span></span><br><span class=\"line\"><span class=\"attr\">  uyan:</span> <span class=\"comment\">## 友言(uid)</span></span><br><span class=\"line\"><span class=\"attr\">  cloudTie:</span> <span class=\"comment\">## 网易云跟帖(productKey)</span></span><br><span class=\"line\"><span class=\"attr\">  changyan:</span> <span class=\"comment\">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class=\"line\"><span class=\"attr\">    appid:</span> <span class=\"comment\">## 畅言(appid)</span></span><br><span class=\"line\"><span class=\"attr\">    appkey:</span> <span class=\"comment\">##畅言(appkey)</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h4><ol>\n<li>登录<a href=\"http://tongji.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度统计</a>，定位到站点的代码获取页面。</li>\n<li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li>\n<li>配置<code>主题_config.yml</code>:<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"number\">8006843039519956000</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n</blockquote>\n<h4 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h4><figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p>\n<h4 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>获取您自己的微博秀代码来替换。</p>\n<ol>\n<li>登录<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，选择微博秀。</li>\n<li>为了与主题风格统一，作如下配置<ul>\n<li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li>\n<li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li>\n<li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li>\n</ul>\n</li>\n<li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class=\"highlight stylus\"><figcaption><span>weibo.jade</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade\" target=\"_blank\" rel=\"noopener\">layout/_widget/weibo.jade</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line marked\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=<span class=\"string\">'fa fa-weibo'</span>)= <span class=\"string\">' '</span> + __(<span class=\"string\">'新浪微博'</span>)</span><br><span class=\"line\">  iframe(<span class=\"attribute\">width</span>=<span class=\"string\">\"100%\"</span>,height=<span class=\"string\">\"400\"</span>,class=<span class=\"string\">\"share_self\"</span>,frameborder=<span class=\"string\">\"0\"</span>,scrolling=<span class=\"string\">\"no\"</span>,src=<span class=\"string\">\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\"</span>)</span><br></pre></td></tr></table></figure>\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote>\n<p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p><a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake主题</a>写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>","more":"<p>在阅读本文之前，假定您已经成功安装了<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<blockquote>\n<p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>您可以直接到<a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p>\n<h4 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">BlueLake</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\n<h4 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><h4 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> </span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> </span><br><span class=\"line\"><span class=\"attr\">description:</span> </span><br><span class=\"line\"><span class=\"attr\">author:</span></span><br></pre></td></tr></table></figure>\n\n<p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p>\n<h4 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">archives/</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># - page: about</span></span><br><span class=\"line\">  <span class=\"comment\">#   directory: about/</span></span><br><span class=\"line\">  <span class=\"comment\">#   icon: fa-user</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">rss</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></table></figure>\n\n<p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">'about'</span></span><br></pre></td></tr></table></figure>\n\n<p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  photo_url:</span> <span class=\"comment\">## 头像的链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  weibo_name:</span> <span class=\"comment\">## 微博用户名 </span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_name:</span> <span class=\"comment\">## github用户名</span></span><br></pre></td></tr></table></figure>\n\n<p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p>\n<h5 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n\n<p>添加<code>主题_config.yml</code>配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Plugins:</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-feed</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-sitemap</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-baidu-sitemap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">atom</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">  limit:</span> <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>来创建JSON数据文件：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>根_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后在<code>主题_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">local_search:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为** favicon.ico <strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为</strong> apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h4 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站简要描述,如：Charles·Zheng's</span> <span class=\"string\">blog.</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站关键字,</span> <span class=\"string\">key,</span> <span class=\"string\">key1,</span> <span class=\"string\">key2,</span> <span class=\"string\">key3</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Charles</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-7-首页添加文章置顶\"><a href=\"#2-7-首页添加文章置顶\" class=\"headerlink\" title=\"2.7 首页添加文章置顶\"></a>2.7 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm uninstall hexo-generator-index --save</span><br><span class=\"line\">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: BlueLake博客主题的详细配置</span><br><span class=\"line\">tags: [hexo,BlueLake]</span><br><span class=\"line\">categories: hexo博客折腾</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-8-更换主题背景和添加文章版权信息\"><a href=\"#2-8-更换主题背景和添加文章版权信息\" class=\"headerlink\" title=\"2.8 更换主题背景和添加文章版权信息\"></a>2.8 更换主题背景和添加文章版权信息</h4><p>更换主题背景为深色</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"attr\">dark:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false</span></span><br></pre></td></tr></table></figure>\n\n<p>添加文章版权信息</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"comment\">#Copyright</span></span><br><span class=\"line\"><span class=\"attr\">copyright:</span> </span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false  </span></span><br><span class=\"line\"><span class=\"attr\">  describe:</span> <span class=\"string\">转载请注明出处(必须保留原文作者署名原文链接)</span> <span class=\"comment\">#自定义描述替换默认描述</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-9-其他配置\"><a href=\"#2-9-其他配置\" class=\"headerlink\" title=\"2.9 其他配置\"></a>2.9 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p>\n<ol>\n<li><code>show_category_count</code>——是否显示分类下的文章数。</li>\n<li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">show_category_count:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"attr\">widgets_on_small_screens:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h3><h4 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>、<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>、<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>、<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>、<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>、<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。</p>\n<ol>\n<li>注册并获得代码。<ul>\n<li>若使用<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>，注册多说后获得short_name。</li>\n<li>若使用<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>，注册Disqus后获得short_name。</li>\n<li>若使用<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>，注册来必力,获得data-uid。</li>\n<li>若使用<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>，注册友言,获得uid。</li>\n<li>若使用<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li>\n<li>若使用<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，注册畅言，获得appid，appkey。</li>\n</ul>\n</li>\n<li>配置<code>主题_config.yml</code>：<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Cmments</span></span><br><span class=\"line\"><span class=\"attr\">comment:</span></span><br><span class=\"line\"><span class=\"attr\">  duoshuo:</span> <span class=\"comment\">## duoshuo_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  disqus:</span> <span class=\"comment\">## disqus_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  livere:</span> <span class=\"comment\">## 来必力(data-uid)</span></span><br><span class=\"line\"><span class=\"attr\">  uyan:</span> <span class=\"comment\">## 友言(uid)</span></span><br><span class=\"line\"><span class=\"attr\">  cloudTie:</span> <span class=\"comment\">## 网易云跟帖(productKey)</span></span><br><span class=\"line\"><span class=\"attr\">  changyan:</span> <span class=\"comment\">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class=\"line\"><span class=\"attr\">    appid:</span> <span class=\"comment\">## 畅言(appid)</span></span><br><span class=\"line\"><span class=\"attr\">    appkey:</span> <span class=\"comment\">##畅言(appkey)</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h4><ol>\n<li>登录<a href=\"http://tongji.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度统计</a>，定位到站点的代码获取页面。</li>\n<li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li>\n<li>配置<code>主题_config.yml</code>:<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"number\">8006843039519956000</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n</blockquote>\n<h4 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h4><figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p>\n<h4 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>获取您自己的微博秀代码来替换。</p>\n<ol>\n<li>登录<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，选择微博秀。</li>\n<li>为了与主题风格统一，作如下配置<ul>\n<li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li>\n<li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li>\n<li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li>\n</ul>\n</li>\n<li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class=\"highlight stylus\"><figcaption><span>weibo.jade</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade\" target=\"_blank\" rel=\"noopener\">layout/_widget/weibo.jade</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line marked\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=<span class=\"string\">'fa fa-weibo'</span>)= <span class=\"string\">' '</span> + __(<span class=\"string\">'新浪微博'</span>)</span><br><span class=\"line\">  iframe(<span class=\"attribute\">width</span>=<span class=\"string\">\"100%\"</span>,height=<span class=\"string\">\"400\"</span>,class=<span class=\"string\">\"share_self\"</span>,frameborder=<span class=\"string\">\"0\"</span>,scrolling=<span class=\"string\">\"no\"</span>,src=<span class=\"string\">\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\"</span>)</span><br></pre></td></tr></table></figure>\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote>\n<p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p>\n</blockquote>\n</li>\n</ol>"},{"title":"MongoDB学习笔记","date":"2016-07-30T10:20:16.000Z","_content":"\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","source":"_posts/MongoDB学习笔记.md","raw":"---\ntitle: MongoDB学习笔记\ndate: 2016-07-30 18:20:16\ntags: mongodb\ncategories: 数据库\n---\n\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","slug":"MongoDB学习笔记","published":1,"updated":"2019-07-07T06:36:14.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylo6c002iyot3syqn37ca","content":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\" target=\"_blank\" rel=\"noopener\">http://www.mongodb.org/downloads</a>。</p>\n<a id=\"more\"></a> \n<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config</span><br></pre></td></tr></table></figure>\n\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot;</span><br></pre></td></tr></table></figure>\n\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil2\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">550</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil3\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">800</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"orange\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.4\"</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">\"item\"</span>: <span class=\"string\">\"human\"</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">'...'</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"count\"</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"count\"</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"count\"</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user0\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">\"age\"</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"john\"</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jess\"</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jeff\"</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"barney\"</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"john\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 4, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"barney\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"jess\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 4&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\" target=\"_blank\" rel=\"noopener\">http://www.mongodb.org/downloads</a>。</p>","more":"<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config</span><br></pre></td></tr></table></figure>\n\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot;</span><br></pre></td></tr></table></figure>\n\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil2\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">550</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil3\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">800</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"orange\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.4\"</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">\"item\"</span>: <span class=\"string\">\"human\"</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">'...'</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"count\"</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"count\"</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"count\"</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user0\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">\"age\"</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"john\"</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jess\"</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jeff\"</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"barney\"</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"john\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 4, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"barney\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"jess\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 4&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"[post]","title":"Win10下配置Nginx+PHP-7+MySQL-5.6","date":"2019-02-22T03:39:12.000Z","_content":"\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","source":"_posts/Win10下配置Nginx-php7-mysql-5-6.md","raw":"---\nlayout: '[post]'\ntitle: Win10下配置Nginx+PHP-7+MySQL-5.6\ndate: 2019-02-22 11:39:12\ntags:\n---\n\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","slug":"Win10下配置Nginx-php7-mysql-5-6","published":1,"updated":"2019-07-07T03:06:11.448Z","comments":1,"photos":[],"link":"","_id":"cjztylo6k002myot3e86rje0j","content":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\" target=\"_blank\" rel=\"noopener\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。<a id=\"more\"></a>\n<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p>\n<p>  配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p>\n<ol>\n<li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p>\n</li>\n<li><p>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>\n</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure></p>\n<p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure></p>\n<p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p>\n<p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\" target=\"_blank\" rel=\"noopener\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\" target=\"_blank\" rel=\"noopener\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。","more":"<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p>\n<p>  配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p>\n<ol>\n<li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p>\n</li>\n<li><p>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>\n</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure></p>\n<p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure></p>\n<p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p>\n<p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\" target=\"_blank\" rel=\"noopener\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>"},{"title":"数据库系统基础","date":"2019-07-22T12:20:19.000Z","_content":"\n\n### 1. 概述\n1. 数据库 是 电子化信息的集合\n  * 将信息规范化并使之电子化，形成电子信息'库'，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。\n2. 表(Table)：以按行按列形式组织及展现的数据\n<!-- more -->\n  * 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据-->关系\n3. 数据库系统的构成（概念层次）:\n  1. 数据库(DB):Database：相互之间有关联关系的数据的集合\n  2. 数据库管理系统(DBMS):Database Management System\n  3. 数据库应用(DBAP):Database Application\n  4. 数据库管理员(DBA):Database Asministrator\n  5. 计算机基本系统\n\n### 2. 数据库管理系统(DBMS)\n#### 2.1 从用户角度看DBMS(数据库管理系统)\n1. 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等\n  * DBMS提供了一套**数据定义语言(DDL**: Data Definition Language)给用户\n  * 用户使用DDL描述其所要建立的表的格式\n  * DBMS依照用户的定义，创建数据库及其中的表\n2. 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等\n  * DBMS提供了一套**数据库操纵语言(DML**: Data Manipulation Language)给用户\n  * 用户使用DML描述其所要进行的增、删、改、查等操作\n  * DBMS依照用户的操作描述，实际执行这些操作\n3. 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)\n  * DBMS提供了一套**数据控制语言(DCL**: Data Control Language)给用户\n  * 用户使用DCL描述其对数据库所要实施的控制\n  * DBMS依照用户描述，实际ijnx控制\n4. 数据库维护：转储/恢复/重组/性能监测/分析...\n  * DBMS提供了一系列程序(实用程序/例行程序)给用户\n  * 在这些程序中提供了对数据库维护的各种功能\n  * 用户使用这些程序进行各种数据库维护操作\n  * (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)\n\n\n#### 2.2 数据库语言 \n* 使用者使用数据库语言，利用DBMS操纵数据库\n* SQL语言：结构化的数据库语言\n* 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用\n\n\n#### 2.3 从系统实现角度看DBMS的功能\n1. 数据库管理系统的实现：形式 --> 构造 --> 自动化\n2. DBMS为完成DB管理，在后台运行着一系列程序...\n  + **语言编译器**：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等\n  + **查询优化**(执行引擎)与**查询实现**(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序\n  + **数据存取与索引**：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等\n  + **通信控制**：提供网络环境下数据库操作与数据传输的手段\n  + **事务管理**：提供提高可靠性并避免并发操作错误的手段\n  + **故障恢复**：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序\n  + **安全性控制**：提供合法性检验，避免非授权非法用户访问数据库的手段\n  + **完整性控制**：提供数据及数据操作正确性检查的手段\n  + **数据字典管理**：管理用户已经定义的信息\n  + **应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段\n  + **数据库数据装载、重组等实用程序**\n  + **数据库性能分析**：统计在运行过程中数据库的各种性能数据，便于优化运行\n\n> 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL \n\n\n### 3. 数据库系统的标准结构\n#### 3.1 DBMS管理数据的三个层次\n1. External Level = User Level（外部级别 = 用户级别）\n  * 某一用户能够看到与处理的数据,   全局数据中的某一部分\n2. Conceptual Level = Logic level（概念级别 = 逻辑级别）\n  * 从全局角度理解/管理的数据, 含相应的关联约束\n3. Internal Level = Physical level（内部级别 = 物理级别）\n  * 存储在介质上的数据，含存储路径、存储方式 、索引方式等\n\n#### 3.2 三级模式两层映像\n##### 3.2.1 数据(视图)与模式(数据的结构)\n+ 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息\n+ 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据\n\n##### 3.2.2 三级模式(三级视图)\n+ External Schema ----(External) View\n  * 某一用户能够看到与处理的数据的结构描述\n+ (Conceptual) Schema ---- Conceptual View\n  * 从全局角度理解/管理的数据的结构描述, 含相应的关联约束\n  * 体现在数据之间的内在本质联系\n+ Internal Schema ---- Internal  View\n  * 存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等\n\n##### 3.2.3 两层映像\n* E-C Mapping：External Schema-Conceptual Schema Mapping \n  + 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换\n  + 便于用户观察和使用\n* C-I Mapping：Conceptual Schema-Internal Schema Mapping \n  + 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换\n  + 便于计算机进行存储和处理\n\n#### 3.3 标准结构的两个独立性\n* 逻辑数据独立性\n  + 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序\n* 物理数据独立性\n  + 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式\n\n\n### 4. 数据模型\n* 数据模型：模式 与 模式的结构\n  - 规定模式统一描述方式的模型，包括：数据结构、操作和约束\n  - 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象\n  - 比如：关系模型：所有模式都可为抽象表(Table)的形式[**数据结构**]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[**操作**]和[**约束**]\n* 三大经典数据模型\n  - 关系模型：**表**的形式组织数据\n  - 层次模型：**树**的形式组织数据\n  - 网状模型：**图**的形式组织数据\n\n### 5. 关系模型\n* 形象地说，**一个关系(relation)就是一个Table**，关系模型就是处理Table的，它由三个部分组成：\n  + 描述DB各种数据的基本结构形式(Table/Relation)\n  + 描述Table与Table之间所可能发生的各种操作(关系运算)\n  + 描述这些操作所应遵循的约束条件(完整性约束)\n* 关系模型的三个要素：\n  + 基本结构：Relation/Table\n  + 基本操作：Relation Operator\n    - 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。\n    - 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算\n  + 完整性约束：实体完整性、参照完整性和用户自定义的完整性\n* 表(Table)的基本构成要素\n  + 列/字段/属性/数据项：列名，列值\n  + 行/元组/记录\n  + 标题/模式\n\n#### 5.1 “表”的严格定义\n* 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型\n* 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组\n* 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)\n\n#### 5.2 关系模式与关系\n* 同一关系模式下，可有很多的关系\n* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据\n* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的\n\n#### 5.3 关系的特性\n* 列是同质：即每一列中的分量来自同一域，是同一类型的数据\n* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。\n* 列位置互换性：区分哪一列是靠列名\n* 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)\n* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分\n* 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。\n* 属性不可再分特性:又被称为关系第一范式\n\n#### 5.4 关系的一些重要概念\n* 候选码(Candidate Key)/候选键\n  - 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉\n任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。\n* 主码(Primary Key)/主键\n  - 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组\n* 主属性与非主属性\n  - 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性\n  - 最简单的，候选码只包含一个属性；\n  - 极端的，所有属性构成这个关系的候选码，称为全码(All-Key)\n* 外码(Foreign Key)/外键\n  - 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。\n  - 两个关系通常是靠外码连接起来的。\n\n\n### 6. 关系模型中的完整性\n#### 6.1 实体完整性\n* 关系的主码中的属性值不能为空值；\n* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。\n\n#### 6.2 参照完整性\n* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值\n* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在\n\n#### 6.3 用户自定义完整性\n* 用户针对具体的应用环境定义的完整性约束条件\n\n#### 6.4 DBMS对关系完整性的支持\n* 实体完整性和参照完整性由DBMS系统自动支持\n* DBMS系统通常提供了如下机制：\n  1. 它使用户可以自行定义有关的完整性约束条件\n  2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性\n\n\n### 7. 关系代数\n#### 7.1 关系代数的特点\n* 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作\n* 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。\n* 关系代数操作以一个或多个关系为输入，结果是一个新的关系。\n* 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。\n* 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础\n\n#### 7.2 关系代数的约束\n某些关系代数操作，如并、差、交等，需满足\"并相容性\"\n\n* 并相容性\n  + 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性\n  + 定义：关系R与关系S存在相容性，当且仅当：\n    - (1) 关系R和关系S的属性数目必须相同；\n    - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同\n  + 示例：关系R：STUDENT(SID **char(10)**, Sname **char(8)**, Age **char(3)**)\n  + 示例：关系S：TEACHER(TID **char(10)**, Tname **char(8)**, Age **char(3)**)\n\n\n#### 7.3 关系代数的基本操作\n1. 集合操作\n  * 并（UNIO）：R∪S\n  * 交（INTERSECTION）：R∩S\n  * 差（DIFFERENCE）：R-S\n  * 笛卡儿积（Cartesian PRODUCT）：R×S\n2. 纯关系操作\n  * 投影（PROJECT）：∏ a(R)\n  * 选择（SELECT）：σ Con(R)\n  * 连接（JOIN）：R⋈S\n  * 除（DIVISION）：R÷S\n\n##### 7.3.1 并(Union) 操作\n* 定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**`R∪S`**, 它由 或者出现在关系R中，或者出现在S中的元组构成。\n* 数学描述：`R∪S = {t|t∈R ∨ t∈S}`，其中t是元组\n* 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。\n* 汉语中的“或者…或者…”通常意义是并运算的要求。\n* `R ∪S` 与 `S∪R` 运算的结果是**同**一个关系\n\n##### 7.3.2 差(Difference) 操作\n* 定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**`R-S`**, 它由出现在关系R中但不出现在关系S中的元组构成。\n* 数学描述：`R-S ={t|t∈R ∧ t(!∈)S }` ，其中t是元组\n* 汉语中的“是…但不含…”通常意义是差运算的要求。\n* `R-S` 与 `S-R` 是**不同**的\n\n##### 7.3.3 广义笛卡尔积(Cartesian Product) 操作\n* 定义：关系`R(<a1,a2, …,an>)`与关系`S(<b1,b2, …,bm >)`的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**`RxS`**, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。\n* 数学描述：`RxS = {<a1,a2,…,an,b1,b2,…,bm>|<a1,a2,…,an>∈R ∧ <b1,b2,…,bm>∈S}`\n* `RxS=SxR`：RxS为R中的每一个元组都和S中的所有元组进行串接。`SxR`为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。\n* 两个关系R和S，它们的**属性个数**分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).\n* 两个关系R和S，它们的**元组个数**分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).\n\n##### 7.3.4 选择(Select)\n* 定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作**`σ con(R)`**, 它从关系R中选择出满足给定条件condition的元组构成。\n* 数学描述：`con(R)={t|t(R)={t|t∈R ∧ con(t)='真'}`，\n* 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ `括弧()；θ；﹁；∧；∨` }\n\n##### 7.3.5 投影(Project)\n* 定义：给定一个关系R, 投影运算结果也是一个关系，记作**`A(R)`**, 它从关系R中选出属性包含在A中的列构成。\n* 数学描述：`∏ Ai1,Ai2,…,Aik (R) = {<t[Ai1],t[Ai2],…,t[Aik]> | t∈R}`\n* 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系\n\n\n#### 7.4 关系代数的扩展操作\n##### 7.4.1 交(Intersection)\n* **定义**：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**`R∩S`**, 它由同时出现在关系R和关系S中的元组构成。\n* 数学描述：`R∩S = {t|t∈R ∧ t∈S}`，其中t是元组\n* R∩S 和 S∩R 运算的结果是同一个关系\n* 交运算可以通过差运算来实现：`R∩S = R-(R-S) = S-(S-R)`\n* 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求\n\n##### 7.4.2 θ-连接(θ-Join, theta-Join)\n* 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作\n* **定义**：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **`R⋈[AθB]S`**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。\n* 数学描述：`R⋈[AθB]S = σ t[A] θ s[B] (R×S)`\n* 在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用\n* **特别注意**：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。\n\n##### 7.4.3 等值连接(Equi-Join)\n* **定义**：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**`R⋈[A=B]S`**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。\n* 数学描述：`R⋈[A=B]S = σ t[A] = s[B] (R×S)`\n* 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；\n* 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用**θ-连接/等值连接**运算可大幅度降低中间结果的保存量，提高速度。\n\n##### 7.4.4 自然连接(Natural-Join)\n* 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。\n* 数学描述：`R⋈S = σ t[B]=s[B](R×S)`\n* 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列\n\n#### 7.5 关系代数的基本书写思路\n1. 选出将用到的关系/表\n2. 做\"积\"运算（可用连接运算替换）\n3. 做选择运算保留所需的行/元组\n4. 做投影运算保留所需的列/属性\n\n- 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可\n- 如涉及多个表，则检查：\n  * 能否使用自然连接，将多个表连接起来(多数情况是这样的)\n  * 如不能，能否使用等值或不等值连接(-连接)\n  * 还不能，则使用广义笛卡尔积，注意相关条件的书写\n- 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作\n\n\n#### 7.6 关系代数之复杂扩展操作\n##### 7.6.1 除(Division)\n* 除法运算经常用于求解“查询… 全部的/所有的…”问题\n* 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m < n。\n* 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。\n* 数学描述：\n``` math\nR÷S = {t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) }\n    = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R)\n```\n\n##### 7.6.2 外连接(Outer-Join)\n* 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。\n* 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)\n* 外连接的形式：左外连接、右外连接、全外连接\n  - 左外连接 = 自然连接(或连接) + 左侧表中失配的元组\n  - 右外连接 = 自然连接(或连接) + 右侧表中失配的元组\n  - 全外连接 = 自然连接(或连接) + 两侧表中失配的元组\n  - 左外连接(Left Outer Join)记为：⋊\n  - 右外连接(Right Outer Join)记为：⋉\n  - 全外连接(Full Outer Join)记为：×\n\n\n### 8. 关系演算\n* 关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的\n* 按照谓词变量的不同，可分为关系元组演算和关系域演算\n  + 关系元组演算是以元组变量作为谓词变量的基本对象\n  + 关系域演算是以域变量作为谓词变量的基本对象\n\n#### 8.1 关系元组演算\n* 关系元组演算公式：{ t | P(t) }\n  - 表示：所有使谓词 P 为真的元组 t 的集合\n  - t 是元组变量\n  - t ∈ r 表示元组 t 在关系 r 中\n  - t[A] 表示元组 t 的分量，即 t 在属性 A 上的值\n  - P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式\n* 关系元组演算公式的基本形式：{ t | P(t) }\n* P(t)可以是如下三种形式之一的原子公式：\n  + t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}\n  + s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符<,<=,=,<>,>,>=\n  + s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，\n* P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造\n  + 如果F是一个公式，则 ﹁F 也是公式\n  + 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式\n* P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例\n\n","source":"_posts/01-数据库系统基础.md","raw":"---\ntitle: 数据库系统基础\ndate: 2019-07-22 20:20:19\ntags: [数据库, 后端开发]\ncategories: 数据库系统\n---\n\n\n### 1. 概述\n1. 数据库 是 电子化信息的集合\n  * 将信息规范化并使之电子化，形成电子信息'库'，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。\n2. 表(Table)：以按行按列形式组织及展现的数据\n<!-- more -->\n  * 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据-->关系\n3. 数据库系统的构成（概念层次）:\n  1. 数据库(DB):Database：相互之间有关联关系的数据的集合\n  2. 数据库管理系统(DBMS):Database Management System\n  3. 数据库应用(DBAP):Database Application\n  4. 数据库管理员(DBA):Database Asministrator\n  5. 计算机基本系统\n\n### 2. 数据库管理系统(DBMS)\n#### 2.1 从用户角度看DBMS(数据库管理系统)\n1. 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等\n  * DBMS提供了一套**数据定义语言(DDL**: Data Definition Language)给用户\n  * 用户使用DDL描述其所要建立的表的格式\n  * DBMS依照用户的定义，创建数据库及其中的表\n2. 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等\n  * DBMS提供了一套**数据库操纵语言(DML**: Data Manipulation Language)给用户\n  * 用户使用DML描述其所要进行的增、删、改、查等操作\n  * DBMS依照用户的操作描述，实际执行这些操作\n3. 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)\n  * DBMS提供了一套**数据控制语言(DCL**: Data Control Language)给用户\n  * 用户使用DCL描述其对数据库所要实施的控制\n  * DBMS依照用户描述，实际ijnx控制\n4. 数据库维护：转储/恢复/重组/性能监测/分析...\n  * DBMS提供了一系列程序(实用程序/例行程序)给用户\n  * 在这些程序中提供了对数据库维护的各种功能\n  * 用户使用这些程序进行各种数据库维护操作\n  * (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)\n\n\n#### 2.2 数据库语言 \n* 使用者使用数据库语言，利用DBMS操纵数据库\n* SQL语言：结构化的数据库语言\n* 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用\n\n\n#### 2.3 从系统实现角度看DBMS的功能\n1. 数据库管理系统的实现：形式 --> 构造 --> 自动化\n2. DBMS为完成DB管理，在后台运行着一系列程序...\n  + **语言编译器**：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等\n  + **查询优化**(执行引擎)与**查询实现**(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序\n  + **数据存取与索引**：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等\n  + **通信控制**：提供网络环境下数据库操作与数据传输的手段\n  + **事务管理**：提供提高可靠性并避免并发操作错误的手段\n  + **故障恢复**：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序\n  + **安全性控制**：提供合法性检验，避免非授权非法用户访问数据库的手段\n  + **完整性控制**：提供数据及数据操作正确性检查的手段\n  + **数据字典管理**：管理用户已经定义的信息\n  + **应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段\n  + **数据库数据装载、重组等实用程序**\n  + **数据库性能分析**：统计在运行过程中数据库的各种性能数据，便于优化运行\n\n> 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL \n\n\n### 3. 数据库系统的标准结构\n#### 3.1 DBMS管理数据的三个层次\n1. External Level = User Level（外部级别 = 用户级别）\n  * 某一用户能够看到与处理的数据,   全局数据中的某一部分\n2. Conceptual Level = Logic level（概念级别 = 逻辑级别）\n  * 从全局角度理解/管理的数据, 含相应的关联约束\n3. Internal Level = Physical level（内部级别 = 物理级别）\n  * 存储在介质上的数据，含存储路径、存储方式 、索引方式等\n\n#### 3.2 三级模式两层映像\n##### 3.2.1 数据(视图)与模式(数据的结构)\n+ 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息\n+ 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据\n\n##### 3.2.2 三级模式(三级视图)\n+ External Schema ----(External) View\n  * 某一用户能够看到与处理的数据的结构描述\n+ (Conceptual) Schema ---- Conceptual View\n  * 从全局角度理解/管理的数据的结构描述, 含相应的关联约束\n  * 体现在数据之间的内在本质联系\n+ Internal Schema ---- Internal  View\n  * 存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等\n\n##### 3.2.3 两层映像\n* E-C Mapping：External Schema-Conceptual Schema Mapping \n  + 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换\n  + 便于用户观察和使用\n* C-I Mapping：Conceptual Schema-Internal Schema Mapping \n  + 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换\n  + 便于计算机进行存储和处理\n\n#### 3.3 标准结构的两个独立性\n* 逻辑数据独立性\n  + 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序\n* 物理数据独立性\n  + 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式\n\n\n### 4. 数据模型\n* 数据模型：模式 与 模式的结构\n  - 规定模式统一描述方式的模型，包括：数据结构、操作和约束\n  - 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象\n  - 比如：关系模型：所有模式都可为抽象表(Table)的形式[**数据结构**]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[**操作**]和[**约束**]\n* 三大经典数据模型\n  - 关系模型：**表**的形式组织数据\n  - 层次模型：**树**的形式组织数据\n  - 网状模型：**图**的形式组织数据\n\n### 5. 关系模型\n* 形象地说，**一个关系(relation)就是一个Table**，关系模型就是处理Table的，它由三个部分组成：\n  + 描述DB各种数据的基本结构形式(Table/Relation)\n  + 描述Table与Table之间所可能发生的各种操作(关系运算)\n  + 描述这些操作所应遵循的约束条件(完整性约束)\n* 关系模型的三个要素：\n  + 基本结构：Relation/Table\n  + 基本操作：Relation Operator\n    - 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。\n    - 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算\n  + 完整性约束：实体完整性、参照完整性和用户自定义的完整性\n* 表(Table)的基本构成要素\n  + 列/字段/属性/数据项：列名，列值\n  + 行/元组/记录\n  + 标题/模式\n\n#### 5.1 “表”的严格定义\n* 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型\n* 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组\n* 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)\n\n#### 5.2 关系模式与关系\n* 同一关系模式下，可有很多的关系\n* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据\n* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的\n\n#### 5.3 关系的特性\n* 列是同质：即每一列中的分量来自同一域，是同一类型的数据\n* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。\n* 列位置互换性：区分哪一列是靠列名\n* 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)\n* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分\n* 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。\n* 属性不可再分特性:又被称为关系第一范式\n\n#### 5.4 关系的一些重要概念\n* 候选码(Candidate Key)/候选键\n  - 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉\n任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。\n* 主码(Primary Key)/主键\n  - 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组\n* 主属性与非主属性\n  - 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性\n  - 最简单的，候选码只包含一个属性；\n  - 极端的，所有属性构成这个关系的候选码，称为全码(All-Key)\n* 外码(Foreign Key)/外键\n  - 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。\n  - 两个关系通常是靠外码连接起来的。\n\n\n### 6. 关系模型中的完整性\n#### 6.1 实体完整性\n* 关系的主码中的属性值不能为空值；\n* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。\n\n#### 6.2 参照完整性\n* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值\n* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在\n\n#### 6.3 用户自定义完整性\n* 用户针对具体的应用环境定义的完整性约束条件\n\n#### 6.4 DBMS对关系完整性的支持\n* 实体完整性和参照完整性由DBMS系统自动支持\n* DBMS系统通常提供了如下机制：\n  1. 它使用户可以自行定义有关的完整性约束条件\n  2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性\n\n\n### 7. 关系代数\n#### 7.1 关系代数的特点\n* 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作\n* 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。\n* 关系代数操作以一个或多个关系为输入，结果是一个新的关系。\n* 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。\n* 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础\n\n#### 7.2 关系代数的约束\n某些关系代数操作，如并、差、交等，需满足\"并相容性\"\n\n* 并相容性\n  + 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性\n  + 定义：关系R与关系S存在相容性，当且仅当：\n    - (1) 关系R和关系S的属性数目必须相同；\n    - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同\n  + 示例：关系R：STUDENT(SID **char(10)**, Sname **char(8)**, Age **char(3)**)\n  + 示例：关系S：TEACHER(TID **char(10)**, Tname **char(8)**, Age **char(3)**)\n\n\n#### 7.3 关系代数的基本操作\n1. 集合操作\n  * 并（UNIO）：R∪S\n  * 交（INTERSECTION）：R∩S\n  * 差（DIFFERENCE）：R-S\n  * 笛卡儿积（Cartesian PRODUCT）：R×S\n2. 纯关系操作\n  * 投影（PROJECT）：∏ a(R)\n  * 选择（SELECT）：σ Con(R)\n  * 连接（JOIN）：R⋈S\n  * 除（DIVISION）：R÷S\n\n##### 7.3.1 并(Union) 操作\n* 定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**`R∪S`**, 它由 或者出现在关系R中，或者出现在S中的元组构成。\n* 数学描述：`R∪S = {t|t∈R ∨ t∈S}`，其中t是元组\n* 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。\n* 汉语中的“或者…或者…”通常意义是并运算的要求。\n* `R ∪S` 与 `S∪R` 运算的结果是**同**一个关系\n\n##### 7.3.2 差(Difference) 操作\n* 定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**`R-S`**, 它由出现在关系R中但不出现在关系S中的元组构成。\n* 数学描述：`R-S ={t|t∈R ∧ t(!∈)S }` ，其中t是元组\n* 汉语中的“是…但不含…”通常意义是差运算的要求。\n* `R-S` 与 `S-R` 是**不同**的\n\n##### 7.3.3 广义笛卡尔积(Cartesian Product) 操作\n* 定义：关系`R(<a1,a2, …,an>)`与关系`S(<b1,b2, …,bm >)`的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**`RxS`**, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。\n* 数学描述：`RxS = {<a1,a2,…,an,b1,b2,…,bm>|<a1,a2,…,an>∈R ∧ <b1,b2,…,bm>∈S}`\n* `RxS=SxR`：RxS为R中的每一个元组都和S中的所有元组进行串接。`SxR`为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。\n* 两个关系R和S，它们的**属性个数**分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).\n* 两个关系R和S，它们的**元组个数**分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).\n\n##### 7.3.4 选择(Select)\n* 定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作**`σ con(R)`**, 它从关系R中选择出满足给定条件condition的元组构成。\n* 数学描述：`con(R)={t|t(R)={t|t∈R ∧ con(t)='真'}`，\n* 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ `括弧()；θ；﹁；∧；∨` }\n\n##### 7.3.5 投影(Project)\n* 定义：给定一个关系R, 投影运算结果也是一个关系，记作**`A(R)`**, 它从关系R中选出属性包含在A中的列构成。\n* 数学描述：`∏ Ai1,Ai2,…,Aik (R) = {<t[Ai1],t[Ai2],…,t[Aik]> | t∈R}`\n* 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系\n\n\n#### 7.4 关系代数的扩展操作\n##### 7.4.1 交(Intersection)\n* **定义**：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**`R∩S`**, 它由同时出现在关系R和关系S中的元组构成。\n* 数学描述：`R∩S = {t|t∈R ∧ t∈S}`，其中t是元组\n* R∩S 和 S∩R 运算的结果是同一个关系\n* 交运算可以通过差运算来实现：`R∩S = R-(R-S) = S-(S-R)`\n* 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求\n\n##### 7.4.2 θ-连接(θ-Join, theta-Join)\n* 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作\n* **定义**：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **`R⋈[AθB]S`**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。\n* 数学描述：`R⋈[AθB]S = σ t[A] θ s[B] (R×S)`\n* 在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用\n* **特别注意**：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。\n\n##### 7.4.3 等值连接(Equi-Join)\n* **定义**：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**`R⋈[A=B]S`**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。\n* 数学描述：`R⋈[A=B]S = σ t[A] = s[B] (R×S)`\n* 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；\n* 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用**θ-连接/等值连接**运算可大幅度降低中间结果的保存量，提高速度。\n\n##### 7.4.4 自然连接(Natural-Join)\n* 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。\n* 数学描述：`R⋈S = σ t[B]=s[B](R×S)`\n* 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列\n\n#### 7.5 关系代数的基本书写思路\n1. 选出将用到的关系/表\n2. 做\"积\"运算（可用连接运算替换）\n3. 做选择运算保留所需的行/元组\n4. 做投影运算保留所需的列/属性\n\n- 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可\n- 如涉及多个表，则检查：\n  * 能否使用自然连接，将多个表连接起来(多数情况是这样的)\n  * 如不能，能否使用等值或不等值连接(-连接)\n  * 还不能，则使用广义笛卡尔积，注意相关条件的书写\n- 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作\n\n\n#### 7.6 关系代数之复杂扩展操作\n##### 7.6.1 除(Division)\n* 除法运算经常用于求解“查询… 全部的/所有的…”问题\n* 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m < n。\n* 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。\n* 数学描述：\n``` math\nR÷S = {t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) }\n    = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R)\n```\n\n##### 7.6.2 外连接(Outer-Join)\n* 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。\n* 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)\n* 外连接的形式：左外连接、右外连接、全外连接\n  - 左外连接 = 自然连接(或连接) + 左侧表中失配的元组\n  - 右外连接 = 自然连接(或连接) + 右侧表中失配的元组\n  - 全外连接 = 自然连接(或连接) + 两侧表中失配的元组\n  - 左外连接(Left Outer Join)记为：⋊\n  - 右外连接(Right Outer Join)记为：⋉\n  - 全外连接(Full Outer Join)记为：×\n\n\n### 8. 关系演算\n* 关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的\n* 按照谓词变量的不同，可分为关系元组演算和关系域演算\n  + 关系元组演算是以元组变量作为谓词变量的基本对象\n  + 关系域演算是以域变量作为谓词变量的基本对象\n\n#### 8.1 关系元组演算\n* 关系元组演算公式：{ t | P(t) }\n  - 表示：所有使谓词 P 为真的元组 t 的集合\n  - t 是元组变量\n  - t ∈ r 表示元组 t 在关系 r 中\n  - t[A] 表示元组 t 的分量，即 t 在属性 A 上的值\n  - P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式\n* 关系元组演算公式的基本形式：{ t | P(t) }\n* P(t)可以是如下三种形式之一的原子公式：\n  + t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}\n  + s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符<,<=,=,<>,>,>=\n  + s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，\n* P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造\n  + 如果F是一个公式，则 ﹁F 也是公式\n  + 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式\n* P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例\n\n","slug":"01-数据库系统基础","published":1,"updated":"2019-08-27T14:36:49.827Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztyloag0035yot3edfc0tb5","content":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><ol>\n<li>数据库 是 电子化信息的集合<ul>\n<li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li>\n</ul>\n</li>\n<li>表(Table)：以按行按列形式组织及展现的数据<a id=\"more\"></a>\n<ul>\n<li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li>\n</ul>\n</li>\n<li>数据库系统的构成（概念层次）:<ol>\n<li>数据库(DB):Database：相互之间有关联关系的数据的集合</li>\n<li>数据库管理系统(DBMS):Database Management System</li>\n<li>数据库应用(DBAP):Database Application</li>\n<li>数据库管理员(DBA):Database Asministrator</li>\n<li>计算机基本系统</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-数据库管理系统-DBMS\"><a href=\"#2-数据库管理系统-DBMS\" class=\"headerlink\" title=\"2. 数据库管理系统(DBMS)\"></a>2. 数据库管理系统(DBMS)</h3><h4 id=\"2-1-从用户角度看DBMS-数据库管理系统\"><a href=\"#2-1-从用户角度看DBMS-数据库管理系统\" class=\"headerlink\" title=\"2.1 从用户角度看DBMS(数据库管理系统)\"></a>2.1 从用户角度看DBMS(数据库管理系统)</h4><ol>\n<li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul>\n<li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li>\n<li>用户使用DDL描述其所要建立的表的格式</li>\n<li>DBMS依照用户的定义，创建数据库及其中的表</li>\n</ul>\n</li>\n<li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul>\n<li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li>\n<li>用户使用DML描述其所要进行的增、删、改、查等操作</li>\n<li>DBMS依照用户的操作描述，实际执行这些操作</li>\n</ul>\n</li>\n<li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul>\n<li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li>\n<li>用户使用DCL描述其对数据库所要实施的控制</li>\n<li>DBMS依照用户描述，实际ijnx控制</li>\n</ul>\n</li>\n<li>数据库维护：转储/恢复/重组/性能监测/分析…<ul>\n<li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li>\n<li>在这些程序中提供了对数据库维护的各种功能</li>\n<li>用户使用这些程序进行各种数据库维护操作</li>\n<li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-数据库语言\"><a href=\"#2-2-数据库语言\" class=\"headerlink\" title=\"2.2 数据库语言\"></a>2.2 数据库语言</h4><ul>\n<li>使用者使用数据库语言，利用DBMS操纵数据库</li>\n<li>SQL语言：结构化的数据库语言</li>\n<li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li>\n</ul>\n<h4 id=\"2-3-从系统实现角度看DBMS的功能\"><a href=\"#2-3-从系统实现角度看DBMS的功能\" class=\"headerlink\" title=\"2.3 从系统实现角度看DBMS的功能\"></a>2.3 从系统实现角度看DBMS的功能</h4><ol>\n<li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li>\n<li>DBMS为完成DB管理，在后台运行着一系列程序…<ul>\n<li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li>\n<li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li>\n<li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li>\n<li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li>\n<li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li>\n<li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li>\n<li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li>\n<li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li>\n<li><strong>数据字典管理</strong>：管理用户已经定义的信息</li>\n<li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li>\n<li><strong>数据库数据装载、重组等实用程序</strong></li>\n<li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p>\n</blockquote>\n<h3 id=\"3-数据库系统的标准结构\"><a href=\"#3-数据库系统的标准结构\" class=\"headerlink\" title=\"3. 数据库系统的标准结构\"></a>3. 数据库系统的标准结构</h3><h4 id=\"3-1-DBMS管理数据的三个层次\"><a href=\"#3-1-DBMS管理数据的三个层次\" class=\"headerlink\" title=\"3.1 DBMS管理数据的三个层次\"></a>3.1 DBMS管理数据的三个层次</h4><ol>\n<li>External Level = User Level（外部级别 = 用户级别）<ul>\n<li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li>\n</ul>\n</li>\n<li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul>\n<li>从全局角度理解/管理的数据, 含相应的关联约束</li>\n</ul>\n</li>\n<li>Internal Level = Physical level（内部级别 = 物理级别）<ul>\n<li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-2-三级模式两层映像\"><a href=\"#3-2-三级模式两层映像\" class=\"headerlink\" title=\"3.2 三级模式两层映像\"></a>3.2 三级模式两层映像</h4><h5 id=\"3-2-1-数据-视图-与模式-数据的结构\"><a href=\"#3-2-1-数据-视图-与模式-数据的结构\" class=\"headerlink\" title=\"3.2.1 数据(视图)与模式(数据的结构)\"></a>3.2.1 数据(视图)与模式(数据的结构)</h5><ul>\n<li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li>\n<li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li>\n</ul>\n<h5 id=\"3-2-2-三级模式-三级视图\"><a href=\"#3-2-2-三级模式-三级视图\" class=\"headerlink\" title=\"3.2.2 三级模式(三级视图)\"></a>3.2.2 三级模式(三级视图)</h5><ul>\n<li>External Schema —-(External) View<ul>\n<li>某一用户能够看到与处理的数据的结构描述</li>\n</ul>\n</li>\n<li>(Conceptual) Schema —- Conceptual View<ul>\n<li>从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li>\n<li>体现在数据之间的内在本质联系</li>\n</ul>\n</li>\n<li>Internal Schema —- Internal  View<ul>\n<li>存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-2-3-两层映像\"><a href=\"#3-2-3-两层映像\" class=\"headerlink\" title=\"3.2.3 两层映像\"></a>3.2.3 两层映像</h5><ul>\n<li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul>\n<li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li>\n<li>便于用户观察和使用</li>\n</ul>\n</li>\n<li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul>\n<li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li>\n<li>便于计算机进行存储和处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-标准结构的两个独立性\"><a href=\"#3-3-标准结构的两个独立性\" class=\"headerlink\" title=\"3.3 标准结构的两个独立性\"></a>3.3 标准结构的两个独立性</h4><ul>\n<li>逻辑数据独立性<ul>\n<li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li>\n</ul>\n</li>\n<li>物理数据独立性<ul>\n<li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-数据模型\"><a href=\"#4-数据模型\" class=\"headerlink\" title=\"4. 数据模型\"></a>4. 数据模型</h3><ul>\n<li>数据模型：模式 与 模式的结构<ul>\n<li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li>\n<li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li>\n<li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li>\n</ul>\n</li>\n<li>三大经典数据模型<ul>\n<li>关系模型：<strong>表</strong>的形式组织数据</li>\n<li>层次模型：<strong>树</strong>的形式组织数据</li>\n<li>网状模型：<strong>图</strong>的形式组织数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-关系模型\"><a href=\"#5-关系模型\" class=\"headerlink\" title=\"5. 关系模型\"></a>5. 关系模型</h3><ul>\n<li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul>\n<li>描述DB各种数据的基本结构形式(Table/Relation)</li>\n<li>描述Table与Table之间所可能发生的各种操作(关系运算)</li>\n<li>描述这些操作所应遵循的约束条件(完整性约束)</li>\n</ul>\n</li>\n<li>关系模型的三个要素：<ul>\n<li>基本结构：Relation/Table</li>\n<li>基本操作：Relation Operator<ul>\n<li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li>\n<li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li>\n</ul>\n</li>\n<li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li>\n</ul>\n</li>\n<li>表(Table)的基本构成要素<ul>\n<li>列/字段/属性/数据项：列名，列值</li>\n<li>行/元组/记录</li>\n<li>标题/模式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-“表”的严格定义\"><a href=\"#5-1-“表”的严格定义\" class=\"headerlink\" title=\"5.1 “表”的严格定义\"></a>5.1 “表”的严格定义</h4><ul>\n<li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li>\n<li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li>\n<li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li>\n</ul>\n<h4 id=\"5-2-关系模式与关系\"><a href=\"#5-2-关系模式与关系\" class=\"headerlink\" title=\"5.2 关系模式与关系\"></a>5.2 关系模式与关系</h4><ul>\n<li>同一关系模式下，可有很多的关系</li>\n<li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li>\n<li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li>\n</ul>\n<h4 id=\"5-3-关系的特性\"><a href=\"#5-3-关系的特性\" class=\"headerlink\" title=\"5.3 关系的特性\"></a>5.3 关系的特性</h4><ul>\n<li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li>\n<li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li>\n<li>列位置互换性：区分哪一列是靠列名</li>\n<li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li>\n<li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li>\n<li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li>\n<li>属性不可再分特性:又被称为关系第一范式</li>\n</ul>\n<h4 id=\"5-4-关系的一些重要概念\"><a href=\"#5-4-关系的一些重要概念\" class=\"headerlink\" title=\"5.4 关系的一些重要概念\"></a>5.4 关系的一些重要概念</h4><ul>\n<li>候选码(Candidate Key)/候选键<ul>\n<li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li>\n</ul>\n</li>\n<li>主码(Primary Key)/主键<ul>\n<li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li>\n</ul>\n</li>\n<li>主属性与非主属性<ul>\n<li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li>\n<li>最简单的，候选码只包含一个属性；</li>\n<li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li>\n</ul>\n</li>\n<li>外码(Foreign Key)/外键<ul>\n<li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li>\n<li>两个关系通常是靠外码连接起来的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-关系模型中的完整性\"><a href=\"#6-关系模型中的完整性\" class=\"headerlink\" title=\"6. 关系模型中的完整性\"></a>6. 关系模型中的完整性</h3><h4 id=\"6-1-实体完整性\"><a href=\"#6-1-实体完整性\" class=\"headerlink\" title=\"6.1 实体完整性\"></a>6.1 实体完整性</h4><ul>\n<li>关系的主码中的属性值不能为空值；</li>\n<li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li>\n</ul>\n<h4 id=\"6-2-参照完整性\"><a href=\"#6-2-参照完整性\" class=\"headerlink\" title=\"6.2 参照完整性\"></a>6.2 参照完整性</h4><ul>\n<li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li>\n<li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li>\n</ul>\n<h4 id=\"6-3-用户自定义完整性\"><a href=\"#6-3-用户自定义完整性\" class=\"headerlink\" title=\"6.3 用户自定义完整性\"></a>6.3 用户自定义完整性</h4><ul>\n<li>用户针对具体的应用环境定义的完整性约束条件</li>\n</ul>\n<h4 id=\"6-4-DBMS对关系完整性的支持\"><a href=\"#6-4-DBMS对关系完整性的支持\" class=\"headerlink\" title=\"6.4 DBMS对关系完整性的支持\"></a>6.4 DBMS对关系完整性的支持</h4><ul>\n<li>实体完整性和参照完整性由DBMS系统自动支持</li>\n<li>DBMS系统通常提供了如下机制：<ol>\n<li>它使用户可以自行定义有关的完整性约束条件</li>\n<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"7-关系代数\"><a href=\"#7-关系代数\" class=\"headerlink\" title=\"7. 关系代数\"></a>7. 关系代数</h3><h4 id=\"7-1-关系代数的特点\"><a href=\"#7-1-关系代数的特点\" class=\"headerlink\" title=\"7.1 关系代数的特点\"></a>7.1 关系代数的特点</h4><ul>\n<li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li>\n<li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li>\n<li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li>\n<li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li>\n<li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li>\n</ul>\n<h4 id=\"7-2-关系代数的约束\"><a href=\"#7-2-关系代数的约束\" class=\"headerlink\" title=\"7.2 关系代数的约束\"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p>\n<ul>\n<li>并相容性<ul>\n<li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li>\n<li>定义：关系R与关系S存在相容性，当且仅当：<ul>\n<li>(1) 关系R和关系S的属性数目必须相同；</li>\n<li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li>\n</ul>\n</li>\n<li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n<li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-3-关系代数的基本操作\"><a href=\"#7-3-关系代数的基本操作\" class=\"headerlink\" title=\"7.3 关系代数的基本操作\"></a>7.3 关系代数的基本操作</h4><ol>\n<li>集合操作<ul>\n<li>并（UNIO）：R∪S</li>\n<li>交（INTERSECTION）：R∩S</li>\n<li>差（DIFFERENCE）：R-S</li>\n<li>笛卡儿积（Cartesian PRODUCT）：R×S</li>\n</ul>\n</li>\n<li>纯关系操作<ul>\n<li>投影（PROJECT）：∏ a(R)</li>\n<li>选择（SELECT）：σ Con(R)</li>\n<li>连接（JOIN）：R⋈S</li>\n<li>除（DIVISION）：R÷S</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"7-3-1-并-Union-操作\"><a href=\"#7-3-1-并-Union-操作\" class=\"headerlink\" title=\"7.3.1 并(Union) 操作\"></a>7.3.1 并(Union) 操作</h5><ul>\n<li>定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li>\n<li>数学描述：<code>R∪S = {t|t∈R ∨ t∈S}</code>，其中t是元组</li>\n<li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li>\n<li>汉语中的“或者…或者…”通常意义是并运算的要求。</li>\n<li><code>R ∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li>\n</ul>\n<h5 id=\"7-3-2-差-Difference-操作\"><a href=\"#7-3-2-差-Difference-操作\" class=\"headerlink\" title=\"7.3.2 差(Difference) 操作\"></a>7.3.2 差(Difference) 操作</h5><ul>\n<li>定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li>\n<li>数学描述：<code>R-S ={t|t∈R ∧ t(!∈)S }</code> ，其中t是元组</li>\n<li>汉语中的“是…但不含…”通常意义是差运算的要求。</li>\n<li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li>\n</ul>\n<h5 id=\"7-3-3-广义笛卡尔积-Cartesian-Product-操作\"><a href=\"#7-3-3-广义笛卡尔积-Cartesian-Product-操作\" class=\"headerlink\" title=\"7.3.3 广义笛卡尔积(Cartesian Product) 操作\"></a>7.3.3 广义笛卡尔积(Cartesian Product) 操作</h5><ul>\n<li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。</li>\n<li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li>\n<li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li>\n<li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li>\n<li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li>\n</ul>\n<h5 id=\"7-3-4-选择-Select\"><a href=\"#7-3-4-选择-Select\" class=\"headerlink\" title=\"7.3.4 选择(Select)\"></a>7.3.4 选择(Select)</h5><ul>\n<li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作<strong><code>σ con(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li>\n<li>数学描述：<code>con(R)={t|t(R)={t|t∈R ∧ con(t)=&#39;真&#39;}</code>，</li>\n<li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；﹁；∧；∨</code> }</li>\n</ul>\n<h5 id=\"7-3-5-投影-Project\"><a href=\"#7-3-5-投影-Project\" class=\"headerlink\" title=\"7.3.5 投影(Project)\"></a>7.3.5 投影(Project)</h5><ul>\n<li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li>\n<li>数学描述：<code>∏ Ai1,Ai2,…,Aik (R) = {&lt;t[Ai1],t[Ai2],…,t[Aik]&gt; | t∈R}</code></li>\n<li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li>\n</ul>\n<h4 id=\"7-4-关系代数的扩展操作\"><a href=\"#7-4-关系代数的扩展操作\" class=\"headerlink\" title=\"7.4 关系代数的扩展操作\"></a>7.4 关系代数的扩展操作</h4><h5 id=\"7-4-1-交-Intersection\"><a href=\"#7-4-1-交-Intersection\" class=\"headerlink\" title=\"7.4.1 交(Intersection)\"></a>7.4.1 交(Intersection)</h5><ul>\n<li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li>\n<li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li>\n<li>R∩S 和 S∩R 运算的结果是同一个关系</li>\n<li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li>\n<li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li>\n</ul>\n<h5 id=\"7-4-2-θ-连接-θ-Join-theta-Join\"><a href=\"#7-4-2-θ-连接-θ-Join-theta-Join\" class=\"headerlink\" title=\"7.4.2 θ-连接(θ-Join, theta-Join)\"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul>\n<li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈[AθB]S</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li>\n<li>数学描述：<code>R⋈[AθB]S = σ t[A] θ s[B] (R×S)</code></li>\n<li>在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用</li>\n<li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li>\n</ul>\n<h5 id=\"7-4-3-等值连接-Equi-Join\"><a href=\"#7-4-3-等值连接-Equi-Join\" class=\"headerlink\" title=\"7.4.3 等值连接(Equi-Join)\"></a>7.4.3 等值连接(Equi-Join)</h5><ul>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈[A=B]S</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈[A=B]S = σ t[A] = s[B] (R×S)</code></li>\n<li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li>\n<li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li>\n</ul>\n<h5 id=\"7-4-4-自然连接-Natural-Join\"><a href=\"#7-4-4-自然连接-Natural-Join\" class=\"headerlink\" title=\"7.4.4 自然连接(Natural-Join)\"></a>7.4.4 自然连接(Natural-Join)</h5><ul>\n<li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S = σ t[B]=s[B](R×S)</code></li>\n<li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li>\n</ul>\n<h4 id=\"7-5-关系代数的基本书写思路\"><a href=\"#7-5-关系代数的基本书写思路\" class=\"headerlink\" title=\"7.5 关系代数的基本书写思路\"></a>7.5 关系代数的基本书写思路</h4><ol>\n<li>选出将用到的关系/表</li>\n<li>做”积”运算（可用连接运算替换）</li>\n<li>做选择运算保留所需的行/元组</li>\n<li>做投影运算保留所需的列/属性</li>\n</ol>\n<ul>\n<li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li>\n<li>如涉及多个表，则检查：<ul>\n<li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li>\n<li>如不能，能否使用等值或不等值连接(-连接)</li>\n<li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li>\n</ul>\n</li>\n<li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li>\n</ul>\n<h4 id=\"7-6-关系代数之复杂扩展操作\"><a href=\"#7-6-关系代数之复杂扩展操作\" class=\"headerlink\" title=\"7.6 关系代数之复杂扩展操作\"></a>7.6 关系代数之复杂扩展操作</h4><h5 id=\"7-6-1-除-Division\"><a href=\"#7-6-1-除-Division\" class=\"headerlink\" title=\"7.6.1 除(Division)\"></a>7.6.1 除(Division)</h5><ul>\n<li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li>\n<li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li>\n<li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li>\n<li>数学描述：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R÷S = &#123;t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) &#125;</span><br><span class=\"line\">    = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"7-6-2-外连接-Outer-Join\"><a href=\"#7-6-2-外连接-Outer-Join\" class=\"headerlink\" title=\"7.6.2 外连接(Outer-Join)\"></a>7.6.2 外连接(Outer-Join)</h5><ul>\n<li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li>\n<li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li>\n<li>外连接的形式：左外连接、右外连接、全外连接<ul>\n<li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li>\n<li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li>\n<li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li>\n<li>左外连接(Left Outer Join)记为：⋊</li>\n<li>右外连接(Right Outer Join)记为：⋉</li>\n<li>全外连接(Full Outer Join)记为：×</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-关系演算\"><a href=\"#8-关系演算\" class=\"headerlink\" title=\"8. 关系演算\"></a>8. 关系演算</h3><ul>\n<li>关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</li>\n<li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ul>\n<li>关系元组演算是以元组变量作为谓词变量的基本对象</li>\n<li>关系域演算是以域变量作为谓词变量的基本对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-1-关系元组演算\"><a href=\"#8-1-关系元组演算\" class=\"headerlink\" title=\"8.1 关系元组演算\"></a>8.1 关系元组演算</h4><ul>\n<li>关系元组演算公式：{ t | P(t) }<ul>\n<li>表示：所有使谓词 P 为真的元组 t 的集合</li>\n<li>t 是元组变量</li>\n<li>t ∈ r 表示元组 t 在关系 r 中</li>\n<li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li>\n<li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li>\n</ul>\n</li>\n<li>关系元组演算公式的基本形式：{ t | P(t) }</li>\n<li>P(t)可以是如下三种形式之一的原子公式：<ul>\n<li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li>\n<li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li>\n<li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li>\n</ul>\n</li>\n<li>P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造<ul>\n<li>如果F是一个公式，则 ﹁F 也是公式</li>\n<li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li>\n</ul>\n</li>\n<li>P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><ol>\n<li>数据库 是 电子化信息的集合<ul>\n<li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li>\n</ul>\n</li>\n<li>表(Table)：以按行按列形式组织及展现的数据","more":"<ul>\n<li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li>\n</ul>\n</li>\n<li>数据库系统的构成（概念层次）:<ol>\n<li>数据库(DB):Database：相互之间有关联关系的数据的集合</li>\n<li>数据库管理系统(DBMS):Database Management System</li>\n<li>数据库应用(DBAP):Database Application</li>\n<li>数据库管理员(DBA):Database Asministrator</li>\n<li>计算机基本系统</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-数据库管理系统-DBMS\"><a href=\"#2-数据库管理系统-DBMS\" class=\"headerlink\" title=\"2. 数据库管理系统(DBMS)\"></a>2. 数据库管理系统(DBMS)</h3><h4 id=\"2-1-从用户角度看DBMS-数据库管理系统\"><a href=\"#2-1-从用户角度看DBMS-数据库管理系统\" class=\"headerlink\" title=\"2.1 从用户角度看DBMS(数据库管理系统)\"></a>2.1 从用户角度看DBMS(数据库管理系统)</h4><ol>\n<li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等<ul>\n<li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li>\n<li>用户使用DDL描述其所要建立的表的格式</li>\n<li>DBMS依照用户的定义，创建数据库及其中的表</li>\n</ul>\n</li>\n<li>数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等<ul>\n<li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li>\n<li>用户使用DML描述其所要进行的增、删、改、查等操作</li>\n<li>DBMS依照用户的操作描述，实际执行这些操作</li>\n</ul>\n</li>\n<li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)<ul>\n<li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li>\n<li>用户使用DCL描述其对数据库所要实施的控制</li>\n<li>DBMS依照用户描述，实际ijnx控制</li>\n</ul>\n</li>\n<li>数据库维护：转储/恢复/重组/性能监测/分析…<ul>\n<li>DBMS提供了一系列程序(实用程序/例行程序)给用户</li>\n<li>在这些程序中提供了对数据库维护的各种功能</li>\n<li>用户使用这些程序进行各种数据库维护操作</li>\n<li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-数据库语言\"><a href=\"#2-2-数据库语言\" class=\"headerlink\" title=\"2.2 数据库语言\"></a>2.2 数据库语言</h4><ul>\n<li>使用者使用数据库语言，利用DBMS操纵数据库</li>\n<li>SQL语言：结构化的数据库语言</li>\n<li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li>\n</ul>\n<h4 id=\"2-3-从系统实现角度看DBMS的功能\"><a href=\"#2-3-从系统实现角度看DBMS的功能\" class=\"headerlink\" title=\"2.3 从系统实现角度看DBMS的功能\"></a>2.3 从系统实现角度看DBMS的功能</h4><ol>\n<li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li>\n<li>DBMS为完成DB管理，在后台运行着一系列程序…<ul>\n<li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li>\n<li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li>\n<li><strong>数据存取与索引</strong>：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等</li>\n<li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li>\n<li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li>\n<li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li>\n<li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li>\n<li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li>\n<li><strong>数据字典管理</strong>：管理用户已经定义的信息</li>\n<li><strong>应用程序接口(API)</strong>：提供应用程序使用DBMS特定功能的二首段</li>\n<li><strong>数据库数据装载、重组等实用程序</strong></li>\n<li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p>\n</blockquote>\n<h3 id=\"3-数据库系统的标准结构\"><a href=\"#3-数据库系统的标准结构\" class=\"headerlink\" title=\"3. 数据库系统的标准结构\"></a>3. 数据库系统的标准结构</h3><h4 id=\"3-1-DBMS管理数据的三个层次\"><a href=\"#3-1-DBMS管理数据的三个层次\" class=\"headerlink\" title=\"3.1 DBMS管理数据的三个层次\"></a>3.1 DBMS管理数据的三个层次</h4><ol>\n<li>External Level = User Level（外部级别 = 用户级别）<ul>\n<li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li>\n</ul>\n</li>\n<li>Conceptual Level = Logic level（概念级别 = 逻辑级别）<ul>\n<li>从全局角度理解/管理的数据, 含相应的关联约束</li>\n</ul>\n</li>\n<li>Internal Level = Physical level（内部级别 = 物理级别）<ul>\n<li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-2-三级模式两层映像\"><a href=\"#3-2-三级模式两层映像\" class=\"headerlink\" title=\"3.2 三级模式两层映像\"></a>3.2 三级模式两层映像</h4><h5 id=\"3-2-1-数据-视图-与模式-数据的结构\"><a href=\"#3-2-1-数据-视图-与模式-数据的结构\" class=\"headerlink\" title=\"3.2.1 数据(视图)与模式(数据的结构)\"></a>3.2.1 数据(视图)与模式(数据的结构)</h5><ul>\n<li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li>\n<li>视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据</li>\n</ul>\n<h5 id=\"3-2-2-三级模式-三级视图\"><a href=\"#3-2-2-三级模式-三级视图\" class=\"headerlink\" title=\"3.2.2 三级模式(三级视图)\"></a>3.2.2 三级模式(三级视图)</h5><ul>\n<li>External Schema —-(External) View<ul>\n<li>某一用户能够看到与处理的数据的结构描述</li>\n</ul>\n</li>\n<li>(Conceptual) Schema —- Conceptual View<ul>\n<li>从全局角度理解/管理的数据的结构描述, 含相应的关联约束</li>\n<li>体现在数据之间的内在本质联系</li>\n</ul>\n</li>\n<li>Internal Schema —- Internal  View<ul>\n<li>存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"3-2-3-两层映像\"><a href=\"#3-2-3-两层映像\" class=\"headerlink\" title=\"3.2.3 两层映像\"></a>3.2.3 两层映像</h5><ul>\n<li>E-C Mapping：External Schema-Conceptual Schema Mapping <ul>\n<li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li>\n<li>便于用户观察和使用</li>\n</ul>\n</li>\n<li>C-I Mapping：Conceptual Schema-Internal Schema Mapping <ul>\n<li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li>\n<li>便于计算机进行存储和处理</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-标准结构的两个独立性\"><a href=\"#3-3-标准结构的两个独立性\" class=\"headerlink\" title=\"3.3 标准结构的两个独立性\"></a>3.3 标准结构的两个独立性</h4><ul>\n<li>逻辑数据独立性<ul>\n<li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li>\n</ul>\n</li>\n<li>物理数据独立性<ul>\n<li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-数据模型\"><a href=\"#4-数据模型\" class=\"headerlink\" title=\"4. 数据模型\"></a>4. 数据模型</h3><ul>\n<li>数据模型：模式 与 模式的结构<ul>\n<li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li>\n<li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li>\n<li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li>\n</ul>\n</li>\n<li>三大经典数据模型<ul>\n<li>关系模型：<strong>表</strong>的形式组织数据</li>\n<li>层次模型：<strong>树</strong>的形式组织数据</li>\n<li>网状模型：<strong>图</strong>的形式组织数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-关系模型\"><a href=\"#5-关系模型\" class=\"headerlink\" title=\"5. 关系模型\"></a>5. 关系模型</h3><ul>\n<li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：<ul>\n<li>描述DB各种数据的基本结构形式(Table/Relation)</li>\n<li>描述Table与Table之间所可能发生的各种操作(关系运算)</li>\n<li>描述这些操作所应遵循的约束条件(完整性约束)</li>\n</ul>\n</li>\n<li>关系模型的三个要素：<ul>\n<li>基本结构：Relation/Table</li>\n<li>基本操作：Relation Operator<ul>\n<li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li>\n<li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li>\n</ul>\n</li>\n<li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li>\n</ul>\n</li>\n<li>表(Table)的基本构成要素<ul>\n<li>列/字段/属性/数据项：列名，列值</li>\n<li>行/元组/记录</li>\n<li>标题/模式</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-“表”的严格定义\"><a href=\"#5-1-“表”的严格定义\" class=\"headerlink\" title=\"5.1 “表”的严格定义\"></a>5.1 “表”的严格定义</h4><ul>\n<li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li>\n<li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li>\n<li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li>\n</ul>\n<h4 id=\"5-2-关系模式与关系\"><a href=\"#5-2-关系模式与关系\" class=\"headerlink\" title=\"5.2 关系模式与关系\"></a>5.2 关系模式与关系</h4><ul>\n<li>同一关系模式下，可有很多的关系</li>\n<li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li>\n<li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li>\n</ul>\n<h4 id=\"5-3-关系的特性\"><a href=\"#5-3-关系的特性\" class=\"headerlink\" title=\"5.3 关系的特性\"></a>5.3 关系的特性</h4><ul>\n<li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li>\n<li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li>\n<li>列位置互换性：区分哪一列是靠列名</li>\n<li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)</li>\n<li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li>\n<li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li>\n<li>属性不可再分特性:又被称为关系第一范式</li>\n</ul>\n<h4 id=\"5-4-关系的一些重要概念\"><a href=\"#5-4-关系的一些重要概念\" class=\"headerlink\" title=\"5.4 关系的一些重要概念\"></a>5.4 关系的一些重要概念</h4><ul>\n<li>候选码(Candidate Key)/候选键<ul>\n<li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li>\n</ul>\n</li>\n<li>主码(Primary Key)/主键<ul>\n<li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li>\n</ul>\n</li>\n<li>主属性与非主属性<ul>\n<li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li>\n<li>最简单的，候选码只包含一个属性；</li>\n<li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li>\n</ul>\n</li>\n<li>外码(Foreign Key)/外键<ul>\n<li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li>\n<li>两个关系通常是靠外码连接起来的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-关系模型中的完整性\"><a href=\"#6-关系模型中的完整性\" class=\"headerlink\" title=\"6. 关系模型中的完整性\"></a>6. 关系模型中的完整性</h3><h4 id=\"6-1-实体完整性\"><a href=\"#6-1-实体完整性\" class=\"headerlink\" title=\"6.1 实体完整性\"></a>6.1 实体完整性</h4><ul>\n<li>关系的主码中的属性值不能为空值；</li>\n<li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li>\n</ul>\n<h4 id=\"6-2-参照完整性\"><a href=\"#6-2-参照完整性\" class=\"headerlink\" title=\"6.2 参照完整性\"></a>6.2 参照完整性</h4><ul>\n<li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li>\n<li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li>\n</ul>\n<h4 id=\"6-3-用户自定义完整性\"><a href=\"#6-3-用户自定义完整性\" class=\"headerlink\" title=\"6.3 用户自定义完整性\"></a>6.3 用户自定义完整性</h4><ul>\n<li>用户针对具体的应用环境定义的完整性约束条件</li>\n</ul>\n<h4 id=\"6-4-DBMS对关系完整性的支持\"><a href=\"#6-4-DBMS对关系完整性的支持\" class=\"headerlink\" title=\"6.4 DBMS对关系完整性的支持\"></a>6.4 DBMS对关系完整性的支持</h4><ul>\n<li>实体完整性和参照完整性由DBMS系统自动支持</li>\n<li>DBMS系统通常提供了如下机制：<ol>\n<li>它使用户可以自行定义有关的完整性约束条件</li>\n<li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"7-关系代数\"><a href=\"#7-关系代数\" class=\"headerlink\" title=\"7. 关系代数\"></a>7. 关系代数</h3><h4 id=\"7-1-关系代数的特点\"><a href=\"#7-1-关系代数的特点\" class=\"headerlink\" title=\"7.1 关系代数的特点\"></a>7.1 关系代数的特点</h4><ul>\n<li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li>\n<li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li>\n<li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li>\n<li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li>\n<li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li>\n</ul>\n<h4 id=\"7-2-关系代数的约束\"><a href=\"#7-2-关系代数的约束\" class=\"headerlink\" title=\"7.2 关系代数的约束\"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p>\n<ul>\n<li>并相容性<ul>\n<li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li>\n<li>定义：关系R与关系S存在相容性，当且仅当：<ul>\n<li>(1) 关系R和关系S的属性数目必须相同；</li>\n<li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li>\n</ul>\n</li>\n<li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n<li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-3-关系代数的基本操作\"><a href=\"#7-3-关系代数的基本操作\" class=\"headerlink\" title=\"7.3 关系代数的基本操作\"></a>7.3 关系代数的基本操作</h4><ol>\n<li>集合操作<ul>\n<li>并（UNIO）：R∪S</li>\n<li>交（INTERSECTION）：R∩S</li>\n<li>差（DIFFERENCE）：R-S</li>\n<li>笛卡儿积（Cartesian PRODUCT）：R×S</li>\n</ul>\n</li>\n<li>纯关系操作<ul>\n<li>投影（PROJECT）：∏ a(R)</li>\n<li>选择（SELECT）：σ Con(R)</li>\n<li>连接（JOIN）：R⋈S</li>\n<li>除（DIVISION）：R÷S</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"7-3-1-并-Union-操作\"><a href=\"#7-3-1-并-Union-操作\" class=\"headerlink\" title=\"7.3.1 并(Union) 操作\"></a>7.3.1 并(Union) 操作</h5><ul>\n<li>定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：<strong><code>R∪S</code></strong>, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li>\n<li>数学描述：<code>R∪S = {t|t∈R ∨ t∈S}</code>，其中t是元组</li>\n<li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li>\n<li>汉语中的“或者…或者…”通常意义是并运算的要求。</li>\n<li><code>R ∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li>\n</ul>\n<h5 id=\"7-3-2-差-Difference-操作\"><a href=\"#7-3-2-差-Difference-操作\" class=\"headerlink\" title=\"7.3.2 差(Difference) 操作\"></a>7.3.2 差(Difference) 操作</h5><ul>\n<li>定义：假设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：<strong><code>R-S</code></strong>, 它由出现在关系R中但不出现在关系S中的元组构成。</li>\n<li>数学描述：<code>R-S ={t|t∈R ∧ t(!∈)S }</code> ，其中t是元组</li>\n<li>汉语中的“是…但不含…”通常意义是差运算的要求。</li>\n<li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li>\n</ul>\n<h5 id=\"7-3-3-广义笛卡尔积-Cartesian-Product-操作\"><a href=\"#7-3-3-广义笛卡尔积-Cartesian-Product-操作\" class=\"headerlink\" title=\"7.3.3 广义笛卡尔积(Cartesian Product) 操作\"></a>7.3.3 广义笛卡尔积(Cartesian Product) 操作</h5><ul>\n<li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：<strong><code>RxS</code></strong>, 它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。</li>\n<li>数学描述：<code>RxS = {&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S}</code></li>\n<li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li>\n<li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li>\n<li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数×,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).</li>\n</ul>\n<h5 id=\"7-3-4-选择-Select\"><a href=\"#7-3-4-选择-Select\" class=\"headerlink\" title=\"7.3.4 选择(Select)\"></a>7.3.4 选择(Select)</h5><ul>\n<li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记con), 选择运算结果也是一个关系，记作<strong><code>σ con(R)</code></strong>, 它从关系R中选择出满足给定条件condition的元组构成。</li>\n<li>数学描述：<code>con(R)={t|t(R)={t|t∈R ∧ con(t)=&#39;真&#39;}</code>，</li>\n<li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；﹁；∧；∨</code> }</li>\n</ul>\n<h5 id=\"7-3-5-投影-Project\"><a href=\"#7-3-5-投影-Project\" class=\"headerlink\" title=\"7.3.5 投影(Project)\"></a>7.3.5 投影(Project)</h5><ul>\n<li>定义：给定一个关系R, 投影运算结果也是一个关系，记作<strong><code>A(R)</code></strong>, 它从关系R中选出属性包含在A中的列构成。</li>\n<li>数学描述：<code>∏ Ai1,Ai2,…,Aik (R) = {&lt;t[Ai1],t[Ai2],…,t[Aik]&gt; | t∈R}</code></li>\n<li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li>\n</ul>\n<h4 id=\"7-4-关系代数的扩展操作\"><a href=\"#7-4-关系代数的扩展操作\" class=\"headerlink\" title=\"7.4 关系代数的扩展操作\"></a>7.4 关系代数的扩展操作</h4><h5 id=\"7-4-1-交-Intersection\"><a href=\"#7-4-1-交-Intersection\" class=\"headerlink\" title=\"7.4.1 交(Intersection)\"></a>7.4.1 交(Intersection)</h5><ul>\n<li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：<strong><code>R∩S</code></strong>, 它由同时出现在关系R和关系S中的元组构成。</li>\n<li>数学描述：<code>R∩S = {t|t∈R ∧ t∈S}</code>，其中t是元组</li>\n<li>R∩S 和 S∩R 运算的结果是同一个关系</li>\n<li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li>\n<li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li>\n</ul>\n<h5 id=\"7-4-2-θ-连接-θ-Join-theta-Join\"><a href=\"#7-4-2-θ-连接-θ-Join-theta-Join\" class=\"headerlink\" title=\"7.4.2 θ-连接(θ-Join, theta-Join)\"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul>\n<li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 <strong><code>R⋈[AθB]S</code></strong>：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li>\n<li>数学描述：<code>R⋈[AθB]S = σ t[A] θ s[B] (R×S)</code></li>\n<li>在实际应用中，θ-连接操作经常与投影∏、选择σ操作一起使用</li>\n<li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li>\n</ul>\n<h5 id=\"7-4-3-等值连接-Equi-Join\"><a href=\"#7-4-3-等值连接-Equi-Join\" class=\"headerlink\" title=\"7.4.3 等值连接(Equi-Join)\"></a>7.4.3 等值连接(Equi-Join)</h5><ul>\n<li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作<strong><code>R⋈[A=B]S</code></strong>：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈[A=B]S = σ t[A] = s[B] (R×S)</code></li>\n<li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li>\n<li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接/等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li>\n</ul>\n<h5 id=\"7-4-4-自然连接-Natural-Join\"><a href=\"#7-4-4-自然连接-Natural-Join\" class=\"headerlink\" title=\"7.4.4 自然连接(Natural-Join)\"></a>7.4.4 自然连接(Natural-Join)</h5><ul>\n<li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li>\n<li>数学描述：<code>R⋈S = σ t[B]=s[B](R×S)</code></li>\n<li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li>\n</ul>\n<h4 id=\"7-5-关系代数的基本书写思路\"><a href=\"#7-5-关系代数的基本书写思路\" class=\"headerlink\" title=\"7.5 关系代数的基本书写思路\"></a>7.5 关系代数的基本书写思路</h4><ol>\n<li>选出将用到的关系/表</li>\n<li>做”积”运算（可用连接运算替换）</li>\n<li>做选择运算保留所需的行/元组</li>\n<li>做投影运算保留所需的列/属性</li>\n</ol>\n<ul>\n<li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li>\n<li>如涉及多个表，则检查：<ul>\n<li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li>\n<li>如不能，能否使用等值或不等值连接(-连接)</li>\n<li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li>\n</ul>\n</li>\n<li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li>\n</ul>\n<h4 id=\"7-6-关系代数之复杂扩展操作\"><a href=\"#7-6-关系代数之复杂扩展操作\" class=\"headerlink\" title=\"7.6 关系代数之复杂扩展操作\"></a>7.6 关系代数之复杂扩展操作</h4><h5 id=\"7-6-1-除-Division\"><a href=\"#7-6-1-除-Division\" class=\"headerlink\" title=\"7.6.1 除(Division)\"></a>7.6.1 除(Division)</h5><ul>\n<li>除法运算经常用于求解“查询… 全部的/所有的…”问题</li>\n<li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li>\n<li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li>\n<li>数学描述：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R÷S = &#123;t|t∈∏[R-S](R) ∧ ▽u∈S(tu∈R) &#125;</span><br><span class=\"line\">    = ∏[R-S](R) - ∏[R-S]((∏[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h5 id=\"7-6-2-外连接-Outer-Join\"><a href=\"#7-6-2-外连接-Outer-Join\" class=\"headerlink\" title=\"7.6.2 外连接(Outer-Join)\"></a>7.6.2 外连接(Outer-Join)</h5><ul>\n<li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li>\n<li>外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li>\n<li>外连接的形式：左外连接、右外连接、全外连接<ul>\n<li>左外连接 = 自然连接(或连接) + 左侧表中失配的元组</li>\n<li>右外连接 = 自然连接(或连接) + 右侧表中失配的元组</li>\n<li>全外连接 = 自然连接(或连接) + 两侧表中失配的元组</li>\n<li>左外连接(Left Outer Join)记为：⋊</li>\n<li>右外连接(Right Outer Join)记为：⋉</li>\n<li>全外连接(Full Outer Join)记为：×</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-关系演算\"><a href=\"#8-关系演算\" class=\"headerlink\" title=\"8. 关系演算\"></a>8. 关系演算</h3><ul>\n<li>关系演算是描述关系运算的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</li>\n<li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ul>\n<li>关系元组演算是以元组变量作为谓词变量的基本对象</li>\n<li>关系域演算是以域变量作为谓词变量的基本对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"8-1-关系元组演算\"><a href=\"#8-1-关系元组演算\" class=\"headerlink\" title=\"8.1 关系元组演算\"></a>8.1 关系元组演算</h4><ul>\n<li>关系元组演算公式：{ t | P(t) }<ul>\n<li>表示：所有使谓词 P 为真的元组 t 的集合</li>\n<li>t 是元组变量</li>\n<li>t ∈ r 表示元组 t 在关系 r 中</li>\n<li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li>\n<li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li>\n</ul>\n</li>\n<li>关系元组演算公式的基本形式：{ t | P(t) }</li>\n<li>P(t)可以是如下三种形式之一的原子公式：<ul>\n<li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li>\n<li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=</li>\n<li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li>\n</ul>\n</li>\n<li>P(t)可以由公式加运算符 ∧(与)、∨(或)、﹁(非)递归地构造<ul>\n<li>如果F是一个公式，则 ﹁F 也是公式</li>\n<li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li>\n</ul>\n</li>\n<li>P(t)运算符优先次序(括弧；θ；E；▽；﹁；∧；∨)示例</li>\n</ul>"},{"title":"四、JavaSE集合框架","date":"2019-07-08T14:10:57.000Z","_content":"\n\n为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。\n<!-- more -->\n\n1. [Collection集合](#id1)\n2. [List集合](#id2)\n3. [泛型机制](#id3)\n4. [Queue集合](#id4)\n5. [*ArrayList类](#id5)\n6. [Vector类](#id6)\n7. [Stack类](#id7)\n8. [*LinkedList类](#id8)\n9. [Set集合](#id9)\n10. [HashSet类](#id10)\n11. [TreeSet类](#id11)\n12. [Map集合](#id12)\n13. [HashMap类](#id13)\n14. [TreeMap类](#id14)\n15. [Lambda表达式](#id15)\n16. [Stream API](#id16)\n\n\n<span id=\"id1\"><span>\n### 1. Collection集合\n- Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。\n\n> 数组与集合的比较\n> - 数组的特点：\n    1. 数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；\n    2. 支持下标访问，实现随机访问非常方便；\n    3. 增删操作不方便，可能会移动大量元素；\n    4. 数组一旦声明长度固定无法更改；\n    5. 数组支持基本数据类型，也支持引用数据类型；\n> - 集合的特点：\n    1. 集合的存储单元可以不连续，数据类容可以不相同；\n    2. 集合部分支持下标访问，部分不支持；\n    3. 集合中增删元素可以不移动大量元素；\n    4. 集合大小可以随时动态调整；\n    5. 集合中的元素必须是引用数据类型（基本数据类型可用包装类）；\n\n```\n-Collection接口\n    |————List接口\n        |————ArrayList类\n        |————LinkedList类\n        |————Stack类\n        |————Vector类\n    |————Queue接口\n        |————LinkedList类\n    |————Set接口\n        |————HashSet类\n        |————TreeSet类\n-Map接口\n    |————HashMap类\n    |————TreeMap类\n```\n\n> - Collection存储的都是value,其中List有序可重复，Set无序无重复\n> - Map存储的是以key-value形式,key无序无重复 value无序可重复\n> - 序 : 顺序--添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序\n\n|Collection集合的常用方法||\n|----------|------------|\n|boolean add(E e); | 向集合中添加对象|\n|boolean contains(Object o); | 判断是否包含指定对象|\n|boolean remove(Object o); | 从集合中删除对象|\n|void clear(); | 清空集合 |\n|int size(); | 返回包含对象的个数 |\n|boolean isEmpty(); | 判断是否为空 |\n\n``` java\nCollection c2 = new ArrayList(); //多态\nboolean b1 = c2.add(new String(\"one\")); //true\nboolean b2 = c2.add(new Integer(2)); //true\nSystem.out.println(\"c2 = \" + c2); //[one, 2]\n\nboolean b3 = c2.contains(new Integer(2));//true\n//contains方法工作原理：(o==null ? e==null : o.equals(e));\n```\n\n\n<span id=\"id2\"><span>\n### 2. List集合\n- java.util.List集合是Collection集合的子集合。\n- List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。\n    - ArrayList类的底层使用**数组**进行数据管理，访问元素方便，增删不方便。\n    - LinkedList类的底层使用**链表**进行数据管理，访问不方便，增删方便。\n    - Stark类的底层使用数组进行数据管理，该类主要描述具有**后进先出**的特征的数据结构，叫做**栈**。\n    - Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。\n- List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。\n\n|List类常用方法|   |\n|----|---|\n|void add(int index, E element)|向集合指定位置添加元素|\n|boolean addAll(int index, Collection<?extends E> c)|向集合中添加所有元素|\n|E get(int index)|从集合中获取指定位置的元素|\n|E set(int index, E element)|修改指定位置的元素|\n|E remove(int index)|删除指定位置的元素|\n|int indexOf(Object o)|在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))|\n|<T> T[] toArray(T[] a)|将集合中的对象序列化以对象数组的形式返回。|\n|List<E> subList(int fromIndex, int toIndex)|获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图|\n \n\n<span id=\"id3\"><span>\n### 3. 泛型机制\n- 集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。\n- 从jdk1.5开始推出泛型机制，在集合名称后面使用<数据类型>的方式明确要求该集合中可以存放的数据类型。如：`List<String> lt = new LinkedList<String>();`。\n- 从jdk1.7开始可省略后面<>的数据类型，叫做`菱形特性`，如：`List<String> lt = new ArrayList<>();`。\n- 泛型本质就是参数化类型，让数据类型作为参数传递，`public interface List<E>{}`其中`E`是占位形参，由于实参可以支持各种广泛的类型，因此得名`泛型`。\n- 泛型可以用在哪里：\n    1. 泛型类：类定义的时候描述某种数据类型，集合的使用就是这样\n    2. 泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型\n    3. 泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中\n    4. 方法参数泛型限制，高级泛型，规范边界，extends，super\n\n\n<span id=\"id4\"><span>\n### 4. Queue集合\n- java.util.Queue集合是Collection集合的子集合。\n- Queue集合主要描述具有**先进先出**特性的数据结构，叫做**队列**(FIFO:First Input First Output)。\n- Queue集合主要实现类是`LinkedList类`，因为该类在增删方面有一定优势。\n\n|Queue接口中主要方法| |\n|----------|--------|\n|boolean offer(E e)| 将一个对象添加至队尾，若添加成功则返回true|\n|E poll()|从队首删除并返回一个元素|\n|E peek()|返回队首的元素（但并不删除）|\n\n``` java\nQueue<Integer> q1 = new LinkedList<Integer>();\n//将数据11、22、33、44、55依次入队\nfor(int i=1; i<=5; i++) {\n    q1.offer(i*11);\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. *ArrayList类\n1. 底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util\n2. ArrayList特点适合遍历轮询，不适合插入删除\n3. 如何构建一个ArrayList对象\n    - 无参数构造方法，带默认容量构造方法，带collection参数的构造方法\n4. ArrayList中常用的方法\n    - 增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()\n5. 类中其他常用的方法\n    - addAll并集，removeAll差集，ratainAll交集;\n    - indexOf()，lastIndexOf()，contains()，List=subList();\n    - isEmpty()，clear()，ensureCapacity()，iterator();迭代器\n    - toArray(T[] x)，trimToSize();\n\n\n<span id=\"id6\"><span>\n### 6. Vector类\n1. 是ArrayList集合的早期版本，所属的包 java.util\n    - Vector底层也是利用(动态)数组的形式存储\n    - Vector是线程同步的(synchronized)，安全性高，效率较低\n2. 扩容方式与ArrayList不同\n    - 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制\n3. 构造方法和常用方法与ArrayList类似\n\n\n<span id=\"id7\"><span>\n### 7. Stack类\n1. Stack类，栈，java.util包\n2. 构造方法只有一个无参数\n3. 除了继承自Vacton类的方法外还有特殊的方法\n    - push(E e)将某一个元素压入栈顶(add())\n    - E = pop()将某一个元素从栈顶取出并删掉(E = remove())\n    - E = peek()查看栈顶的一个元素 不删除(get())\n    - boolean = empty()判断栈内元素是否为空(isEmpty())\n    - int = search()查找给定的元素在占中的位置(indexOf())\n4. 应用场景\n    - 中国象棋，悔棋\n    - 栈中存储每一次操作的步骤\n    - 撤销功能\n\n\n<span id=\"id8\"><span>\n### 8. *LinkedList类\n1. LinkedList类，java.util包\n2. 底层使用**双向链表**的数据结构形式来存储\n    - 适合于插入或删除  不适合遍历轮询\n3. 构建对象\n    - 无参数构造方法，带参数的构造方法(collection)\n4. 常用的方法\n    - 增删改查：add()，remove()，set()，get()，size()，offer，poll，peek\n    - 手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()\n5. 插入删除的特性是否像想的那样\n    - 对比ArrayList  Linked\n\n\n<span id=\"id9\"><span>\n### 9. Set集合\n- java.util.Set集合是Collection集合的子集合。\n- Set集合没有先后放入次序，并且不允许有重复关系，实现类有`HashSet类`和`TreeSet`类。\n- 其中`HashSet类`底层是采用哈希表进行数据管理的。\n- 其中`TreeSet类`的底层是采用二叉树进行数据管理的。\n\n``` java\n//方法和Collection集合基本一样\nSet<String> set1 = new HashSet<String>();\nset1.add(\"one\");\nSystem.out.println(\"s1=\"+s1);\n```\n\n- set集合的无重复特性\n    * HashSet，无重复原则有两个方法同时起作用\n        - equals    hashCode\n        - 默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入\n        - 如果想要改变其比较的规则  可以重写上述两个方法\n    * TreeSet，无重复原则有一个方法起作用\n        - compareTo\n        - 上述这个方法不是每一个对象都有的\n        - 若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable\n        - 实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后\n\n#### 9.1 Set集合的遍历\n- 所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。\n\n|迭代器`Iterator<E> iterator()`，主要方法有||\n|---------------|-------------------------|\n|boolean hasNext() | 判断集合中是否有可以迭代/访问的元素 |\n|E next() | 用于取出一个元素并指向下一个元素|\n|void remove() | 用于删除访问到的最后一个元素|\n\n``` java\nIterator<String> it = set1.iterator();//获取当前集合的迭代器对象\nwhile(it.hasNext()) {//判断是否有可以访问的元素\n    String temp = it.next();//取出一个并指向下一个\n    System.out.println( temp );\n    if(\"two\".equals(temp)){\n        it.remove();//删除set1中该元素\n    }\n}\n```\n\n- 增强for循环(for each结构)\n- 语法格式：`for(元素类型 变量名:集合/数组){ 循环体; }`。\n- 执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。\n\n``` java\n//遍历集合\nfor(String ts : s1) {\n    System.out.println(ts);\n}\n//遍历数组\nint[] arr = {11,22,33,44,55};\nfor(int ti : arr) {\n    System.out.println(ti);\n}\n```\n\n\n<span id=\"id10\"><span>\n### 10. HashSet类\n1. HashSet集合底层采用HashMap（数组+链表-->散列表），java.util包。\n2. 它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 \n3. 创建对象：无参数，有参数\n4. 集合容器的基本使用\n    - 增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)\n    - 没有修改方法\n    - iterator()  获取一个迭代器对象\n    - size()\n5. 无重复的原则\n    - 在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)\n\n\n<span id=\"id11\"><span>\n### 11. TreeSet类\n1. TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))\n2. 创建对象： 无参数构造方法 ，带Collection构造方法\n3. 基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()\n4. 二叉树主要指每个节点最多只有两个子节点的树形结构。\n5. 满足以下三个特征的二叉树叫做**有序二叉树**：\n    * 左子树中的任意节点元素都小于根节点元素；\n    * 右子树中的任意节点元素都大于根节点元素；\n    * 左子树和右子树内部也遵守上述规则；\n6. 无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。\n\n7. 元素放入TreeSet集合过程：\n由于TreeSet集合底层采用**有序二叉树**进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：\n    1. 使用元素的**自然排序**规则进行比较并排序，让元素类型实现java.lang.Comparable接口；\n    2. 使用**比较器规则**进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；\n\n> 注意：\n    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；\n    2. 可以使用Collections工具类对集合中的元素进行操作；\n\n\n<span id=\"id12\"><span>\n### 12. Map集合\n- java.util.Map<K, V>集合存取元素的基本单位是：单对元素（键值对key-value）。\n- Map：映射，通过某一个key可以直接定位到一个value值\n- key无序无重复   value无序可重复\n    * key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致\n- 主要有两个实现类：`HashMap类`和`TreeMap类`。\n- Map基本使用：HashMap，TreeMap，Properties\n- Map集合常用方法：\n    * 增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)\n- Map集合的遍历方式：a.迭代Key，b.迭代Entry\n- Map集合的性能调优：\n    - 加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）\n\n\n<span id=\"id13\"><span>\n### 13. HashMap类\n1. 包:java.util，底层散列表的形式（数组+链表）\n2. 构造方法创建对象   无参数  带默认容量的  带map参数的构造方法\n3. 特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复\n    - 找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry\n4. 基本方法：\n    - 增 put(key,value)，存放一组映射关系key-value\n        1. key存储的顺序与取得顺序不同\n        2. 不同的key可以存储相同的value\n        3. key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)\n    - 删 E = remove(key);\n    - 改 replace(key,newValue)，put(key,value2)\n    - 查 E = get(key)；\n    - Set<Key> = keySet()获取全部的key\n    - Set<Entry> = entrySet();\n    - size();\n\n``` java\nSet<Entry<Integer,String>> entrys = map.entrySet();//获取集合中全部的entry对象\nIterator<Entry<Integer,String>> it = entrys.iterator();\nwhile(it.hasNext()){\n    Entry<Integer,String> entry = it.next();//entry  key value\n    Integer key = entry.getKey();\n    String value = entry.getValue();\n    System.out.println(key+\"--\"+value);\n}\n```\n\n5. 除了上述几个常用的方法外  其他API中提供的方法\n    - clear，containsKey(key)，containsValue(value)\n    - getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值\n    - isEmpty()\n    - putAll(map)\n    - putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦\n6. map集合在什么情形下用?\n    1. 想要存储一组元素\n        - 数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合\n    2. 如果发现长度以后不确定--->集合\n\n| list | Set | Map |\n|:------:|:----:|:------:|\n| List家族有序的 | Set家族无重复 | Map家族k-v |\n|存储有顺序用这个|存储元素希望自动去掉重复元素用这个|通过唯一的k快速找寻v用这个|\n|ArrayList:更适合遍历轮询|HashSet:性能更高|HashMap:性能更高|\n|LinkedList:更适合插入和删除|TreeSet:希望存进去的元素自动去重复,同时还能自动排序|Tree:希望存进去的元素key自动排序|\n|Stack:LIFO|-|-|\n\n\n<span id=\"id14\"><span>\n### 14. TreeMap类\n1. java.util包\n2. 构造方法：无参数，带map参数\n3. 常用方法：put， get，remove，replace，size\n4. 底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）\n5. 自然有序，按照Unicode编码自然有序\n    - ap集合中的key需要可比较的   key的对象需要实现Comparable接口\n\n\n<span id=\"id15\"><span>\n### 15. Lambda表达式\n- java8支持的新的语法格式，Lambda允许`把函数作为一个方法的参数`(函数作为参数传递进方法中)，使用lambda表达式可以`使代码变得更加简洁紧凑`。\n- 函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。\n- lambda表达式语法由**参数列表**、**箭头函数`->`**和**函数体**组成，函数体即可以是一个表达式，也可以是一个语句块。\n\n``` lambda\n(int a, int b) -> a+b\n() -> 42\n(String s) -> {System.out.println(s);}\n```\n\n- 函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。\n- jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。\n\n#### 15.1 Lambda表达式-方法引用\n- 方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n- 方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。\n\n\n<span id=\"id16\"><span>\n### 16. Stream API\n- Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。\n- 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：\n    * **无存储**。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n    * **为函数式编程而生**。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。\n    * **惰式执行**。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n    * **可消费性**。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n- 对stream的操作分为为两类，中间操作和结束操作，二者特点是：\n    * **中间操作**总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。\n    * **结束操作**会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n#### 16.1 stream方法使用\n- stream跟**函数接口**关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。\n\n``` java\n// 找出最长的单词\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n\n","source":"_posts/04_JavaSE集合框架.md","raw":"---\ntitle: 四、JavaSE集合框架\ndate: 2019-07-08 22:10:57\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。\n<!-- more -->\n\n1. [Collection集合](#id1)\n2. [List集合](#id2)\n3. [泛型机制](#id3)\n4. [Queue集合](#id4)\n5. [*ArrayList类](#id5)\n6. [Vector类](#id6)\n7. [Stack类](#id7)\n8. [*LinkedList类](#id8)\n9. [Set集合](#id9)\n10. [HashSet类](#id10)\n11. [TreeSet类](#id11)\n12. [Map集合](#id12)\n13. [HashMap类](#id13)\n14. [TreeMap类](#id14)\n15. [Lambda表达式](#id15)\n16. [Stream API](#id16)\n\n\n<span id=\"id1\"><span>\n### 1. Collection集合\n- Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。\n\n> 数组与集合的比较\n> - 数组的特点：\n    1. 数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；\n    2. 支持下标访问，实现随机访问非常方便；\n    3. 增删操作不方便，可能会移动大量元素；\n    4. 数组一旦声明长度固定无法更改；\n    5. 数组支持基本数据类型，也支持引用数据类型；\n> - 集合的特点：\n    1. 集合的存储单元可以不连续，数据类容可以不相同；\n    2. 集合部分支持下标访问，部分不支持；\n    3. 集合中增删元素可以不移动大量元素；\n    4. 集合大小可以随时动态调整；\n    5. 集合中的元素必须是引用数据类型（基本数据类型可用包装类）；\n\n```\n-Collection接口\n    |————List接口\n        |————ArrayList类\n        |————LinkedList类\n        |————Stack类\n        |————Vector类\n    |————Queue接口\n        |————LinkedList类\n    |————Set接口\n        |————HashSet类\n        |————TreeSet类\n-Map接口\n    |————HashMap类\n    |————TreeMap类\n```\n\n> - Collection存储的都是value,其中List有序可重复，Set无序无重复\n> - Map存储的是以key-value形式,key无序无重复 value无序可重复\n> - 序 : 顺序--添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序\n\n|Collection集合的常用方法||\n|----------|------------|\n|boolean add(E e); | 向集合中添加对象|\n|boolean contains(Object o); | 判断是否包含指定对象|\n|boolean remove(Object o); | 从集合中删除对象|\n|void clear(); | 清空集合 |\n|int size(); | 返回包含对象的个数 |\n|boolean isEmpty(); | 判断是否为空 |\n\n``` java\nCollection c2 = new ArrayList(); //多态\nboolean b1 = c2.add(new String(\"one\")); //true\nboolean b2 = c2.add(new Integer(2)); //true\nSystem.out.println(\"c2 = \" + c2); //[one, 2]\n\nboolean b3 = c2.contains(new Integer(2));//true\n//contains方法工作原理：(o==null ? e==null : o.equals(e));\n```\n\n\n<span id=\"id2\"><span>\n### 2. List集合\n- java.util.List集合是Collection集合的子集合。\n- List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。\n    - ArrayList类的底层使用**数组**进行数据管理，访问元素方便，增删不方便。\n    - LinkedList类的底层使用**链表**进行数据管理，访问不方便，增删方便。\n    - Stark类的底层使用数组进行数据管理，该类主要描述具有**后进先出**的特征的数据结构，叫做**栈**。\n    - Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。\n- List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。\n\n|List类常用方法|   |\n|----|---|\n|void add(int index, E element)|向集合指定位置添加元素|\n|boolean addAll(int index, Collection<?extends E> c)|向集合中添加所有元素|\n|E get(int index)|从集合中获取指定位置的元素|\n|E set(int index, E element)|修改指定位置的元素|\n|E remove(int index)|删除指定位置的元素|\n|int indexOf(Object o)|在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))|\n|<T> T[] toArray(T[] a)|将集合中的对象序列化以对象数组的形式返回。|\n|List<E> subList(int fromIndex, int toIndex)|获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图|\n \n\n<span id=\"id3\"><span>\n### 3. 泛型机制\n- 集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。\n- 从jdk1.5开始推出泛型机制，在集合名称后面使用<数据类型>的方式明确要求该集合中可以存放的数据类型。如：`List<String> lt = new LinkedList<String>();`。\n- 从jdk1.7开始可省略后面<>的数据类型，叫做`菱形特性`，如：`List<String> lt = new ArrayList<>();`。\n- 泛型本质就是参数化类型，让数据类型作为参数传递，`public interface List<E>{}`其中`E`是占位形参，由于实参可以支持各种广泛的类型，因此得名`泛型`。\n- 泛型可以用在哪里：\n    1. 泛型类：类定义的时候描述某种数据类型，集合的使用就是这样\n    2. 泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型\n    3. 泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中\n    4. 方法参数泛型限制，高级泛型，规范边界，extends，super\n\n\n<span id=\"id4\"><span>\n### 4. Queue集合\n- java.util.Queue集合是Collection集合的子集合。\n- Queue集合主要描述具有**先进先出**特性的数据结构，叫做**队列**(FIFO:First Input First Output)。\n- Queue集合主要实现类是`LinkedList类`，因为该类在增删方面有一定优势。\n\n|Queue接口中主要方法| |\n|----------|--------|\n|boolean offer(E e)| 将一个对象添加至队尾，若添加成功则返回true|\n|E poll()|从队首删除并返回一个元素|\n|E peek()|返回队首的元素（但并不删除）|\n\n``` java\nQueue<Integer> q1 = new LinkedList<Integer>();\n//将数据11、22、33、44、55依次入队\nfor(int i=1; i<=5; i++) {\n    q1.offer(i*11);\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. *ArrayList类\n1. 底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util\n2. ArrayList特点适合遍历轮询，不适合插入删除\n3. 如何构建一个ArrayList对象\n    - 无参数构造方法，带默认容量构造方法，带collection参数的构造方法\n4. ArrayList中常用的方法\n    - 增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()\n5. 类中其他常用的方法\n    - addAll并集，removeAll差集，ratainAll交集;\n    - indexOf()，lastIndexOf()，contains()，List=subList();\n    - isEmpty()，clear()，ensureCapacity()，iterator();迭代器\n    - toArray(T[] x)，trimToSize();\n\n\n<span id=\"id6\"><span>\n### 6. Vector类\n1. 是ArrayList集合的早期版本，所属的包 java.util\n    - Vector底层也是利用(动态)数组的形式存储\n    - Vector是线程同步的(synchronized)，安全性高，效率较低\n2. 扩容方式与ArrayList不同\n    - 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制\n3. 构造方法和常用方法与ArrayList类似\n\n\n<span id=\"id7\"><span>\n### 7. Stack类\n1. Stack类，栈，java.util包\n2. 构造方法只有一个无参数\n3. 除了继承自Vacton类的方法外还有特殊的方法\n    - push(E e)将某一个元素压入栈顶(add())\n    - E = pop()将某一个元素从栈顶取出并删掉(E = remove())\n    - E = peek()查看栈顶的一个元素 不删除(get())\n    - boolean = empty()判断栈内元素是否为空(isEmpty())\n    - int = search()查找给定的元素在占中的位置(indexOf())\n4. 应用场景\n    - 中国象棋，悔棋\n    - 栈中存储每一次操作的步骤\n    - 撤销功能\n\n\n<span id=\"id8\"><span>\n### 8. *LinkedList类\n1. LinkedList类，java.util包\n2. 底层使用**双向链表**的数据结构形式来存储\n    - 适合于插入或删除  不适合遍历轮询\n3. 构建对象\n    - 无参数构造方法，带参数的构造方法(collection)\n4. 常用的方法\n    - 增删改查：add()，remove()，set()，get()，size()，offer，poll，peek\n    - 手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()\n5. 插入删除的特性是否像想的那样\n    - 对比ArrayList  Linked\n\n\n<span id=\"id9\"><span>\n### 9. Set集合\n- java.util.Set集合是Collection集合的子集合。\n- Set集合没有先后放入次序，并且不允许有重复关系，实现类有`HashSet类`和`TreeSet`类。\n- 其中`HashSet类`底层是采用哈希表进行数据管理的。\n- 其中`TreeSet类`的底层是采用二叉树进行数据管理的。\n\n``` java\n//方法和Collection集合基本一样\nSet<String> set1 = new HashSet<String>();\nset1.add(\"one\");\nSystem.out.println(\"s1=\"+s1);\n```\n\n- set集合的无重复特性\n    * HashSet，无重复原则有两个方法同时起作用\n        - equals    hashCode\n        - 默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入\n        - 如果想要改变其比较的规则  可以重写上述两个方法\n    * TreeSet，无重复原则有一个方法起作用\n        - compareTo\n        - 上述这个方法不是每一个对象都有的\n        - 若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable\n        - 实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后\n\n#### 9.1 Set集合的遍历\n- 所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。\n\n|迭代器`Iterator<E> iterator()`，主要方法有||\n|---------------|-------------------------|\n|boolean hasNext() | 判断集合中是否有可以迭代/访问的元素 |\n|E next() | 用于取出一个元素并指向下一个元素|\n|void remove() | 用于删除访问到的最后一个元素|\n\n``` java\nIterator<String> it = set1.iterator();//获取当前集合的迭代器对象\nwhile(it.hasNext()) {//判断是否有可以访问的元素\n    String temp = it.next();//取出一个并指向下一个\n    System.out.println( temp );\n    if(\"two\".equals(temp)){\n        it.remove();//删除set1中该元素\n    }\n}\n```\n\n- 增强for循环(for each结构)\n- 语法格式：`for(元素类型 变量名:集合/数组){ 循环体; }`。\n- 执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。\n\n``` java\n//遍历集合\nfor(String ts : s1) {\n    System.out.println(ts);\n}\n//遍历数组\nint[] arr = {11,22,33,44,55};\nfor(int ti : arr) {\n    System.out.println(ti);\n}\n```\n\n\n<span id=\"id10\"><span>\n### 10. HashSet类\n1. HashSet集合底层采用HashMap（数组+链表-->散列表），java.util包。\n2. 它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 \n3. 创建对象：无参数，有参数\n4. 集合容器的基本使用\n    - 增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)\n    - 没有修改方法\n    - iterator()  获取一个迭代器对象\n    - size()\n5. 无重复的原则\n    - 在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)\n\n\n<span id=\"id11\"><span>\n### 11. TreeSet类\n1. TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))\n2. 创建对象： 无参数构造方法 ，带Collection构造方法\n3. 基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()\n4. 二叉树主要指每个节点最多只有两个子节点的树形结构。\n5. 满足以下三个特征的二叉树叫做**有序二叉树**：\n    * 左子树中的任意节点元素都小于根节点元素；\n    * 右子树中的任意节点元素都大于根节点元素；\n    * 左子树和右子树内部也遵守上述规则；\n6. 无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。\n\n7. 元素放入TreeSet集合过程：\n由于TreeSet集合底层采用**有序二叉树**进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：\n    1. 使用元素的**自然排序**规则进行比较并排序，让元素类型实现java.lang.Comparable接口；\n    2. 使用**比较器规则**进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；\n\n> 注意：\n    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；\n    2. 可以使用Collections工具类对集合中的元素进行操作；\n\n\n<span id=\"id12\"><span>\n### 12. Map集合\n- java.util.Map<K, V>集合存取元素的基本单位是：单对元素（键值对key-value）。\n- Map：映射，通过某一个key可以直接定位到一个value值\n- key无序无重复   value无序可重复\n    * key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致\n- 主要有两个实现类：`HashMap类`和`TreeMap类`。\n- Map基本使用：HashMap，TreeMap，Properties\n- Map集合常用方法：\n    * 增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)\n- Map集合的遍历方式：a.迭代Key，b.迭代Entry\n- Map集合的性能调优：\n    - 加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）\n\n\n<span id=\"id13\"><span>\n### 13. HashMap类\n1. 包:java.util，底层散列表的形式（数组+链表）\n2. 构造方法创建对象   无参数  带默认容量的  带map参数的构造方法\n3. 特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复\n    - 找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry\n4. 基本方法：\n    - 增 put(key,value)，存放一组映射关系key-value\n        1. key存储的顺序与取得顺序不同\n        2. 不同的key可以存储相同的value\n        3. key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)\n    - 删 E = remove(key);\n    - 改 replace(key,newValue)，put(key,value2)\n    - 查 E = get(key)；\n    - Set<Key> = keySet()获取全部的key\n    - Set<Entry> = entrySet();\n    - size();\n\n``` java\nSet<Entry<Integer,String>> entrys = map.entrySet();//获取集合中全部的entry对象\nIterator<Entry<Integer,String>> it = entrys.iterator();\nwhile(it.hasNext()){\n    Entry<Integer,String> entry = it.next();//entry  key value\n    Integer key = entry.getKey();\n    String value = entry.getValue();\n    System.out.println(key+\"--\"+value);\n}\n```\n\n5. 除了上述几个常用的方法外  其他API中提供的方法\n    - clear，containsKey(key)，containsValue(value)\n    - getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值\n    - isEmpty()\n    - putAll(map)\n    - putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦\n6. map集合在什么情形下用?\n    1. 想要存储一组元素\n        - 数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合\n    2. 如果发现长度以后不确定--->集合\n\n| list | Set | Map |\n|:------:|:----:|:------:|\n| List家族有序的 | Set家族无重复 | Map家族k-v |\n|存储有顺序用这个|存储元素希望自动去掉重复元素用这个|通过唯一的k快速找寻v用这个|\n|ArrayList:更适合遍历轮询|HashSet:性能更高|HashMap:性能更高|\n|LinkedList:更适合插入和删除|TreeSet:希望存进去的元素自动去重复,同时还能自动排序|Tree:希望存进去的元素key自动排序|\n|Stack:LIFO|-|-|\n\n\n<span id=\"id14\"><span>\n### 14. TreeMap类\n1. java.util包\n2. 构造方法：无参数，带map参数\n3. 常用方法：put， get，remove，replace，size\n4. 底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）\n5. 自然有序，按照Unicode编码自然有序\n    - ap集合中的key需要可比较的   key的对象需要实现Comparable接口\n\n\n<span id=\"id15\"><span>\n### 15. Lambda表达式\n- java8支持的新的语法格式，Lambda允许`把函数作为一个方法的参数`(函数作为参数传递进方法中)，使用lambda表达式可以`使代码变得更加简洁紧凑`。\n- 函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。\n- lambda表达式语法由**参数列表**、**箭头函数`->`**和**函数体**组成，函数体即可以是一个表达式，也可以是一个语句块。\n\n``` lambda\n(int a, int b) -> a+b\n() -> 42\n(String s) -> {System.out.println(s);}\n```\n\n- 函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。\n- jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。\n\n#### 15.1 Lambda表达式-方法引用\n- 方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n- 方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。\n\n\n<span id=\"id16\"><span>\n### 16. Stream API\n- Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。\n- 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：\n    * **无存储**。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n    * **为函数式编程而生**。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。\n    * **惰式执行**。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n    * **可消费性**。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n- 对stream的操作分为为两类，中间操作和结束操作，二者特点是：\n    * **中间操作**总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。\n    * **结束操作**会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n#### 16.1 stream方法使用\n- stream跟**函数接口**关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。\n\n``` java\n// 找出最长的单词\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n\n","slug":"04_JavaSE集合框架","published":1,"updated":"2019-07-20T14:46:43.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztyloah0036yot3pnupxikw","content":"<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Collection集合</a></li>\n<li><a href=\"#id2\">List集合</a></li>\n<li><a href=\"#id3\">泛型机制</a></li>\n<li><a href=\"#id4\">Queue集合</a></li>\n<li><a href=\"#id5\">*ArrayList类</a></li>\n<li><a href=\"#id6\">Vector类</a></li>\n<li><a href=\"#id7\">Stack类</a></li>\n<li><a href=\"#id8\">*LinkedList类</a></li>\n<li><a href=\"#id9\">Set集合</a></li>\n<li><a href=\"#id10\">HashSet类</a></li>\n<li><a href=\"#id11\">TreeSet类</a></li>\n<li><a href=\"#id12\">Map集合</a></li>\n<li><a href=\"#id13\">HashMap类</a></li>\n<li><a href=\"#id14\">TreeMap类</a></li>\n<li><a href=\"#id15\">Lambda表达式</a></li>\n<li><a href=\"#id16\">Stream API</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Collection集合\"><a href=\"#1-Collection集合\" class=\"headerlink\" title=\"1. Collection集合\"></a>1. Collection集合</h3><ul>\n<li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li>\n</ul>\n<blockquote>\n<p>数组与集合的比较</p>\n<ul>\n<li>数组的特点：<ol>\n<li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li>\n<li>支持下标访问，实现随机访问非常方便；</li>\n<li>增删操作不方便，可能会移动大量元素；</li>\n<li>数组一旦声明长度固定无法更改；</li>\n<li>数组支持基本数据类型，也支持引用数据类型；</li>\n</ol>\n</li>\n<li>集合的特点：<ol>\n<li>集合的存储单元可以不连续，数据类容可以不相同；</li>\n<li>集合部分支持下标访问，部分不支持；</li>\n<li>集合中增删元素可以不移动大量元素；</li>\n<li>集合大小可以随时动态调整；</li>\n<li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Collection接口</span><br><span class=\"line\">    |————List接口</span><br><span class=\"line\">        |————ArrayList类</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">        |————Stack类</span><br><span class=\"line\">        |————Vector类</span><br><span class=\"line\">    |————Queue接口</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">    |————Set接口</span><br><span class=\"line\">        |————HashSet类</span><br><span class=\"line\">        |————TreeSet类</span><br><span class=\"line\">-Map接口</span><br><span class=\"line\">    |————HashMap类</span><br><span class=\"line\">    |————TreeMap类</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li>\n<li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li>\n<li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Collection集合的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e);</td>\n<td>向集合中添加对象</td>\n</tr>\n<tr>\n<td>boolean contains(Object o);</td>\n<td>判断是否包含指定对象</td>\n</tr>\n<tr>\n<td>boolean remove(Object o);</td>\n<td>从集合中删除对象</td>\n</tr>\n<tr>\n<td>void clear();</td>\n<td>清空集合</td>\n</tr>\n<tr>\n<td>int size();</td>\n<td>返回包含对象的个数</td>\n</tr>\n<tr>\n<td>boolean isEmpty();</td>\n<td>判断是否为空</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection c2 = <span class=\"keyword\">new</span> ArrayList(); <span class=\"comment\">//多态</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = c2.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"one\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = c2.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"c2 = \"</span> + c2); <span class=\"comment\">//[one, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b3 = c2.contains(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-List集合\"><a href=\"#2-List集合\" class=\"headerlink\" title=\"2. List集合\"></a>2. List集合</h3><ul>\n<li>java.util.List集合是Collection集合的子集合。</li>\n<li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul>\n<li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li>\n<li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li>\n<li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li>\n<li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li>\n</ul>\n</li>\n<li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>List类常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index, E element)</td>\n<td>向集合指定位置添加元素</td>\n</tr>\n<tr>\n<td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td>\n<td>向集合中添加所有元素</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>从集合中获取指定位置的元素</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定位置的元素</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定位置的元素</td>\n</tr>\n<tr>\n<td>int indexOf(Object o)</td>\n<td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td>\n</tr>\n<tr>\n<td><t> T[] toArray(T[] a)</t></td>\n<td>将集合中的对象序列化以对象数组的形式返回。</td>\n</tr>\n<tr>\n<td>List<e> subList(int fromIndex, int toIndex)</e></td>\n<td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-泛型机制\"><a href=\"#3-泛型机制\" class=\"headerlink\" title=\"3. 泛型机制\"></a>3. 泛型机制</h3><ul>\n<li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li>\n<li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li>\n<li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li>\n<li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li>\n<li>泛型可以用在哪里：<ol>\n<li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li>\n<li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li>\n<li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li>\n<li>方法参数泛型限制，高级泛型，规范边界，extends，super</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Queue集合\"><a href=\"#4-Queue集合\" class=\"headerlink\" title=\"4. Queue集合\"></a>4. Queue集合</h3><ul>\n<li>java.util.Queue集合是Collection集合的子集合。</li>\n<li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li>\n<li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Queue接口中主要方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean offer(E e)</td>\n<td>将一个对象添加至队尾，若添加成功则返回true</td>\n</tr>\n<tr>\n<td>E poll()</td>\n<td>从队首删除并返回一个元素</td>\n</tr>\n<tr>\n<td>E peek()</td>\n<td>返回队首的元素（但并不删除）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; q1 = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//将数据11、22、33、44、55依次入队</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    q1.offer(i*<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-ArrayList类\"><a href=\"#5-ArrayList类\" class=\"headerlink\" title=\"5. *ArrayList类\"></a>5. *ArrayList类</h3><ol>\n<li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li>\n<li>ArrayList特点适合遍历轮询，不适合插入删除</li>\n<li>如何构建一个ArrayList对象<ul>\n<li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li>\n</ul>\n</li>\n<li>ArrayList中常用的方法<ul>\n<li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li>\n</ul>\n</li>\n<li>类中其他常用的方法<ul>\n<li>addAll并集，removeAll差集，ratainAll交集;</li>\n<li>indexOf()，lastIndexOf()，contains()，List=subList();</li>\n<li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li>\n<li>toArray(T[] x)，trimToSize();</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Vector类\"><a href=\"#6-Vector类\" class=\"headerlink\" title=\"6. Vector类\"></a>6. Vector类</h3><ol>\n<li>是ArrayList集合的早期版本，所属的包 java.util<ul>\n<li>Vector底层也是利用(动态)数组的形式存储</li>\n<li>Vector是线程同步的(synchronized)，安全性高，效率较低</li>\n</ul>\n</li>\n<li>扩容方式与ArrayList不同<ul>\n<li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li>\n</ul>\n</li>\n<li>构造方法和常用方法与ArrayList类似</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Stack类\"><a href=\"#7-Stack类\" class=\"headerlink\" title=\"7. Stack类\"></a>7. Stack类</h3><ol>\n<li>Stack类，栈，java.util包</li>\n<li>构造方法只有一个无参数</li>\n<li>除了继承自Vacton类的方法外还有特殊的方法<ul>\n<li>push(E e)将某一个元素压入栈顶(add())</li>\n<li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li>\n<li>E = peek()查看栈顶的一个元素 不删除(get())</li>\n<li>boolean = empty()判断栈内元素是否为空(isEmpty())</li>\n<li>int = search()查找给定的元素在占中的位置(indexOf())</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>中国象棋，悔棋</li>\n<li>栈中存储每一次操作的步骤</li>\n<li>撤销功能</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-LinkedList类\"><a href=\"#8-LinkedList类\" class=\"headerlink\" title=\"8. *LinkedList类\"></a>8. *LinkedList类</h3><ol>\n<li>LinkedList类，java.util包</li>\n<li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul>\n<li>适合于插入或删除  不适合遍历轮询</li>\n</ul>\n</li>\n<li>构建对象<ul>\n<li>无参数构造方法，带参数的构造方法(collection)</li>\n</ul>\n</li>\n<li>常用的方法<ul>\n<li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li>\n<li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li>\n</ul>\n</li>\n<li>插入删除的特性是否像想的那样<ul>\n<li>对比ArrayList  Linked</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Set集合\"><a href=\"#9-Set集合\" class=\"headerlink\" title=\"9. Set集合\"></a>9. Set集合</h3><ul>\n<li>java.util.Set集合是Collection集合的子集合。</li>\n<li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li>\n<li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li>\n<li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法和Collection集合基本一样</span></span><br><span class=\"line\">Set&lt;String&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">set1.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s1=\"</span>+s1);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>set集合的无重复特性<ul>\n<li>HashSet，无重复原则有两个方法同时起作用<ul>\n<li>equals    hashCode</li>\n<li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li>\n<li>如果想要改变其比较的规则  可以重写上述两个方法</li>\n</ul>\n</li>\n<li>TreeSet，无重复原则有一个方法起作用<ul>\n<li>compareTo</li>\n<li>上述这个方法不是每一个对象都有的</li>\n<li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li>\n<li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-1-Set集合的遍历\"><a href=\"#9-1-Set集合的遍历\" class=\"headerlink\" title=\"9.1 Set集合的遍历\"></a>9.1 Set集合的遍历</h4><ul>\n<li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td>判断集合中是否有可以迭代/访问的元素</td>\n</tr>\n<tr>\n<td>E next()</td>\n<td>用于取出一个元素并指向下一个元素</td>\n</tr>\n<tr>\n<td>void remove()</td>\n<td>用于删除访问到的最后一个元素</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; it = set1.iterator();<span class=\"comment\">//获取当前集合的迭代器对象</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()) &#123;<span class=\"comment\">//判断是否有可以访问的元素</span></span><br><span class=\"line\">    String temp = it.next();<span class=\"comment\">//取出一个并指向下一个</span></span><br><span class=\"line\">    System.out.println( temp );</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"two\"</span>.equals(temp))&#123;</span><br><span class=\"line\">        it.remove();<span class=\"comment\">//删除set1中该元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>增强for循环(for each结构)</li>\n<li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li>\n<li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(String ts : s1) &#123;</span><br><span class=\"line\">    System.out.println(ts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">44</span>,<span class=\"number\">55</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> ti : arr) &#123;</span><br><span class=\"line\">    System.out.println(ti);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-HashSet类\"><a href=\"#10-HashSet类\" class=\"headerlink\" title=\"10. HashSet类\"></a>10. HashSet类</h3><ol>\n<li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li>\n<li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li>\n<li>创建对象：无参数，有参数</li>\n<li>集合容器的基本使用<ul>\n<li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li>\n<li>没有修改方法</li>\n<li>iterator()  获取一个迭代器对象</li>\n<li>size()</li>\n</ul>\n</li>\n<li>无重复的原则<ul>\n<li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-TreeSet类\"><a href=\"#11-TreeSet类\" class=\"headerlink\" title=\"11. TreeSet类\"></a>11. TreeSet类</h3><ol>\n<li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p>\n</li>\n<li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p>\n</li>\n<li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p>\n</li>\n<li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p>\n</li>\n<li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p>\n<ul>\n<li>左子树中的任意节点元素都小于根节点元素；</li>\n<li>右子树中的任意节点元素都大于根节点元素；</li>\n<li>左子树和右子树内部也遵守上述规则；</li>\n</ul>\n</li>\n<li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p>\n</li>\n<li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p>\n<ol>\n<li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li>\n<li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p>\n</blockquote>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-Map集合\"><a href=\"#12-Map集合\" class=\"headerlink\" title=\"12. Map集合\"></a>12. Map集合</h3><ul>\n<li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li>\n<li>Map：映射，通过某一个key可以直接定位到一个value值</li>\n<li>key无序无重复   value无序可重复<ul>\n<li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li>\n</ul>\n</li>\n<li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li>\n<li>Map基本使用：HashMap，TreeMap，Properties</li>\n<li>Map集合常用方法：<ul>\n<li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li>\n</ul>\n</li>\n<li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li>\n<li>Map集合的性能调优：<ul>\n<li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-HashMap类\"><a href=\"#13-HashMap类\" class=\"headerlink\" title=\"13. HashMap类\"></a>13. HashMap类</h3><ol>\n<li>包:java.util，底层散列表的形式（数组+链表）</li>\n<li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li>\n<li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul>\n<li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li>\n</ul>\n</li>\n<li>基本方法：<ul>\n<li>增 put(key,value)，存放一组映射关系key-value<ol>\n<li>key存储的顺序与取得顺序不同</li>\n<li>不同的key可以存储相同的value</li>\n<li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li>\n</ol>\n</li>\n<li>删 E = remove(key);</li>\n<li>改 replace(key,newValue)，put(key,value2)</li>\n<li>查 E = get(key)；</li>\n<li>Set<key> = keySet()获取全部的key</key></li>\n<li>Set<entry> = entrySet();</entry></li>\n<li>size();</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class=\"comment\">//获取集合中全部的entry对象</span></span><br><span class=\"line\">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    Entry&lt;Integer,String&gt; entry = it.next();<span class=\"comment\">//entry  key value</span></span><br><span class=\"line\">    Integer key = entry.getKey();</span><br><span class=\"line\">    String value = entry.getValue();</span><br><span class=\"line\">    System.out.println(key+<span class=\"string\">\"--\"</span>+value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>除了上述几个常用的方法外  其他API中提供的方法<ul>\n<li>clear，containsKey(key)，containsValue(value)</li>\n<li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li>\n<li>isEmpty()</li>\n<li>putAll(map)</li>\n<li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li>\n</ul>\n</li>\n<li>map集合在什么情形下用?<ol>\n<li>想要存储一组元素<ul>\n<li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li>\n</ul>\n</li>\n<li>如果发现长度以后不确定—&gt;集合</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">list</th>\n<th align=\"center\">Set</th>\n<th align=\"center\">Map</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">List家族有序的</td>\n<td align=\"center\">Set家族无重复</td>\n<td align=\"center\">Map家族k-v</td>\n</tr>\n<tr>\n<td align=\"center\">存储有顺序用这个</td>\n<td align=\"center\">存储元素希望自动去掉重复元素用这个</td>\n<td align=\"center\">通过唯一的k快速找寻v用这个</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayList:更适合遍历轮询</td>\n<td align=\"center\">HashSet:性能更高</td>\n<td align=\"center\">HashMap:性能更高</td>\n</tr>\n<tr>\n<td align=\"center\">LinkedList:更适合插入和删除</td>\n<td align=\"center\">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td>\n<td align=\"center\">Tree:希望存进去的元素key自动排序</td>\n</tr>\n<tr>\n<td align=\"center\">Stack:LIFO</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-TreeMap类\"><a href=\"#14-TreeMap类\" class=\"headerlink\" title=\"14. TreeMap类\"></a>14. TreeMap类</h3><ol>\n<li>java.util包</li>\n<li>构造方法：无参数，带map参数</li>\n<li>常用方法：put， get，remove，replace，size</li>\n<li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li>\n<li>自然有序，按照Unicode编码自然有序<ul>\n<li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-Lambda表达式\"><a href=\"#15-Lambda表达式\" class=\"headerlink\" title=\"15. Lambda表达式\"></a>15. Lambda表达式</h3><ul>\n<li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li>\n<li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li>\n<li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(int a, int b) -&gt; a+b</span><br><span class=\"line\">() -&gt; 42</span><br><span class=\"line\">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li>\n<li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li>\n</ul>\n<h4 id=\"15-1-Lambda表达式-方法引用\"><a href=\"#15-1-Lambda表达式-方法引用\" class=\"headerlink\" title=\"15.1 Lambda表达式-方法引用\"></a>15.1 Lambda表达式-方法引用</h4><ul>\n<li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li>\n<li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li>\n</ul>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-Stream-API\"><a href=\"#16-Stream-API\" class=\"headerlink\" title=\"16. Stream API\"></a>16. Stream API</h3><ul>\n<li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p>\n</li>\n<li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>\n<ul>\n<li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>\n<li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n</li>\n<li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p>\n<ul>\n<li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>\n<li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-1-stream方法使用\"><a href=\"#16-1-stream方法使用\" class=\"headerlink\" title=\"16.1 stream方法使用\"></a>16.1 stream方法使用</h4><ul>\n<li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找出最长的单词</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p>","more":"<ol>\n<li><a href=\"#id1\">Collection集合</a></li>\n<li><a href=\"#id2\">List集合</a></li>\n<li><a href=\"#id3\">泛型机制</a></li>\n<li><a href=\"#id4\">Queue集合</a></li>\n<li><a href=\"#id5\">*ArrayList类</a></li>\n<li><a href=\"#id6\">Vector类</a></li>\n<li><a href=\"#id7\">Stack类</a></li>\n<li><a href=\"#id8\">*LinkedList类</a></li>\n<li><a href=\"#id9\">Set集合</a></li>\n<li><a href=\"#id10\">HashSet类</a></li>\n<li><a href=\"#id11\">TreeSet类</a></li>\n<li><a href=\"#id12\">Map集合</a></li>\n<li><a href=\"#id13\">HashMap类</a></li>\n<li><a href=\"#id14\">TreeMap类</a></li>\n<li><a href=\"#id15\">Lambda表达式</a></li>\n<li><a href=\"#id16\">Stream API</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Collection集合\"><a href=\"#1-Collection集合\" class=\"headerlink\" title=\"1. Collection集合\"></a>1. Collection集合</h3><ul>\n<li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li>\n</ul>\n<blockquote>\n<p>数组与集合的比较</p>\n<ul>\n<li>数组的特点：<ol>\n<li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li>\n<li>支持下标访问，实现随机访问非常方便；</li>\n<li>增删操作不方便，可能会移动大量元素；</li>\n<li>数组一旦声明长度固定无法更改；</li>\n<li>数组支持基本数据类型，也支持引用数据类型；</li>\n</ol>\n</li>\n<li>集合的特点：<ol>\n<li>集合的存储单元可以不连续，数据类容可以不相同；</li>\n<li>集合部分支持下标访问，部分不支持；</li>\n<li>集合中增删元素可以不移动大量元素；</li>\n<li>集合大小可以随时动态调整；</li>\n<li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Collection接口</span><br><span class=\"line\">    |————List接口</span><br><span class=\"line\">        |————ArrayList类</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">        |————Stack类</span><br><span class=\"line\">        |————Vector类</span><br><span class=\"line\">    |————Queue接口</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">    |————Set接口</span><br><span class=\"line\">        |————HashSet类</span><br><span class=\"line\">        |————TreeSet类</span><br><span class=\"line\">-Map接口</span><br><span class=\"line\">    |————HashMap类</span><br><span class=\"line\">    |————TreeMap类</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li>\n<li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li>\n<li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Collection集合的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e);</td>\n<td>向集合中添加对象</td>\n</tr>\n<tr>\n<td>boolean contains(Object o);</td>\n<td>判断是否包含指定对象</td>\n</tr>\n<tr>\n<td>boolean remove(Object o);</td>\n<td>从集合中删除对象</td>\n</tr>\n<tr>\n<td>void clear();</td>\n<td>清空集合</td>\n</tr>\n<tr>\n<td>int size();</td>\n<td>返回包含对象的个数</td>\n</tr>\n<tr>\n<td>boolean isEmpty();</td>\n<td>判断是否为空</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection c2 = <span class=\"keyword\">new</span> ArrayList(); <span class=\"comment\">//多态</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = c2.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"one\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = c2.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"c2 = \"</span> + c2); <span class=\"comment\">//[one, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b3 = c2.contains(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-List集合\"><a href=\"#2-List集合\" class=\"headerlink\" title=\"2. List集合\"></a>2. List集合</h3><ul>\n<li>java.util.List集合是Collection集合的子集合。</li>\n<li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul>\n<li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li>\n<li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li>\n<li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li>\n<li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li>\n</ul>\n</li>\n<li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>List类常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index, E element)</td>\n<td>向集合指定位置添加元素</td>\n</tr>\n<tr>\n<td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td>\n<td>向集合中添加所有元素</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>从集合中获取指定位置的元素</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定位置的元素</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定位置的元素</td>\n</tr>\n<tr>\n<td>int indexOf(Object o)</td>\n<td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td>\n</tr>\n<tr>\n<td><t> T[] toArray(T[] a)</t></td>\n<td>将集合中的对象序列化以对象数组的形式返回。</td>\n</tr>\n<tr>\n<td>List<e> subList(int fromIndex, int toIndex)</e></td>\n<td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-泛型机制\"><a href=\"#3-泛型机制\" class=\"headerlink\" title=\"3. 泛型机制\"></a>3. 泛型机制</h3><ul>\n<li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li>\n<li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li>\n<li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li>\n<li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li>\n<li>泛型可以用在哪里：<ol>\n<li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li>\n<li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li>\n<li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li>\n<li>方法参数泛型限制，高级泛型，规范边界，extends，super</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Queue集合\"><a href=\"#4-Queue集合\" class=\"headerlink\" title=\"4. Queue集合\"></a>4. Queue集合</h3><ul>\n<li>java.util.Queue集合是Collection集合的子集合。</li>\n<li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li>\n<li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Queue接口中主要方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean offer(E e)</td>\n<td>将一个对象添加至队尾，若添加成功则返回true</td>\n</tr>\n<tr>\n<td>E poll()</td>\n<td>从队首删除并返回一个元素</td>\n</tr>\n<tr>\n<td>E peek()</td>\n<td>返回队首的元素（但并不删除）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; q1 = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//将数据11、22、33、44、55依次入队</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    q1.offer(i*<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-ArrayList类\"><a href=\"#5-ArrayList类\" class=\"headerlink\" title=\"5. *ArrayList类\"></a>5. *ArrayList类</h3><ol>\n<li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li>\n<li>ArrayList特点适合遍历轮询，不适合插入删除</li>\n<li>如何构建一个ArrayList对象<ul>\n<li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li>\n</ul>\n</li>\n<li>ArrayList中常用的方法<ul>\n<li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li>\n</ul>\n</li>\n<li>类中其他常用的方法<ul>\n<li>addAll并集，removeAll差集，ratainAll交集;</li>\n<li>indexOf()，lastIndexOf()，contains()，List=subList();</li>\n<li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li>\n<li>toArray(T[] x)，trimToSize();</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Vector类\"><a href=\"#6-Vector类\" class=\"headerlink\" title=\"6. Vector类\"></a>6. Vector类</h3><ol>\n<li>是ArrayList集合的早期版本，所属的包 java.util<ul>\n<li>Vector底层也是利用(动态)数组的形式存储</li>\n<li>Vector是线程同步的(synchronized)，安全性高，效率较低</li>\n</ul>\n</li>\n<li>扩容方式与ArrayList不同<ul>\n<li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li>\n</ul>\n</li>\n<li>构造方法和常用方法与ArrayList类似</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Stack类\"><a href=\"#7-Stack类\" class=\"headerlink\" title=\"7. Stack类\"></a>7. Stack类</h3><ol>\n<li>Stack类，栈，java.util包</li>\n<li>构造方法只有一个无参数</li>\n<li>除了继承自Vacton类的方法外还有特殊的方法<ul>\n<li>push(E e)将某一个元素压入栈顶(add())</li>\n<li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li>\n<li>E = peek()查看栈顶的一个元素 不删除(get())</li>\n<li>boolean = empty()判断栈内元素是否为空(isEmpty())</li>\n<li>int = search()查找给定的元素在占中的位置(indexOf())</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>中国象棋，悔棋</li>\n<li>栈中存储每一次操作的步骤</li>\n<li>撤销功能</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-LinkedList类\"><a href=\"#8-LinkedList类\" class=\"headerlink\" title=\"8. *LinkedList类\"></a>8. *LinkedList类</h3><ol>\n<li>LinkedList类，java.util包</li>\n<li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul>\n<li>适合于插入或删除  不适合遍历轮询</li>\n</ul>\n</li>\n<li>构建对象<ul>\n<li>无参数构造方法，带参数的构造方法(collection)</li>\n</ul>\n</li>\n<li>常用的方法<ul>\n<li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li>\n<li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li>\n</ul>\n</li>\n<li>插入删除的特性是否像想的那样<ul>\n<li>对比ArrayList  Linked</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Set集合\"><a href=\"#9-Set集合\" class=\"headerlink\" title=\"9. Set集合\"></a>9. Set集合</h3><ul>\n<li>java.util.Set集合是Collection集合的子集合。</li>\n<li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li>\n<li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li>\n<li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法和Collection集合基本一样</span></span><br><span class=\"line\">Set&lt;String&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">set1.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s1=\"</span>+s1);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>set集合的无重复特性<ul>\n<li>HashSet，无重复原则有两个方法同时起作用<ul>\n<li>equals    hashCode</li>\n<li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li>\n<li>如果想要改变其比较的规则  可以重写上述两个方法</li>\n</ul>\n</li>\n<li>TreeSet，无重复原则有一个方法起作用<ul>\n<li>compareTo</li>\n<li>上述这个方法不是每一个对象都有的</li>\n<li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li>\n<li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-1-Set集合的遍历\"><a href=\"#9-1-Set集合的遍历\" class=\"headerlink\" title=\"9.1 Set集合的遍历\"></a>9.1 Set集合的遍历</h4><ul>\n<li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td>判断集合中是否有可以迭代/访问的元素</td>\n</tr>\n<tr>\n<td>E next()</td>\n<td>用于取出一个元素并指向下一个元素</td>\n</tr>\n<tr>\n<td>void remove()</td>\n<td>用于删除访问到的最后一个元素</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; it = set1.iterator();<span class=\"comment\">//获取当前集合的迭代器对象</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()) &#123;<span class=\"comment\">//判断是否有可以访问的元素</span></span><br><span class=\"line\">    String temp = it.next();<span class=\"comment\">//取出一个并指向下一个</span></span><br><span class=\"line\">    System.out.println( temp );</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"two\"</span>.equals(temp))&#123;</span><br><span class=\"line\">        it.remove();<span class=\"comment\">//删除set1中该元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>增强for循环(for each结构)</li>\n<li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li>\n<li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(String ts : s1) &#123;</span><br><span class=\"line\">    System.out.println(ts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">44</span>,<span class=\"number\">55</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> ti : arr) &#123;</span><br><span class=\"line\">    System.out.println(ti);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-HashSet类\"><a href=\"#10-HashSet类\" class=\"headerlink\" title=\"10. HashSet类\"></a>10. HashSet类</h3><ol>\n<li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li>\n<li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li>\n<li>创建对象：无参数，有参数</li>\n<li>集合容器的基本使用<ul>\n<li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li>\n<li>没有修改方法</li>\n<li>iterator()  获取一个迭代器对象</li>\n<li>size()</li>\n</ul>\n</li>\n<li>无重复的原则<ul>\n<li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-TreeSet类\"><a href=\"#11-TreeSet类\" class=\"headerlink\" title=\"11. TreeSet类\"></a>11. TreeSet类</h3><ol>\n<li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p>\n</li>\n<li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p>\n</li>\n<li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p>\n</li>\n<li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p>\n</li>\n<li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p>\n<ul>\n<li>左子树中的任意节点元素都小于根节点元素；</li>\n<li>右子树中的任意节点元素都大于根节点元素；</li>\n<li>左子树和右子树内部也遵守上述规则；</li>\n</ul>\n</li>\n<li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p>\n</li>\n<li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p>\n<ol>\n<li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li>\n<li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p>\n</blockquote>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-Map集合\"><a href=\"#12-Map集合\" class=\"headerlink\" title=\"12. Map集合\"></a>12. Map集合</h3><ul>\n<li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li>\n<li>Map：映射，通过某一个key可以直接定位到一个value值</li>\n<li>key无序无重复   value无序可重复<ul>\n<li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li>\n</ul>\n</li>\n<li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li>\n<li>Map基本使用：HashMap，TreeMap，Properties</li>\n<li>Map集合常用方法：<ul>\n<li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li>\n</ul>\n</li>\n<li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li>\n<li>Map集合的性能调优：<ul>\n<li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-HashMap类\"><a href=\"#13-HashMap类\" class=\"headerlink\" title=\"13. HashMap类\"></a>13. HashMap类</h3><ol>\n<li>包:java.util，底层散列表的形式（数组+链表）</li>\n<li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li>\n<li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul>\n<li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li>\n</ul>\n</li>\n<li>基本方法：<ul>\n<li>增 put(key,value)，存放一组映射关系key-value<ol>\n<li>key存储的顺序与取得顺序不同</li>\n<li>不同的key可以存储相同的value</li>\n<li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li>\n</ol>\n</li>\n<li>删 E = remove(key);</li>\n<li>改 replace(key,newValue)，put(key,value2)</li>\n<li>查 E = get(key)；</li>\n<li>Set<key> = keySet()获取全部的key</key></li>\n<li>Set<entry> = entrySet();</entry></li>\n<li>size();</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class=\"comment\">//获取集合中全部的entry对象</span></span><br><span class=\"line\">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    Entry&lt;Integer,String&gt; entry = it.next();<span class=\"comment\">//entry  key value</span></span><br><span class=\"line\">    Integer key = entry.getKey();</span><br><span class=\"line\">    String value = entry.getValue();</span><br><span class=\"line\">    System.out.println(key+<span class=\"string\">\"--\"</span>+value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>除了上述几个常用的方法外  其他API中提供的方法<ul>\n<li>clear，containsKey(key)，containsValue(value)</li>\n<li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li>\n<li>isEmpty()</li>\n<li>putAll(map)</li>\n<li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li>\n</ul>\n</li>\n<li>map集合在什么情形下用?<ol>\n<li>想要存储一组元素<ul>\n<li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li>\n</ul>\n</li>\n<li>如果发现长度以后不确定—&gt;集合</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">list</th>\n<th align=\"center\">Set</th>\n<th align=\"center\">Map</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">List家族有序的</td>\n<td align=\"center\">Set家族无重复</td>\n<td align=\"center\">Map家族k-v</td>\n</tr>\n<tr>\n<td align=\"center\">存储有顺序用这个</td>\n<td align=\"center\">存储元素希望自动去掉重复元素用这个</td>\n<td align=\"center\">通过唯一的k快速找寻v用这个</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayList:更适合遍历轮询</td>\n<td align=\"center\">HashSet:性能更高</td>\n<td align=\"center\">HashMap:性能更高</td>\n</tr>\n<tr>\n<td align=\"center\">LinkedList:更适合插入和删除</td>\n<td align=\"center\">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td>\n<td align=\"center\">Tree:希望存进去的元素key自动排序</td>\n</tr>\n<tr>\n<td align=\"center\">Stack:LIFO</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-TreeMap类\"><a href=\"#14-TreeMap类\" class=\"headerlink\" title=\"14. TreeMap类\"></a>14. TreeMap类</h3><ol>\n<li>java.util包</li>\n<li>构造方法：无参数，带map参数</li>\n<li>常用方法：put， get，remove，replace，size</li>\n<li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li>\n<li>自然有序，按照Unicode编码自然有序<ul>\n<li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-Lambda表达式\"><a href=\"#15-Lambda表达式\" class=\"headerlink\" title=\"15. Lambda表达式\"></a>15. Lambda表达式</h3><ul>\n<li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li>\n<li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li>\n<li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(int a, int b) -&gt; a+b</span><br><span class=\"line\">() -&gt; 42</span><br><span class=\"line\">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li>\n<li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li>\n</ul>\n<h4 id=\"15-1-Lambda表达式-方法引用\"><a href=\"#15-1-Lambda表达式-方法引用\" class=\"headerlink\" title=\"15.1 Lambda表达式-方法引用\"></a>15.1 Lambda表达式-方法引用</h4><ul>\n<li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li>\n<li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li>\n</ul>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-Stream-API\"><a href=\"#16-Stream-API\" class=\"headerlink\" title=\"16. Stream API\"></a>16. Stream API</h3><ul>\n<li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p>\n</li>\n<li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>\n<ul>\n<li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>\n<li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n</li>\n<li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p>\n<ul>\n<li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>\n<li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-1-stream方法使用\"><a href=\"#16-1-stream方法使用\" class=\"headerlink\" title=\"16.1 stream方法使用\"></a>16.1 stream方法使用</h4><ul>\n<li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找出最长的单词</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>"},{"title":"七、JavaSE多线程","date":"2019-07-09T10:07:41.000Z","_content":"\n\n多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。 \n程序的执行其实都是在抢CPU的资源，CPU的执行权。 \n多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [实现线程的过程](#id2)\n3. [线程常用方法](#id3)\n4. [线程池](#id4)\n5. [线程的主要状态](#id5)\n6. [线程的同步机制](#id6)\n7. [线程的死锁](#id7)\n8. [内存可见性](#id8)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  \n- 进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个**进程包含n个线程**；(进程是系统进行资源分配和调度的一个独立单位)。\n- 线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。\n- 多进程是指操作系统能同时运行多个任务（程序）。\n- 多线程是指在同一程序(一个进程)中有多个顺序流在执行。\n- 并行与并发：\n    * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。\n    * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。\n- 线程和进程一样分为五个阶段：**创建**、**就绪状态**、**执行状态**、**等待/挂起/阻塞**、**终止/异常/消亡**。\n\n\n<span id=\"id2\"><span>\n### 2. 实现线程的过程\njava.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。\n\n- 自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  \n- 自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 \n\n#### 2.1 实现方式一：继承Thread类\n1. 自己描述一个类\n2. 继承父类Thread\n3. 重写run方法\n4. new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)\n\n``` java\nclass MyThread extends Thread{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nmt.start();\n```\n\n#### 2.2 实现方式二：实现Runnable接口\n1. 自己描述一个类\n2. 实现一个父接口Runnable\n3. 重写run方法\n4. new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态\n\n``` java\nclass MyThread implements Runnable{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nThread td = new Thread(mt);\ntd.start();\n```\n\n#### 2.3 两种方式优缺点：\n- 使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类\n- 使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。\n\n\n<span id=\"id3\"><span>\n### 3. 线程常用方法\n\n![Thread常用方法](http://cdn.chaooo.top/java/thread.jpg)\n\n#### 3.1 相关方法的解析：\n* Thread()：使用无参方式构造对象  \n* Thread(String name)：根据参数指定的名称来构造对象。  \n* Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   \n* Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。\n* void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  \n* void **start()**：用于**启动线程**，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。\n- int getPriority()：用于获取线程的优先级，优先级1-10\n- void setPriority(int)：更改线程的优先级\n\n#### 3.2 多线程原理分析\n1. 执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  \n2. 对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  \n3. 当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  \n4. 两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  \n\n#### 3.3 线程的编号和名称\n- long getId()：用于获取调用对象所表示线程的编号\n- String getName()：用于获取调用对象所表示线程的名称\n- void setName()：用于设置线程的名称为参数指定的数值\n- static Thread currentThread()：获取当前正在执行线程的引用\n\n\n<span id=\"id4\"><span>\n### 4. 线程池\n- 为了避免重复的创建线程，线程池的出现可以**让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。\n- 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。\n- 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务\n    * 接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService\n    * 抽象类：AbstractExecutorService\n    * 实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor\n- 创建线程的第三种方式是实现Callable接口，主要用于线程池\n\n\n<span id=\"id5\"><span>\n### 5. 线程的主要状态\n\n![线程的生命周期](http://cdn.chaooo.top/java/threadLife.jpg)\n\n1. 新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行\n2. 就绪状态：调用start()进入的状态，此时线程还是没有开始执行\n3. 运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态\n4. 消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止\n5. 阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态\n\n#### 5.1 线程的休眠\n- **终止线程**：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。\n- static void **yield()**：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。\n- static void **sleep(times)**：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。\n\n#### 5.1 线程的等待\n- void **join()**：等待该线程终止，让多个线程同步执行，变成单个线程\n- void **join(long millis)**：表示等待参数指定的毫秒数\n- **对象.wait()** 和 **对象.notify()/notifyAll()**可以让线程的状态来回切换\n- sleep()和wait()的区别：\n\n|sleep()和wait()的区别|sleep() |wait()|\n|------|----------------|------|\n|1.类  |Thread类        |Object类|\n|2.调用|静态 类名.       | 对象. |\n|3.理解|调用位置的线程等待|对象调用，访问对象的其他线程等待|\n|4.唤醒|不需要唤醒       |需要其他对象调用notify唤醒|\n|5.锁  |不会释放锁       |等待后会释放锁|\n\n#### 5.2 守护线程\n- boolean **isDeamon()**：用于判断是否为守护线程\n- void **setDeamon(boolean on)**：用于设置线程为守护线程\n- Java线程有两类：\n    * 用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程\n    * 守护线程：运行在后台，为其他前台线程服务\n- 守护线程特点：\n    * **一旦所有线程都结束运行，守护线程会随JVM一起结束工作**\n- 守护线程应用：\n    * 数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。\n- 设置守护线程：\n    * 可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程\n\n\n<span id=\"id6\"><span>\n### 6. 线程的同步机制\n- 条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。\n- 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做**线程的同步机制**。\n\n- Java提供了一种**内置的锁机制**来支持**原子性**，使用**synchronized**关键字来保证线程执行操作的原子性，叫做**对象/同步锁机制**。\n- 特征修饰符synchronized：表示同步，一个时间点只有一个线程访问\n- 线程安全锁：两种形式是（锁定的永远是对象）\n    1. 使用同步代码块的方式，将synchronized关键字放在方法体内部\n    ``` java\n    synchronized(对象){\n        //需同步执行(锁定)的代码\n    }\n    ```\n    2. 使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象\n    ``` java\n    public synchronized void 方法名(){}\n    ```\n\n- 使用synchronized保证线程同步时应当注意：\n    1. 多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用\n    2. 在使用同步块时应当尽量减少同步范围以提高并发的执行效率\n\n> 1. 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。\n> 2. 每个对象只有一个锁（lock）与之相关联。\n> 3. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。\n\n\n<span id=\"id7\"><span>\n### 7. 线程的死锁\nJava线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。\n\n``` java\n/**当两个线程或多个线程之间相互锁定时就形成了死锁**/\n//线程一：\npublic void run() {   \n    synchronized(a) { //表示:持有对象锁a,等待对象锁b\n        synchronized(b) {\n            //...\n        }\n    }\n}\n//线程二：\npublic void run() {   \n    synchronized(b) { //表示:持有对象锁b,等待对象锁a\n        synchronized(a) {\n            //...\n        }\n    }\n}\n// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。\n```\n\n- 产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。\n- 隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。\n- 两种导致隐性死锁的情况：加锁次序和占有并等待。\n    * 加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。\n    * 占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。\n\n#### 7.1 死锁的避免 \n- 避免死锁的原则：顺序上锁，反向解锁，不要回头\n- 静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。\n- 动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：**安全序列**和**银行家算法**。\n\n\n\n\n<span id=\"id8\"><span>\n### 8.内存可见性\n#### 8.1 基本概念\n- 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到\n- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量\n- Java内存模型(JMM)：\n    * Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。\n    * 所有的变量都存储在主内存中\n    * 每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)\n- Java内存模型规定：\n    * 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。\n    * 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\n- 要实现共享变量的可见性，必须保证两点：\n    * 线程修改后的共享变量值能够及时从工作内存中刷新到主内存中\n    * 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。\n- Java**语言层面**支持的可见性实现方式：Synchronized，volatile\n\n#### 8.2 Synchronized实现可见性\n- Synchronized能够实现：原子性(同步)、可见性\n- JMM关于synchronized的两条规定：\n    * 线程解锁前，必须把共享变量的最新值刷新到主内存中\n    * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）\n- 线程执行互斥代码的过程：\n    1. 获得互斥锁\n    2. 清空工作内存\n    3. 从主内存拷贝变量的最新副本到工作内存\n    4. 执行代码\n    5. 将更改后的共享变量的值刷新到主内存\n    6. 释放互斥锁\n- 重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化\n    1. 编译器优化重排序（编译器处理）\n    2. 指令级并行重排序（处理器优化）\n    3. 内存系统的重排序（处理器读写缓存的优化）\n- as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致\n- 单线程中重排序不会带来内存可见性问题\n- 多线程中程序交错执行时，重排序可能造成内存可见性问题\n\n|  不可见的原因        |syschronized解决方案 |\n|---------------------|-------|\n|1.线程的交叉执行       |原子性|\n|2.重排序结合线程交叉执行|原子性|\n|3.共享变量未及时更新    |可见性|\n\n\n#### 8.3 volatile实现可见性\n- 深入来说：通过加入内存屏障和禁止重排序优化来实现的。\n    * 对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令\n    * 对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令\n- 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。\n- 线程**写**volatile变量的过程：\n    1. 改变线程工作内存中volatile变量副本的值\n    2. 将改变后的副本的值从工作内存刷新到主内存\n- 线程**读**volatile变量的过程：\n    1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n    2. 从工作内存中读取volatile变量的副本\n- volatile不能保证volatile变量复合操作的原子性\n- volatile适用场景：\n    1. 对变量的写操作不依赖其当前值\n    2. 该变量没有包含在具有其他变量的不变式中\n\n#### 8.4 Synchronized和volatile比较\n- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n- 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁\n- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性\n- volatile没有synchronized使用广泛。\n\n\n","source":"_posts/07_JavaSE多线程.md","raw":"---\ntitle: 七、JavaSE多线程\ndate: 2019-07-09 18:07:41\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。 \n程序的执行其实都是在抢CPU的资源，CPU的执行权。 \n多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [实现线程的过程](#id2)\n3. [线程常用方法](#id3)\n4. [线程池](#id4)\n5. [线程的主要状态](#id5)\n6. [线程的同步机制](#id6)\n7. [线程的死锁](#id7)\n8. [内存可见性](#id8)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  \n- 进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个**进程包含n个线程**；(进程是系统进行资源分配和调度的一个独立单位)。\n- 线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。\n- 多进程是指操作系统能同时运行多个任务（程序）。\n- 多线程是指在同一程序(一个进程)中有多个顺序流在执行。\n- 并行与并发：\n    * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。\n    * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。\n- 线程和进程一样分为五个阶段：**创建**、**就绪状态**、**执行状态**、**等待/挂起/阻塞**、**终止/异常/消亡**。\n\n\n<span id=\"id2\"><span>\n### 2. 实现线程的过程\njava.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。\n\n- 自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  \n- 自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 \n\n#### 2.1 实现方式一：继承Thread类\n1. 自己描述一个类\n2. 继承父类Thread\n3. 重写run方法\n4. new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)\n\n``` java\nclass MyThread extends Thread{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nmt.start();\n```\n\n#### 2.2 实现方式二：实现Runnable接口\n1. 自己描述一个类\n2. 实现一个父接口Runnable\n3. 重写run方法\n4. new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态\n\n``` java\nclass MyThread implements Runnable{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nThread td = new Thread(mt);\ntd.start();\n```\n\n#### 2.3 两种方式优缺点：\n- 使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类\n- 使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。\n\n\n<span id=\"id3\"><span>\n### 3. 线程常用方法\n\n![Thread常用方法](http://cdn.chaooo.top/java/thread.jpg)\n\n#### 3.1 相关方法的解析：\n* Thread()：使用无参方式构造对象  \n* Thread(String name)：根据参数指定的名称来构造对象。  \n* Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   \n* Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。\n* void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  \n* void **start()**：用于**启动线程**，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。\n- int getPriority()：用于获取线程的优先级，优先级1-10\n- void setPriority(int)：更改线程的优先级\n\n#### 3.2 多线程原理分析\n1. 执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  \n2. 对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  \n3. 当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  \n4. 两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  \n\n#### 3.3 线程的编号和名称\n- long getId()：用于获取调用对象所表示线程的编号\n- String getName()：用于获取调用对象所表示线程的名称\n- void setName()：用于设置线程的名称为参数指定的数值\n- static Thread currentThread()：获取当前正在执行线程的引用\n\n\n<span id=\"id4\"><span>\n### 4. 线程池\n- 为了避免重复的创建线程，线程池的出现可以**让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。\n- 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。\n- 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务\n    * 接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService\n    * 抽象类：AbstractExecutorService\n    * 实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor\n- 创建线程的第三种方式是实现Callable接口，主要用于线程池\n\n\n<span id=\"id5\"><span>\n### 5. 线程的主要状态\n\n![线程的生命周期](http://cdn.chaooo.top/java/threadLife.jpg)\n\n1. 新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行\n2. 就绪状态：调用start()进入的状态，此时线程还是没有开始执行\n3. 运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态\n4. 消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止\n5. 阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态\n\n#### 5.1 线程的休眠\n- **终止线程**：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。\n- static void **yield()**：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。\n- static void **sleep(times)**：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。\n\n#### 5.1 线程的等待\n- void **join()**：等待该线程终止，让多个线程同步执行，变成单个线程\n- void **join(long millis)**：表示等待参数指定的毫秒数\n- **对象.wait()** 和 **对象.notify()/notifyAll()**可以让线程的状态来回切换\n- sleep()和wait()的区别：\n\n|sleep()和wait()的区别|sleep() |wait()|\n|------|----------------|------|\n|1.类  |Thread类        |Object类|\n|2.调用|静态 类名.       | 对象. |\n|3.理解|调用位置的线程等待|对象调用，访问对象的其他线程等待|\n|4.唤醒|不需要唤醒       |需要其他对象调用notify唤醒|\n|5.锁  |不会释放锁       |等待后会释放锁|\n\n#### 5.2 守护线程\n- boolean **isDeamon()**：用于判断是否为守护线程\n- void **setDeamon(boolean on)**：用于设置线程为守护线程\n- Java线程有两类：\n    * 用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程\n    * 守护线程：运行在后台，为其他前台线程服务\n- 守护线程特点：\n    * **一旦所有线程都结束运行，守护线程会随JVM一起结束工作**\n- 守护线程应用：\n    * 数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。\n- 设置守护线程：\n    * 可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程\n\n\n<span id=\"id6\"><span>\n### 6. 线程的同步机制\n- 条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。\n- 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做**线程的同步机制**。\n\n- Java提供了一种**内置的锁机制**来支持**原子性**，使用**synchronized**关键字来保证线程执行操作的原子性，叫做**对象/同步锁机制**。\n- 特征修饰符synchronized：表示同步，一个时间点只有一个线程访问\n- 线程安全锁：两种形式是（锁定的永远是对象）\n    1. 使用同步代码块的方式，将synchronized关键字放在方法体内部\n    ``` java\n    synchronized(对象){\n        //需同步执行(锁定)的代码\n    }\n    ```\n    2. 使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象\n    ``` java\n    public synchronized void 方法名(){}\n    ```\n\n- 使用synchronized保证线程同步时应当注意：\n    1. 多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用\n    2. 在使用同步块时应当尽量减少同步范围以提高并发的执行效率\n\n> 1. 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。\n> 2. 每个对象只有一个锁（lock）与之相关联。\n> 3. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。\n\n\n<span id=\"id7\"><span>\n### 7. 线程的死锁\nJava线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。\n\n``` java\n/**当两个线程或多个线程之间相互锁定时就形成了死锁**/\n//线程一：\npublic void run() {   \n    synchronized(a) { //表示:持有对象锁a,等待对象锁b\n        synchronized(b) {\n            //...\n        }\n    }\n}\n//线程二：\npublic void run() {   \n    synchronized(b) { //表示:持有对象锁b,等待对象锁a\n        synchronized(a) {\n            //...\n        }\n    }\n}\n// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。\n```\n\n- 产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。\n- 隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。\n- 两种导致隐性死锁的情况：加锁次序和占有并等待。\n    * 加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。\n    * 占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。\n\n#### 7.1 死锁的避免 \n- 避免死锁的原则：顺序上锁，反向解锁，不要回头\n- 静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。\n- 动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：**安全序列**和**银行家算法**。\n\n\n\n\n<span id=\"id8\"><span>\n### 8.内存可见性\n#### 8.1 基本概念\n- 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到\n- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量\n- Java内存模型(JMM)：\n    * Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。\n    * 所有的变量都存储在主内存中\n    * 每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)\n- Java内存模型规定：\n    * 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。\n    * 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\n- 要实现共享变量的可见性，必须保证两点：\n    * 线程修改后的共享变量值能够及时从工作内存中刷新到主内存中\n    * 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。\n- Java**语言层面**支持的可见性实现方式：Synchronized，volatile\n\n#### 8.2 Synchronized实现可见性\n- Synchronized能够实现：原子性(同步)、可见性\n- JMM关于synchronized的两条规定：\n    * 线程解锁前，必须把共享变量的最新值刷新到主内存中\n    * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）\n- 线程执行互斥代码的过程：\n    1. 获得互斥锁\n    2. 清空工作内存\n    3. 从主内存拷贝变量的最新副本到工作内存\n    4. 执行代码\n    5. 将更改后的共享变量的值刷新到主内存\n    6. 释放互斥锁\n- 重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化\n    1. 编译器优化重排序（编译器处理）\n    2. 指令级并行重排序（处理器优化）\n    3. 内存系统的重排序（处理器读写缓存的优化）\n- as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致\n- 单线程中重排序不会带来内存可见性问题\n- 多线程中程序交错执行时，重排序可能造成内存可见性问题\n\n|  不可见的原因        |syschronized解决方案 |\n|---------------------|-------|\n|1.线程的交叉执行       |原子性|\n|2.重排序结合线程交叉执行|原子性|\n|3.共享变量未及时更新    |可见性|\n\n\n#### 8.3 volatile实现可见性\n- 深入来说：通过加入内存屏障和禁止重排序优化来实现的。\n    * 对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令\n    * 对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令\n- 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。\n- 线程**写**volatile变量的过程：\n    1. 改变线程工作内存中volatile变量副本的值\n    2. 将改变后的副本的值从工作内存刷新到主内存\n- 线程**读**volatile变量的过程：\n    1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n    2. 从工作内存中读取volatile变量的副本\n- volatile不能保证volatile变量复合操作的原子性\n- volatile适用场景：\n    1. 对变量的写操作不依赖其当前值\n    2. 该变量没有包含在具有其他变量的不变式中\n\n#### 8.4 Synchronized和volatile比较\n- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n- 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁\n- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性\n- volatile没有synchronized使用广泛。\n\n\n","slug":"07_JavaSE多线程","published":1,"updated":"2019-07-20T14:51:55.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztyloaj0039yot3kf5dlpgi","content":"<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">实现线程的过程</a></li>\n<li><a href=\"#id3\">线程常用方法</a></li>\n<li><a href=\"#id4\">线程池</a></li>\n<li><a href=\"#id5\">线程的主要状态</a></li>\n<li><a href=\"#id6\">线程的同步机制</a></li>\n<li><a href=\"#id7\">线程的死锁</a></li>\n<li><a href=\"#id8\">内存可见性</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li>\n<li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li>\n<li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li>\n<li>多进程是指操作系统能同时运行多个任务（程序）。</li>\n<li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li>\n<li>并行与并发：<ul>\n<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>\n<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>\n</ul>\n</li>\n<li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-实现线程的过程\"><a href=\"#2-实现线程的过程\" class=\"headerlink\" title=\"2. 实现线程的过程\"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p>\n<ul>\n<li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li>\n<li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li>\n</ul>\n<h4 id=\"2-1-实现方式一：继承Thread类\"><a href=\"#2-1-实现方式一：继承Thread类\" class=\"headerlink\" title=\"2.1 实现方式一：继承Thread类\"></a>2.1 实现方式一：继承Thread类</h4><ol>\n<li>自己描述一个类</li>\n<li>继承父类Thread</li>\n<li>重写run方法</li>\n<li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">mt.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-实现方式二：实现Runnable接口\"><a href=\"#2-2-实现方式二：实现Runnable接口\" class=\"headerlink\" title=\"2.2 实现方式二：实现Runnable接口\"></a>2.2 实现方式二：实现Runnable接口</h4><ol>\n<li>自己描述一个类</li>\n<li>实现一个父接口Runnable</li>\n<li>重写run方法</li>\n<li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread td = <span class=\"keyword\">new</span> Thread(mt);</span><br><span class=\"line\">td.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-两种方式优缺点：\"><a href=\"#2-3-两种方式优缺点：\" class=\"headerlink\" title=\"2.3 两种方式优缺点：\"></a>2.3 两种方式优缺点：</h4><ul>\n<li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li>\n<li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-线程常用方法\"><a href=\"#3-线程常用方法\" class=\"headerlink\" title=\"3. 线程常用方法\"></a>3. 线程常用方法</h3><p><img src=\"http://cdn.chaooo.top/java/thread.jpg\" alt=\"Thread常用方法\"></p>\n<h4 id=\"3-1-相关方法的解析：\"><a href=\"#3-1-相关方法的解析：\" class=\"headerlink\" title=\"3.1 相关方法的解析：\"></a>3.1 相关方法的解析：</h4><ul>\n<li>Thread()：使用无参方式构造对象  </li>\n<li>Thread(String name)：根据参数指定的名称来构造对象。  </li>\n<li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li>\n<li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li>\n<li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li>\n<li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li>\n</ul>\n<ul>\n<li>int getPriority()：用于获取线程的优先级，优先级1-10</li>\n<li>void setPriority(int)：更改线程的优先级</li>\n</ul>\n<h4 id=\"3-2-多线程原理分析\"><a href=\"#3-2-多线程原理分析\" class=\"headerlink\" title=\"3.2 多线程原理分析\"></a>3.2 多线程原理分析</h4><ol>\n<li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li>\n<li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li>\n<li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li>\n<li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li>\n</ol>\n<h4 id=\"3-3-线程的编号和名称\"><a href=\"#3-3-线程的编号和名称\" class=\"headerlink\" title=\"3.3 线程的编号和名称\"></a>3.3 线程的编号和名称</h4><ul>\n<li>long getId()：用于获取调用对象所表示线程的编号</li>\n<li>String getName()：用于获取调用对象所表示线程的名称</li>\n<li>void setName()：用于设置线程的名称为参数指定的数值</li>\n<li>static Thread currentThread()：获取当前正在执行线程的引用</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4. 线程池\"></a>4. 线程池</h3><ul>\n<li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li>\n<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li>\n<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul>\n<li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li>\n<li>抽象类：AbstractExecutorService</li>\n<li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-线程的主要状态\"><a href=\"#5-线程的主要状态\" class=\"headerlink\" title=\"5. 线程的主要状态\"></a>5. 线程的主要状态</h3><p><img src=\"http://cdn.chaooo.top/java/threadLife.jpg\" alt=\"线程的生命周期\"></p>\n<ol>\n<li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li>\n<li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li>\n<li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li>\n<li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li>\n<li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li>\n</ol>\n<h4 id=\"5-1-线程的休眠\"><a href=\"#5-1-线程的休眠\" class=\"headerlink\" title=\"5.1 线程的休眠\"></a>5.1 线程的休眠</h4><ul>\n<li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li>\n<li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li>\n<li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li>\n</ul>\n<h4 id=\"5-1-线程的等待\"><a href=\"#5-1-线程的等待\" class=\"headerlink\" title=\"5.1 线程的等待\"></a>5.1 线程的等待</h4><ul>\n<li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li>\n<li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li>\n<li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li>\n<li>sleep()和wait()的区别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sleep()和wait()的区别</th>\n<th>sleep()</th>\n<th>wait()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.类</td>\n<td>Thread类</td>\n<td>Object类</td>\n</tr>\n<tr>\n<td>2.调用</td>\n<td>静态 类名.</td>\n<td>对象.</td>\n</tr>\n<tr>\n<td>3.理解</td>\n<td>调用位置的线程等待</td>\n<td>对象调用，访问对象的其他线程等待</td>\n</tr>\n<tr>\n<td>4.唤醒</td>\n<td>不需要唤醒</td>\n<td>需要其他对象调用notify唤醒</td>\n</tr>\n<tr>\n<td>5.锁</td>\n<td>不会释放锁</td>\n<td>等待后会释放锁</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-2-守护线程\"><a href=\"#5-2-守护线程\" class=\"headerlink\" title=\"5.2 守护线程\"></a>5.2 守护线程</h4><ul>\n<li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li>\n<li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li>\n<li>Java线程有两类：<ul>\n<li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li>\n<li>守护线程：运行在后台，为其他前台线程服务</li>\n</ul>\n</li>\n<li>守护线程特点：<ul>\n<li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li>\n</ul>\n</li>\n<li>守护线程应用：<ul>\n<li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li>\n</ul>\n</li>\n<li>设置守护线程：<ul>\n<li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-线程的同步机制\"><a href=\"#6-线程的同步机制\" class=\"headerlink\" title=\"6. 线程的同步机制\"></a>6. 线程的同步机制</h3><ul>\n<li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p>\n</li>\n<li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p>\n</li>\n<li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p>\n</li>\n<li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p>\n</li>\n<li><p>线程安全锁：两种形式是（锁定的永远是对象）</p>\n<ol>\n<li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//需同步执行(锁定)的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>使用synchronized保证线程同步时应当注意：</p>\n<ol>\n<li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li>\n<li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li>\n<li>每个对象只有一个锁（lock）与之相关联。</li>\n<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>\n</ol>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-线程的死锁\"><a href=\"#7-线程的死锁\" class=\"headerlink\" title=\"7. 线程的死锁\"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class=\"line\"><span class=\"comment\">//线程一：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(a) &#123; <span class=\"comment\">//表示:持有对象锁a,等待对象锁b</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//线程二：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(b) &#123; <span class=\"comment\">//表示:持有对象锁b,等待对象锁a</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(a) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li>\n<li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li>\n<li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul>\n<li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li>\n<li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-1-死锁的避免\"><a href=\"#7-1-死锁的避免\" class=\"headerlink\" title=\"7.1 死锁的避免\"></a>7.1 死锁的避免</h4><ul>\n<li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li>\n<li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li>\n<li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-内存可见性\"><a href=\"#8-内存可见性\" class=\"headerlink\" title=\"8.内存可见性\"></a>8.内存可见性</h3><h4 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h4><ul>\n<li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li>\n<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li>\n<li>Java内存模型(JMM)：<ul>\n<li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li>\n<li>所有的变量都存储在主内存中</li>\n<li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li>\n</ul>\n</li>\n<li>Java内存模型规定：<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n</li>\n<li>要实现共享变量的可见性，必须保证两点：<ul>\n<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>\n<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li>\n</ul>\n</li>\n<li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li>\n</ul>\n<h4 id=\"8-2-Synchronized实现可见性\"><a href=\"#8-2-Synchronized实现可见性\" class=\"headerlink\" title=\"8.2 Synchronized实现可见性\"></a>8.2 Synchronized实现可见性</h4><ul>\n<li>Synchronized能够实现：原子性(同步)、可见性</li>\n<li>JMM关于synchronized的两条规定：<ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>\n</ul>\n</li>\n<li>线程执行互斥代码的过程：<ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n</li>\n<li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol>\n<li>编译器优化重排序（编译器处理）</li>\n<li>指令级并行重排序（处理器优化）</li>\n<li>内存系统的重排序（处理器读写缓存的优化）</li>\n</ol>\n</li>\n<li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li>\n<li>单线程中重排序不会带来内存可见性问题</li>\n<li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>不可见的原因</th>\n<th>syschronized解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.线程的交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>2.重排序结合线程交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>3.共享变量未及时更新</td>\n<td>可见性</td>\n</tr>\n</tbody></table>\n<h4 id=\"8-3-volatile实现可见性\"><a href=\"#8-3-volatile实现可见性\" class=\"headerlink\" title=\"8.3 volatile实现可见性\"></a>8.3 volatile实现可见性</h4><ul>\n<li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li>\n</ul>\n</li>\n<li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li>\n<li>线程<strong>写</strong>volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程<strong>读</strong>volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n<li>volatile不能保证volatile变量复合操作的原子性</li>\n<li>volatile适用场景：<ol>\n<li>对变量的写操作不依赖其当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-4-Synchronized和volatile比较\"><a href=\"#8-4-Synchronized和volatile比较\" class=\"headerlink\" title=\"8.4 Synchronized和volatile比较\"></a>8.4 Synchronized和volatile比较</h4><ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li>\n<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li>\n<li>volatile没有synchronized使用广泛。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">实现线程的过程</a></li>\n<li><a href=\"#id3\">线程常用方法</a></li>\n<li><a href=\"#id4\">线程池</a></li>\n<li><a href=\"#id5\">线程的主要状态</a></li>\n<li><a href=\"#id6\">线程的同步机制</a></li>\n<li><a href=\"#id7\">线程的死锁</a></li>\n<li><a href=\"#id8\">内存可见性</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li>\n<li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li>\n<li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li>\n<li>多进程是指操作系统能同时运行多个任务（程序）。</li>\n<li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li>\n<li>并行与并发：<ul>\n<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>\n<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>\n</ul>\n</li>\n<li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-实现线程的过程\"><a href=\"#2-实现线程的过程\" class=\"headerlink\" title=\"2. 实现线程的过程\"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p>\n<ul>\n<li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li>\n<li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li>\n</ul>\n<h4 id=\"2-1-实现方式一：继承Thread类\"><a href=\"#2-1-实现方式一：继承Thread类\" class=\"headerlink\" title=\"2.1 实现方式一：继承Thread类\"></a>2.1 实现方式一：继承Thread类</h4><ol>\n<li>自己描述一个类</li>\n<li>继承父类Thread</li>\n<li>重写run方法</li>\n<li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">mt.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-实现方式二：实现Runnable接口\"><a href=\"#2-2-实现方式二：实现Runnable接口\" class=\"headerlink\" title=\"2.2 实现方式二：实现Runnable接口\"></a>2.2 实现方式二：实现Runnable接口</h4><ol>\n<li>自己描述一个类</li>\n<li>实现一个父接口Runnable</li>\n<li>重写run方法</li>\n<li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread td = <span class=\"keyword\">new</span> Thread(mt);</span><br><span class=\"line\">td.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-两种方式优缺点：\"><a href=\"#2-3-两种方式优缺点：\" class=\"headerlink\" title=\"2.3 两种方式优缺点：\"></a>2.3 两种方式优缺点：</h4><ul>\n<li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li>\n<li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-线程常用方法\"><a href=\"#3-线程常用方法\" class=\"headerlink\" title=\"3. 线程常用方法\"></a>3. 线程常用方法</h3><p><img src=\"http://cdn.chaooo.top/java/thread.jpg\" alt=\"Thread常用方法\"></p>\n<h4 id=\"3-1-相关方法的解析：\"><a href=\"#3-1-相关方法的解析：\" class=\"headerlink\" title=\"3.1 相关方法的解析：\"></a>3.1 相关方法的解析：</h4><ul>\n<li>Thread()：使用无参方式构造对象  </li>\n<li>Thread(String name)：根据参数指定的名称来构造对象。  </li>\n<li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li>\n<li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li>\n<li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li>\n<li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li>\n</ul>\n<ul>\n<li>int getPriority()：用于获取线程的优先级，优先级1-10</li>\n<li>void setPriority(int)：更改线程的优先级</li>\n</ul>\n<h4 id=\"3-2-多线程原理分析\"><a href=\"#3-2-多线程原理分析\" class=\"headerlink\" title=\"3.2 多线程原理分析\"></a>3.2 多线程原理分析</h4><ol>\n<li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li>\n<li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li>\n<li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li>\n<li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li>\n</ol>\n<h4 id=\"3-3-线程的编号和名称\"><a href=\"#3-3-线程的编号和名称\" class=\"headerlink\" title=\"3.3 线程的编号和名称\"></a>3.3 线程的编号和名称</h4><ul>\n<li>long getId()：用于获取调用对象所表示线程的编号</li>\n<li>String getName()：用于获取调用对象所表示线程的名称</li>\n<li>void setName()：用于设置线程的名称为参数指定的数值</li>\n<li>static Thread currentThread()：获取当前正在执行线程的引用</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4. 线程池\"></a>4. 线程池</h3><ul>\n<li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li>\n<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li>\n<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul>\n<li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li>\n<li>抽象类：AbstractExecutorService</li>\n<li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-线程的主要状态\"><a href=\"#5-线程的主要状态\" class=\"headerlink\" title=\"5. 线程的主要状态\"></a>5. 线程的主要状态</h3><p><img src=\"http://cdn.chaooo.top/java/threadLife.jpg\" alt=\"线程的生命周期\"></p>\n<ol>\n<li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li>\n<li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li>\n<li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li>\n<li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li>\n<li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li>\n</ol>\n<h4 id=\"5-1-线程的休眠\"><a href=\"#5-1-线程的休眠\" class=\"headerlink\" title=\"5.1 线程的休眠\"></a>5.1 线程的休眠</h4><ul>\n<li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li>\n<li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li>\n<li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li>\n</ul>\n<h4 id=\"5-1-线程的等待\"><a href=\"#5-1-线程的等待\" class=\"headerlink\" title=\"5.1 线程的等待\"></a>5.1 线程的等待</h4><ul>\n<li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li>\n<li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li>\n<li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li>\n<li>sleep()和wait()的区别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sleep()和wait()的区别</th>\n<th>sleep()</th>\n<th>wait()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.类</td>\n<td>Thread类</td>\n<td>Object类</td>\n</tr>\n<tr>\n<td>2.调用</td>\n<td>静态 类名.</td>\n<td>对象.</td>\n</tr>\n<tr>\n<td>3.理解</td>\n<td>调用位置的线程等待</td>\n<td>对象调用，访问对象的其他线程等待</td>\n</tr>\n<tr>\n<td>4.唤醒</td>\n<td>不需要唤醒</td>\n<td>需要其他对象调用notify唤醒</td>\n</tr>\n<tr>\n<td>5.锁</td>\n<td>不会释放锁</td>\n<td>等待后会释放锁</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-2-守护线程\"><a href=\"#5-2-守护线程\" class=\"headerlink\" title=\"5.2 守护线程\"></a>5.2 守护线程</h4><ul>\n<li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li>\n<li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li>\n<li>Java线程有两类：<ul>\n<li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li>\n<li>守护线程：运行在后台，为其他前台线程服务</li>\n</ul>\n</li>\n<li>守护线程特点：<ul>\n<li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li>\n</ul>\n</li>\n<li>守护线程应用：<ul>\n<li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li>\n</ul>\n</li>\n<li>设置守护线程：<ul>\n<li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-线程的同步机制\"><a href=\"#6-线程的同步机制\" class=\"headerlink\" title=\"6. 线程的同步机制\"></a>6. 线程的同步机制</h3><ul>\n<li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p>\n</li>\n<li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p>\n</li>\n<li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p>\n</li>\n<li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p>\n</li>\n<li><p>线程安全锁：两种形式是（锁定的永远是对象）</p>\n<ol>\n<li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//需同步执行(锁定)的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>使用synchronized保证线程同步时应当注意：</p>\n<ol>\n<li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li>\n<li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li>\n<li>每个对象只有一个锁（lock）与之相关联。</li>\n<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>\n</ol>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-线程的死锁\"><a href=\"#7-线程的死锁\" class=\"headerlink\" title=\"7. 线程的死锁\"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class=\"line\"><span class=\"comment\">//线程一：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(a) &#123; <span class=\"comment\">//表示:持有对象锁a,等待对象锁b</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//线程二：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(b) &#123; <span class=\"comment\">//表示:持有对象锁b,等待对象锁a</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(a) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li>\n<li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li>\n<li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul>\n<li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li>\n<li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-1-死锁的避免\"><a href=\"#7-1-死锁的避免\" class=\"headerlink\" title=\"7.1 死锁的避免\"></a>7.1 死锁的避免</h4><ul>\n<li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li>\n<li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li>\n<li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-内存可见性\"><a href=\"#8-内存可见性\" class=\"headerlink\" title=\"8.内存可见性\"></a>8.内存可见性</h3><h4 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h4><ul>\n<li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li>\n<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li>\n<li>Java内存模型(JMM)：<ul>\n<li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li>\n<li>所有的变量都存储在主内存中</li>\n<li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li>\n</ul>\n</li>\n<li>Java内存模型规定：<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n</li>\n<li>要实现共享变量的可见性，必须保证两点：<ul>\n<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>\n<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li>\n</ul>\n</li>\n<li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li>\n</ul>\n<h4 id=\"8-2-Synchronized实现可见性\"><a href=\"#8-2-Synchronized实现可见性\" class=\"headerlink\" title=\"8.2 Synchronized实现可见性\"></a>8.2 Synchronized实现可见性</h4><ul>\n<li>Synchronized能够实现：原子性(同步)、可见性</li>\n<li>JMM关于synchronized的两条规定：<ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>\n</ul>\n</li>\n<li>线程执行互斥代码的过程：<ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n</li>\n<li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol>\n<li>编译器优化重排序（编译器处理）</li>\n<li>指令级并行重排序（处理器优化）</li>\n<li>内存系统的重排序（处理器读写缓存的优化）</li>\n</ol>\n</li>\n<li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li>\n<li>单线程中重排序不会带来内存可见性问题</li>\n<li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>不可见的原因</th>\n<th>syschronized解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.线程的交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>2.重排序结合线程交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>3.共享变量未及时更新</td>\n<td>可见性</td>\n</tr>\n</tbody></table>\n<h4 id=\"8-3-volatile实现可见性\"><a href=\"#8-3-volatile实现可见性\" class=\"headerlink\" title=\"8.3 volatile实现可见性\"></a>8.3 volatile实现可见性</h4><ul>\n<li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li>\n</ul>\n</li>\n<li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li>\n<li>线程<strong>写</strong>volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程<strong>读</strong>volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n<li>volatile不能保证volatile变量复合操作的原子性</li>\n<li>volatile适用场景：<ol>\n<li>对变量的写操作不依赖其当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-4-Synchronized和volatile比较\"><a href=\"#8-4-Synchronized和volatile比较\" class=\"headerlink\" title=\"8.4 Synchronized和volatile比较\"></a>8.4 Synchronized和volatile比较</h4><ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li>\n<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li>\n<li>volatile没有synchronized使用广泛。</li>\n</ul>"},{"title":"十三、Spring基础和IoC控制反转","date":"2019-08-27T14:38:23.000Z","_content":"\nSpring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。\n- IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础\n<!-- more -->\n- DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装\n- WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持\n- AOP：是在面向对象的基础上发展来的更高级的技术\n- ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库\n- JEE：Java的消息服务，远程调用，邮件服务等\n\n\n1. [IoC（控制反转）](#id1)\n2. [Spring容器初始化](#id2)\n3. [spring容器创建对象(实例化)](#id3)\n4. [Spring DI注入的实现](#id4)\n5. [DI的参数的注入](#id5)\n6. [Bean的常用配置项(作用域,生命周期,懒加载等)](#id6)\n\n\n<span id=\"id1\"><span>\n### 1. IoC（控制反转）\n**IoC**：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。\n1. 控制：控制对象的创建及销毁（生命周期）\n2. 反转：将对象的控制权交给IoC容器\n\n**DI**：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。\n- 简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入\n\n> IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。\n\n\n<span id=\"id2\"><span>\n### 2. Spring容器初始化\n任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext\n- BeanFactory提供配置结构和基本功能，加载并初始化Bean\n- ApplicationContext保存了Bean对象并在Spring中被广泛使用\n\n#### 2.1 初始化ApplicationContext的几种方式：\n1. 本地文件\n``` java\nFileSystemXmlApplicationContext app = \n    new FileSystemXmlApplicationContext(\"F:/workspace/appcontext.xml\");\n```\n2. Classpath\n``` java\nClassPathXmlApplicationContext app = \n    new ClassPathXmlApplicationContext(\"classath:applicationContext.xml\");\n```\n3. Web应用中依赖Servlet或Listener\n``` xml\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n```\n\n\n#### 2.2 Spring容器完成IOC的步骤\n1. 建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下\n2. 在spring容器配置文件中配置文件中配置一个对象的创建\n  + `<baen id=\"对象引用名\" class=\"包名.类名\"></baen>`\n3. 写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件\n  + `applicationContext.getBean(\"对象引用名\", 类名.class)`\n\n\n\n<span id=\"id3\"><span>\n### 3. spring容器创建对象(实例化)\n#### 3.1 构造器方式实例化\n+ 配置文件：`<baen id=\"对象引用名\" class=\"包名.类名\"></baen>`\n+ `applicationContext.getBean(\"对象引用名\", 类名.class)`默认调用类型对应的无参构造方法\n``` xml\n<bean id=\"date\" class=\"java.util.Date\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nDate date = app.getBean(\"date\", Date.class);\n```\n\n#### 3.2 静态工厂方法实例化\n+ 使用一个类型对应的静态方法来获取这个类型的对象\n+ `<bean id=\"对象引用名\" class=\"包名.工厂类名\" factory-method=\"静态方法名\"></bean>`\n``` xml\n<bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nCalendar cal = app.getBean(\"cal\", Calendar.class);\n```\n\n#### 3.3 实例工厂方法实例化\n+ 使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象\n+ `<bean id=\"对象的引用名\" factory-bean=\"工厂方法的id\" factory-method=\"成员方法名\"></bean>`\n``` xml\n<bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"></bean>\n<bean id=\"time\" factory-bean=\"cal\" factory-method=\"getTime\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nDate time = app.getBean(\"time\", Date.class);\n```\n\n\n<span id=\"id4\"><span>\n### 4. Spring DI注入的实现\nSpring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。\nBean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。\nDI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)\n\n* 实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。\n\n#### 4.1 设值注入\nproperty(属性)的name参考对象set方法\n``` xml\n<bean id=\"card\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"黑桃\"></property>\n    <property name=\"point\" value=\"A\"></property>\n</bean>\n<!-- Player参考其setCard方法 -->\n<bean id=\"player\" class=\"bean.Player\">\n    <property name=\"name\" value=\"玩家1\"></property>\n    <property name=\"card\" ref=\"card\"></property>\n</bean>\n```\n\n#### 4.2 构造注入（Constructor arguments）\n构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）\n``` xml\n<bean id=\"card2\" class=\"bean.Card\">\n    <constructor-arg name=\"suit\" value=\"红桃\"></constructor-arg>\n    <constructor-arg name=\"point\" value=\"K\"></constructor-arg>\n</bean>\n<!-- Player参考其构造方法Player(name,card) -->\n<bean id=\"player2\" class=\"bean.Player\">\n    <constructor-arg name=\"name\" value=\"玩家2\"></constructor-arg>\n    <constructor-arg name=\"card\" ref=\"card2\"></constructor-arg>\n</bean>\n```\n\n#### 4.3 自动化注入（Autowiring mode）\n一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=\"byName/byType/constructor\")指定对应的自动化的注入方式\n``` xml\n<bean id=\"bean1\" class=\"example.exampleBean\" autowire=\"\" />\n```\n\n**自动装配autowire**属性 有五种自动装配的方式：\n+ No：默认，需要通过`ref`属性来连接bean。\n+ **byName**： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。\n``` xml\n<bean id=\"card3\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)\n    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)-->\n<bean id=\"player3\" class=\"bean.Player\" autowire=\"byName\"></bean>\n```\n\n+ **byType**：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。\n``` xml\n<bean class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) -->\n<bean id=\"player4\" class=\"bean.Player\" autowire=\"byType\"></bean>\n```\n\n+ **constructor**：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。\n``` xml\n<bean id=\"card5\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 -->\n<bean id=\"player5\" class=\"bean.Player\" autowire=\"constructor\"></bean>\n```\n\n+ **autodetect**：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。\n\n\n\n<span id=\"id5\"><span>\n### 5. DI的参数的注入\nBean对象 注入类型 可以是 字符串、集合、bean对象。\n\n#### 5.1 注入字符串\n``` xml\n<bean id=\"msg\" class=\"com.xdl.bean.OracleDataSource\">\n    <property name=\"username\" value=\"scott\"/>\n    <property name=\"password\"><value>tiger</value></property>\n    <property name=\"msg\"><null/></property>\n</bean>\n```\n\n#### 5.2 注入集合\n``` xml\n<!-- 1. 定义list集合 -->\n<property name=\"friends\">\n    <list>\n        <value>值1</value>\n        <value>值2</value>\n    </list>\n</property>\n<!-- 2. 定义set集合 -->\n<property name=\"friends2\">\n    <set>\n        <value>值1</value>\n        <value>值2</value>\n    </set>\n</property>\n<!-- 3. 定义map集合 -->\n<property name=\"phones\">\n    <map>\n        <entry key=\"1594546454\" value=\"值1\"></entry>\n        <entry key=\"1594546464\" value=\"值2\"></entry>\n    </map>\n</property>\n<!-- 4. props集合 -->\n<property name=\"phones2\">\n    <props>\n        <prop key=\"164545564\">值1</prop>\n        <prop key=\"164546756\">值2</prop>\n    </props>\n</property>\n```\n\n\n#### 5.3 集合参数的单独定义\n注入集合--引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。\n``` xml\n<!-- 1. 定义list集合 -->\n<util:list id=\"ref_friends\">\n    <value>值1</value>\n    <value>值2</value>\n</util:list>\n<!-- 2. 定义set集合 -->\n<util:set id=\"ref_buddys\">\n    <value>值</value>\n    <value>值2</value>\n</util:set>\n<!-- 3. 定义map集合 -->\n<util:map id=\"ref_phones\">\n    <entry key=\"159454644\" value=\"值1\"></entry>\n    <entry key=\"1594546454\" value=\"值2\"></entry>\n</util:map>\n<!-- 4. props集合 -->\n<util:properties id=\"ref_phonePro\">\n    <prop key=\"164545564\">值1</prop>\n    <prop key=\"16454675665564\">值2</prop>\n</util:properties>\n<util:properties id=\"ref_db\" location=\"classpath:db.properties\"></util:properties>\n<!-- 使用 -->\n<property name=\"phones\" ref=\"ref_phones\"></property>\n<property name=\"phones2\" ref=\"ref_phonePro\"></property>\n```\n\n\n#### 5.3 Spring的'EL'表达式\n它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。\nSpring EL 采用 #{Sp Expression Language} 即 `#{spring表达式}`，可在xml配置和注解中使用。\n\n+ Spring EL配置连接池对象\n``` xml\n<!-- 引入数据库配置文件 -->\n<util:properties id=\"db\" location=\"classpath:db.properties\"/>\n<!-- 配置连接池 -->\n<bean id=\"dataSource\" class=\"com.xdl.bean.OracleDataSource\">\n    <property name=\"username\" value=\"#{db.name}\"/>\n    <property name=\"password\" value=\"#{db.password}\"/>\n    <property name=\"url\" value=\"#{db.url}\"/>\n</bean>\n```\n\n\n\n<span id=\"id6\"><span>\n### 6. Bean的常用配置项(作用域,生命周期,懒加载等)\nBean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method\n\n#### 6.1 Bean作用域（Scope）\n1. Singleton作用域\n    + 单例，指一个Bean容器只存在一份\n2. prototype作用域\n    + 每次请求(使用)创建新的实例，destroy方式不生效\n3. Web环境作用域：\n    + request作用域：每个request请求都会创建一个单独的实例。\n    + session作用域：每个session都会创建一个单独的实例。\n    + application作用域：每个servletContext都会创建一个单独的实例。\n    + websocket作用域：每个websocket连接都会创建一个单独的实例。\n4. 自定义作用域\n    + SimpleThreadScope作用域：每个线程都会创建一个单独的实例。\n\n#### 6.2 Bean的生命周期（Initialization/destruction method）\nBean的生命周期：定义 --> 初始化 --> 使用 --> 销毁\n\n##### 6.2.1 Bean初始化\n如果需要在Bean实例化之后执行一些逻辑，有两种方法：\n+ 实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。\n+ **配置init-method**\n    - 配置**`beans`**的`default-init-method`属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。\n    - 配置**`bean`**的`init-method`来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。\n``` xml\n<bean id=\"exampleId\" class=\"example.exampleBean\" init-method=\"init\"></bean>\n```\n``` java\npublic class ExampleBean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n}\n```\n\n\n##### 6.2.2 Bean销毁\n如果需要在Bean销毁之前执行一些逻辑，有两种方法：\n+ 实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。\n+ **配置destroy-method**\n    - 配置**`beans`**的`default-destroy-method`属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。\n    - 配置**`bean`**的`destroy-method`来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。\n``` xml\n<bean id=\"exampleId\" class=\"example.exampleBean\" destroy-method=\"cleanup\"></bean>\n```\n``` java\npublic class ExampleBean{\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n> 注意：销毁方法只针对单例模式的对象\n\n\n#### 6.3 Bean的懒加载（Lazy-initialization mode）\nSpring容器会在创建容器时提前初始化`Singleton作用域`的bean，可以通过bean标记`lazy-init=\"true\"`延迟实例化(对象被使用时才创建)。\n+ **配置lazy-init**\n    - 配置**`beans`**的`default-lazy-init=\"true\"`为所有Bean设定懒加载。\n    - 配置**`bean`**的`lazy-init=\"true\"`为单独的某个Bean设定懒加载。\n``` xml\n<bean id=\"bean1\" class=\"example.exampleBean\" lazy-init=\"true\"/>\n```\n\n+ 适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载\n    - 优点：尽可能的节约了资源\n    - 缺点：可能导致某个操作响应时间增加\n\n\n#### 6.4 Bean装配的Aware接口 \n实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。\n1. ApplicationContextAware\n    + 接口方法：setApplicationContext\n    + 作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用\n    + 实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。\n2. BeanNameAware\n    + 接口方法：setBeanName\n    + 作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用\n    + 实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。\n\n\n#### 6.4 Bean装配之Resource\n**Resources**（针对于资源文件的统一接口）\n1. UrlResource：URL 对应的资源，根据一个 URL 地址即可获取\n2. ClassPathResource：获取类路径下的资源\n3. FileSystemResource：获取文件系统里面的资源\n4. ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源\n5. InputStreamResource：获取输入流封装的资源\n6. ByteArrayResource：获取字节数组封装的资源\n\nResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。\n- getResource()参数：\n    + classPath方式：\"classPath:class路径下文件\"\n    + file方式： \"file:本地磁盘文件绝对地址\"\n    + url方式： \"url:URL地址下文件\"\n    + 没有前缀时依赖applicationContext的配置文件路径: \"文件全名\"\n- eg:`applicationContext.getResource(\"classpath:config.txt\")`\n\n","source":"_posts/13-Spring基础和IoC控制反转.md","raw":"---\ntitle: 十三、Spring基础和IoC控制反转\ndate: 2019-08-27 22:38:23\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nSpring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。\n- IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础\n<!-- more -->\n- DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装\n- WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持\n- AOP：是在面向对象的基础上发展来的更高级的技术\n- ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库\n- JEE：Java的消息服务，远程调用，邮件服务等\n\n\n1. [IoC（控制反转）](#id1)\n2. [Spring容器初始化](#id2)\n3. [spring容器创建对象(实例化)](#id3)\n4. [Spring DI注入的实现](#id4)\n5. [DI的参数的注入](#id5)\n6. [Bean的常用配置项(作用域,生命周期,懒加载等)](#id6)\n\n\n<span id=\"id1\"><span>\n### 1. IoC（控制反转）\n**IoC**：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。\n1. 控制：控制对象的创建及销毁（生命周期）\n2. 反转：将对象的控制权交给IoC容器\n\n**DI**：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。\n- 简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入\n\n> IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。\n\n\n<span id=\"id2\"><span>\n### 2. Spring容器初始化\n任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext\n- BeanFactory提供配置结构和基本功能，加载并初始化Bean\n- ApplicationContext保存了Bean对象并在Spring中被广泛使用\n\n#### 2.1 初始化ApplicationContext的几种方式：\n1. 本地文件\n``` java\nFileSystemXmlApplicationContext app = \n    new FileSystemXmlApplicationContext(\"F:/workspace/appcontext.xml\");\n```\n2. Classpath\n``` java\nClassPathXmlApplicationContext app = \n    new ClassPathXmlApplicationContext(\"classath:applicationContext.xml\");\n```\n3. Web应用中依赖Servlet或Listener\n``` xml\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n```\n\n\n#### 2.2 Spring容器完成IOC的步骤\n1. 建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下\n2. 在spring容器配置文件中配置文件中配置一个对象的创建\n  + `<baen id=\"对象引用名\" class=\"包名.类名\"></baen>`\n3. 写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件\n  + `applicationContext.getBean(\"对象引用名\", 类名.class)`\n\n\n\n<span id=\"id3\"><span>\n### 3. spring容器创建对象(实例化)\n#### 3.1 构造器方式实例化\n+ 配置文件：`<baen id=\"对象引用名\" class=\"包名.类名\"></baen>`\n+ `applicationContext.getBean(\"对象引用名\", 类名.class)`默认调用类型对应的无参构造方法\n``` xml\n<bean id=\"date\" class=\"java.util.Date\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nDate date = app.getBean(\"date\", Date.class);\n```\n\n#### 3.2 静态工厂方法实例化\n+ 使用一个类型对应的静态方法来获取这个类型的对象\n+ `<bean id=\"对象引用名\" class=\"包名.工厂类名\" factory-method=\"静态方法名\"></bean>`\n``` xml\n<bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nCalendar cal = app.getBean(\"cal\", Calendar.class);\n```\n\n#### 3.3 实例工厂方法实例化\n+ 使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象\n+ `<bean id=\"对象的引用名\" factory-bean=\"工厂方法的id\" factory-method=\"成员方法名\"></bean>`\n``` xml\n<bean id=\"cal\" class=\"java.util.Calendar\" factory-method=\"getInstance\"></bean>\n<bean id=\"time\" factory-bean=\"cal\" factory-method=\"getTime\"></bean>\n```\n``` java\nApplicationContext app = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nDate time = app.getBean(\"time\", Date.class);\n```\n\n\n<span id=\"id4\"><span>\n### 4. Spring DI注入的实现\nSpring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。\nBean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。\nDI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)\n\n* 实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。\n\n#### 4.1 设值注入\nproperty(属性)的name参考对象set方法\n``` xml\n<bean id=\"card\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"黑桃\"></property>\n    <property name=\"point\" value=\"A\"></property>\n</bean>\n<!-- Player参考其setCard方法 -->\n<bean id=\"player\" class=\"bean.Player\">\n    <property name=\"name\" value=\"玩家1\"></property>\n    <property name=\"card\" ref=\"card\"></property>\n</bean>\n```\n\n#### 4.2 构造注入（Constructor arguments）\n构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）\n``` xml\n<bean id=\"card2\" class=\"bean.Card\">\n    <constructor-arg name=\"suit\" value=\"红桃\"></constructor-arg>\n    <constructor-arg name=\"point\" value=\"K\"></constructor-arg>\n</bean>\n<!-- Player参考其构造方法Player(name,card) -->\n<bean id=\"player2\" class=\"bean.Player\">\n    <constructor-arg name=\"name\" value=\"玩家2\"></constructor-arg>\n    <constructor-arg name=\"card\" ref=\"card2\"></constructor-arg>\n</bean>\n```\n\n#### 4.3 自动化注入（Autowiring mode）\n一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=\"byName/byType/constructor\")指定对应的自动化的注入方式\n``` xml\n<bean id=\"bean1\" class=\"example.exampleBean\" autowire=\"\" />\n```\n\n**自动装配autowire**属性 有五种自动装配的方式：\n+ No：默认，需要通过`ref`属性来连接bean。\n+ **byName**： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。\n``` xml\n<bean id=\"card3\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)\n    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)-->\n<bean id=\"player3\" class=\"bean.Player\" autowire=\"byName\"></bean>\n```\n\n+ **byType**：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。\n``` xml\n<bean class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) -->\n<bean id=\"player4\" class=\"bean.Player\" autowire=\"byType\"></bean>\n```\n\n+ **constructor**：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。\n``` xml\n<bean id=\"card5\" class=\"bean.Card\">\n    <property name=\"suit\" value=\"方片\"></property>\n    <property name=\"point\" value=\"J\"></property>\n</bean>\n<!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 -->\n<bean id=\"player5\" class=\"bean.Player\" autowire=\"constructor\"></bean>\n```\n\n+ **autodetect**：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。\n\n\n\n<span id=\"id5\"><span>\n### 5. DI的参数的注入\nBean对象 注入类型 可以是 字符串、集合、bean对象。\n\n#### 5.1 注入字符串\n``` xml\n<bean id=\"msg\" class=\"com.xdl.bean.OracleDataSource\">\n    <property name=\"username\" value=\"scott\"/>\n    <property name=\"password\"><value>tiger</value></property>\n    <property name=\"msg\"><null/></property>\n</bean>\n```\n\n#### 5.2 注入集合\n``` xml\n<!-- 1. 定义list集合 -->\n<property name=\"friends\">\n    <list>\n        <value>值1</value>\n        <value>值2</value>\n    </list>\n</property>\n<!-- 2. 定义set集合 -->\n<property name=\"friends2\">\n    <set>\n        <value>值1</value>\n        <value>值2</value>\n    </set>\n</property>\n<!-- 3. 定义map集合 -->\n<property name=\"phones\">\n    <map>\n        <entry key=\"1594546454\" value=\"值1\"></entry>\n        <entry key=\"1594546464\" value=\"值2\"></entry>\n    </map>\n</property>\n<!-- 4. props集合 -->\n<property name=\"phones2\">\n    <props>\n        <prop key=\"164545564\">值1</prop>\n        <prop key=\"164546756\">值2</prop>\n    </props>\n</property>\n```\n\n\n#### 5.3 集合参数的单独定义\n注入集合--引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。\n``` xml\n<!-- 1. 定义list集合 -->\n<util:list id=\"ref_friends\">\n    <value>值1</value>\n    <value>值2</value>\n</util:list>\n<!-- 2. 定义set集合 -->\n<util:set id=\"ref_buddys\">\n    <value>值</value>\n    <value>值2</value>\n</util:set>\n<!-- 3. 定义map集合 -->\n<util:map id=\"ref_phones\">\n    <entry key=\"159454644\" value=\"值1\"></entry>\n    <entry key=\"1594546454\" value=\"值2\"></entry>\n</util:map>\n<!-- 4. props集合 -->\n<util:properties id=\"ref_phonePro\">\n    <prop key=\"164545564\">值1</prop>\n    <prop key=\"16454675665564\">值2</prop>\n</util:properties>\n<util:properties id=\"ref_db\" location=\"classpath:db.properties\"></util:properties>\n<!-- 使用 -->\n<property name=\"phones\" ref=\"ref_phones\"></property>\n<property name=\"phones2\" ref=\"ref_phonePro\"></property>\n```\n\n\n#### 5.3 Spring的'EL'表达式\n它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。\nSpring EL 采用 #{Sp Expression Language} 即 `#{spring表达式}`，可在xml配置和注解中使用。\n\n+ Spring EL配置连接池对象\n``` xml\n<!-- 引入数据库配置文件 -->\n<util:properties id=\"db\" location=\"classpath:db.properties\"/>\n<!-- 配置连接池 -->\n<bean id=\"dataSource\" class=\"com.xdl.bean.OracleDataSource\">\n    <property name=\"username\" value=\"#{db.name}\"/>\n    <property name=\"password\" value=\"#{db.password}\"/>\n    <property name=\"url\" value=\"#{db.url}\"/>\n</bean>\n```\n\n\n\n<span id=\"id6\"><span>\n### 6. Bean的常用配置项(作用域,生命周期,懒加载等)\nBean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method\n\n#### 6.1 Bean作用域（Scope）\n1. Singleton作用域\n    + 单例，指一个Bean容器只存在一份\n2. prototype作用域\n    + 每次请求(使用)创建新的实例，destroy方式不生效\n3. Web环境作用域：\n    + request作用域：每个request请求都会创建一个单独的实例。\n    + session作用域：每个session都会创建一个单独的实例。\n    + application作用域：每个servletContext都会创建一个单独的实例。\n    + websocket作用域：每个websocket连接都会创建一个单独的实例。\n4. 自定义作用域\n    + SimpleThreadScope作用域：每个线程都会创建一个单独的实例。\n\n#### 6.2 Bean的生命周期（Initialization/destruction method）\nBean的生命周期：定义 --> 初始化 --> 使用 --> 销毁\n\n##### 6.2.1 Bean初始化\n如果需要在Bean实例化之后执行一些逻辑，有两种方法：\n+ 实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。\n+ **配置init-method**\n    - 配置**`beans`**的`default-init-method`属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。\n    - 配置**`bean`**的`init-method`来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。\n``` xml\n<bean id=\"exampleId\" class=\"example.exampleBean\" init-method=\"init\"></bean>\n```\n``` java\npublic class ExampleBean{\n    public void init(){\n        //执行一些初始化后的工作\n    }\n}\n```\n\n\n##### 6.2.2 Bean销毁\n如果需要在Bean销毁之前执行一些逻辑，有两种方法：\n+ 实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。\n+ **配置destroy-method**\n    - 配置**`beans`**的`default-destroy-method`属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。\n    - 配置**`bean`**的`destroy-method`来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。\n``` xml\n<bean id=\"exampleId\" class=\"example.exampleBean\" destroy-method=\"cleanup\"></bean>\n```\n``` java\npublic class ExampleBean{\n    public void cleanup(){\n        //执行一些销毁前的工作\n    }\n}\n```\n\n> 注意：销毁方法只针对单例模式的对象\n\n\n#### 6.3 Bean的懒加载（Lazy-initialization mode）\nSpring容器会在创建容器时提前初始化`Singleton作用域`的bean，可以通过bean标记`lazy-init=\"true\"`延迟实例化(对象被使用时才创建)。\n+ **配置lazy-init**\n    - 配置**`beans`**的`default-lazy-init=\"true\"`为所有Bean设定懒加载。\n    - 配置**`bean`**的`lazy-init=\"true\"`为单独的某个Bean设定懒加载。\n``` xml\n<bean id=\"bean1\" class=\"example.exampleBean\" lazy-init=\"true\"/>\n```\n\n+ 适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载\n    - 优点：尽可能的节约了资源\n    - 缺点：可能导致某个操作响应时间增加\n\n\n#### 6.4 Bean装配的Aware接口 \n实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。\n1. ApplicationContextAware\n    + 接口方法：setApplicationContext\n    + 作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用\n    + 实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。\n2. BeanNameAware\n    + 接口方法：setBeanName\n    + 作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用\n    + 实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。\n\n\n#### 6.4 Bean装配之Resource\n**Resources**（针对于资源文件的统一接口）\n1. UrlResource：URL 对应的资源，根据一个 URL 地址即可获取\n2. ClassPathResource：获取类路径下的资源\n3. FileSystemResource：获取文件系统里面的资源\n4. ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源\n5. InputStreamResource：获取输入流封装的资源\n6. ByteArrayResource：获取字节数组封装的资源\n\nResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。\n- getResource()参数：\n    + classPath方式：\"classPath:class路径下文件\"\n    + file方式： \"file:本地磁盘文件绝对地址\"\n    + url方式： \"url:URL地址下文件\"\n    + 没有前缀时依赖applicationContext的配置文件路径: \"文件全名\"\n- eg:`applicationContext.getResource(\"classpath:config.txt\")`\n\n","slug":"13-Spring基础和IoC控制反转","published":1,"updated":"2019-08-27T14:55:50.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztyloam003byot3wi3pli3q","content":"<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p>\n<ul>\n<li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础<a id=\"more\"></a></li>\n<li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li>\n<li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li>\n<li>AOP：是在面向对象的基础上发展来的更高级的技术</li>\n<li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li>\n<li>JEE：Java的消息服务，远程调用，邮件服务等</li>\n</ul>\n<ol>\n<li><a href=\"#id1\">IoC（控制反转）</a></li>\n<li><a href=\"#id2\">Spring容器初始化</a></li>\n<li><a href=\"#id3\">spring容器创建对象(实例化)</a></li>\n<li><a href=\"#id4\">Spring DI注入的实现</a></li>\n<li><a href=\"#id5\">DI的参数的注入</a></li>\n<li><a href=\"#id6\">Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-IoC（控制反转）\"><a href=\"#1-IoC（控制反转）\" class=\"headerlink\" title=\"1. IoC（控制反转）\"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p>\n<ol>\n<li>控制：控制对象的创建及销毁（生命周期）</li>\n<li>反转：将对象的控制权交给IoC容器</li>\n</ol>\n<p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p>\n<ul>\n<li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li>\n</ul>\n<blockquote>\n<p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p>\n</blockquote>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring容器初始化\"><a href=\"#2-Spring容器初始化\" class=\"headerlink\" title=\"2. Spring容器初始化\"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p>\n<ul>\n<li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li>\n<li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li>\n</ul>\n<h4 id=\"2-1-初始化ApplicationContext的几种方式：\"><a href=\"#2-1-初始化ApplicationContext的几种方式：\" class=\"headerlink\" title=\"2.1 初始化ApplicationContext的几种方式：\"></a>2.1 初始化ApplicationContext的几种方式：</h4><ol>\n<li><p>本地文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileSystemXmlApplicationContext app = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> FileSystemXmlApplicationContext(<span class=\"string\">\"F:/workspace/appcontext.xml\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Classpath</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPathXmlApplicationContext app = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"classath:applicationContext.xml\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Web应用中依赖Servlet或Listener</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"2-2-Spring容器完成IOC的步骤\"><a href=\"#2-2-Spring容器完成IOC的步骤\" class=\"headerlink\" title=\"2.2 Spring容器完成IOC的步骤\"></a>2.2 Spring容器完成IOC的步骤</h4><ol>\n<li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li>\n<li>在spring容器配置文件中配置文件中配置一个对象的创建<ul>\n<li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>\n</ul>\n</li>\n<li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件<ul>\n<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-spring容器创建对象-实例化\"><a href=\"#3-spring容器创建对象-实例化\" class=\"headerlink\" title=\"3. spring容器创建对象(实例化)\"></a>3. spring容器创建对象(实例化)</h3><h4 id=\"3-1-构造器方式实例化\"><a href=\"#3-1-构造器方式实例化\" class=\"headerlink\" title=\"3.1 构造器方式实例化\"></a>3.1 构造器方式实例化</h4><ul>\n<li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>\n<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"date\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Date\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Date date = app.getBean(<span class=\"string\">\"date\"</span>, Date.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-静态工厂方法实例化\"><a href=\"#3-2-静态工厂方法实例化\" class=\"headerlink\" title=\"3.2 静态工厂方法实例化\"></a>3.2 静态工厂方法实例化</h4><ul>\n<li>使用一个类型对应的静态方法来获取这个类型的对象</li>\n<li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Calendar\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getInstance\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Calendar cal = app.getBean(<span class=\"string\">\"cal\"</span>, Calendar.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-实例工厂方法实例化\"><a href=\"#3-3-实例工厂方法实例化\" class=\"headerlink\" title=\"3.3 实例工厂方法实例化\"></a>3.3 实例工厂方法实例化</h4><ul>\n<li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li>\n<li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Calendar\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getInstance\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"time\"</span> <span class=\"attr\">factory-bean</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getTime\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Date time = app.getBean(<span class=\"string\">\"time\"</span>, Date.class);</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Spring-DI注入的实现\"><a href=\"#4-Spring-DI注入的实现\" class=\"headerlink\" title=\"4. Spring DI注入的实现\"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p>\n<ul>\n<li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li>\n</ul>\n<h4 id=\"4-1-设值注入\"><a href=\"#4-1-设值注入\" class=\"headerlink\" title=\"4.1 设值注入\"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"黑桃\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"A\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"玩家1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"card\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-构造注入（Constructor-arguments）\"><a href=\"#4-2-构造注入（Constructor-arguments）\" class=\"headerlink\" title=\"4.2 构造注入（Constructor arguments）\"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"红桃\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"K\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"玩家2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"card2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-自动化注入（Autowiring-mode）\"><a href=\"#4-3-自动化注入（Autowiring-mode）\" class=\"headerlink\" title=\"4.3 自动化注入（Autowiring mode）\"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p>\n<ul>\n<li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p>\n</li>\n<li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class=\"line\"><span class=\"comment\">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"byName\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player4\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"byType\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card5\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player5\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"constructor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-DI的参数的注入\"><a href=\"#5-DI的参数的注入\" class=\"headerlink\" title=\"5. DI的参数的注入\"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p>\n<h4 id=\"5-1-注入字符串\"><a href=\"#5-1-注入字符串\" class=\"headerlink\" title=\"5.1 注入字符串\"></a>5.1 注入字符串</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"msg\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.bean.OracleDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"scott\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>tiger<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">null</span>/&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-注入集合\"><a href=\"#5-2-注入集合\" class=\"headerlink\" title=\"5.2 注入集合\"></a>5.2 注入集合</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"friends\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"friends2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546454\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546464\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 4. props集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164545564\"</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164546756\"</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-集合参数的单独定义\"><a href=\"#5-3-集合参数的单独定义\" class=\"headerlink\" title=\"5.3 集合参数的单独定义\"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:list</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_friends\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:set</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_buddys\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:set</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:map</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_phones\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"159454644\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546454\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:map</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 4. props集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_phonePro\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164545564\"</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"16454675665564\"</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_db\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:db.properties\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">util:properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ref_phones\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones2\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ref_phonePro\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-Spring的’EL’表达式\"><a href=\"#5-3-Spring的’EL’表达式\" class=\"headerlink\" title=\"5.3 Spring的’EL’表达式\"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#{spring表达式}</code>，可在xml配置和注解中使用。</p>\n<ul>\n<li>Spring EL配置连接池对象<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"db\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:db.properties\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.bean.OracleDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.name&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.password&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Bean的常用配置项-作用域-生命周期-懒加载等\"><a href=\"#6-Bean的常用配置项-作用域-生命周期-懒加载等\" class=\"headerlink\" title=\"6. Bean的常用配置项(作用域,生命周期,懒加载等)\"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method</p>\n<h4 id=\"6-1-Bean作用域（Scope）\"><a href=\"#6-1-Bean作用域（Scope）\" class=\"headerlink\" title=\"6.1 Bean作用域（Scope）\"></a>6.1 Bean作用域（Scope）</h4><ol>\n<li>Singleton作用域<ul>\n<li>单例，指一个Bean容器只存在一份</li>\n</ul>\n</li>\n<li>prototype作用域<ul>\n<li>每次请求(使用)创建新的实例，destroy方式不生效</li>\n</ul>\n</li>\n<li>Web环境作用域：<ul>\n<li>request作用域：每个request请求都会创建一个单独的实例。</li>\n<li>session作用域：每个session都会创建一个单独的实例。</li>\n<li>application作用域：每个servletContext都会创建一个单独的实例。</li>\n<li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li>\n</ul>\n</li>\n<li>自定义作用域<ul>\n<li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-Bean的生命周期（Initialization-destruction-method）\"><a href=\"#6-2-Bean的生命周期（Initialization-destruction-method）\" class=\"headerlink\" title=\"6.2 Bean的生命周期（Initialization/destruction method）\"></a>6.2 Bean的生命周期（Initialization/destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p>\n<h5 id=\"6-2-1-Bean初始化\"><a href=\"#6-2-1-Bean初始化\" class=\"headerlink\" title=\"6.2.1 Bean初始化\"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p>\n<ul>\n<li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li>\n<li><strong>配置init-method</strong><ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li>\n<li>配置<strong><code>bean</code></strong>的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleId\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-2-2-Bean销毁\"><a href=\"#6-2-2-Bean销毁\" class=\"headerlink\" title=\"6.2.2 Bean销毁\"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p>\n<ul>\n<li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li>\n<li><strong>配置destroy-method</strong><ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li>\n<li>配置<strong><code>bean</code></strong>的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleId\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"cleanup\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：销毁方法只针对单例模式的对象</p>\n</blockquote>\n<h4 id=\"6-3-Bean的懒加载（Lazy-initialization-mode）\"><a href=\"#6-3-Bean的懒加载（Lazy-initialization-mode）\" class=\"headerlink\" title=\"6.3 Bean的懒加载（Lazy-initialization mode）\"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p>\n<ul>\n<li><p><strong>配置lazy-init</strong></p>\n<ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li>\n<li>配置<strong><code>bean</code></strong>的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">lazy-init</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p>\n<ul>\n<li>优点：尽可能的节约了资源</li>\n<li>缺点：可能导致某个操作响应时间增加</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-4-Bean装配的Aware接口\"><a href=\"#6-4-Bean装配的Aware接口\" class=\"headerlink\" title=\"6.4 Bean装配的Aware接口\"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p>\n<ol>\n<li>ApplicationContextAware<ul>\n<li>接口方法：setApplicationContext</li>\n<li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>\n<li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>\n</ul>\n</li>\n<li>BeanNameAware<ul>\n<li>接口方法：setBeanName</li>\n<li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>\n<li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-4-Bean装配之Resource\"><a href=\"#6-4-Bean装配之Resource\" class=\"headerlink\" title=\"6.4 Bean装配之Resource\"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p>\n<ol>\n<li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li>\n<li>ClassPathResource：获取类路径下的资源</li>\n<li>FileSystemResource：获取文件系统里面的资源</li>\n<li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li>\n<li>InputStreamResource：获取输入流封装的资源</li>\n<li>ByteArrayResource：获取字节数组封装的资源</li>\n</ol>\n<p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p>\n<ul>\n<li>getResource()参数：<ul>\n<li>classPath方式：”classPath:class路径下文件”</li>\n<li>file方式： “file:本地磁盘文件绝对地址”</li>\n<li>url方式： “url:URL地址下文件”</li>\n<li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li>\n</ul>\n</li>\n<li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p>\n<ul>\n<li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础","more":"</li>\n<li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li>\n<li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li>\n<li>AOP：是在面向对象的基础上发展来的更高级的技术</li>\n<li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li>\n<li>JEE：Java的消息服务，远程调用，邮件服务等</li>\n</ul>\n<ol>\n<li><a href=\"#id1\">IoC（控制反转）</a></li>\n<li><a href=\"#id2\">Spring容器初始化</a></li>\n<li><a href=\"#id3\">spring容器创建对象(实例化)</a></li>\n<li><a href=\"#id4\">Spring DI注入的实现</a></li>\n<li><a href=\"#id5\">DI的参数的注入</a></li>\n<li><a href=\"#id6\">Bean的常用配置项(作用域,生命周期,懒加载等)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-IoC（控制反转）\"><a href=\"#1-IoC（控制反转）\" class=\"headerlink\" title=\"1. IoC（控制反转）\"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p>\n<ol>\n<li>控制：控制对象的创建及销毁（生命周期）</li>\n<li>反转：将对象的控制权交给IoC容器</li>\n</ol>\n<p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p>\n<ul>\n<li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li>\n</ul>\n<blockquote>\n<p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p>\n</blockquote>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring容器初始化\"><a href=\"#2-Spring容器初始化\" class=\"headerlink\" title=\"2. Spring容器初始化\"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p>\n<ul>\n<li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li>\n<li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li>\n</ul>\n<h4 id=\"2-1-初始化ApplicationContext的几种方式：\"><a href=\"#2-1-初始化ApplicationContext的几种方式：\" class=\"headerlink\" title=\"2.1 初始化ApplicationContext的几种方式：\"></a>2.1 初始化ApplicationContext的几种方式：</h4><ol>\n<li><p>本地文件</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileSystemXmlApplicationContext app = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> FileSystemXmlApplicationContext(<span class=\"string\">\"F:/workspace/appcontext.xml\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Classpath</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassPathXmlApplicationContext app = </span><br><span class=\"line\">    <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"classath:applicationContext.xml\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Web应用中依赖Servlet或Listener</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"2-2-Spring容器完成IOC的步骤\"><a href=\"#2-2-Spring容器完成IOC的步骤\" class=\"headerlink\" title=\"2.2 Spring容器完成IOC的步骤\"></a>2.2 Spring容器完成IOC的步骤</h4><ol>\n<li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li>\n<li>在spring容器配置文件中配置文件中配置一个对象的创建<ul>\n<li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>\n</ul>\n</li>\n<li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件<ul>\n<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-spring容器创建对象-实例化\"><a href=\"#3-spring容器创建对象-实例化\" class=\"headerlink\" title=\"3. spring容器创建对象(实例化)\"></a>3. spring容器创建对象(实例化)</h3><h4 id=\"3-1-构造器方式实例化\"><a href=\"#3-1-构造器方式实例化\" class=\"headerlink\" title=\"3.1 构造器方式实例化\"></a>3.1 构造器方式实例化</h4><ul>\n<li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li>\n<li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"date\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Date\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Date date = app.getBean(<span class=\"string\">\"date\"</span>, Date.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-静态工厂方法实例化\"><a href=\"#3-2-静态工厂方法实例化\" class=\"headerlink\" title=\"3.2 静态工厂方法实例化\"></a>3.2 静态工厂方法实例化</h4><ul>\n<li>使用一个类型对应的静态方法来获取这个类型的对象</li>\n<li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Calendar\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getInstance\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Calendar cal = app.getBean(<span class=\"string\">\"cal\"</span>, Calendar.class);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-实例工厂方法实例化\"><a href=\"#3-3-实例工厂方法实例化\" class=\"headerlink\" title=\"3.3 实例工厂方法实例化\"></a>3.3 实例工厂方法实例化</h4><ul>\n<li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li>\n<li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"java.util.Calendar\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getInstance\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"time\"</span> <span class=\"attr\">factory-bean</span>=<span class=\"string\">\"cal\"</span> <span class=\"attr\">factory-method</span>=<span class=\"string\">\"getTime\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ApplicationContext app = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"applicationContext.xml\"</span>);</span><br><span class=\"line\">Date time = app.getBean(<span class=\"string\">\"time\"</span>, Date.class);</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Spring-DI注入的实现\"><a href=\"#4-Spring-DI注入的实现\" class=\"headerlink\" title=\"4. Spring DI注入的实现\"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p>\n<ul>\n<li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li>\n</ul>\n<h4 id=\"4-1-设值注入\"><a href=\"#4-1-设值注入\" class=\"headerlink\" title=\"4.1 设值注入\"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"黑桃\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"A\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"玩家1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"card\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2-构造注入（Constructor-arguments）\"><a href=\"#4-2-构造注入（Constructor-arguments）\" class=\"headerlink\" title=\"4.2 构造注入（Constructor arguments）\"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"红桃\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"K\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"name\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"玩家2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">name</span>=<span class=\"string\">\"card\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"card2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">constructor-arg</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3-自动化注入（Autowiring-mode）\"><a href=\"#4-3-自动化注入（Autowiring-mode）\" class=\"headerlink\" title=\"4.3 自动化注入（Autowiring mode）\"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire=”byName/byType/constructor”)指定对应的自动化的注入方式</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p>\n<ul>\n<li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p>\n</li>\n<li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class=\"line\"><span class=\"comment\">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"byName\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player4\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"byType\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"card5\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Card\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"方片\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"point\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"J\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"player5\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bean.Player\"</span> <span class=\"attr\">autowire</span>=<span class=\"string\">\"constructor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-DI的参数的注入\"><a href=\"#5-DI的参数的注入\" class=\"headerlink\" title=\"5. DI的参数的注入\"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p>\n<h4 id=\"5-1-注入字符串\"><a href=\"#5-1-注入字符串\" class=\"headerlink\" title=\"5.1 注入字符串\"></a>5.1 注入字符串</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"msg\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.bean.OracleDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"scott\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>tiger<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"msg\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">null</span>/&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-注入集合\"><a href=\"#5-2-注入集合\" class=\"headerlink\" title=\"5.2 注入集合\"></a>5.2 注入集合</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"friends\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"friends2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">set</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546454\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546464\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 4. props集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones2\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164545564\"</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164546756\"</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-集合参数的单独定义\"><a href=\"#5-3-集合参数的单独定义\" class=\"headerlink\" title=\"5.3 集合参数的单独定义\"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:list</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_friends\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:list</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:set</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_buddys\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:set</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:map</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_phones\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"159454644\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值1\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">\"1594546454\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"值2\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:map</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 4. props集合 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_phonePro\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"164545564\"</span>&gt;</span>值1<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"16454675665564\"</span>&gt;</span>值2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">util:properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"ref_db\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:db.properties\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">util:properties</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 使用 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ref_phones\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"phones2\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"ref_phonePro\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-3-Spring的’EL’表达式\"><a href=\"#5-3-Spring的’EL’表达式\" class=\"headerlink\" title=\"5.3 Spring的’EL’表达式\"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象/集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#{spring表达式}</code>，可在xml配置和注解中使用。</p>\n<ul>\n<li>Spring EL配置连接池对象<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">util:properties</span> <span class=\"attr\">id</span>=<span class=\"string\">\"db\"</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:db.properties\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置连接池 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.bean.OracleDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.name&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.password&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"#&#123;db.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Bean的常用配置项-作用域-生命周期-懒加载等\"><a href=\"#6-Bean的常用配置项-作用域-生命周期-懒加载等\" class=\"headerlink\" title=\"6. Bean的常用配置项(作用域,生命周期,懒加载等)\"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization/destruction method</p>\n<h4 id=\"6-1-Bean作用域（Scope）\"><a href=\"#6-1-Bean作用域（Scope）\" class=\"headerlink\" title=\"6.1 Bean作用域（Scope）\"></a>6.1 Bean作用域（Scope）</h4><ol>\n<li>Singleton作用域<ul>\n<li>单例，指一个Bean容器只存在一份</li>\n</ul>\n</li>\n<li>prototype作用域<ul>\n<li>每次请求(使用)创建新的实例，destroy方式不生效</li>\n</ul>\n</li>\n<li>Web环境作用域：<ul>\n<li>request作用域：每个request请求都会创建一个单独的实例。</li>\n<li>session作用域：每个session都会创建一个单独的实例。</li>\n<li>application作用域：每个servletContext都会创建一个单独的实例。</li>\n<li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li>\n</ul>\n</li>\n<li>自定义作用域<ul>\n<li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-2-Bean的生命周期（Initialization-destruction-method）\"><a href=\"#6-2-Bean的生命周期（Initialization-destruction-method）\" class=\"headerlink\" title=\"6.2 Bean的生命周期（Initialization/destruction method）\"></a>6.2 Bean的生命周期（Initialization/destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p>\n<h5 id=\"6-2-1-Bean初始化\"><a href=\"#6-2-1-Bean初始化\" class=\"headerlink\" title=\"6.2.1 Bean初始化\"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p>\n<ul>\n<li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li>\n<li><strong>配置init-method</strong><ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li>\n<li>配置<strong><code>bean</code></strong>的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleId\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">init-method</span>=<span class=\"string\">\"init\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些初始化后的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"6-2-2-Bean销毁\"><a href=\"#6-2-2-Bean销毁\" class=\"headerlink\" title=\"6.2.2 Bean销毁\"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p>\n<ul>\n<li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li>\n<li><strong>配置destroy-method</strong><ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li>\n<li>配置<strong><code>bean</code></strong>的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"exampleId\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">destroy-method</span>=<span class=\"string\">\"cleanup\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleBean</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cleanup</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行一些销毁前的工作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：销毁方法只针对单例模式的对象</p>\n</blockquote>\n<h4 id=\"6-3-Bean的懒加载（Lazy-initialization-mode）\"><a href=\"#6-3-Bean的懒加载（Lazy-initialization-mode）\" class=\"headerlink\" title=\"6.3 Bean的懒加载（Lazy-initialization mode）\"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p>\n<ul>\n<li><p><strong>配置lazy-init</strong></p>\n<ul>\n<li>配置<strong><code>beans</code></strong>的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li>\n<li>配置<strong><code>bean</code></strong>的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bean1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"example.exampleBean\"</span> <span class=\"attr\">lazy-init</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p>\n<ul>\n<li>优点：尽可能的节约了资源</li>\n<li>缺点：可能导致某个操作响应时间增加</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-4-Bean装配的Aware接口\"><a href=\"#6-4-Bean装配的Aware接口\" class=\"headerlink\" title=\"6.4 Bean装配的Aware接口\"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p>\n<ol>\n<li>ApplicationContextAware<ul>\n<li>接口方法：setApplicationContext</li>\n<li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>\n<li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>\n</ul>\n</li>\n<li>BeanNameAware<ul>\n<li>接口方法：setBeanName</li>\n<li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li>\n<li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-4-Bean装配之Resource\"><a href=\"#6-4-Bean装配之Resource\" class=\"headerlink\" title=\"6.4 Bean装配之Resource\"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p>\n<ol>\n<li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li>\n<li>ClassPathResource：获取类路径下的资源</li>\n<li>FileSystemResource：获取文件系统里面的资源</li>\n<li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li>\n<li>InputStreamResource：获取输入流封装的资源</li>\n<li>ByteArrayResource：获取字节数组封装的资源</li>\n</ol>\n<p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p>\n<ul>\n<li>getResource()参数：<ul>\n<li>classPath方式：”classPath:class路径下文件”</li>\n<li>file方式： “file:本地磁盘文件绝对地址”</li>\n<li>url方式： “url:URL地址下文件”</li>\n<li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li>\n</ul>\n</li>\n<li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li>\n</ul>"},{"title":"十八、Spring MVC框架","date":"2019-08-27T14:50:22.000Z","_content":"\nSpring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。\n<!-- more -->\n\n1. [Spring MVC基本概念](#id1)\n2. [Spring MVC的编写步骤](#id2)\n3. [标注(注解)形式的MVC](#id3)\n4. [mvc控制器接收页面参数](#id4)\n5. [mvc控制器把数据传递给页面](#id5)\n6. [Spring MVC实现重定向](#id6)\n7. [Spring MVC 中文参数的乱码问题](#id7)\n8. [Spring MVC 拦截器](#id8)\n9. [Spring MVC 拦截器的使用步骤](#id9)\n10. [Spring MVC异常处理](#id10)\n11. [Spring MVC文件上传](#id11)\n12. [文件上传与异常处理的结合](#id12)\n13. [Spring MVC响应JSON](#id13)\n14. [REST](#id14)\n15. [REST实例](#id15)\n\n\n\n\n<span id=\"id1\"><span>\n### 1. Spring MVC基本概念\n#### 1.1 Spring MVC 五大核心组件\nSpring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。\n1. DispatcherServlet：控制器，请求入口\n2. HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系\n3. Controller：控制器，处理请求\n4. ModelAndView：封装了 数据信息和视图信息\n5. ViewResolver：视图处理器\n\n他的两个核心是两个核心：\n- 处理器映射：选择使用哪个控制器来处理请求 \n- 视图解析器：选择结果应该如何渲染\n> 通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。\n\n#### 1.2 SpringMVC运行原理\n1. Http请求：客户端请求提交到DispatcherServlet。 \n2. 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 \n3. 调用处理器：DispatcherServlet将请求提交到Controller。 \n4. 调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 \n5. 处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 \n6. Http响应：视图负责将结果显示到客户端。\n\n#### 1.3 SpringMVC接口解释\n1. **DispatcherServlet接口**：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： \n    1. 截获符合特定格式的URL请求。 \n    2. 初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 \n    3. 初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。\n2. **HandlerMapping接口**：能够完成客户请求到Controller映射。 \n3. **Controller接口**： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 \n    - Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 \n    - 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 \n4. **ViewResolver接口**：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。\n\n#### 1.4 SpringMVC配置\n1. 在web.xml文件中进行配置applicationContext.xml路径\n``` xml\n<!-- 配置DispatcherServlet -->\n<servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>*.do</url-pattern>\n</servlet-mapping>\n```\n\n2. 配置applicationContext.xml，开启注解功能、配置试图解析器\n``` xml\n\t<!-- 配置HandlerMapping -->\n\t<bean id=\"handlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n\t\t<property name=\"mappings\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"/toHello.do\">helloController</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\t<!-- 控制器对象 -->\n\t<bean id=\"helloController\" class=\"com.controller.MyHelleController\"></bean>\n\t<!-- 配置视图处理器 -->\n\t<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<property name=\"prefix\" value=\"/WEB-INF/\"></property>\n\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t</bean>\n```\n\n\n\n<span id=\"id2\"><span>\n### 2. Spring MVC的编写步骤\n1. 建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。\n2. 在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。\n3. 在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。\n4. 编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象\n5. 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。\n\n\n<span id=\"id3\"><span>\n### 3. 标注(注解)形式的MVC\n1. 建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。\n2. 在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。\n3. 开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。\n``` xml\n<context:component-scan base-package=\"包名\" />\n<mvc:annotation-driven />\n```\n\n4. 编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）\n    + 使用`@Controller` 可以把普通Java类转换成控制器，同时在容器中创建对象\n    + 使用`@RequestMapping(\"/路径\")` 设置方法上\n5. 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。\n\n\n<span id=\"id4\"><span>\n### 4. mvc控制器接收页面参数\n1. 使用HttpServletRequest类型的参数来接收\n``` java\n@RequestMapping(\"/login.do\")\npublic String login(HttpServletRequest request) {\n    String acc_no = request.getParameter(\"acc_no\");\n    String acc_pwd = request.getParameter(\"acc_password\");\n    return \"main\";\n}\n```\n\n2. 直接定义和页面请求参数同名的控制器参数\n``` java\n@RequestMapping(\"/login2.do\")\npublic ModelAndView login2(String acc_no,String acc_password, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n3. 当页面参数和控制器参数名字不一致，@RequestParam(\"acc_no\") 让请求参数和控制器参数对应\n``` java\n@RequestMapping(\"/login3.do\")\npublic ModelAndView login3(@RequestParam(\"acc_no\") String a,String acc_password, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n4. 控制器中 直接定义对象类型的参数\n``` java\n@RequestMapping(\"/login4.do\")\npublic ModelAndView login4(Account acc, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. mvc控制器把数据传递给页面 \n使用EL表达式在jsp页面接收数据`<h1>欢迎 ${acc_no} </h1>`\n1. 使用域对象 进行传输 (request session ServletContext )\n``` java\n@RequestMapping(\"/login6.do\")\npublic String login6(String acc_no, HttpServletRequest req) {\n    req.setAttribute(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n2. 使用ModelAndView进行数据传输 \n    + `mav.getModel().put(\"acc_no\", acc_no);`\n    + `mav.getModelMap().put(key, value);`\n    + `mav.getModelMap().addAttribute(\"acc_no\", acc_no);`\n\n``` java\n@RequestMapping(\"/login7.do\")\npublic ModelAndView login7(String acc_no, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    //mav.getModel().put(\"acc_no\", acc_no);\n    //mav.getModelMap().put(key, value)\n    mav.getModelMap().addAttribute(\"acc_no\", acc_no);\n    return mav;\n}\n```\n\n3. 使用Model进行数据传输\n``` java\n@RequestMapping(\"/login8.do\")\npublic String login8(String acc_no, Model m) {\n    m.addAttribute(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n4. 使用ModelMap进行数据传输\n``` java\n@RequestMapping(\"/login9.do\")\npublic String login9(String acc_no, ModelMap m) {\n    //m.addAttribute(\"acc_no\", acc_no);\n    m.put(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n5. 使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(\"新名\")修改）\n    + 默认名：`<h1>欢迎 ${ account.acc_no } </h1>`\n    + @ModelAttribute(\"acc\")：`<h1>欢迎 ${ acc.acc_no } </h1>`\n\n``` java\n@RequestMapping(\"/login10.do\")\npublic String login10(@ModelAttribute(\"acc\") Account acc) {\n    return \"main\";\n}\n```\n\n\n<span id=\"id6\"><span>\n### 6. Spring MVC实现重定向\n1. 控制器方法返回String \n    + redirect:请求路径\n\n``` java\n@RequestMapping(\"/login11.do\")\npublic String login11(@ModelAttribute(\"acc\") Account acc) {\n    //return \"forward:toMain.do\";\n    return \"redirect:toMain.do\";\n}\n@RequestMapping(\"/toMain.do\")\npublic String toMain() {\n    // 干其它的事情\n    return \"main\";\n}\n```\n\n2. 控制器方法返回ModelAndView \n    + 使用RedirectView  完成\n\n``` java\n@RequestMapping(\"/login12.do\")\npublic ModelAndView login12(@ModelAttribute(\"acc\") Account acc) {\n    ModelAndView mav = new ModelAndView();\n    //重定向\n    RedirectView rv = new RedirectView(\"toMain.do\");\n    mav.setView(rv);\n    return mav;\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. Spring MVC 中文参数的乱码问题 \ntomcat8中 get 没有乱码问题，post 请求有乱码问题 \n1. 参数为页面(HttpServletRequest request)与(HttpServletResponse response)时\n``` java\nrequest.setCharacterEncoding(\"UTF-8\");\nresponse.setContentType(\"application/json;charset=UTF-8\");\n```\n\n2. 传入参数为`@RequestParam`时，可以通过字符串重新编码来解决\n``` java\nnew String(string.getBytes(\"ISO-8859-1\"),\"UTF-8\");\n```\n\n3. 方法名前出现`@RequestMapping(value=\"XXX\")`时可以在value属性后再加一个属性`produces=\"text/html;charset=UTF-8\"`来解决\n\n4. 在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器\n``` java\n<filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>*.do</url-pattern>\n</filter-mapping>\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. Spring MVC 拦截器\n1. 拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）\n2. HandlerMapping接口\n    * preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。\n    * postHandle：处理器执行后、视图处理前调用。\n    * afterCompletion：整个请求处理完毕后调用。\n\n\n\n<span id=\"id9\"><span>\n### 9. Spring MVC 拦截器的使用步骤\n1. 搭建一个基于标注的mvc\n2. 编写一个类实现HandlerInterceptor接口\n3. 在Spring配置文件中配置拦截器\n``` xml\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/**\"/>\n        <mvc:exclude-mapping path=\"/login.do\"/>\n        <bean class=\"com.xdl.interceptor.SomeInterceptor\"/>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Spring MVC异常处理\n1. 配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常\n``` xml\n<bean id=\"simpleExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\">\n        <props>\n            <prop key=\"java.lang.RuntimeException\">error</prop>\n            <prop key=\"java.lang.Exception\">error2</prop>\n        </props>\n    </property>\n</bean>\n```\n\n2. 自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常\n``` java\n@Controller\npublic class MyExceptionResolver implements HandlerExceptionResolver {\n\t@Override\n\tpublic ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e) {\n\t\tModelAndView mav = new ModelAndView();\n\t\tif(e instanceof RuntimeException) {\n\t\t\tmav.setViewName(\"error\");\n\t\t}else if(e instanceof Exception) {\n\t\t\tmav.setViewName(\"error2\");\n\t\t}\n\t\treturn mav;\n\t}\n}\n```\n\n3. 使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)\n``` java\n//@Controller\n//public class MyController {\n@ExceptionHandler\npublic String processException(Exception e) {\n    System.out.println(e.getMessage());\n    return \"error3\";\n}\n```\n\n\n\n<span id=\"id11\"><span>\n### 11. Spring MVC文件上传\n1. jsp页面（method=\"POST\" enctype=\"multipart/form-data type=\"file\"）\n``` html\n<form action=\"upload.do\" method=\"post\" enctype=\"multipart/form-data\">\n    头像：<input type=\"file\" name=\"head_img\"><br>\n    <input type=\"submit\" value=\"上传\"><br>\n</form>\n```\n2. 控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）\n``` xml\n<bean id=\"multipartResolver\" \n    class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n</bean>\n```\n\n\n\n<span id=\"id12\"><span>\n### 12. 文件上传与异常处理的结合\n``` java\n@Controller\npublic class fileController {\n\t@RequestMapping(\"/toFile.do\")\n\tpublic String tofile() {\n\t\treturn \"file\";\n\t}\n\t@RequestMapping(\"/upload.do\")\n\tpublic String upload(String acc_no, MultipartFile head_img) {\n\t\tSystem.out.println(\"acc_no:\" + acc_no );\n\t\tif(head_img.getSize()>1024*10) {\n\t\t\tthrow new RuntimeException(\"文件过大！\");\n\t\t}\n\t\t// 把文件写入磁盘\n\t\tString uniqueStr = UUID.randomUUID().toString();\n\t\tString oriFilename = head_img.getOriginalFilename();\n\t\tString suffix = oriFilename.substring(oriFilename.lastIndexOf(\".\"));\n\t\tFile file = new File(\"F:/Eclipse/datas/\"+uniqueStr+suffix);\n\t\ttry {\n\t\t\thead_img.transferTo(file);\n\t\t} catch (IllegalStateException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(oriFilename);\n\t\tSystem.out.println(file);\n\t\treturn \"file\";\n\t}\n\t/** 局部异常 */\n\t@ExceptionHandler\n\tpublic String processError(Exception e) {\n\t\treturn \"error4\";\n\t}\n}\n```\n\n\n\n<span id=\"id13\"><span>\n### 13. Spring MVC响应JSON\n1. 搭建基于标注的mvc\n2. 在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON\n4. 给方法加@RequestMapping(\"/请求路径\")、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包\n\n\n\n<span id=\"id14\"><span>\n### 14. REST\nREST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。\n1. REST两个核心规范\n    * url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:http://test/source/1234）\n    * 对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新\n2. restful\n    * 符合REST设计规范和风格的应用程序或设计 就是RESTful\n3. Spring MVC对REST的支持\n    * @RequestMapping支持URI的模板，以及http请求方式设定的支持\n        + `@RequestMapping(value=\"/account/{id}\",method=RequestMethod.POST)`\n    * 对URI上路径变量的处理的支持，@PathVariable\n        + `@PathVariable(\"id\") int id`\n    * rest请求路径是没有后缀的，需要把url-parttern修改成`/`\n    * `<servlet-mapping><servlet-name>DispatcherServlet</servlet-name><url-pattern>/</url-pattern></servlet-mapping>`\n    * 需要对静态资源进行放行`<mvc:default-servlet-handler/>`\n \n\n\n<span id=\"id15\"><span>\n### 15. REST实例\n1. 配置web.xml与applicationContext.xml(部分配置)\n\n``` xml\n<!-- 修改rest请求路径 -->\n<!-- web.xml -->\n    <servlet-mapping>\n      <servlet-name>DispatcherServlet</servlet-name>\n      <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n<!-- 对静态资源进行放行 -->\n<!-- applicationContext.xml -->\n    <mvc:default-servlet-handler/>\n```\n\n2. 编写控制类\n\n``` java\n@Controller\npublic class AccountController {\n    @RequestMapping(\"/toLogin.do\")\n    public String toLogin() {\n        return \"login\";\n    }\n/** 根据id查询账户 GET */\n    @RequestMapping(value=\"/account/{id}\", method=RequestMethod.GET)\n    @ResponseBody\n    public Account getAccountById(@PathVariable(\"id\") int id) {\n        Random rm = new Random();\n        Account acc = new Account(id, \"test\"+rm.nextInt(100),\"123\", rm.nextInt(999)+1000);\n        return acc;\n    }\n/** 新增账户 POST */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.POST)\n    @ResponseBody\n    public boolean addAccount(Account acc) {\n        System.out.println(\"add:\"+acc);\n        if(acc.getId()>100) return true;\n        return false;\n    }\n/** 根据id删除帐户对象 DELETE */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.DELETE)\n    @ResponseBody\n    public boolean deleteAccountById(@PathVariable(\"id\") int id) {\n        System.out.println(\"delete:\"+id);\n        if(id>100) return true;\n        return false;\n    }\n/** 根据id更新帐户 PUT */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.PUT)\n    @ResponseBody\n    public boolean putAccount(@RequestBody Account acc) {\n        //@RequestBody将接收的ajax请求的json字符串写入Account对象中\n        System.out.println(\"update:\"+acc);\n        if(acc.getId()>100) return true;\n        return false;\n    }\n}\n```\n\n3. 编写jsp页面\n\n``` html\n<form>\n    <p>ID：<input id=\"accountId\"></p>\n    <p>姓名：<input id=\"accountNo\"></p>\n    <p>密码：<input id=\"accountPassword\"></p>\n    <p>金额：<input id=\"accountMoney\"></p>\n    <button id=\"findBtn\" type=\"button\">查询</button>\n    <button id=\"addBtn\" type=\"button\">添加</button>\n    <button id=\"updateBtn\" type=\"button\">更新</button>\n    <button id=\"delBtn\" type=\"button\">删除</button>\n</form>\n\n<script src=\"js/jquery.min.js\"></script>\n<script>\n$(\"#findBtn\").on(\"click\", function(){\n    findAccount();\n});\n$(\"#addBtn\").on(\"click\", function(){\n    addAccount();\n});\n$(\"#updateBtn\").on(\"click\", function(){\n    updateAccount();\n});\n$(\"#delBtn\").on(\"click\", function(){\n    delAccount();\n});\nfunction getDatas(){\n\tvar accountId = $(\"#accountId\").val();\n\tvar accountNo = $(\"#accountNo\").val();\n\tvar accountPassword = $(\"#accountPassword\").val();\n\tvar accountMoney = $(\"#accountMoney\").val();\n\treturn {\n\t    id: accountId,\n\t    acc_no: accountNo,\n\t    acc_password: accountPassword,\n\t    acc_money: accountMoney\n\t};\n}\nfunction findAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"get\",\n        success: function(res){\n            $(\"#accountNo\").val(res.acc_no);\n            $(\"#accountPassword\").val(res.acc_password);\n            $(\"#accountMoney\").val(res.acc_money);\n        },\n    });\n}\nfunction addAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"post\",\n        data: datas,\n        success: function(res){\n            alert(res);\n        },\n    });\n}\nfunction delAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"delete\",\n        success: function(res){\n            alert(res);\n        },\n    });\n}\nfunction updateAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url:\"account/\"+ datas.id,\n        type:\"put\",\n        data:JSON.stringify(datas),\n        contentType:\"application/json\",//以json字符串提交数据\n        success: function(res){\n            alert(res);\n        },\n    });\n}\n</script>\n```\n\n注意：\n> - PUT需要以json字符串提交数据`contentType:\"application/json\"`\n> - @RequestBody将接收的ajax请求的json字符串写入Account对象中\n> - JSON.stringify()：将json对象转换为json字符串\n> - JSON.parse()：将json字符串转换为json对象","source":"_posts/18-SpringMVC框架.md","raw":"---\ntitle: 十八、Spring MVC框架\ndate: 2019-08-27 22:50:22\ntags: [javaEE, 后端开发, Spring]\ncategories: JavaWeb编程\n---\n\nSpring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。\n<!-- more -->\n\n1. [Spring MVC基本概念](#id1)\n2. [Spring MVC的编写步骤](#id2)\n3. [标注(注解)形式的MVC](#id3)\n4. [mvc控制器接收页面参数](#id4)\n5. [mvc控制器把数据传递给页面](#id5)\n6. [Spring MVC实现重定向](#id6)\n7. [Spring MVC 中文参数的乱码问题](#id7)\n8. [Spring MVC 拦截器](#id8)\n9. [Spring MVC 拦截器的使用步骤](#id9)\n10. [Spring MVC异常处理](#id10)\n11. [Spring MVC文件上传](#id11)\n12. [文件上传与异常处理的结合](#id12)\n13. [Spring MVC响应JSON](#id13)\n14. [REST](#id14)\n15. [REST实例](#id15)\n\n\n\n\n<span id=\"id1\"><span>\n### 1. Spring MVC基本概念\n#### 1.1 Spring MVC 五大核心组件\nSpring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。\n1. DispatcherServlet：控制器，请求入口\n2. HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系\n3. Controller：控制器，处理请求\n4. ModelAndView：封装了 数据信息和视图信息\n5. ViewResolver：视图处理器\n\n他的两个核心是两个核心：\n- 处理器映射：选择使用哪个控制器来处理请求 \n- 视图解析器：选择结果应该如何渲染\n> 通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。\n\n#### 1.2 SpringMVC运行原理\n1. Http请求：客户端请求提交到DispatcherServlet。 \n2. 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 \n3. 调用处理器：DispatcherServlet将请求提交到Controller。 \n4. 调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 \n5. 处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 \n6. Http响应：视图负责将结果显示到客户端。\n\n#### 1.3 SpringMVC接口解释\n1. **DispatcherServlet接口**：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： \n    1. 截获符合特定格式的URL请求。 \n    2. 初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 \n    3. 初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。\n2. **HandlerMapping接口**：能够完成客户请求到Controller映射。 \n3. **Controller接口**： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 \n    - Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 \n    - 从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 \n4. **ViewResolver接口**：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。\n\n#### 1.4 SpringMVC配置\n1. 在web.xml文件中进行配置applicationContext.xml路径\n``` xml\n<!-- 配置DispatcherServlet -->\n<servlet>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n<servlet-mapping>\n    <servlet-name>DispatcherServlet</servlet-name>\n    <url-pattern>*.do</url-pattern>\n</servlet-mapping>\n```\n\n2. 配置applicationContext.xml，开启注解功能、配置试图解析器\n``` xml\n\t<!-- 配置HandlerMapping -->\n\t<bean id=\"handlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n\t\t<property name=\"mappings\">\n\t\t\t<props>\n\t\t\t\t<prop key=\"/toHello.do\">helloController</prop>\n\t\t\t</props>\n\t\t</property>\n\t</bean>\n\t<!-- 控制器对象 -->\n\t<bean id=\"helloController\" class=\"com.controller.MyHelleController\"></bean>\n\t<!-- 配置视图处理器 -->\n\t<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n\t\t<property name=\"prefix\" value=\"/WEB-INF/\"></property>\n\t\t<property name=\"suffix\" value=\".jsp\"></property>\n\t</bean>\n```\n\n\n\n<span id=\"id2\"><span>\n### 2. Spring MVC的编写步骤\n1. 建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。\n2. 在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。\n3. 在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。\n4. 编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象\n5. 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。\n\n\n<span id=\"id3\"><span>\n### 3. 标注(注解)形式的MVC\n1. 建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。\n2. 在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。\n3. 开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。\n``` xml\n<context:component-scan base-package=\"包名\" />\n<mvc:annotation-driven />\n```\n\n4. 编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）\n    + 使用`@Controller` 可以把普通Java类转换成控制器，同时在容器中创建对象\n    + 使用`@RequestMapping(\"/路径\")` 设置方法上\n5. 在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。\n\n\n<span id=\"id4\"><span>\n### 4. mvc控制器接收页面参数\n1. 使用HttpServletRequest类型的参数来接收\n``` java\n@RequestMapping(\"/login.do\")\npublic String login(HttpServletRequest request) {\n    String acc_no = request.getParameter(\"acc_no\");\n    String acc_pwd = request.getParameter(\"acc_password\");\n    return \"main\";\n}\n```\n\n2. 直接定义和页面请求参数同名的控制器参数\n``` java\n@RequestMapping(\"/login2.do\")\npublic ModelAndView login2(String acc_no,String acc_password, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n3. 当页面参数和控制器参数名字不一致，@RequestParam(\"acc_no\") 让请求参数和控制器参数对应\n``` java\n@RequestMapping(\"/login3.do\")\npublic ModelAndView login3(@RequestParam(\"acc_no\") String a,String acc_password, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n4. 控制器中 直接定义对象类型的参数\n``` java\n@RequestMapping(\"/login4.do\")\npublic ModelAndView login4(Account acc, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    return mav;\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. mvc控制器把数据传递给页面 \n使用EL表达式在jsp页面接收数据`<h1>欢迎 ${acc_no} </h1>`\n1. 使用域对象 进行传输 (request session ServletContext )\n``` java\n@RequestMapping(\"/login6.do\")\npublic String login6(String acc_no, HttpServletRequest req) {\n    req.setAttribute(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n2. 使用ModelAndView进行数据传输 \n    + `mav.getModel().put(\"acc_no\", acc_no);`\n    + `mav.getModelMap().put(key, value);`\n    + `mav.getModelMap().addAttribute(\"acc_no\", acc_no);`\n\n``` java\n@RequestMapping(\"/login7.do\")\npublic ModelAndView login7(String acc_no, ModelAndView mav) {\n    mav.setViewName(\"main\");\n    //mav.getModel().put(\"acc_no\", acc_no);\n    //mav.getModelMap().put(key, value)\n    mav.getModelMap().addAttribute(\"acc_no\", acc_no);\n    return mav;\n}\n```\n\n3. 使用Model进行数据传输\n``` java\n@RequestMapping(\"/login8.do\")\npublic String login8(String acc_no, Model m) {\n    m.addAttribute(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n4. 使用ModelMap进行数据传输\n``` java\n@RequestMapping(\"/login9.do\")\npublic String login9(String acc_no, ModelMap m) {\n    //m.addAttribute(\"acc_no\", acc_no);\n    m.put(\"acc_no\", acc_no);\n    return \"main\";\n}\n```\n\n5. 使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(\"新名\")修改）\n    + 默认名：`<h1>欢迎 ${ account.acc_no } </h1>`\n    + @ModelAttribute(\"acc\")：`<h1>欢迎 ${ acc.acc_no } </h1>`\n\n``` java\n@RequestMapping(\"/login10.do\")\npublic String login10(@ModelAttribute(\"acc\") Account acc) {\n    return \"main\";\n}\n```\n\n\n<span id=\"id6\"><span>\n### 6. Spring MVC实现重定向\n1. 控制器方法返回String \n    + redirect:请求路径\n\n``` java\n@RequestMapping(\"/login11.do\")\npublic String login11(@ModelAttribute(\"acc\") Account acc) {\n    //return \"forward:toMain.do\";\n    return \"redirect:toMain.do\";\n}\n@RequestMapping(\"/toMain.do\")\npublic String toMain() {\n    // 干其它的事情\n    return \"main\";\n}\n```\n\n2. 控制器方法返回ModelAndView \n    + 使用RedirectView  完成\n\n``` java\n@RequestMapping(\"/login12.do\")\npublic ModelAndView login12(@ModelAttribute(\"acc\") Account acc) {\n    ModelAndView mav = new ModelAndView();\n    //重定向\n    RedirectView rv = new RedirectView(\"toMain.do\");\n    mav.setView(rv);\n    return mav;\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. Spring MVC 中文参数的乱码问题 \ntomcat8中 get 没有乱码问题，post 请求有乱码问题 \n1. 参数为页面(HttpServletRequest request)与(HttpServletResponse response)时\n``` java\nrequest.setCharacterEncoding(\"UTF-8\");\nresponse.setContentType(\"application/json;charset=UTF-8\");\n```\n\n2. 传入参数为`@RequestParam`时，可以通过字符串重新编码来解决\n``` java\nnew String(string.getBytes(\"ISO-8859-1\"),\"UTF-8\");\n```\n\n3. 方法名前出现`@RequestMapping(value=\"XXX\")`时可以在value属性后再加一个属性`produces=\"text/html;charset=UTF-8\"`来解决\n\n4. 在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器\n``` java\n<filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>*.do</url-pattern>\n</filter-mapping>\n```\n\n\n\n<span id=\"id8\"><span>\n### 8. Spring MVC 拦截器\n1. 拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）\n2. HandlerMapping接口\n    * preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。\n    * postHandle：处理器执行后、视图处理前调用。\n    * afterCompletion：整个请求处理完毕后调用。\n\n\n\n<span id=\"id9\"><span>\n### 9. Spring MVC 拦截器的使用步骤\n1. 搭建一个基于标注的mvc\n2. 编写一个类实现HandlerInterceptor接口\n3. 在Spring配置文件中配置拦截器\n``` xml\n<mvc:interceptors>\n    <mvc:interceptor>\n        <mvc:mapping path=\"/**\"/>\n        <mvc:exclude-mapping path=\"/login.do\"/>\n        <bean class=\"com.xdl.interceptor.SomeInterceptor\"/>\n    </mvc:interceptor>\n</mvc:interceptors>\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Spring MVC异常处理\n1. 配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常\n``` xml\n<bean id=\"simpleExceptionResolver\" class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    <property name=\"exceptionMappings\">\n        <props>\n            <prop key=\"java.lang.RuntimeException\">error</prop>\n            <prop key=\"java.lang.Exception\">error2</prop>\n        </props>\n    </property>\n</bean>\n```\n\n2. 自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常\n``` java\n@Controller\npublic class MyExceptionResolver implements HandlerExceptionResolver {\n\t@Override\n\tpublic ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e) {\n\t\tModelAndView mav = new ModelAndView();\n\t\tif(e instanceof RuntimeException) {\n\t\t\tmav.setViewName(\"error\");\n\t\t}else if(e instanceof Exception) {\n\t\t\tmav.setViewName(\"error2\");\n\t\t}\n\t\treturn mav;\n\t}\n}\n```\n\n3. 使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)\n``` java\n//@Controller\n//public class MyController {\n@ExceptionHandler\npublic String processException(Exception e) {\n    System.out.println(e.getMessage());\n    return \"error3\";\n}\n```\n\n\n\n<span id=\"id11\"><span>\n### 11. Spring MVC文件上传\n1. jsp页面（method=\"POST\" enctype=\"multipart/form-data type=\"file\"）\n``` html\n<form action=\"upload.do\" method=\"post\" enctype=\"multipart/form-data\">\n    头像：<input type=\"file\" name=\"head_img\"><br>\n    <input type=\"submit\" value=\"上传\"><br>\n</form>\n```\n2. 控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）\n``` xml\n<bean id=\"multipartResolver\" \n    class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">\n</bean>\n```\n\n\n\n<span id=\"id12\"><span>\n### 12. 文件上传与异常处理的结合\n``` java\n@Controller\npublic class fileController {\n\t@RequestMapping(\"/toFile.do\")\n\tpublic String tofile() {\n\t\treturn \"file\";\n\t}\n\t@RequestMapping(\"/upload.do\")\n\tpublic String upload(String acc_no, MultipartFile head_img) {\n\t\tSystem.out.println(\"acc_no:\" + acc_no );\n\t\tif(head_img.getSize()>1024*10) {\n\t\t\tthrow new RuntimeException(\"文件过大！\");\n\t\t}\n\t\t// 把文件写入磁盘\n\t\tString uniqueStr = UUID.randomUUID().toString();\n\t\tString oriFilename = head_img.getOriginalFilename();\n\t\tString suffix = oriFilename.substring(oriFilename.lastIndexOf(\".\"));\n\t\tFile file = new File(\"F:/Eclipse/datas/\"+uniqueStr+suffix);\n\t\ttry {\n\t\t\thead_img.transferTo(file);\n\t\t} catch (IllegalStateException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(oriFilename);\n\t\tSystem.out.println(file);\n\t\treturn \"file\";\n\t}\n\t/** 局部异常 */\n\t@ExceptionHandler\n\tpublic String processError(Exception e) {\n\t\treturn \"error4\";\n\t}\n}\n```\n\n\n\n<span id=\"id13\"><span>\n### 13. Spring MVC响应JSON\n1. 搭建基于标注的mvc\n2. 在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON\n4. 给方法加@RequestMapping(\"/请求路径\")、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包\n\n\n\n<span id=\"id14\"><span>\n### 14. REST\nREST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。\n1. REST两个核心规范\n    * url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:http://test/source/1234）\n    * 对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新\n2. restful\n    * 符合REST设计规范和风格的应用程序或设计 就是RESTful\n3. Spring MVC对REST的支持\n    * @RequestMapping支持URI的模板，以及http请求方式设定的支持\n        + `@RequestMapping(value=\"/account/{id}\",method=RequestMethod.POST)`\n    * 对URI上路径变量的处理的支持，@PathVariable\n        + `@PathVariable(\"id\") int id`\n    * rest请求路径是没有后缀的，需要把url-parttern修改成`/`\n    * `<servlet-mapping><servlet-name>DispatcherServlet</servlet-name><url-pattern>/</url-pattern></servlet-mapping>`\n    * 需要对静态资源进行放行`<mvc:default-servlet-handler/>`\n \n\n\n<span id=\"id15\"><span>\n### 15. REST实例\n1. 配置web.xml与applicationContext.xml(部分配置)\n\n``` xml\n<!-- 修改rest请求路径 -->\n<!-- web.xml -->\n    <servlet-mapping>\n      <servlet-name>DispatcherServlet</servlet-name>\n      <url-pattern>/</url-pattern>\n    </servlet-mapping>\n\n<!-- 对静态资源进行放行 -->\n<!-- applicationContext.xml -->\n    <mvc:default-servlet-handler/>\n```\n\n2. 编写控制类\n\n``` java\n@Controller\npublic class AccountController {\n    @RequestMapping(\"/toLogin.do\")\n    public String toLogin() {\n        return \"login\";\n    }\n/** 根据id查询账户 GET */\n    @RequestMapping(value=\"/account/{id}\", method=RequestMethod.GET)\n    @ResponseBody\n    public Account getAccountById(@PathVariable(\"id\") int id) {\n        Random rm = new Random();\n        Account acc = new Account(id, \"test\"+rm.nextInt(100),\"123\", rm.nextInt(999)+1000);\n        return acc;\n    }\n/** 新增账户 POST */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.POST)\n    @ResponseBody\n    public boolean addAccount(Account acc) {\n        System.out.println(\"add:\"+acc);\n        if(acc.getId()>100) return true;\n        return false;\n    }\n/** 根据id删除帐户对象 DELETE */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.DELETE)\n    @ResponseBody\n    public boolean deleteAccountById(@PathVariable(\"id\") int id) {\n        System.out.println(\"delete:\"+id);\n        if(id>100) return true;\n        return false;\n    }\n/** 根据id更新帐户 PUT */\n    @RequestMapping(value=\"/account/{id}\",method=RequestMethod.PUT)\n    @ResponseBody\n    public boolean putAccount(@RequestBody Account acc) {\n        //@RequestBody将接收的ajax请求的json字符串写入Account对象中\n        System.out.println(\"update:\"+acc);\n        if(acc.getId()>100) return true;\n        return false;\n    }\n}\n```\n\n3. 编写jsp页面\n\n``` html\n<form>\n    <p>ID：<input id=\"accountId\"></p>\n    <p>姓名：<input id=\"accountNo\"></p>\n    <p>密码：<input id=\"accountPassword\"></p>\n    <p>金额：<input id=\"accountMoney\"></p>\n    <button id=\"findBtn\" type=\"button\">查询</button>\n    <button id=\"addBtn\" type=\"button\">添加</button>\n    <button id=\"updateBtn\" type=\"button\">更新</button>\n    <button id=\"delBtn\" type=\"button\">删除</button>\n</form>\n\n<script src=\"js/jquery.min.js\"></script>\n<script>\n$(\"#findBtn\").on(\"click\", function(){\n    findAccount();\n});\n$(\"#addBtn\").on(\"click\", function(){\n    addAccount();\n});\n$(\"#updateBtn\").on(\"click\", function(){\n    updateAccount();\n});\n$(\"#delBtn\").on(\"click\", function(){\n    delAccount();\n});\nfunction getDatas(){\n\tvar accountId = $(\"#accountId\").val();\n\tvar accountNo = $(\"#accountNo\").val();\n\tvar accountPassword = $(\"#accountPassword\").val();\n\tvar accountMoney = $(\"#accountMoney\").val();\n\treturn {\n\t    id: accountId,\n\t    acc_no: accountNo,\n\t    acc_password: accountPassword,\n\t    acc_money: accountMoney\n\t};\n}\nfunction findAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"get\",\n        success: function(res){\n            $(\"#accountNo\").val(res.acc_no);\n            $(\"#accountPassword\").val(res.acc_password);\n            $(\"#accountMoney\").val(res.acc_money);\n        },\n    });\n}\nfunction addAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"post\",\n        data: datas,\n        success: function(res){\n            alert(res);\n        },\n    });\n}\nfunction delAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url: \"account/\" + datas.id,\n        type: \"delete\",\n        success: function(res){\n            alert(res);\n        },\n    });\n}\nfunction updateAccount(){\n\tvar datas = getDatas();\n    $.ajax({\n        url:\"account/\"+ datas.id,\n        type:\"put\",\n        data:JSON.stringify(datas),\n        contentType:\"application/json\",//以json字符串提交数据\n        success: function(res){\n            alert(res);\n        },\n    });\n}\n</script>\n```\n\n注意：\n> - PUT需要以json字符串提交数据`contentType:\"application/json\"`\n> - @RequestBody将接收的ajax请求的json字符串写入Account对象中\n> - JSON.stringify()：将json对象转换为json字符串\n> - JSON.parse()：将json字符串转换为json对象","slug":"18-SpringMVC框架","published":1,"updated":"2019-08-27T14:55:17.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztyloao003dyot3ktr5watk","content":"<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Spring MVC基本概念</a></li>\n<li><a href=\"#id2\">Spring MVC的编写步骤</a></li>\n<li><a href=\"#id3\">标注(注解)形式的MVC</a></li>\n<li><a href=\"#id4\">mvc控制器接收页面参数</a></li>\n<li><a href=\"#id5\">mvc控制器把数据传递给页面</a></li>\n<li><a href=\"#id6\">Spring MVC实现重定向</a></li>\n<li><a href=\"#id7\">Spring MVC 中文参数的乱码问题</a></li>\n<li><a href=\"#id8\">Spring MVC 拦截器</a></li>\n<li><a href=\"#id9\">Spring MVC 拦截器的使用步骤</a></li>\n<li><a href=\"#id10\">Spring MVC异常处理</a></li>\n<li><a href=\"#id11\">Spring MVC文件上传</a></li>\n<li><a href=\"#id12\">文件上传与异常处理的结合</a></li>\n<li><a href=\"#id13\">Spring MVC响应JSON</a></li>\n<li><a href=\"#id14\">REST</a></li>\n<li><a href=\"#id15\">REST实例</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Spring-MVC基本概念\"><a href=\"#1-Spring-MVC基本概念\" class=\"headerlink\" title=\"1. Spring MVC基本概念\"></a>1. Spring MVC基本概念</h3><h4 id=\"1-1-Spring-MVC-五大核心组件\"><a href=\"#1-1-Spring-MVC-五大核心组件\" class=\"headerlink\" title=\"1.1 Spring MVC 五大核心组件\"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p>\n<ol>\n<li>DispatcherServlet：控制器，请求入口</li>\n<li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li>\n<li>Controller：控制器，处理请求</li>\n<li>ModelAndView：封装了 数据信息和视图信息</li>\n<li>ViewResolver：视图处理器</li>\n</ol>\n<p>他的两个核心是两个核心：</p>\n<ul>\n<li>处理器映射：选择使用哪个控制器来处理请求 </li>\n<li>视图解析器：选择结果应该如何渲染<blockquote>\n<p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"1-2-SpringMVC运行原理\"><a href=\"#1-2-SpringMVC运行原理\" class=\"headerlink\" title=\"1.2 SpringMVC运行原理\"></a>1.2 SpringMVC运行原理</h4><ol>\n<li>Http请求：客户端请求提交到DispatcherServlet。 </li>\n<li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li>\n<li>调用处理器：DispatcherServlet将请求提交到Controller。 </li>\n<li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li>\n<li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li>\n<li>Http响应：视图负责将结果显示到客户端。</li>\n</ol>\n<h4 id=\"1-3-SpringMVC接口解释\"><a href=\"#1-3-SpringMVC接口解释\" class=\"headerlink\" title=\"1.3 SpringMVC接口解释\"></a>1.3 SpringMVC接口解释</h4><ol>\n<li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol>\n<li>截获符合特定格式的URL请求。 </li>\n<li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li>\n<li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li>\n</ol>\n</li>\n<li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li>\n<li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul>\n<li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li>\n<li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 </li>\n</ul>\n</li>\n<li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li>\n</ol>\n<h4 id=\"1-4-SpringMVC配置\"><a href=\"#1-4-SpringMVC配置\" class=\"headerlink\" title=\"1.4 SpringMVC配置\"></a>1.4 SpringMVC配置</h4><ol>\n<li><p>在web.xml文件中进行配置applicationContext.xml路径</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerMapping\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappings\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"/toHello.do\"</span>&gt;</span>helloController<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 控制器对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"helloController\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.controller.MyHelleController\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring-MVC的编写步骤\"><a href=\"#2-Spring-MVC的编写步骤\" class=\"headerlink\" title=\"2. Spring MVC的编写步骤\"></a>2. Spring MVC的编写步骤</h3><ol>\n<li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li>\n<li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li>\n<li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li>\n<li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li>\n<li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-标注-注解-形式的MVC\"><a href=\"#3-标注-注解-形式的MVC\" class=\"headerlink\" title=\"3. 标注(注解)形式的MVC\"></a>3. 标注(注解)形式的MVC</h3><ol>\n<li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p>\n</li>\n<li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p>\n</li>\n<li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"包名\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p>\n<ul>\n<li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li>\n<li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li>\n</ul>\n</li>\n<li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-mvc控制器接收页面参数\"><a href=\"#4-mvc控制器接收页面参数\" class=\"headerlink\" title=\"4. mvc控制器接收页面参数\"></a>4. mvc控制器接收页面参数</h3><ol>\n<li><p>使用HttpServletRequest类型的参数来接收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    String acc_no = request.getParameter(<span class=\"string\">\"acc_no\"</span>);</span><br><span class=\"line\">    String acc_pwd = request.getParameter(<span class=\"string\">\"acc_password\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义和页面请求参数同名的控制器参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login2.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login2</span><span class=\"params\">(String acc_no,String acc_password, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login3.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login3</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"acc_no\"</span>)</span> String a,String acc_password, ModelAndView mav) </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制器中 直接定义对象类型的参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login4.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login4</span><span class=\"params\">(Account acc, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-mvc控制器把数据传递给页面\"><a href=\"#5-mvc控制器把数据传递给页面\" class=\"headerlink\" title=\"5. mvc控制器把数据传递给页面\"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt;</code></p>\n<ol>\n<li><p>使用域对象 进行传输 (request session ServletContext )</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login6.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login6</span><span class=\"params\">(String acc_no, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">    req.setAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用ModelAndView进行数据传输 </p>\n<ul>\n<li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li>\n<li><code>mav.getModelMap().put(key, value);</code></li>\n<li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login7.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login7</span><span class=\"params\">(String acc_no, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//mav.getModel().put(\"acc_no\", acc_no);</span></span><br><span class=\"line\">    <span class=\"comment\">//mav.getModelMap().put(key, value)</span></span><br><span class=\"line\">    mav.getModelMap().addAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>使用Model进行数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login8.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login8</span><span class=\"params\">(String acc_no, Model m)</span> </span>&#123;</span><br><span class=\"line\">    m.addAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用ModelMap进行数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login9.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login9</span><span class=\"params\">(String acc_no, ModelMap m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//m.addAttribute(\"acc_no\", acc_no);</span></span><br><span class=\"line\">    m.put(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p>\n<ul>\n<li>默认名：<code>&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt;</code></li>\n<li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt;</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login10.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login10</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Spring-MVC实现重定向\"><a href=\"#6-Spring-MVC实现重定向\" class=\"headerlink\" title=\"6. Spring MVC实现重定向\"></a>6. Spring MVC实现重定向</h3><ol>\n<li>控制器方法返回String <ul>\n<li>redirect:请求路径</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login11.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login11</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//return \"forward:toMain.do\";</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:toMain.do\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toMain.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toMain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 干其它的事情</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>控制器方法返回ModelAndView <ul>\n<li>使用RedirectView  完成</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login12.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login12</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    ModelAndView mav = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">    <span class=\"comment\">//重定向</span></span><br><span class=\"line\">    RedirectView rv = <span class=\"keyword\">new</span> RedirectView(<span class=\"string\">\"toMain.do\"</span>);</span><br><span class=\"line\">    mav.setView(rv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Spring-MVC-中文参数的乱码问题\"><a href=\"#7-Spring-MVC-中文参数的乱码问题\" class=\"headerlink\" title=\"7. Spring MVC 中文参数的乱码问题\"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p>\n<ol>\n<li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">response.setContentType(<span class=\"string\">\"application/json;charset=UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> String(string.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p>\n</li>\n<li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;filter&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class=\"line\">    &lt;filter-<span class=\"class\"><span class=\"keyword\">class</span>&gt;<span class=\"title\">org</span>.<span class=\"title\">springframework</span>.<span class=\"title\">web</span>.<span class=\"title\">filter</span>.<span class=\"title\">CharacterEncodingFilter</span>&lt;/<span class=\"title\">filter</span>-<span class=\"title\">class</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">init</span>-<span class=\"title\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">param</span>-<span class=\"title\">name</span>&gt;<span class=\"title\">encoding</span>&lt;/<span class=\"title\">param</span>-<span class=\"title\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">param</span>-<span class=\"title\">value</span>&gt;<span class=\"title\">utf</span>-8&lt;/<span class=\"title\">param</span>-<span class=\"title\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">init</span>-<span class=\"title\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">filter</span>-<span class=\"title\">mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">filter</span>-<span class=\"title\">name</span>&gt;<span class=\"title\">encodingFilter</span>&lt;/<span class=\"title\">filter</span>-<span class=\"title\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">url</span>-<span class=\"title\">pattern</span>&gt;*.<span class=\"title\">do</span>&lt;/<span class=\"title\">url</span>-<span class=\"title\">pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">filter</span>-<span class=\"title\">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Spring-MVC-拦截器\"><a href=\"#8-Spring-MVC-拦截器\" class=\"headerlink\" title=\"8. Spring MVC 拦截器\"></a>8. Spring MVC 拦截器</h3><ol>\n<li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li>\n<li>HandlerMapping接口<ul>\n<li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li>\n<li>postHandle：处理器执行后、视图处理前调用。</li>\n<li>afterCompletion：整个请求处理完毕后调用。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Spring-MVC-拦截器的使用步骤\"><a href=\"#9-Spring-MVC-拦截器的使用步骤\" class=\"headerlink\" title=\"9. Spring MVC 拦截器的使用步骤\"></a>9. Spring MVC 拦截器的使用步骤</h3><ol>\n<li>搭建一个基于标注的mvc</li>\n<li>编写一个类实现HandlerInterceptor接口</li>\n<li>在Spring配置文件中配置拦截器<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/**\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:exclude-mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/login.do\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.interceptor.SomeInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Spring-MVC异常处理\"><a href=\"#10-Spring-MVC异常处理\" class=\"headerlink\" title=\"10. Spring MVC异常处理\"></a>10. Spring MVC异常处理</h3><ol>\n<li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"java.lang.RuntimeException\"</span>&gt;</span>error<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"java.lang.Exception\"</span>&gt;</span>error2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExceptionResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> </span>&#123;</span><br><span class=\"line\">\t\tModelAndView mav = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(e <span class=\"keyword\">instanceof</span> RuntimeException) &#123;</span><br><span class=\"line\">\t\t\tmav.setViewName(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e <span class=\"keyword\">instanceof</span> Exception) &#123;</span><br><span class=\"line\">\t\t\tmav.setViewName(<span class=\"string\">\"error2\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@Controller</span></span><br><span class=\"line\"><span class=\"comment\">//public class MyController &#123;</span></span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">processException</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"error3\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-Spring-MVC文件上传\"><a href=\"#11-Spring-MVC文件上传\" class=\"headerlink\" title=\"11. Spring MVC文件上传\"></a>11. Spring MVC文件上传</h3><ol>\n<li><p>jsp页面（method=”POST” enctype=”multipart/form-data type=”file”）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"upload.do\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    头像：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"head_img\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"multipartResolver\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-文件上传与异常处理的结合\"><a href=\"#12-文件上传与异常处理的结合\" class=\"headerlink\" title=\"12. 文件上传与异常处理的结合\"></a>12. 文件上传与异常处理的结合</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fileController</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toFile.do\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">tofile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"file\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/upload.do\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">upload</span><span class=\"params\">(String acc_no, MultipartFile head_img)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"acc_no:\"</span> + acc_no );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(head_img.getSize()&gt;<span class=\"number\">1024</span>*<span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"文件过大！\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把文件写入磁盘</span></span><br><span class=\"line\">\t\tString uniqueStr = UUID.randomUUID().toString();</span><br><span class=\"line\">\t\tString oriFilename = head_img.getOriginalFilename();</span><br><span class=\"line\">\t\tString suffix = oriFilename.substring(oriFilename.lastIndexOf(<span class=\"string\">\".\"</span>));</span><br><span class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F:/Eclipse/datas/\"</span>+uniqueStr+suffix);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\thead_img.transferTo(file);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(oriFilename);</span><br><span class=\"line\">\t\tSystem.out.println(file);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"file\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/** 局部异常 */</span></span><br><span class=\"line\">\t<span class=\"meta\">@ExceptionHandler</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">processError</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error4\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-Spring-MVC响应JSON\"><a href=\"#13-Spring-MVC响应JSON\" class=\"headerlink\" title=\"13. Spring MVC响应JSON\"></a>13. Spring MVC响应JSON</h3><ol>\n<li>搭建基于标注的mvc</li>\n<li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li>\n<li>给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li>\n</ol>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-REST\"><a href=\"#14-REST\" class=\"headerlink\" title=\"14. REST\"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p>\n<ol>\n<li>REST两个核心规范<ul>\n<li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href=\"http://test/source/1234）\" target=\"_blank\" rel=\"noopener\">http://test/source/1234）</a></li>\n<li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li>\n</ul>\n</li>\n<li>restful<ul>\n<li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li>\n</ul>\n</li>\n<li>Spring MVC对REST的支持<ul>\n<li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul>\n<li><code>@RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST)</code></li>\n</ul>\n</li>\n<li>对URI上路径变量的处理的支持，@PathVariable<ul>\n<li><code>@PathVariable(&quot;id&quot;) int id</code></li>\n</ul>\n</li>\n<li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li>\n<li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li>\n<li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-REST实例\"><a href=\"#15-REST实例\" class=\"headerlink\" title=\"15. REST实例\"></a>15. REST实例</h3><ol>\n<li>配置web.xml与applicationContext.xml(部分配置)</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- web.xml --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写控制类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toLogin.do\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toLogin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id查询账户 GET */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>, method=RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Account <span class=\"title\">getAccountById</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        Random rm = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        Account acc = <span class=\"keyword\">new</span> Account(id, <span class=\"string\">\"test\"</span>+rm.nextInt(<span class=\"number\">100</span>),<span class=\"string\">\"123\"</span>, rm.nextInt(<span class=\"number\">999</span>)+<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 新增账户 POST */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.POST)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAccount</span><span class=\"params\">(Account acc)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add:\"</span>+acc);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(acc.getId()&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id删除帐户对象 DELETE */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.DELETE)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteAccountById</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"delete:\"</span>+id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id更新帐户 PUT */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.PUT)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putAccount</span><span class=\"params\">(@RequestBody Account acc)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"update:\"</span>+acc);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(acc.getId()&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>编写jsp页面</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>ID：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>姓名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountNo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountPassword\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>金额：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountMoney\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>查询<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"addBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>添加<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"updateBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>更新<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"delBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>删除<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#findBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    findAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#addBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    addAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#updateBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    updateAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#delBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    delAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDatas</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountId = $(<span class=\"string\">\"#accountId\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountNo = $(<span class=\"string\">\"#accountNo\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountPassword = $(<span class=\"string\">\"#accountPassword\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountMoney = $(<span class=\"string\">\"#accountMoney\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">\t    id: accountId,</span><br><span class=\"line\">\t    acc_no: accountNo,</span><br><span class=\"line\">\t    acc_password: accountPassword,</span><br><span class=\"line\">\t    acc_money: accountMoney</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"get\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountNo\"</span>).val(res.acc_no);</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountPassword\"</span>).val(res.acc_password);</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountMoney\"</span>).val(res.acc_money);</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"post\"</span>,</span></span><br><span class=\"line\">        data: datas,</span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"delete\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url:<span class=\"string\">\"account/\"</span>+ datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type:<span class=\"string\">\"put\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        data:<span class=\"built_in\">JSON</span>.stringify(datas),</span></span><br><span class=\"line\"><span class=\"javascript\">        contentType:<span class=\"string\">\"application/json\"</span>,<span class=\"comment\">//以json字符串提交数据</span></span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li>\n<li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li>\n<li>JSON.stringify()：将json对象转换为json字符串</li>\n<li>JSON.parse()：将json字符串转换为json对象</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p>","more":"<ol>\n<li><a href=\"#id1\">Spring MVC基本概念</a></li>\n<li><a href=\"#id2\">Spring MVC的编写步骤</a></li>\n<li><a href=\"#id3\">标注(注解)形式的MVC</a></li>\n<li><a href=\"#id4\">mvc控制器接收页面参数</a></li>\n<li><a href=\"#id5\">mvc控制器把数据传递给页面</a></li>\n<li><a href=\"#id6\">Spring MVC实现重定向</a></li>\n<li><a href=\"#id7\">Spring MVC 中文参数的乱码问题</a></li>\n<li><a href=\"#id8\">Spring MVC 拦截器</a></li>\n<li><a href=\"#id9\">Spring MVC 拦截器的使用步骤</a></li>\n<li><a href=\"#id10\">Spring MVC异常处理</a></li>\n<li><a href=\"#id11\">Spring MVC文件上传</a></li>\n<li><a href=\"#id12\">文件上传与异常处理的结合</a></li>\n<li><a href=\"#id13\">Spring MVC响应JSON</a></li>\n<li><a href=\"#id14\">REST</a></li>\n<li><a href=\"#id15\">REST实例</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Spring-MVC基本概念\"><a href=\"#1-Spring-MVC基本概念\" class=\"headerlink\" title=\"1. Spring MVC基本概念\"></a>1. Spring MVC基本概念</h3><h4 id=\"1-1-Spring-MVC-五大核心组件\"><a href=\"#1-1-Spring-MVC-五大核心组件\" class=\"headerlink\" title=\"1.1 Spring MVC 五大核心组件\"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p>\n<ol>\n<li>DispatcherServlet：控制器，请求入口</li>\n<li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li>\n<li>Controller：控制器，处理请求</li>\n<li>ModelAndView：封装了 数据信息和视图信息</li>\n<li>ViewResolver：视图处理器</li>\n</ol>\n<p>他的两个核心是两个核心：</p>\n<ul>\n<li>处理器映射：选择使用哪个控制器来处理请求 </li>\n<li>视图解析器：选择结果应该如何渲染<blockquote>\n<p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"1-2-SpringMVC运行原理\"><a href=\"#1-2-SpringMVC运行原理\" class=\"headerlink\" title=\"1.2 SpringMVC运行原理\"></a>1.2 SpringMVC运行原理</h4><ol>\n<li>Http请求：客户端请求提交到DispatcherServlet。 </li>\n<li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li>\n<li>调用处理器：DispatcherServlet将请求提交到Controller。 </li>\n<li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li>\n<li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li>\n<li>Http响应：视图负责将结果显示到客户端。</li>\n</ol>\n<h4 id=\"1-3-SpringMVC接口解释\"><a href=\"#1-3-SpringMVC接口解释\" class=\"headerlink\" title=\"1.3 SpringMVC接口解释\"></a>1.3 SpringMVC接口解释</h4><ol>\n<li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol>\n<li>截获符合特定格式的URL请求。 </li>\n<li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li>\n<li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li>\n</ol>\n</li>\n<li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li>\n<li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul>\n<li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li>\n<li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。 </li>\n</ul>\n</li>\n<li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li>\n</ol>\n<h4 id=\"1-4-SpringMVC配置\"><a href=\"#1-4-SpringMVC配置\" class=\"headerlink\" title=\"1.4 SpringMVC配置\"></a>1.4 SpringMVC配置</h4><ol>\n<li><p>在web.xml文件中进行配置applicationContext.xml路径</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:applicationContext.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>*.do<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"handlerMapping\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mappings\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"/toHello.do\"</span>&gt;</span>helloController<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 控制器对象 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"helloController\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.controller.MyHelleController\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"viewResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"prefix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"/WEB-INF/\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"suffix\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\".jsp\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Spring-MVC的编写步骤\"><a href=\"#2-Spring-MVC的编写步骤\" class=\"headerlink\" title=\"2. Spring MVC的编写步骤\"></a>2. Spring MVC的编写步骤</h3><ol>\n<li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li>\n<li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li>\n<li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li>\n<li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li>\n<li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-标注-注解-形式的MVC\"><a href=\"#3-标注-注解-形式的MVC\" class=\"headerlink\" title=\"3. 标注(注解)形式的MVC\"></a>3. 标注(注解)形式的MVC</h3><ol>\n<li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p>\n</li>\n<li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p>\n</li>\n<li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:component-scan</span> <span class=\"attr\">base-package</span>=<span class=\"string\">\"包名\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p>\n<ul>\n<li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li>\n<li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li>\n</ul>\n</li>\n<li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p>\n</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-mvc控制器接收页面参数\"><a href=\"#4-mvc控制器接收页面参数\" class=\"headerlink\" title=\"4. mvc控制器接收页面参数\"></a>4. mvc控制器接收页面参数</h3><ol>\n<li><p>使用HttpServletRequest类型的参数来接收</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\">    String acc_no = request.getParameter(<span class=\"string\">\"acc_no\"</span>);</span><br><span class=\"line\">    String acc_pwd = request.getParameter(<span class=\"string\">\"acc_password\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接定义和页面请求参数同名的控制器参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login2.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login2</span><span class=\"params\">(String acc_no,String acc_password, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login3.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login3</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"acc_no\"</span>)</span> String a,String acc_password, ModelAndView mav) </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制器中 直接定义对象类型的参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login4.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login4</span><span class=\"params\">(Account acc, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-mvc控制器把数据传递给页面\"><a href=\"#5-mvc控制器把数据传递给页面\" class=\"headerlink\" title=\"5. mvc控制器把数据传递给页面\"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 ${acc_no} &lt;/h1&gt;</code></p>\n<ol>\n<li><p>使用域对象 进行传输 (request session ServletContext )</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login6.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login6</span><span class=\"params\">(String acc_no, HttpServletRequest req)</span> </span>&#123;</span><br><span class=\"line\">    req.setAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用ModelAndView进行数据传输 </p>\n<ul>\n<li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li>\n<li><code>mav.getModelMap().put(key, value);</code></li>\n<li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login7.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login7</span><span class=\"params\">(String acc_no, ModelAndView mav)</span> </span>&#123;</span><br><span class=\"line\">    mav.setViewName(<span class=\"string\">\"main\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//mav.getModel().put(\"acc_no\", acc_no);</span></span><br><span class=\"line\">    <span class=\"comment\">//mav.getModelMap().put(key, value)</span></span><br><span class=\"line\">    mav.getModelMap().addAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>使用Model进行数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login8.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login8</span><span class=\"params\">(String acc_no, Model m)</span> </span>&#123;</span><br><span class=\"line\">    m.addAttribute(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用ModelMap进行数据传输</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login9.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login9</span><span class=\"params\">(String acc_no, ModelMap m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//m.addAttribute(\"acc_no\", acc_no);</span></span><br><span class=\"line\">    m.put(<span class=\"string\">\"acc_no\"</span>, acc_no);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p>\n<ul>\n<li>默认名：<code>&lt;h1&gt;欢迎 ${ account.acc_no } &lt;/h1&gt;</code></li>\n<li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 ${ acc.acc_no } &lt;/h1&gt;</code></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login10.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login10</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Spring-MVC实现重定向\"><a href=\"#6-Spring-MVC实现重定向\" class=\"headerlink\" title=\"6. Spring MVC实现重定向\"></a>6. Spring MVC实现重定向</h3><ol>\n<li>控制器方法返回String <ul>\n<li>redirect:请求路径</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login11.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login11</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//return \"forward:toMain.do\";</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:toMain.do\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toMain.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toMain</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 干其它的事情</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"main\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>控制器方法返回ModelAndView <ul>\n<li>使用RedirectView  完成</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/login12.do\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">login12</span><span class=\"params\">(@ModelAttribute(<span class=\"string\">\"acc\"</span>)</span> Account acc) </span>&#123;</span><br><span class=\"line\">    ModelAndView mav = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">    <span class=\"comment\">//重定向</span></span><br><span class=\"line\">    RedirectView rv = <span class=\"keyword\">new</span> RedirectView(<span class=\"string\">\"toMain.do\"</span>);</span><br><span class=\"line\">    mav.setView(rv);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Spring-MVC-中文参数的乱码问题\"><a href=\"#7-Spring-MVC-中文参数的乱码问题\" class=\"headerlink\" title=\"7. Spring MVC 中文参数的乱码问题\"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p>\n<ol>\n<li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">response.setContentType(<span class=\"string\">\"application/json;charset=UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> String(string.getBytes(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"UTF-8\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p>\n</li>\n<li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;filter&gt;</span><br><span class=\"line\">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class=\"line\">    &lt;filter-<span class=\"class\"><span class=\"keyword\">class</span>&gt;<span class=\"title\">org</span>.<span class=\"title\">springframework</span>.<span class=\"title\">web</span>.<span class=\"title\">filter</span>.<span class=\"title\">CharacterEncodingFilter</span>&lt;/<span class=\"title\">filter</span>-<span class=\"title\">class</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">init</span>-<span class=\"title\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">param</span>-<span class=\"title\">name</span>&gt;<span class=\"title\">encoding</span>&lt;/<span class=\"title\">param</span>-<span class=\"title\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        &lt;<span class=\"title\">param</span>-<span class=\"title\">value</span>&gt;<span class=\"title\">utf</span>-8&lt;/<span class=\"title\">param</span>-<span class=\"title\">value</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;/<span class=\"title\">init</span>-<span class=\"title\">param</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">filter</span>-<span class=\"title\">mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">filter</span>-<span class=\"title\">name</span>&gt;<span class=\"title\">encodingFilter</span>&lt;/<span class=\"title\">filter</span>-<span class=\"title\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    &lt;<span class=\"title\">url</span>-<span class=\"title\">pattern</span>&gt;*.<span class=\"title\">do</span>&lt;/<span class=\"title\">url</span>-<span class=\"title\">pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">&lt;/<span class=\"title\">filter</span>-<span class=\"title\">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Spring-MVC-拦截器\"><a href=\"#8-Spring-MVC-拦截器\" class=\"headerlink\" title=\"8. Spring MVC 拦截器\"></a>8. Spring MVC 拦截器</h3><ol>\n<li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li>\n<li>HandlerMapping接口<ul>\n<li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li>\n<li>postHandle：处理器执行后、视图处理前调用。</li>\n<li>afterCompletion：整个请求处理完毕后调用。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Spring-MVC-拦截器的使用步骤\"><a href=\"#9-Spring-MVC-拦截器的使用步骤\" class=\"headerlink\" title=\"9. Spring MVC 拦截器的使用步骤\"></a>9. Spring MVC 拦截器的使用步骤</h3><ol>\n<li>搭建一个基于标注的mvc</li>\n<li>编写一个类实现HandlerInterceptor接口</li>\n<li>在Spring配置文件中配置拦截器<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/**\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mvc:exclude-mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/login.do\"</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.xdl.interceptor.SomeInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Spring-MVC异常处理\"><a href=\"#10-Spring-MVC异常处理\" class=\"headerlink\" title=\"10. Spring MVC异常处理\"></a>10. Spring MVC异常处理</h3><ol>\n<li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"simpleExceptionResolver\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"exceptionMappings\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"java.lang.RuntimeException\"</span>&gt;</span>error<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">prop</span> <span class=\"attr\">key</span>=<span class=\"string\">\"java.lang.Exception\"</span>&gt;</span>error2<span class=\"tag\">&lt;/<span class=\"name\">prop</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">props</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExceptionResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> </span>&#123;</span><br><span class=\"line\">\t\tModelAndView mav = <span class=\"keyword\">new</span> ModelAndView();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(e <span class=\"keyword\">instanceof</span> RuntimeException) &#123;</span><br><span class=\"line\">\t\t\tmav.setViewName(<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e <span class=\"keyword\">instanceof</span> Exception) &#123;</span><br><span class=\"line\">\t\t\tmav.setViewName(<span class=\"string\">\"error2\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> mav;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@Controller</span></span><br><span class=\"line\"><span class=\"comment\">//public class MyController &#123;</span></span><br><span class=\"line\"><span class=\"meta\">@ExceptionHandler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">processException</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(e.getMessage());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"error3\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-Spring-MVC文件上传\"><a href=\"#11-Spring-MVC文件上传\" class=\"headerlink\" title=\"11. Spring MVC文件上传\"></a>11. Spring MVC文件上传</h3><ol>\n<li><p>jsp页面（method=”POST” enctype=”multipart/form-data type=”file”）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">\"upload.do\"</span> <span class=\"attr\">method</span>=<span class=\"string\">\"post\"</span> <span class=\"attr\">enctype</span>=<span class=\"string\">\"multipart/form-data\"</span>&gt;</span></span><br><span class=\"line\">    头像：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"head_img\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"上传\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"multipartResolver\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-文件上传与异常处理的结合\"><a href=\"#12-文件上传与异常处理的结合\" class=\"headerlink\" title=\"12. 文件上传与异常处理的结合\"></a>12. 文件上传与异常处理的结合</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">fileController</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toFile.do\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">tofile</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"file\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/upload.do\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">upload</span><span class=\"params\">(String acc_no, MultipartFile head_img)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"acc_no:\"</span> + acc_no );</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(head_img.getSize()&gt;<span class=\"number\">1024</span>*<span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"文件过大！\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 把文件写入磁盘</span></span><br><span class=\"line\">\t\tString uniqueStr = UUID.randomUUID().toString();</span><br><span class=\"line\">\t\tString oriFilename = head_img.getOriginalFilename();</span><br><span class=\"line\">\t\tString suffix = oriFilename.substring(oriFilename.lastIndexOf(<span class=\"string\">\".\"</span>));</span><br><span class=\"line\">\t\tFile file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F:/Eclipse/datas/\"</span>+uniqueStr+suffix);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\thead_img.transferTo(file);</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IllegalStateException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tSystem.out.println(oriFilename);</span><br><span class=\"line\">\t\tSystem.out.println(file);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"file\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">/** 局部异常 */</span></span><br><span class=\"line\">\t<span class=\"meta\">@ExceptionHandler</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">processError</span><span class=\"params\">(Exception e)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error4\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-Spring-MVC响应JSON\"><a href=\"#13-Spring-MVC响应JSON\" class=\"headerlink\" title=\"13. Spring MVC响应JSON\"></a>13. Spring MVC响应JSON</h3><ol>\n<li>搭建基于标注的mvc</li>\n<li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li>\n<li>给方法加@RequestMapping(“/请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li>\n</ol>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-REST\"><a href=\"#14-REST\" class=\"headerlink\" title=\"14. REST\"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p>\n<ol>\n<li>REST两个核心规范<ul>\n<li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href=\"http://test/source/1234）\" target=\"_blank\" rel=\"noopener\">http://test/source/1234）</a></li>\n<li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li>\n</ul>\n</li>\n<li>restful<ul>\n<li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li>\n</ul>\n</li>\n<li>Spring MVC对REST的支持<ul>\n<li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul>\n<li><code>@RequestMapping(value=&quot;/account/{id}&quot;,method=RequestMethod.POST)</code></li>\n</ul>\n</li>\n<li>对URI上路径变量的处理的支持，@PathVariable<ul>\n<li><code>@PathVariable(&quot;id&quot;) int id</code></li>\n</ul>\n</li>\n<li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li>\n<li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li>\n<li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-REST实例\"><a href=\"#15-REST实例\" class=\"headerlink\" title=\"15. REST实例\"></a>15. REST实例</h3><ol>\n<li>配置web.xml与applicationContext.xml(部分配置)</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- web.xml --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写控制类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/toLogin.do\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toLogin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"login\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id查询账户 GET */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>, method=RequestMethod.GET)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Account <span class=\"title\">getAccountById</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        Random rm = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        Account acc = <span class=\"keyword\">new</span> Account(id, <span class=\"string\">\"test\"</span>+rm.nextInt(<span class=\"number\">100</span>),<span class=\"string\">\"123\"</span>, rm.nextInt(<span class=\"number\">999</span>)+<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 新增账户 POST */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.POST)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAccount</span><span class=\"params\">(Account acc)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"add:\"</span>+acc);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(acc.getId()&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id删除帐户对象 DELETE */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.DELETE)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">deleteAccountById</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"id\"</span>)</span> <span class=\"keyword\">int</span> id) </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"delete:\"</span>+id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/** 根据id更新帐户 PUT */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/account/&#123;id&#125;\"</span>,method=RequestMethod.PUT)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">putAccount</span><span class=\"params\">(@RequestBody Account acc)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"update:\"</span>+acc);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(acc.getId()&gt;<span class=\"number\">100</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>编写jsp页面</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>ID：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountId\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>姓名：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountNo\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountPassword\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>金额：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"accountMoney\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"findBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>查询<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"addBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>添加<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"updateBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>更新<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"delBtn\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span>&gt;</span>删除<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"js/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#findBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    findAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#addBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    addAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#updateBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    updateAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\">$(<span class=\"string\">\"#delBtn\"</span>).on(<span class=\"string\">\"click\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\">    delAccount();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDatas</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountId = $(<span class=\"string\">\"#accountId\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountNo = $(<span class=\"string\">\"#accountNo\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountPassword = $(<span class=\"string\">\"#accountPassword\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> accountMoney = $(<span class=\"string\">\"#accountMoney\"</span>).val();</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">\t    id: accountId,</span><br><span class=\"line\">\t    acc_no: accountNo,</span><br><span class=\"line\">\t    acc_password: accountPassword,</span><br><span class=\"line\">\t    acc_money: accountMoney</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"get\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountNo\"</span>).val(res.acc_no);</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountPassword\"</span>).val(res.acc_password);</span></span><br><span class=\"line\"><span class=\"javascript\">            $(<span class=\"string\">\"#accountMoney\"</span>).val(res.acc_money);</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"post\"</span>,</span></span><br><span class=\"line\">        data: datas,</span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url: <span class=\"string\">\"account/\"</span> + datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type: <span class=\"string\">\"delete\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateAccount</span>(<span class=\"params\"></span>)</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t<span class=\"keyword\">var</span> datas = getDatas();</span></span><br><span class=\"line\"><span class=\"javascript\">    $.ajax(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        url:<span class=\"string\">\"account/\"</span>+ datas.id,</span></span><br><span class=\"line\"><span class=\"javascript\">        type:<span class=\"string\">\"put\"</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">        data:<span class=\"built_in\">JSON</span>.stringify(datas),</span></span><br><span class=\"line\"><span class=\"javascript\">        contentType:<span class=\"string\">\"application/json\"</span>,<span class=\"comment\">//以json字符串提交数据</span></span></span><br><span class=\"line\"><span class=\"javascript\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span></span><br><span class=\"line\">            alert(res);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li>\n<li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li>\n<li>JSON.stringify()：将json对象转换为json字符串</li>\n<li>JSON.parse()：将json字符串转换为json对象</li>\n</ul>\n</blockquote>"},{"title":"二、JavaSE面向对象","date":"2019-07-07T10:50:47.000Z","_content":"\n面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。\nJava中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。\n<!-- more -->\n\n1. [类与对象](#id1)\n2. [构造方法和方法重载](#id2)\n3. [this关键字](#id3)\n4. [方法的传递和递归](#id4)\n5. [封装](#id5)\n6. [static关键字](#id6)\n7. [单例设计模式](#id7)\n8. [继承（extends）](#id8)\n9. [方法的重写（Override）](#id9)\n10. [访问控制](#id10)\n11. [包（Package）](#id11)\n12. [final关键字](#id12)\n13. [对象的创建过程](#id13)\n14. [多态](#id14)\n15. [抽象类](#id15)\n16. [接口](#id16)\n17. [内部类](#id17)\n18. [回调模式](#id18)\n19. [抽象方法的笔试考点](#id19)\n20. [枚举类（enum）](#id20)\n21. [内存机制问题](#id21)\n\n\n<span id=\"id1\"><span>\n### 1. 类与对象\n#### 1.1 类的定义\n``` java\nclass 类名 {类体}\n```\n\n> 类名由多个单词组成时，要求每个单词首字母大写\n\n#### 1.2 成员变量的定义\n``` java\nclass 类名 { 数据类型 成员变量名=初始值; ... }\n```\n\n> 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写\n\n#### 1.3 对象的创建\n``` java\nnew 类名();\n```\n\n> 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。\n\n#### 1.4 引用\n``` java\n类名 引用变量名;\nPerson p = new Person(); //声明person类型的引用p指向Person类型对象\n```\n\n``` java\n引用变量名.成员变量名;\np.name = 'zhangsan';\n```\n\n>- 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。\n>- 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。\n\n- 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。\n\n\n#### 1.5 成员方法\n``` java\nclass 类名 {\n    返回值类型 成员方法名(形参列表){方法体;}\n}\n```\n\n- 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void\n- 形参列表：数据类型 形参1, 数据类型 形参2, ...\n\n\n<span id=\"id2\"><span>\n### 2. 构造方法和方法重载\n#### 2.1 构造方法\n``` java\nclass 类名 { 构造方法名(形参列表){构造方法体;} }\n```\n\n- 构造方法名与类名相同且没有返回值\n- 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。\n\n#### 2.2 默认构造方法\n- 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。\n- 若类中出现自定义构造方法，则编译器不再提供构造方法。\n\n#### 2.3 方法重载（overload）\n在Java中，方法名相同，参数列表不同的方法构成重载关系。\n\n- 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）\n- 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。\n\n\n<span id=\"id3\"><span>\n### 3. this关键字\n在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。\n- 使用方式：\n    1. 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名\n    2. 在构造方法的的第一行，可以调用本类中的其他构造方法。\n\n\n<span id=\"id4\"><span>\n### 4. 方法的传递和递归\n#### 4.1 传参\n- 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。\n- 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。\n- 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。\n\n#### 4.2 递归的调用\n- 递归是指方法体内部调用自身\n- 必须有递归的规律和退出条件\n- 使用递归必须使得问题简单化而不是复杂化\n- 若递归影响到程序的执行性能时，则用递推取代之\n\n\n<span id=\"id5\"><span>\n### 5. 封装\n面向对象的三大特征：封装，继承，多态。\n- 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断\n- 封装基本流程：\n    1. 私有化成员变量(private)\n    2. 提供公有的get、set方法，并在set方法体中进行合理性判断\n    3. 在构方法中调用set方法进行合理值的判断\n\n\n<span id=\"id6\"><span>\n### 6. static关键字\n基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。\n\n> 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。\n\n- static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)\n- 特点\n    * 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问\n    * 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突\n    * 静态元素只加载一次，全部类对象及类本身共享\n    * 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存\n    * 非静态成员和静态成员都可以访问静态成员\n    * 静态成员不可以访问非静态成员\n    * 静态元素中不可出现this或super关键字，静态元素属于类的\n\n\n<span id=\"id7\"><span>\n### 7. 单例设计模式\n基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。\n\n``` java\n/**\n * 编程实现Singleton类的封装\n */\npublic class Singleton{\n    private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象\n    private Singleton(){} //1.私有化构造方法\n    public static Singleton getInstance(){//3.提供公有的get方法将上述成员变量的数值返回出去\n        return sin;\n    }\n}\n```\n\n- 实现流程：\n    1. 私有化构造方法（private）\n    2. 提供本类类型的引用指向本类类型对象（private static）\n    3. 提供公有的get方法将上述对象return出去（public static）\n    4. 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。\n\n\n<span id=\"id8\"><span>\n### 8. 继承（extends）\n- 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系\n- 使用继承可以提高代码复用性、扩展性、以及可维护性。\n    1. 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。\n    2. 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。\n    3. 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。\n    4. 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。\n\n``` java\nclass Cricle extends Shape{\n    int r;\n    Cricle(){}   //编译器会加入无参的调用 super()。\n    Cricle(int x, int y, int r){\n        super(x, y);  //通过super关键字调用父类的构造方法。\n        setR(r);\n    }\n    public void setR(int r){\n        this.r = r;\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 方法的重写（Override）\n概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。\n<br>原则：\n1. 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。\n2. 要求访问权限不能变小，可以相同或变大\n3. 重写的方法不能抛出更大的异常\n\n\n<span id=\"id10\"><span>\n### 10. 访问控制\n- public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，\n- 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰\n\n| 访问控制符 | 访问权限    | 本类内部    | 本类中的包 | 子类    | 其他包 |\n| ---------    |:---------:| ------:    |-------:    |-----:    |------:|\n| public    | 共有的        | Y            | Y            | Y        | Y        |\n| protected    | 保护的        | Y            | Y            | Y        | N        |\n| 不写        | 默认的        | Y            | Y            | N        | N        |\n| private    | 私有的        | Y            | N            | N        | N        |\n\n\n<span id=\"id11\"><span>\n### 11. 包（Package）\n为了解决命名冲突问题，便于文件的管理\n\n``` java\npackage 包名；\npackage 包名1.包名2.包名3...包名n;\n/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */\norg.apache.commons.lang.StringUtil;\n```\n\n\n<span id=\"id12\"><span>\n### 12. final关键字\n1. final关键字修饰**类**体现该类**不能被继承**（防止滥用继承）。\n2. final关键字修饰**方法**体现在该方法**不能被重新，但可以被继承**（防止不经意间造成的方法重写）。\n3. final关键字修饰**成员变量**体现在改成员变量**必须初始化且不能更改**（防止不经意间造成的数据更改）。\n\n> 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用**`public static final`**共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。\n\n\n<span id=\"id13\"><span>\n### 13. 对象的创建过程\n- 单个对象的创建过程\n    1. main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；\n    2. 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；\n    3. 执行构造块中的代码可以对成员变量进行赋值；\n    4. 执行构造方法体中的代码可以对成员变量进行再次赋值；\n    5. 此时对象构造完毕，继续向下执行后续的代码；\n- 子类对象的创建过程\n    1. main方法是程序的入口，先加载父类的的代码再加载子类的代码；\n    2. 先执行父类静态代码块，再执行子类的静态代码块；\n    3. 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；\n    4. 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。\n\n\n<span id=\"id14\"><span>\n### 14. 多态\n1. 语法：父类的引用指向子类的对象\n\n``` java\n父类类型 引用变量名 = new 子类类型();\nPerson pw = new Worker();\npw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。\n```\n\n2. 多态的效果：\n    1. 父类的引用**可以**直接调用**父类独有**的方法。\n    2. 父类的引用**不可以**直接调用**子类独有**的方法。\n    3. 对于父类子类都有的**非静态方法**来说，编译阶段调用父类的，运行阶段调用子类重写后的。\n    4. 对于父类子类都有的**静态方法**来说，只调用父类的。\n3. 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。\n4. 多态的表现形式\n    1. 多态的前提要有继承的关系\n    2. 使用父类引用指向子类对象 Person p = new Teacher();//向上转型\n    3. 该引用只能调用父类中定义的属性/方法\n    4. 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写\n    5. 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException\n5. 引用数据类型之间的转换\n    - 转换必须发生在父子类之间，否则编译报错。\n    - 自动类型转换：小到大，子类型向父类型的转换，eg:`Person pw = new Worker();`。\n    - 强制类型转换：大到小，父类型向子类型转换，eg:`((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法`。\n6. 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。\n\n``` java\n/*语法格式：*/ 对象 instanceof 类型  //返回布尔值\nif(pw instanceof Teacher){\n    Teacher t = (Teacher) pw;\n}else{\n    System.out.println(\"转换会有异常\");\n}\n```\n\n7. 多态的使用场合：\n\n``` java\n// 通过方法的参数传递形成多态。\npublic static void draw(Shape s){}\nTestShape.draw(new Rect(1,2,3,4));\n\n// 在方法体中直接使用多态的语法格式。\nTestAbstrat ta = new SubTestAbstract();\nta.show();\n```\n\n\n<span id=\"id15\"><span>\n### 15. 抽象类\n1. 基本概念\n    - 用**abstract**关键字修饰的类称为抽象类。\n    - 抽象类不能实例化，抽象类的意义在于被继承。\n    - 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。\n    - 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。\n\n``` java\npublic abstract class Shape{ //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类\n    private int x;\n    private int y;\n    public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体\n}\n```\n\n2. 注意：\n    1. 抽象类中可以有成员变量，成员方法，以及构造方法。\n    2. 抽象类中可以没有抽象方法，也可以有抽象方法。\n    3. 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。\n    4. 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。\n    5. 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。\n    6. 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。\n\n> 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。\n\n\n<span id=\"id16\"><span>\n### 16. 接口\n1. 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过**interface**关键字定义。\n\n``` java\ninterface Runner { //-通过interface关键字定义接口\n    public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量\n    public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）\n}\n```\n\n2. 一个类可以通过**implements**关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。\n\n``` java\nclass American implements Runner,... { //与继承不同，可以实现多个接口\n    @Override\n    public void run(){//该类需要实现接口中定义的所有方法\n        System.out.println(\"run...\");\n    }\n    public static void main(String[] args) {\n        Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象\n        ra.run();//通过该变量可以调用该接口定义的方法\n    }\n}\n```\n\n3. 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。\n\n``` java\ninterface Hunter extends Runner{...}\n```\n\n4. 类与接口的关系\n    - 类和类使用`extends`继承，仅支持**单继承**。\n    - 接口和接口使用`extends`继承，支持多继承。\n    - 类使用`implements`实现接口，支持**多实现**。\n5. 抽象类与接口的关系（笔试题）\n    1. 定义抽象类:`abstract class`，而定义接口:`interface`；\n    2. 类继承抽象类:`extends`单继承，而类实现接口:`implements`多实现；\n    3. 抽象类可以`有`构造方法，而接口`不能有`构造方法；\n    4. 抽象类可以有`成员变量`，而接口只能有`常量`；\n    5. 抽象类可以有`成员方法`，而接口只能有`抽象方法`；\n    6. 抽象类中增加方法子类可以`不用重写`，而接口中增加方法子类`必须重写`；\n    7. 从jdk1.8开始允许接口中有非抽象方法，但需要`default`关键字修饰。\n\n\n<span id=\"id17\"><span>\n### 17. 内部类\n- 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部\n- 内部类定义在 类的内部 ，与类成员层次一致\n- 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）\n    * 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n    * 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n    * 匿名内部类：成员匿名内部类，局部匿名内部类\n    * 静态内部类：成员静态内部类\n\n#### 17.1 *成员内部类\n- 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n- 成员内部类可以与正常类一样 使用不同的修饰符来修饰\n- 好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的\n- 若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;\n- 内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class\n\n#### 17.2 局部内部类\n- 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n- 局部内部类像是一个局部的变量一样，不能用public protected private及static\n- 只能用abstract或final\n- 局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod\n- 局部内部类使用的变量只能是final修饰\n\n#### 17.3 *匿名内部类\n将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类\n<br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体\n<br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类\n<br>匿名类内部没有构造方法，也不能用任何修饰符来修饰\n\n- 当接口类型的引用作为方法的形参时，实参的传递方式有两种：\n    1. 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。\n    2. 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。\n\n``` java\npublic interface A {\n    public abstract void show();\n}\n//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递\npublic class SubA implements A {\n    @Override\n    public void show() {\n        System.out.println(\"这里自定义类实现接口并重写抽象方法！\");\n    }\n}\n//测试类\npublic class ATest {\n    public static void test(A a) {\n        a.show();\n    }\n    public static void main(String[] args) {\n        //ATest.test(new A());//报错，A是接口，不能new对象\n        //-方式1：接口实现类的对象作为实参传递\n        ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。\n        \n        //-方式2：匿名内部类\n        // 接口/父类类型 引用变量名 = new 接口/父类类型() {方法的重写};\n        A ta = new A() {\n            @Override\n            public void show() {\n                System.out.println(\"这里是匿名内部类\");\n            }\n        };\n        ATest.test(ta);//得到接口类型的引用，再作为实参传递\n    }\n}\n```\n\n- 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。\n- 语法格式：`接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};`。\n\n``` java\nSuperType obj = new SuperType(...){ ... };\n```\n\n\n#### 17.4 静态内部类\n- 成员静态内部类\n- 不需要外部类对象，通过正常的方式直接创建内部类\n- 静态元素不能访问非静态成员(自己类和外部类)\n\n\n<span id=\"id18\"><span>\n### 18. 回调模式\n回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法\n\n``` java\ninterface Action{\n    public void doSth();\n}\n//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次\npublic static void repeat(int n, Action ac){\n    for(int i=0; i<n; i++){ ac.doSth();}\n}\n//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。\npublic static void main(String[] args){\n    repeat(5, new Action(){//通过匿名内部类传递参数\n        public void doSth(){\n            System.out.println(\"Hello\")\n        }\n    });\n}\n```\n\n\n<span id=\"id19\"><span>\n### 19. 抽象方法的笔试考点\n- `abstract`与哪些关键字不能共存：\n    1. `final`关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。\n    2. `static`关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。\n    3. `private`关键字；因为private修饰的私有方法不能被继承，就不能重写，而`abstract`方法需要重写。\n\n\n<span id=\"id20\"><span>\n### 20. 枚举类（enum）\n- 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来\n- 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum<E extends Enum<E>>，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。\n- 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object\n- Enum类型，有两个属性\n    * name----->枚举对象的名字，name()获取name属性\n    * ordinal--->枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号\n- 一些常用的方法\n    * valueOf()   通过给定的name获取对应的枚举对象\n    * values()     获取全部的枚举对象  ---> 返回一个数组  Day[]\n    * compareTo()   可以比较两个枚举对象   int\n    * toString()      由于这个方法没有final修饰  可以覆盖(重写)\n- switch内部判断枚举的应用\n- 我们也可以在enum中描述自己的一些属性或方法\n    * 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;\n    * 可以定义自己的属性\n    * 类创建的过程中  帮我们创建枚举类型的对象\n    * 需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载\n\n``` java\npublic enum Day{\n    //描述了七个当前类的对象\n    monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday;\n\n    private String name;\n    private int index;\n    \n    private Day(){}\n    private Day(String  name,int index){\n        this.name=name;\n        this.index=index;\n    }\n    \n    public String getName(){\n        return this.name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n}\n```\n\n\n<span id=\"id21\"><span>\n### 21. 内存机制问题\n- 类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行\n- 栈内存--->Person p = new Person();---->堆内存    方法区---类模板\n    * 栈内存----变量空间,方法临时执行空间（从创建开始执行完毕,**立即回收**）\n    * 堆内存----new申请对象空间（**垃圾回收器GC**,对象空间没有任何引用指向视为垃圾）\n    * 方法区----常量  类模板  静态成员（有且只有一份,**不回收**）\n- Runtime类(是单例模式)之中提供了几个管理内存的方法\n    * maxMemory\n    * totalMemory\n    * freeMemory\n    * 栈内存溢出错误StackOverflowError \n    * 堆内存溢出错误OutOfMemoryError\n- Object类中有一个finalize方法  如果重写也能看见对象回收的效果\n- GC系统提供的一个线程    回收算法\n\n","source":"_posts/02_JavaSE面向对象.md","raw":"---\ntitle: 二、JavaSE面向对象\ndate: 2019-07-07 18:50:47\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。\nJava中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。\n<!-- more -->\n\n1. [类与对象](#id1)\n2. [构造方法和方法重载](#id2)\n3. [this关键字](#id3)\n4. [方法的传递和递归](#id4)\n5. [封装](#id5)\n6. [static关键字](#id6)\n7. [单例设计模式](#id7)\n8. [继承（extends）](#id8)\n9. [方法的重写（Override）](#id9)\n10. [访问控制](#id10)\n11. [包（Package）](#id11)\n12. [final关键字](#id12)\n13. [对象的创建过程](#id13)\n14. [多态](#id14)\n15. [抽象类](#id15)\n16. [接口](#id16)\n17. [内部类](#id17)\n18. [回调模式](#id18)\n19. [抽象方法的笔试考点](#id19)\n20. [枚举类（enum）](#id20)\n21. [内存机制问题](#id21)\n\n\n<span id=\"id1\"><span>\n### 1. 类与对象\n#### 1.1 类的定义\n``` java\nclass 类名 {类体}\n```\n\n> 类名由多个单词组成时，要求每个单词首字母大写\n\n#### 1.2 成员变量的定义\n``` java\nclass 类名 { 数据类型 成员变量名=初始值; ... }\n```\n\n> 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写\n\n#### 1.3 对象的创建\n``` java\nnew 类名();\n```\n\n> 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。\n\n#### 1.4 引用\n``` java\n类名 引用变量名;\nPerson p = new Person(); //声明person类型的引用p指向Person类型对象\n```\n\n``` java\n引用变量名.成员变量名;\np.name = 'zhangsan';\n```\n\n>- 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。\n>- 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。\n\n- 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。\n\n\n#### 1.5 成员方法\n``` java\nclass 类名 {\n    返回值类型 成员方法名(形参列表){方法体;}\n}\n```\n\n- 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void\n- 形参列表：数据类型 形参1, 数据类型 形参2, ...\n\n\n<span id=\"id2\"><span>\n### 2. 构造方法和方法重载\n#### 2.1 构造方法\n``` java\nclass 类名 { 构造方法名(形参列表){构造方法体;} }\n```\n\n- 构造方法名与类名相同且没有返回值\n- 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。\n\n#### 2.2 默认构造方法\n- 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。\n- 若类中出现自定义构造方法，则编译器不再提供构造方法。\n\n#### 2.3 方法重载（overload）\n在Java中，方法名相同，参数列表不同的方法构成重载关系。\n\n- 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）\n- 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。\n\n\n<span id=\"id3\"><span>\n### 3. this关键字\n在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。\n- 使用方式：\n    1. 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名\n    2. 在构造方法的的第一行，可以调用本类中的其他构造方法。\n\n\n<span id=\"id4\"><span>\n### 4. 方法的传递和递归\n#### 4.1 传参\n- 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。\n- 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。\n- 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。\n\n#### 4.2 递归的调用\n- 递归是指方法体内部调用自身\n- 必须有递归的规律和退出条件\n- 使用递归必须使得问题简单化而不是复杂化\n- 若递归影响到程序的执行性能时，则用递推取代之\n\n\n<span id=\"id5\"><span>\n### 5. 封装\n面向对象的三大特征：封装，继承，多态。\n- 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断\n- 封装基本流程：\n    1. 私有化成员变量(private)\n    2. 提供公有的get、set方法，并在set方法体中进行合理性判断\n    3. 在构方法中调用set方法进行合理值的判断\n\n\n<span id=\"id6\"><span>\n### 6. static关键字\n基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。\n\n> 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。\n\n- static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)\n- 特点\n    * 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问\n    * 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突\n    * 静态元素只加载一次，全部类对象及类本身共享\n    * 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存\n    * 非静态成员和静态成员都可以访问静态成员\n    * 静态成员不可以访问非静态成员\n    * 静态元素中不可出现this或super关键字，静态元素属于类的\n\n\n<span id=\"id7\"><span>\n### 7. 单例设计模式\n基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。\n\n``` java\n/**\n * 编程实现Singleton类的封装\n */\npublic class Singleton{\n    private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象\n    private Singleton(){} //1.私有化构造方法\n    public static Singleton getInstance(){//3.提供公有的get方法将上述成员变量的数值返回出去\n        return sin;\n    }\n}\n```\n\n- 实现流程：\n    1. 私有化构造方法（private）\n    2. 提供本类类型的引用指向本类类型对象（private static）\n    3. 提供公有的get方法将上述对象return出去（public static）\n    4. 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。\n\n\n<span id=\"id8\"><span>\n### 8. 继承（extends）\n- 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系\n- 使用继承可以提高代码复用性、扩展性、以及可维护性。\n    1. 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。\n    2. 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。\n    3. 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。\n    4. 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。\n\n``` java\nclass Cricle extends Shape{\n    int r;\n    Cricle(){}   //编译器会加入无参的调用 super()。\n    Cricle(int x, int y, int r){\n        super(x, y);  //通过super关键字调用父类的构造方法。\n        setR(r);\n    }\n    public void setR(int r){\n        this.r = r;\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 方法的重写（Override）\n概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。\n<br>原则：\n1. 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。\n2. 要求访问权限不能变小，可以相同或变大\n3. 重写的方法不能抛出更大的异常\n\n\n<span id=\"id10\"><span>\n### 10. 访问控制\n- public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，\n- 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰\n\n| 访问控制符 | 访问权限    | 本类内部    | 本类中的包 | 子类    | 其他包 |\n| ---------    |:---------:| ------:    |-------:    |-----:    |------:|\n| public    | 共有的        | Y            | Y            | Y        | Y        |\n| protected    | 保护的        | Y            | Y            | Y        | N        |\n| 不写        | 默认的        | Y            | Y            | N        | N        |\n| private    | 私有的        | Y            | N            | N        | N        |\n\n\n<span id=\"id11\"><span>\n### 11. 包（Package）\n为了解决命名冲突问题，便于文件的管理\n\n``` java\npackage 包名；\npackage 包名1.包名2.包名3...包名n;\n/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */\norg.apache.commons.lang.StringUtil;\n```\n\n\n<span id=\"id12\"><span>\n### 12. final关键字\n1. final关键字修饰**类**体现该类**不能被继承**（防止滥用继承）。\n2. final关键字修饰**方法**体现在该方法**不能被重新，但可以被继承**（防止不经意间造成的方法重写）。\n3. final关键字修饰**成员变量**体现在改成员变量**必须初始化且不能更改**（防止不经意间造成的数据更改）。\n\n> 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用**`public static final`**共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。\n\n\n<span id=\"id13\"><span>\n### 13. 对象的创建过程\n- 单个对象的创建过程\n    1. main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；\n    2. 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；\n    3. 执行构造块中的代码可以对成员变量进行赋值；\n    4. 执行构造方法体中的代码可以对成员变量进行再次赋值；\n    5. 此时对象构造完毕，继续向下执行后续的代码；\n- 子类对象的创建过程\n    1. main方法是程序的入口，先加载父类的的代码再加载子类的代码；\n    2. 先执行父类静态代码块，再执行子类的静态代码块；\n    3. 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；\n    4. 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。\n\n\n<span id=\"id14\"><span>\n### 14. 多态\n1. 语法：父类的引用指向子类的对象\n\n``` java\n父类类型 引用变量名 = new 子类类型();\nPerson pw = new Worker();\npw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。\n```\n\n2. 多态的效果：\n    1. 父类的引用**可以**直接调用**父类独有**的方法。\n    2. 父类的引用**不可以**直接调用**子类独有**的方法。\n    3. 对于父类子类都有的**非静态方法**来说，编译阶段调用父类的，运行阶段调用子类重写后的。\n    4. 对于父类子类都有的**静态方法**来说，只调用父类的。\n3. 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。\n4. 多态的表现形式\n    1. 多态的前提要有继承的关系\n    2. 使用父类引用指向子类对象 Person p = new Teacher();//向上转型\n    3. 该引用只能调用父类中定义的属性/方法\n    4. 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写\n    5. 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException\n5. 引用数据类型之间的转换\n    - 转换必须发生在父子类之间，否则编译报错。\n    - 自动类型转换：小到大，子类型向父类型的转换，eg:`Person pw = new Worker();`。\n    - 强制类型转换：大到小，父类型向子类型转换，eg:`((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法`。\n6. 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。\n\n``` java\n/*语法格式：*/ 对象 instanceof 类型  //返回布尔值\nif(pw instanceof Teacher){\n    Teacher t = (Teacher) pw;\n}else{\n    System.out.println(\"转换会有异常\");\n}\n```\n\n7. 多态的使用场合：\n\n``` java\n// 通过方法的参数传递形成多态。\npublic static void draw(Shape s){}\nTestShape.draw(new Rect(1,2,3,4));\n\n// 在方法体中直接使用多态的语法格式。\nTestAbstrat ta = new SubTestAbstract();\nta.show();\n```\n\n\n<span id=\"id15\"><span>\n### 15. 抽象类\n1. 基本概念\n    - 用**abstract**关键字修饰的类称为抽象类。\n    - 抽象类不能实例化，抽象类的意义在于被继承。\n    - 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。\n    - 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。\n\n``` java\npublic abstract class Shape{ //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类\n    private int x;\n    private int y;\n    public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体\n}\n```\n\n2. 注意：\n    1. 抽象类中可以有成员变量，成员方法，以及构造方法。\n    2. 抽象类中可以没有抽象方法，也可以有抽象方法。\n    3. 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。\n    4. 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。\n    5. 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。\n    6. 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。\n\n> 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。\n\n\n<span id=\"id16\"><span>\n### 16. 接口\n1. 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过**interface**关键字定义。\n\n``` java\ninterface Runner { //-通过interface关键字定义接口\n    public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量\n    public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）\n}\n```\n\n2. 一个类可以通过**implements**关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。\n\n``` java\nclass American implements Runner,... { //与继承不同，可以实现多个接口\n    @Override\n    public void run(){//该类需要实现接口中定义的所有方法\n        System.out.println(\"run...\");\n    }\n    public static void main(String[] args) {\n        Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象\n        ra.run();//通过该变量可以调用该接口定义的方法\n    }\n}\n```\n\n3. 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。\n\n``` java\ninterface Hunter extends Runner{...}\n```\n\n4. 类与接口的关系\n    - 类和类使用`extends`继承，仅支持**单继承**。\n    - 接口和接口使用`extends`继承，支持多继承。\n    - 类使用`implements`实现接口，支持**多实现**。\n5. 抽象类与接口的关系（笔试题）\n    1. 定义抽象类:`abstract class`，而定义接口:`interface`；\n    2. 类继承抽象类:`extends`单继承，而类实现接口:`implements`多实现；\n    3. 抽象类可以`有`构造方法，而接口`不能有`构造方法；\n    4. 抽象类可以有`成员变量`，而接口只能有`常量`；\n    5. 抽象类可以有`成员方法`，而接口只能有`抽象方法`；\n    6. 抽象类中增加方法子类可以`不用重写`，而接口中增加方法子类`必须重写`；\n    7. 从jdk1.8开始允许接口中有非抽象方法，但需要`default`关键字修饰。\n\n\n<span id=\"id17\"><span>\n### 17. 内部类\n- 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部\n- 内部类定义在 类的内部 ，与类成员层次一致\n- 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）\n    * 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n    * 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n    * 匿名内部类：成员匿名内部类，局部匿名内部类\n    * 静态内部类：成员静态内部类\n\n#### 17.1 *成员内部类\n- 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n- 成员内部类可以与正常类一样 使用不同的修饰符来修饰\n- 好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的\n- 若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;\n- 内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class\n\n#### 17.2 局部内部类\n- 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n- 局部内部类像是一个局部的变量一样，不能用public protected private及static\n- 只能用abstract或final\n- 局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod\n- 局部内部类使用的变量只能是final修饰\n\n#### 17.3 *匿名内部类\n将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类\n<br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体\n<br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类\n<br>匿名类内部没有构造方法，也不能用任何修饰符来修饰\n\n- 当接口类型的引用作为方法的形参时，实参的传递方式有两种：\n    1. 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。\n    2. 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。\n\n``` java\npublic interface A {\n    public abstract void show();\n}\n//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递\npublic class SubA implements A {\n    @Override\n    public void show() {\n        System.out.println(\"这里自定义类实现接口并重写抽象方法！\");\n    }\n}\n//测试类\npublic class ATest {\n    public static void test(A a) {\n        a.show();\n    }\n    public static void main(String[] args) {\n        //ATest.test(new A());//报错，A是接口，不能new对象\n        //-方式1：接口实现类的对象作为实参传递\n        ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。\n        \n        //-方式2：匿名内部类\n        // 接口/父类类型 引用变量名 = new 接口/父类类型() {方法的重写};\n        A ta = new A() {\n            @Override\n            public void show() {\n                System.out.println(\"这里是匿名内部类\");\n            }\n        };\n        ATest.test(ta);//得到接口类型的引用，再作为实参传递\n    }\n}\n```\n\n- 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。\n- 语法格式：`接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};`。\n\n``` java\nSuperType obj = new SuperType(...){ ... };\n```\n\n\n#### 17.4 静态内部类\n- 成员静态内部类\n- 不需要外部类对象，通过正常的方式直接创建内部类\n- 静态元素不能访问非静态成员(自己类和外部类)\n\n\n<span id=\"id18\"><span>\n### 18. 回调模式\n回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法\n\n``` java\ninterface Action{\n    public void doSth();\n}\n//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次\npublic static void repeat(int n, Action ac){\n    for(int i=0; i<n; i++){ ac.doSth();}\n}\n//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。\npublic static void main(String[] args){\n    repeat(5, new Action(){//通过匿名内部类传递参数\n        public void doSth(){\n            System.out.println(\"Hello\")\n        }\n    });\n}\n```\n\n\n<span id=\"id19\"><span>\n### 19. 抽象方法的笔试考点\n- `abstract`与哪些关键字不能共存：\n    1. `final`关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。\n    2. `static`关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。\n    3. `private`关键字；因为private修饰的私有方法不能被继承，就不能重写，而`abstract`方法需要重写。\n\n\n<span id=\"id20\"><span>\n### 20. 枚举类（enum）\n- 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来\n- 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum<E extends Enum<E>>，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。\n- 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object\n- Enum类型，有两个属性\n    * name----->枚举对象的名字，name()获取name属性\n    * ordinal--->枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号\n- 一些常用的方法\n    * valueOf()   通过给定的name获取对应的枚举对象\n    * values()     获取全部的枚举对象  ---> 返回一个数组  Day[]\n    * compareTo()   可以比较两个枚举对象   int\n    * toString()      由于这个方法没有final修饰  可以覆盖(重写)\n- switch内部判断枚举的应用\n- 我们也可以在enum中描述自己的一些属性或方法\n    * 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;\n    * 可以定义自己的属性\n    * 类创建的过程中  帮我们创建枚举类型的对象\n    * 需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载\n\n``` java\npublic enum Day{\n    //描述了七个当前类的对象\n    monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday;\n\n    private String name;\n    private int index;\n    \n    private Day(){}\n    private Day(String  name,int index){\n        this.name=name;\n        this.index=index;\n    }\n    \n    public String getName(){\n        return this.name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n}\n```\n\n\n<span id=\"id21\"><span>\n### 21. 内存机制问题\n- 类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行\n- 栈内存--->Person p = new Person();---->堆内存    方法区---类模板\n    * 栈内存----变量空间,方法临时执行空间（从创建开始执行完毕,**立即回收**）\n    * 堆内存----new申请对象空间（**垃圾回收器GC**,对象空间没有任何引用指向视为垃圾）\n    * 方法区----常量  类模板  静态成员（有且只有一份,**不回收**）\n- Runtime类(是单例模式)之中提供了几个管理内存的方法\n    * maxMemory\n    * totalMemory\n    * freeMemory\n    * 栈内存溢出错误StackOverflowError \n    * 堆内存溢出错误OutOfMemoryError\n- Object类中有一个finalize方法  如果重写也能看见对象回收的效果\n- GC系统提供的一个线程    回收算法\n\n","slug":"02_JavaSE面向对象","published":1,"updated":"2019-07-20T14:45:51.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylobj003tyot3mzgdvlqa","content":"<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br>Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">类与对象</a></li>\n<li><a href=\"#id2\">构造方法和方法重载</a></li>\n<li><a href=\"#id3\">this关键字</a></li>\n<li><a href=\"#id4\">方法的传递和递归</a></li>\n<li><a href=\"#id5\">封装</a></li>\n<li><a href=\"#id6\">static关键字</a></li>\n<li><a href=\"#id7\">单例设计模式</a></li>\n<li><a href=\"#id8\">继承（extends）</a></li>\n<li><a href=\"#id9\">方法的重写（Override）</a></li>\n<li><a href=\"#id10\">访问控制</a></li>\n<li><a href=\"#id11\">包（Package）</a></li>\n<li><a href=\"#id12\">final关键字</a></li>\n<li><a href=\"#id13\">对象的创建过程</a></li>\n<li><a href=\"#id14\">多态</a></li>\n<li><a href=\"#id15\">抽象类</a></li>\n<li><a href=\"#id16\">接口</a></li>\n<li><a href=\"#id17\">内部类</a></li>\n<li><a href=\"#id18\">回调模式</a></li>\n<li><a href=\"#id19\">抽象方法的笔试考点</a></li>\n<li><a href=\"#id20\">枚举类（enum）</a></li>\n<li><a href=\"#id21\">内存机制问题</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-类与对象\"><a href=\"#1-类与对象\" class=\"headerlink\" title=\"1. 类与对象\"></a>1. 类与对象</h3><h4 id=\"1-1-类的定义\"><a href=\"#1-1-类的定义\" class=\"headerlink\" title=\"1.1 类的定义\"></a>1.1 类的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;类体&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类名由多个单词组成时，要求每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-2-成员变量的定义\"><a href=\"#1-2-成员变量的定义\" class=\"headerlink\" title=\"1.2 成员变量的定义\"></a>1.2 成员变量的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-3-对象的创建\"><a href=\"#1-3-对象的创建\" class=\"headerlink\" title=\"1.3 对象的创建\"></a>1.3 对象的创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。</p>\n</blockquote>\n<h4 id=\"1-4-引用\"><a href=\"#1-4-引用\" class=\"headerlink\" title=\"1.4 引用\"></a>1.4 引用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名 引用变量名;</span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用变量名.成员变量名;</span><br><span class=\"line\">p.name = <span class=\"string\">'zhangsan'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li>\n<li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li>\n</ul>\n</blockquote>\n<ul>\n<li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li>\n</ul>\n<h4 id=\"1-5-成员方法\"><a href=\"#1-5-成员方法\" class=\"headerlink\" title=\"1.5 成员方法\"></a>1.5 成员方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;</span><br><span class=\"line\">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li>\n<li>形参列表：数据类型 形参1, 数据类型 形参2, …</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-构造方法和方法重载\"><a href=\"#2-构造方法和方法重载\" class=\"headerlink\" title=\"2. 构造方法和方法重载\"></a>2. 构造方法和方法重载</h3><h4 id=\"2-1-构造方法\"><a href=\"#2-1-构造方法\" class=\"headerlink\" title=\"2.1 构造方法\"></a>2.1 构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造方法名与类名相同且没有返回值</li>\n<li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li>\n</ul>\n<h4 id=\"2-2-默认构造方法\"><a href=\"#2-2-默认构造方法\" class=\"headerlink\" title=\"2.2 默认构造方法\"></a>2.2 默认构造方法</h4><ul>\n<li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。</li>\n<li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li>\n</ul>\n<h4 id=\"2-3-方法重载（overload）\"><a href=\"#2-3-方法重载（overload）\" class=\"headerlink\" title=\"2.3 方法重载（overload）\"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p>\n<ul>\n<li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li>\n<li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-this关键字\"><a href=\"#3-this关键字\" class=\"headerlink\" title=\"3. this关键字\"></a>3. this关键字</h3><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p>\n<ul>\n<li>使用方式：<ol>\n<li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li>\n<li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-方法的传递和递归\"><a href=\"#4-方法的传递和递归\" class=\"headerlink\" title=\"4. 方法的传递和递归\"></a>4. 方法的传递和递归</h3><h4 id=\"4-1-传参\"><a href=\"#4-1-传参\" class=\"headerlink\" title=\"4.1 传参\"></a>4.1 传参</h4><ul>\n<li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li>\n<li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li>\n<li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li>\n</ul>\n<h4 id=\"4-2-递归的调用\"><a href=\"#4-2-递归的调用\" class=\"headerlink\" title=\"4.2 递归的调用\"></a>4.2 递归的调用</h4><ul>\n<li>递归是指方法体内部调用自身</li>\n<li>必须有递归的规律和退出条件</li>\n<li>使用递归必须使得问题简单化而不是复杂化</li>\n<li>若递归影响到程序的执行性能时，则用递推取代之</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-封装\"><a href=\"#5-封装\" class=\"headerlink\" title=\"5. 封装\"></a>5. 封装</h3><p>面向对象的三大特征：封装，继承，多态。</p>\n<ul>\n<li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li>\n<li>封装基本流程：<ol>\n<li>私有化成员变量(private)</li>\n<li>提供公有的get、set方法，并在set方法体中进行合理性判断</li>\n<li>在构方法中调用set方法进行合理值的判断</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-static关键字\"><a href=\"#6-static关键字\" class=\"headerlink\" title=\"6. static关键字\"></a>6. static关键字</h3><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p>\n<blockquote>\n<p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p>\n</blockquote>\n<ul>\n<li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li>\n<li>特点<ul>\n<li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li>\n<li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li>\n<li>静态元素只加载一次，全部类对象及类本身共享</li>\n<li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li>\n<li>非静态成员和静态成员都可以访问静态成员</li>\n<li>静态成员不可以访问非静态成员</li>\n<li>静态元素中不可出现this或super关键字，静态元素属于类的</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-单例设计模式\"><a href=\"#7-单例设计模式\" class=\"headerlink\" title=\"7. 单例设计模式\"></a>7. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 编程实现Singleton类的封装</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton sin = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//2.提供本类的引用指向本类的对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125; <span class=\"comment\">//1.私有化构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现流程：<ol>\n<li>私有化构造方法（private）</li>\n<li>提供本类类型的引用指向本类类型对象（private static）</li>\n<li>提供公有的get方法将上述对象return出去（public static）</li>\n<li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-继承（extends）\"><a href=\"#8-继承（extends）\" class=\"headerlink\" title=\"8. 继承（extends）\"></a>8. 继承（extends）</h3><ul>\n<li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li>\n<li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol>\n<li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li>\n<li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li>\n<li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li>\n<li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cricle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    Cricle()&#123;&#125;   <span class=\"comment\">//编译器会加入无参的调用 super()。</span></span><br><span class=\"line\">    Cricle(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(x, y);  <span class=\"comment\">//通过super关键字调用父类的构造方法。</span></span><br><span class=\"line\">        setR(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setR</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-方法的重写（Override）\"><a href=\"#9-方法的重写（Override）\" class=\"headerlink\" title=\"9. 方法的重写（Override）\"></a>9. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p>\n<ol>\n<li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li>\n<li>要求访问权限不能变小，可以相同或变大</li>\n<li>重写的方法不能抛出更大的异常</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-访问控制\"><a href=\"#10-访问控制\" class=\"headerlink\" title=\"10. 访问控制\"></a>10. 访问控制</h3><ul>\n<li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li>\n<li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>访问控制符</th>\n<th align=\"center\">访问权限</th>\n<th align=\"right\">本类内部</th>\n<th align=\"right\">本类中的包</th>\n<th align=\"right\">子类</th>\n<th align=\"right\">其他包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td align=\"center\">共有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n</tr>\n<tr>\n<td>protected</td>\n<td align=\"center\">保护的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>不写</td>\n<td align=\"center\">默认的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">私有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n</tbody></table>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-包（Package）\"><a href=\"#11-包（Package）\" class=\"headerlink\" title=\"11. 包（Package）\"></a>11. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> 包名；</span><br><span class=\"line\"><span class=\"keyword\">package</span> 包名<span class=\"number\">1</span>.包名<span class=\"number\">2</span>.包名<span class=\"number\">3</span>...包名n;</span><br><span class=\"line\"><span class=\"comment\">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class=\"line\">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-final关键字\"><a href=\"#12-final关键字\" class=\"headerlink\" title=\"12. final关键字\"></a>12. final关键字</h3><ol>\n<li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li>\n<li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li>\n<li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li>\n</ol>\n<blockquote>\n<p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用<strong><code>public static final</code></strong>共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p>\n</blockquote>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-对象的创建过程\"><a href=\"#13-对象的创建过程\" class=\"headerlink\" title=\"13. 对象的创建过程\"></a>13. 对象的创建过程</h3><ul>\n<li>单个对象的创建过程<ol>\n<li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li>\n<li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li>\n<li>执行构造块中的代码可以对成员变量进行赋值；</li>\n<li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li>\n<li>此时对象构造完毕，继续向下执行后续的代码；</li>\n</ol>\n</li>\n<li>子类对象的创建过程<ol>\n<li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li>\n<li>先执行父类静态代码块，再执行子类的静态代码块；</li>\n<li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li>\n<li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-多态\"><a href=\"#14-多态\" class=\"headerlink\" title=\"14. 多态\"></a>14. 多态</h3><ol>\n<li>语法：父类的引用指向子类的对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类类型 引用变量名 = <span class=\"keyword\">new</span> 子类类型();</span><br><span class=\"line\">Person pw = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">pw.show();<span class=\"comment\">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>多态的效果：<ol>\n<li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li>\n<li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li>\n<li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li>\n<li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li>\n</ol>\n</li>\n<li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li>\n<li>多态的表现形式<ol>\n<li>多态的前提要有继承的关系</li>\n<li>使用父类引用指向子类对象 Person p = new Teacher();//向上转型</li>\n<li>该引用只能调用父类中定义的属性/方法</li>\n<li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li>\n<li>若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li>\n</ol>\n</li>\n<li>引用数据类型之间的转换<ul>\n<li>转换必须发生在父子类之间，否则编译报错。</li>\n<li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li>\n<li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li>\n</ul>\n</li>\n<li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*语法格式：*/</span> 对象 <span class=\"keyword\">instanceof</span> 类型  <span class=\"comment\">//返回布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw <span class=\"keyword\">instanceof</span> Teacher)&#123;</span><br><span class=\"line\">    Teacher t = (Teacher) pw;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"转换会有异常\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>多态的使用场合：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过方法的参数传递形成多态。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Shape s)</span></span>&#123;&#125;</span><br><span class=\"line\">TestShape.draw(<span class=\"keyword\">new</span> Rect(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在方法体中直接使用多态的语法格式。</span></span><br><span class=\"line\">TestAbstrat ta = <span class=\"keyword\">new</span> SubTestAbstract();</span><br><span class=\"line\">ta.show();</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-抽象类\"><a href=\"#15-抽象类\" class=\"headerlink\" title=\"15. 抽象类\"></a>15. 抽象类</h3><ol>\n<li>基本概念<ul>\n<li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li>\n<li>抽象类不能实例化，抽象类的意义在于被继承。</li>\n<li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li>\n<li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span>&#123; <span class=\"comment\">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;<span class=\"comment\">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>注意：<ol>\n<li>抽象类中可以有成员变量，成员方法，以及构造方法。</li>\n<li>抽象类中可以没有抽象方法，也可以有抽象方法。</li>\n<li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li>\n<li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li>\n<li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>\n<li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p>\n</blockquote>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-接口\"><a href=\"#16-接口\" class=\"headerlink\" title=\"16. 接口\"></a>16. 接口</h3><ol>\n<li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runner</span> </span>&#123; <span class=\"comment\">//-通过interface关键字定义接口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SEF_SPEED=<span class=\"number\">100</span>;<span class=\"comment\">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;<span class=\"comment\">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">American</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runner</span>,... </span>&#123; <span class=\"comment\">//与继承不同，可以实现多个接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//该类需要实现接口中定义的所有方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"run...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runner ra = <span class=\"keyword\">new</span> American();<span class=\"comment\">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class=\"line\">        ra.run();<span class=\"comment\">//通过该变量可以调用该接口定义的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hunter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runner</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>类与接口的关系<ul>\n<li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li>\n<li>接口和接口使用<code>extends</code>继承，支持多继承。</li>\n<li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li>\n</ul>\n</li>\n<li>抽象类与接口的关系（笔试题）<ol>\n<li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li>\n<li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li>\n<li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li>\n<li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li>\n<li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li>\n<li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li>\n<li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id17\"><span></span></span></p>\n<h3 id=\"17-内部类\"><a href=\"#17-内部类\" class=\"headerlink\" title=\"17. 内部类\"></a>17. 内部类</h3><ul>\n<li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li>\n<li>内部类定义在 类的内部 ，与类成员层次一致</li>\n<li>内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul>\n<li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>匿名内部类：成员匿名内部类，局部匿名内部类</li>\n<li>静态内部类：成员静态内部类</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"17-1-成员内部类\"><a href=\"#17-1-成员内部类\" class=\"headerlink\" title=\"17.1 *成员内部类\"></a>17.1 *成员内部类</h4><ul>\n<li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li>\n<li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li>\n<li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li>\n<li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li>\n</ul>\n<h4 id=\"17-2-局部内部类\"><a href=\"#17-2-局部内部类\" class=\"headerlink\" title=\"17.2 局部内部类\"></a>17.2 局部内部类</h4><ul>\n<li>将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li>\n<li>只能用abstract或final</li>\n<li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li>\n<li>局部内部类使用的变量只能是final修饰</li>\n</ul>\n<h4 id=\"17-3-匿名内部类\"><a href=\"#17-3-匿名内部类\" class=\"headerlink\" title=\"17.3 *匿名内部类\"></a>17.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p>\n<ul>\n<li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol>\n<li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li>\n<li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubA</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这里自定义类实现接口并重写抽象方法！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ATest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(A a)</span> </span>&#123;</span><br><span class=\"line\">        a.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class=\"line\">        <span class=\"comment\">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class=\"line\">        ATest.test(<span class=\"keyword\">new</span> ASub());<span class=\"comment\">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//-方式2：匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class=\"line\">        A ta = <span class=\"keyword\">new</span> A() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"这里是匿名内部类\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ATest.test(ta);<span class=\"comment\">//得到接口类型的引用，再作为实参传递</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li>\n<li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SuperType obj = <span class=\"keyword\">new</span> SuperType(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-静态内部类\"><a href=\"#17-4-静态内部类\" class=\"headerlink\" title=\"17.4 静态内部类\"></a>17.4 静态内部类</h4><ul>\n<li>成员静态内部类</li>\n<li>不需要外部类对象，通过正常的方式直接创建内部类</li>\n<li>静态元素不能访问非静态成员(自己类和外部类)</li>\n</ul>\n<p><span id=\"id18\"><span></span></span></p>\n<h3 id=\"18-回调模式\"><a href=\"#18-回调模式\" class=\"headerlink\" title=\"18. 回调模式\"></a>18. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">repeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Action ac)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    repeat(<span class=\"number\">5</span>, <span class=\"keyword\">new</span> Action()&#123;<span class=\"comment\">//通过匿名内部类传递参数</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id19\"><span></span></span></p>\n<h3 id=\"19-抽象方法的笔试考点\"><a href=\"#19-抽象方法的笔试考点\" class=\"headerlink\" title=\"19. 抽象方法的笔试考点\"></a>19. 抽象方法的笔试考点</h3><ul>\n<li><code>abstract</code>与哪些关键字不能共存：<ol>\n<li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li>\n<li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li>\n<li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id20\"><span></span></span></p>\n<h3 id=\"20-枚举类（enum）\"><a href=\"#20-枚举类（enum）\" class=\"headerlink\" title=\"20. 枚举类（enum）\"></a>20. 枚举类（enum）</h3><ul>\n<li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li>\n<li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></li>\n<li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li>\n<li>Enum类型，有两个属性<ul>\n<li>name—–&gt;枚举对象的名字，name()获取name属性</li>\n<li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li>\n</ul>\n</li>\n<li>一些常用的方法<ul>\n<li>valueOf()   通过给定的name获取对应的枚举对象</li>\n<li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li>\n<li>compareTo()   可以比较两个枚举对象   int</li>\n<li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li>\n</ul>\n</li>\n<li>switch内部判断枚举的应用</li>\n<li>我们也可以在enum中描述自己的一些属性或方法<ul>\n<li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li>\n<li>可以定义自己的属性</li>\n<li>类创建的过程中  帮我们创建枚举类型的对象</li>\n<li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Day&#123;</span><br><span class=\"line\">    <span class=\"comment\">//描述了七个当前类的对象</span></span><br><span class=\"line\">    monday(<span class=\"string\">\"星期一\"</span>,<span class=\"number\">1</span>),tuesday(<span class=\"string\">\"星期二\"</span>,<span class=\"number\">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">(String  name,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index=index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id21\"><span></span></span></p>\n<h3 id=\"21-内存机制问题\"><a href=\"#21-内存机制问题\" class=\"headerlink\" title=\"21. 内存机制问题\"></a>21. 内存机制问题</h3><ul>\n<li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li>\n<li>栈内存—&gt;Person p = new Person();—-&gt;堆内存    方法区—类模板<ul>\n<li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li>\n<li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li>\n<li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li>\n</ul>\n</li>\n<li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul>\n<li>maxMemory</li>\n<li>totalMemory</li>\n<li>freeMemory</li>\n<li>栈内存溢出错误StackOverflowError </li>\n<li>堆内存溢出错误OutOfMemoryError</li>\n</ul>\n</li>\n<li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li>\n<li>GC系统提供的一个线程    回收算法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br>Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p>","more":"<ol>\n<li><a href=\"#id1\">类与对象</a></li>\n<li><a href=\"#id2\">构造方法和方法重载</a></li>\n<li><a href=\"#id3\">this关键字</a></li>\n<li><a href=\"#id4\">方法的传递和递归</a></li>\n<li><a href=\"#id5\">封装</a></li>\n<li><a href=\"#id6\">static关键字</a></li>\n<li><a href=\"#id7\">单例设计模式</a></li>\n<li><a href=\"#id8\">继承（extends）</a></li>\n<li><a href=\"#id9\">方法的重写（Override）</a></li>\n<li><a href=\"#id10\">访问控制</a></li>\n<li><a href=\"#id11\">包（Package）</a></li>\n<li><a href=\"#id12\">final关键字</a></li>\n<li><a href=\"#id13\">对象的创建过程</a></li>\n<li><a href=\"#id14\">多态</a></li>\n<li><a href=\"#id15\">抽象类</a></li>\n<li><a href=\"#id16\">接口</a></li>\n<li><a href=\"#id17\">内部类</a></li>\n<li><a href=\"#id18\">回调模式</a></li>\n<li><a href=\"#id19\">抽象方法的笔试考点</a></li>\n<li><a href=\"#id20\">枚举类（enum）</a></li>\n<li><a href=\"#id21\">内存机制问题</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-类与对象\"><a href=\"#1-类与对象\" class=\"headerlink\" title=\"1. 类与对象\"></a>1. 类与对象</h3><h4 id=\"1-1-类的定义\"><a href=\"#1-1-类的定义\" class=\"headerlink\" title=\"1.1 类的定义\"></a>1.1 类的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;类体&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类名由多个单词组成时，要求每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-2-成员变量的定义\"><a href=\"#1-2-成员变量的定义\" class=\"headerlink\" title=\"1.2 成员变量的定义\"></a>1.2 成员变量的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-3-对象的创建\"><a href=\"#1-3-对象的创建\" class=\"headerlink\" title=\"1.3 对象的创建\"></a>1.3 对象的创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。</p>\n</blockquote>\n<h4 id=\"1-4-引用\"><a href=\"#1-4-引用\" class=\"headerlink\" title=\"1.4 引用\"></a>1.4 引用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名 引用变量名;</span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用变量名.成员变量名;</span><br><span class=\"line\">p.name = <span class=\"string\">'zhangsan'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li>\n<li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li>\n</ul>\n</blockquote>\n<ul>\n<li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li>\n</ul>\n<h4 id=\"1-5-成员方法\"><a href=\"#1-5-成员方法\" class=\"headerlink\" title=\"1.5 成员方法\"></a>1.5 成员方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;</span><br><span class=\"line\">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li>\n<li>形参列表：数据类型 形参1, 数据类型 形参2, …</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-构造方法和方法重载\"><a href=\"#2-构造方法和方法重载\" class=\"headerlink\" title=\"2. 构造方法和方法重载\"></a>2. 构造方法和方法重载</h3><h4 id=\"2-1-构造方法\"><a href=\"#2-1-构造方法\" class=\"headerlink\" title=\"2.1 构造方法\"></a>2.1 构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造方法名与类名相同且没有返回值</li>\n<li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li>\n</ul>\n<h4 id=\"2-2-默认构造方法\"><a href=\"#2-2-默认构造方法\" class=\"headerlink\" title=\"2.2 默认构造方法\"></a>2.2 默认构造方法</h4><ul>\n<li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。</li>\n<li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li>\n</ul>\n<h4 id=\"2-3-方法重载（overload）\"><a href=\"#2-3-方法重载（overload）\" class=\"headerlink\" title=\"2.3 方法重载（overload）\"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p>\n<ul>\n<li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li>\n<li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-this关键字\"><a href=\"#3-this关键字\" class=\"headerlink\" title=\"3. this关键字\"></a>3. this关键字</h3><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p>\n<ul>\n<li>使用方式：<ol>\n<li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li>\n<li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-方法的传递和递归\"><a href=\"#4-方法的传递和递归\" class=\"headerlink\" title=\"4. 方法的传递和递归\"></a>4. 方法的传递和递归</h3><h4 id=\"4-1-传参\"><a href=\"#4-1-传参\" class=\"headerlink\" title=\"4.1 传参\"></a>4.1 传参</h4><ul>\n<li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li>\n<li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li>\n<li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li>\n</ul>\n<h4 id=\"4-2-递归的调用\"><a href=\"#4-2-递归的调用\" class=\"headerlink\" title=\"4.2 递归的调用\"></a>4.2 递归的调用</h4><ul>\n<li>递归是指方法体内部调用自身</li>\n<li>必须有递归的规律和退出条件</li>\n<li>使用递归必须使得问题简单化而不是复杂化</li>\n<li>若递归影响到程序的执行性能时，则用递推取代之</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-封装\"><a href=\"#5-封装\" class=\"headerlink\" title=\"5. 封装\"></a>5. 封装</h3><p>面向对象的三大特征：封装，继承，多态。</p>\n<ul>\n<li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li>\n<li>封装基本流程：<ol>\n<li>私有化成员变量(private)</li>\n<li>提供公有的get、set方法，并在set方法体中进行合理性判断</li>\n<li>在构方法中调用set方法进行合理值的判断</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-static关键字\"><a href=\"#6-static关键字\" class=\"headerlink\" title=\"6. static关键字\"></a>6. static关键字</h3><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p>\n<blockquote>\n<p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p>\n</blockquote>\n<ul>\n<li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li>\n<li>特点<ul>\n<li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li>\n<li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li>\n<li>静态元素只加载一次，全部类对象及类本身共享</li>\n<li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li>\n<li>非静态成员和静态成员都可以访问静态成员</li>\n<li>静态成员不可以访问非静态成员</li>\n<li>静态元素中不可出现this或super关键字，静态元素属于类的</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-单例设计模式\"><a href=\"#7-单例设计模式\" class=\"headerlink\" title=\"7. 单例设计模式\"></a>7. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 编程实现Singleton类的封装</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton sin = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//2.提供本类的引用指向本类的对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125; <span class=\"comment\">//1.私有化构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现流程：<ol>\n<li>私有化构造方法（private）</li>\n<li>提供本类类型的引用指向本类类型对象（private static）</li>\n<li>提供公有的get方法将上述对象return出去（public static）</li>\n<li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-继承（extends）\"><a href=\"#8-继承（extends）\" class=\"headerlink\" title=\"8. 继承（extends）\"></a>8. 继承（extends）</h3><ul>\n<li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li>\n<li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol>\n<li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li>\n<li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li>\n<li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li>\n<li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cricle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    Cricle()&#123;&#125;   <span class=\"comment\">//编译器会加入无参的调用 super()。</span></span><br><span class=\"line\">    Cricle(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(x, y);  <span class=\"comment\">//通过super关键字调用父类的构造方法。</span></span><br><span class=\"line\">        setR(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setR</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-方法的重写（Override）\"><a href=\"#9-方法的重写（Override）\" class=\"headerlink\" title=\"9. 方法的重写（Override）\"></a>9. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p>\n<ol>\n<li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li>\n<li>要求访问权限不能变小，可以相同或变大</li>\n<li>重写的方法不能抛出更大的异常</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-访问控制\"><a href=\"#10-访问控制\" class=\"headerlink\" title=\"10. 访问控制\"></a>10. 访问控制</h3><ul>\n<li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li>\n<li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>访问控制符</th>\n<th align=\"center\">访问权限</th>\n<th align=\"right\">本类内部</th>\n<th align=\"right\">本类中的包</th>\n<th align=\"right\">子类</th>\n<th align=\"right\">其他包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td align=\"center\">共有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n</tr>\n<tr>\n<td>protected</td>\n<td align=\"center\">保护的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>不写</td>\n<td align=\"center\">默认的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">私有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n</tbody></table>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-包（Package）\"><a href=\"#11-包（Package）\" class=\"headerlink\" title=\"11. 包（Package）\"></a>11. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> 包名；</span><br><span class=\"line\"><span class=\"keyword\">package</span> 包名<span class=\"number\">1</span>.包名<span class=\"number\">2</span>.包名<span class=\"number\">3</span>...包名n;</span><br><span class=\"line\"><span class=\"comment\">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class=\"line\">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-final关键字\"><a href=\"#12-final关键字\" class=\"headerlink\" title=\"12. final关键字\"></a>12. final关键字</h3><ol>\n<li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li>\n<li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li>\n<li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li>\n</ol>\n<blockquote>\n<p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用<strong><code>public static final</code></strong>共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p>\n</blockquote>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-对象的创建过程\"><a href=\"#13-对象的创建过程\" class=\"headerlink\" title=\"13. 对象的创建过程\"></a>13. 对象的创建过程</h3><ul>\n<li>单个对象的创建过程<ol>\n<li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li>\n<li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li>\n<li>执行构造块中的代码可以对成员变量进行赋值；</li>\n<li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li>\n<li>此时对象构造完毕，继续向下执行后续的代码；</li>\n</ol>\n</li>\n<li>子类对象的创建过程<ol>\n<li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li>\n<li>先执行父类静态代码块，再执行子类的静态代码块；</li>\n<li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li>\n<li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-多态\"><a href=\"#14-多态\" class=\"headerlink\" title=\"14. 多态\"></a>14. 多态</h3><ol>\n<li>语法：父类的引用指向子类的对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类类型 引用变量名 = <span class=\"keyword\">new</span> 子类类型();</span><br><span class=\"line\">Person pw = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">pw.show();<span class=\"comment\">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>多态的效果：<ol>\n<li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li>\n<li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li>\n<li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li>\n<li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li>\n</ol>\n</li>\n<li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li>\n<li>多态的表现形式<ol>\n<li>多态的前提要有继承的关系</li>\n<li>使用父类引用指向子类对象 Person p = new Teacher();//向上转型</li>\n<li>该引用只能调用父类中定义的属性/方法</li>\n<li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li>\n<li>若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li>\n</ol>\n</li>\n<li>引用数据类型之间的转换<ul>\n<li>转换必须发生在父子类之间，否则编译报错。</li>\n<li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li>\n<li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li>\n</ul>\n</li>\n<li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*语法格式：*/</span> 对象 <span class=\"keyword\">instanceof</span> 类型  <span class=\"comment\">//返回布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw <span class=\"keyword\">instanceof</span> Teacher)&#123;</span><br><span class=\"line\">    Teacher t = (Teacher) pw;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"转换会有异常\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>多态的使用场合：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过方法的参数传递形成多态。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Shape s)</span></span>&#123;&#125;</span><br><span class=\"line\">TestShape.draw(<span class=\"keyword\">new</span> Rect(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在方法体中直接使用多态的语法格式。</span></span><br><span class=\"line\">TestAbstrat ta = <span class=\"keyword\">new</span> SubTestAbstract();</span><br><span class=\"line\">ta.show();</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-抽象类\"><a href=\"#15-抽象类\" class=\"headerlink\" title=\"15. 抽象类\"></a>15. 抽象类</h3><ol>\n<li>基本概念<ul>\n<li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li>\n<li>抽象类不能实例化，抽象类的意义在于被继承。</li>\n<li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li>\n<li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span>&#123; <span class=\"comment\">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;<span class=\"comment\">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>注意：<ol>\n<li>抽象类中可以有成员变量，成员方法，以及构造方法。</li>\n<li>抽象类中可以没有抽象方法，也可以有抽象方法。</li>\n<li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li>\n<li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li>\n<li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>\n<li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p>\n</blockquote>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-接口\"><a href=\"#16-接口\" class=\"headerlink\" title=\"16. 接口\"></a>16. 接口</h3><ol>\n<li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runner</span> </span>&#123; <span class=\"comment\">//-通过interface关键字定义接口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SEF_SPEED=<span class=\"number\">100</span>;<span class=\"comment\">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;<span class=\"comment\">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">American</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runner</span>,... </span>&#123; <span class=\"comment\">//与继承不同，可以实现多个接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//该类需要实现接口中定义的所有方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"run...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runner ra = <span class=\"keyword\">new</span> American();<span class=\"comment\">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class=\"line\">        ra.run();<span class=\"comment\">//通过该变量可以调用该接口定义的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hunter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runner</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>类与接口的关系<ul>\n<li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li>\n<li>接口和接口使用<code>extends</code>继承，支持多继承。</li>\n<li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li>\n</ul>\n</li>\n<li>抽象类与接口的关系（笔试题）<ol>\n<li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li>\n<li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li>\n<li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li>\n<li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li>\n<li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li>\n<li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li>\n<li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id17\"><span></span></span></p>\n<h3 id=\"17-内部类\"><a href=\"#17-内部类\" class=\"headerlink\" title=\"17. 内部类\"></a>17. 内部类</h3><ul>\n<li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li>\n<li>内部类定义在 类的内部 ，与类成员层次一致</li>\n<li>内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul>\n<li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>匿名内部类：成员匿名内部类，局部匿名内部类</li>\n<li>静态内部类：成员静态内部类</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"17-1-成员内部类\"><a href=\"#17-1-成员内部类\" class=\"headerlink\" title=\"17.1 *成员内部类\"></a>17.1 *成员内部类</h4><ul>\n<li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li>\n<li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li>\n<li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li>\n<li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li>\n</ul>\n<h4 id=\"17-2-局部内部类\"><a href=\"#17-2-局部内部类\" class=\"headerlink\" title=\"17.2 局部内部类\"></a>17.2 局部内部类</h4><ul>\n<li>将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li>\n<li>只能用abstract或final</li>\n<li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li>\n<li>局部内部类使用的变量只能是final修饰</li>\n</ul>\n<h4 id=\"17-3-匿名内部类\"><a href=\"#17-3-匿名内部类\" class=\"headerlink\" title=\"17.3 *匿名内部类\"></a>17.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p>\n<ul>\n<li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol>\n<li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li>\n<li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubA</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这里自定义类实现接口并重写抽象方法！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ATest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(A a)</span> </span>&#123;</span><br><span class=\"line\">        a.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class=\"line\">        <span class=\"comment\">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class=\"line\">        ATest.test(<span class=\"keyword\">new</span> ASub());<span class=\"comment\">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//-方式2：匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class=\"line\">        A ta = <span class=\"keyword\">new</span> A() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"这里是匿名内部类\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ATest.test(ta);<span class=\"comment\">//得到接口类型的引用，再作为实参传递</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li>\n<li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SuperType obj = <span class=\"keyword\">new</span> SuperType(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-静态内部类\"><a href=\"#17-4-静态内部类\" class=\"headerlink\" title=\"17.4 静态内部类\"></a>17.4 静态内部类</h4><ul>\n<li>成员静态内部类</li>\n<li>不需要外部类对象，通过正常的方式直接创建内部类</li>\n<li>静态元素不能访问非静态成员(自己类和外部类)</li>\n</ul>\n<p><span id=\"id18\"><span></span></span></p>\n<h3 id=\"18-回调模式\"><a href=\"#18-回调模式\" class=\"headerlink\" title=\"18. 回调模式\"></a>18. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">repeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Action ac)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    repeat(<span class=\"number\">5</span>, <span class=\"keyword\">new</span> Action()&#123;<span class=\"comment\">//通过匿名内部类传递参数</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id19\"><span></span></span></p>\n<h3 id=\"19-抽象方法的笔试考点\"><a href=\"#19-抽象方法的笔试考点\" class=\"headerlink\" title=\"19. 抽象方法的笔试考点\"></a>19. 抽象方法的笔试考点</h3><ul>\n<li><code>abstract</code>与哪些关键字不能共存：<ol>\n<li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li>\n<li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li>\n<li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id20\"><span></span></span></p>\n<h3 id=\"20-枚举类（enum）\"><a href=\"#20-枚举类（enum）\" class=\"headerlink\" title=\"20. 枚举类（enum）\"></a>20. 枚举类（enum）</h3><ul>\n<li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li>\n<li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></li>\n<li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li>\n<li>Enum类型，有两个属性<ul>\n<li>name—–&gt;枚举对象的名字，name()获取name属性</li>\n<li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li>\n</ul>\n</li>\n<li>一些常用的方法<ul>\n<li>valueOf()   通过给定的name获取对应的枚举对象</li>\n<li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li>\n<li>compareTo()   可以比较两个枚举对象   int</li>\n<li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li>\n</ul>\n</li>\n<li>switch内部判断枚举的应用</li>\n<li>我们也可以在enum中描述自己的一些属性或方法<ul>\n<li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li>\n<li>可以定义自己的属性</li>\n<li>类创建的过程中  帮我们创建枚举类型的对象</li>\n<li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Day&#123;</span><br><span class=\"line\">    <span class=\"comment\">//描述了七个当前类的对象</span></span><br><span class=\"line\">    monday(<span class=\"string\">\"星期一\"</span>,<span class=\"number\">1</span>),tuesday(<span class=\"string\">\"星期二\"</span>,<span class=\"number\">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">(String  name,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index=index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id21\"><span></span></span></p>\n<h3 id=\"21-内存机制问题\"><a href=\"#21-内存机制问题\" class=\"headerlink\" title=\"21. 内存机制问题\"></a>21. 内存机制问题</h3><ul>\n<li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li>\n<li>栈内存—&gt;Person p = new Person();—-&gt;堆内存    方法区—类模板<ul>\n<li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li>\n<li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li>\n<li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li>\n</ul>\n</li>\n<li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul>\n<li>maxMemory</li>\n<li>totalMemory</li>\n<li>freeMemory</li>\n<li>栈内存溢出错误StackOverflowError </li>\n<li>堆内存溢出错误OutOfMemoryError</li>\n</ul>\n</li>\n<li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li>\n<li>GC系统提供的一个线程    回收算法</li>\n</ul>"},{"title":"三、JavaSE核心工具类","date":"2019-07-08T08:42:47.000Z","_content":"\n\nAPI (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。\n<!-- more -->\n\n1. [Object类与其常用方法](#id1)\n2. [包装类](#id2)\n3. [数学处理类](#id3)\n4. [Scanner类和System类](#id4)\n5. [日期类](#id5)\n6. [String类](#id6)\n7. [StringBuilder类/StringBuffer类](#id7)\n8. [Optional类](#id8)\n\n\n### 常用的包\n- java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类...\n- java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类...\n- java.io包：是输入输出包，包括读写各种设备。\n- java.net包：是网络编程的包，包括各种网络编程。\n- java.sql包：是操作数据库的所有类和接口。\n\n<span id=\"id1\"><span>\n### 1. Object类与其常用方法\n#### 1.1 Object类\n- java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。\n- Object定义了“对象”的基本行为，被子类默认继承。\n\n#### 1.2 equals() 和 hashCode()\n- boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。\n- equals()方法要求：自反性/对称性/传递性/一致性/非空性。\n- Java类可以根据需要重写继承自Object的equals()方法。\n\n> 注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n\n- int hashCode():返回对象的哈希码值，对应一个内存。\n- hashCode规范要求：\n    * 一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的\n    * 如果两个对象判定相等，它们的hashCode应该时同一个值\n    * 如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。\n\n- hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。\n\n#### 1.3 toString()\n- String toString()：用于获取调用对象的字符串形式，返回\"包名.类名@hashCode值的16进制\"。\n- Java类可以根据需要重写toString方法返回更有意义的信息。\n- Java在使用System.out.println()打印对象时或者`+`连接字符串时，默认调用toString()方法。\n\n<span id=\"id2\"><span>\n### 2. 包装类\n#### 2.1 包装类\n- 由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。\n- Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。\n\n|基本类型 |对应包装类         |\n|--------|------------------|\n|byte    |java.lang.Byte    |\n|short   |java.lang.Short   |\n|int     |java.lang.Integer |\n|long    |java.lang.Long    |\n|float   |java.lang.Float   |\n|double  |java.lang.Double  |\n|boolean |java.lang.Boolean |\n|char    |java.lang.Character|\n\n1. 八个包装类都在同一个包下（java.lang包），不需要import导包直接使用\n2. 八个包装类中有六个是与数字相关，都默认继承父类Number\n3. 八个包装类都实现了Serializable, Comparable\n4. 八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型\n5. 八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型\n\n#### 2.2 Integer类\n- java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。\n- Integer类重写了**equals()**方法（重写后比较的是数值）、hashCode()以及toString()方法。\n\n|Integer类的常用方法|                  |\n|-----------------|------------------|\n|Integer(int i)               |根据参数指定整数来构造对象|\n|Integer(String s)            |根据参数指定的字符串来构造对象|\n|int intValue()               |获取调用对象中整数值并返回|\n|static Integer valueOf(int i)|根据参数指定整数值得到Integer类型对象|\n|static int parseInt(String s)|将字符串类型转换为int类型并返回|\n\n#### 2.3 装箱和拆箱\n\n``` java\nint i = 100;\nInteger it = Integer.valueOf(i); //实现了int类型到Integer类型的转换，这个过程叫做装箱\nint ia = it.intValue();//实现了Integer类型到int类型的转换，这个过程叫做拆箱\n//jdk5增加了自动拆箱和装箱功能（编译器预处理）:\nInteger i = 100;//自动装箱\nint ia = i;//自动拆箱\n```\n\n- 笔试考点：\n> * 在Integer类部提供了自动装箱池技术，将**-128~127间的整数已经装箱完毕**，当使用该范围整数时直接取池中的对象即可，从而提高效率。\n> * Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。\n\n``` java\nInteger it1 = 128;\nInteger it2 = 128;\nInteger it3 = new Integer(128);\nInteger it4 = new Integer(128);\nSystem.out.println(it1.equals(it2));//比较内容 true\nSystem.out.println(it1 == it2);//比较地址 false\nSystem.out.println(it3.equals(it4));//比较内容 true\nSystem.out.println(it3 == it4);//比较地址 false\n\nInteger it5 = 127;\nInteger it6 = 127;\nInteger it7 = new Integer(127);\nInteger it8 = new Integer(127);\nSystem.out.println(it5.equals(it6));//比较内容 true\nSystem.out.println(it5 == it6);//比较地址 true, 自动装箱池范围-128~127。\nSystem.out.println(it7.equals(it8));//比较内容 true\nSystem.out.println(it7 == it8);//比较地址 false\n```\n\n<span id=\"id3\"><span>\n### 3. 数学处理类\n- java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。\n\n| 常用的方法             |返回值类型|  |\n|-----------------------|---------|---|\n|Math.abs()             |      |返回给定数字的绝对值(参数 int long float double)|\n|Math.ceil()            |double| 向上取整|\n|Math.floor()           |double| 向下取整|\n|Math.rint()            |double| 临近的整数 如果两边距离一样 则返回偶数|\n|Math.round()           |int   | 四舍五入的整数|\n|Math.max(a,b)/min(a,b) |      | (参数int  long  float  double)|\n|Math.pow(a,b)          |double| a的b次方  (参数double 返回值double)|\n|Math.sqrt(double a)    |      |获取给定参数的平方根|\n|Math.random()          |double|随机产生一个[0.0--1.0)|\n\n- 0-9之间的随机整数：int value = (int)**(Math.random()*10**);\n- Math.random()计算小数的时候精确程度可能有些损失\n\n#### 3.1 Random类\n- java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n\n| 常用的方法                |Random r = new Random();  |\n|--------------------------|--------|\n| r.nextInt();             |随机产生 int取值范围的整数 有正有负(`-2^31`\\~`2^31-1`即`正负21亿`之间)|\n| r.nextInt(int bound);    |随机产生一个[0--bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException|\n| r.nextFloat()            |随机产生一个 [0.0---1.0)|\n| r.nextBoolean()          |随机产生一个boolean值   true  false|\n\n#### 3.2 UUID类\n- java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n- 只有有参构造方法，我们通常不会创建对象\n- UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key\n- 产生一个32位的随机元素 每一个位置是一个16进制的数字\n\n#### 3.3 BigDecimal\n- java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number\n- Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。\n- 提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(\"1.23\");\n\n|BigDecimal类的常用方法|                  |\n|-----------------|------------------|\n|BigDecimal(String val)                       | 根据参数指定的字符串来构造对象|\n|BigDecimal    setScale(int newScale, RoundingMode roundingMode)|两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)|\n|BigDecimal **add**(BigDecimal augend)            | 用于实现**加法**运算 |\n|BigDecimal **subtract**(BigDecimal subtrahend)   | 用于实现**减法**运算 |\n|BigDecimal **multiply**(BigDecimal multiplicand) | 用于实现**乘法**运算 |\n|BigDecimal **divide**(BigDecimal divisor)        | 用于实现**除法**运算，也可传入更多参数设置保留小数点位数和取值模式 |\n\n``` java\nBigDecimal d3 = new BigDecimal(\"3.0\");\nBigDecimal d4 = new BigDecimal(\"2.9\");\nSystem.out.println(d3.add(d4));//加：5.9\nSystem.out.println(d3.subtract(d4));//减：0.1\nSystem.out.println(d3.multiply(d4));//乘：8.70\nSystem.out.println(d3.divide(d4, 8, BigDecimal.ROUND_HALF_UP));//除：1.03448276\n```\n\n对于divide方法，通常需要制定**精度和舍入模式**，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。\n\n#### 3.4 BigInteger\n- java.math.BigInteger类处理大整数，需要import导入，继承自Number\n- java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 \n- 如何创建对象，提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(\"123\");\n- 和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。\n\n#### 3.5 DecimalFormat类\n- 所属的包 java.text，import导入才能使用\n- 通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）\n\n``` java\n    //调用format方法将一个小数格式化成一个字符串\nDecimalFormat df = new DecimalFormat(\"000.000\");\nSystem.out.println(df.format(12.45)); //012.450\nSystem.out.println(df.format(12345.6789)); //12345.679\n\nDecimalFormat df2 = new DecimalFormat(\"###.###\");\nSystem.out.println(df2.format(12.45)); //12.45\nSystem.out.println(df2.format(12345.6789)); //12345.679\n\nDecimalFormat df3 = new DecimalFormat(\"000.###\");\nSystem.out.println(df3.format(12.45)); //012.45\nSystem.out.println(df3.format(12345.6789)); //12345.679    \n```\n\n\n<span id=\"id4\"><span>\n### 4. Scanner类和System类\n#### 4.1 Scanner类\n1. 所属的包java.util包  需要import导包\n2. 通过一个带输入流的构造方法创建对象\n3. 常用方法    nextInt()  nextFloat()   next()   nextLine()\n\n#### 4.1 System类\n1. 所属的包java.lang包 不需要导入\n2. 不需要创建对象  通过类名就可以访问\n3. 有三个属性及若干的方法\n    * 三个属性out   in   err\n    * 方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;\n\n\n<span id=\"id5\"><span>\n### 5. 日期类\n#### 5.1 Date类\n- java.util.Date类表示特定的瞬间，精确到毫秒。\n- 通常使用无参数的构造方法，或者带long构造方法\n- Date类中常用的方法\n    * before();  after();\n    * setTime()  getTime();----->long\n    * compareTo();   //-1  1  0\n- Date类大多数用于进行时间分量计算的方法已经被Calender取代。\n\n``` java\nDate date = new Date();//当前日期信息\n    //Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019\nlong time = date.getTime();//1970年1月1日距今毫秒数。\ndate.setTime(time + 24\\*60\\*60\\*1000);//通过毫秒数设置时间\n```\n\n#### 5.2 SimpleDateFormat类\n- java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类\n- 其构造方法 SimpleDateFormat(String pattern)\n\n``` java\nDate date = new Date();\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");\nString dateStr = sdf.format(date);\n// format用于将日期按指定格式转换为字符串\n\nString str = \"2013-01-06\";\nSimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date2 = sdf2.parse(str);//如果字符串格式不匹配将抛出异常\n```\n\n|常用格式字符串| 含义        |  示例  |\n|----------|------------|---------|\n|y|年      |yyyy年——2013年；yy——13年 |\n|M|月      |MM月——01月；M月——1月|\n|d|日      |dd日——01日；d日——1日|\n|H|小时(24)|HH:mm:ss—12:46:33|\n|h|小时(12)|hh(a):mm:ss—12(下午):47:48|\n|m|分钟    |--|\n|s|秒      |--|\n\n#### 5.3 Calendar类\n- java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。\n- 有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();\n- 通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现\n\n``` java\nCalendar c1 = Calendar.getInstance();\nc1.set(2008,9-1,20,8,8,8);\nSystem.out.println(c1.getTime());\n```\n\n- 常用方法\n    * after()  before()\n    * setTime()  getTime()---->Date\n    * getTimeInMillis()----time\n    * getTimeZone()---TimeZone\n    * Calendar里面包含一个date属性  可以操作date的某一个局部信息\n    * set   get\n        * calendar.set(Calendar.YEAR,2015);\n        *int year = calendar.get(Calendar.YEAR);\n\n- TimeZone\n    1. java.util包\n    2. 可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();\n    3. 常用方法\n        - tz.getID()       ---->    Asia/Shanghai\n        - tz.getDisplayName()    ---->  中国标准时间\n\n\n<span id=\"id6\"><span>\n### 6. String类\n#### 6.1 基本概念\n- String类 ---> 引用类型  ---> java.lang包\n- 没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<String>\n- java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如\"abc\"等，任何一个字符对应2字节定长编码。\n- String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。\n\n``` java\n//如何构建对象\nString str1 = \"abc\"; //直接将字符串常量赋值给str   (字符串常量池)\nString str2 = new String();//无参数构造方法创建空的对象\nString str3 = new String(\"abc\");//带string参数的构造方法创建对象\nbyte[] bArr = {97, 98, 99, 100, 101};//a:97，b:98，c:99，d:100\nString str4 = new String(bArr);//将数组中的每一个元素转化成对应的char 组合成String\nchar[] cArr = {'h', 'e', 'l', 'l', 'o'};\nString str5 = new String(cArr);//将数组中的每一个char元素拼接成最终的String\nString str6 = String(char[], index, count);//使用char数组中下标从index位置开始的count个字符来构造对象\nString str7 = String(byte[], index, length);//使用byte数组下标从index位置开始length个字节来构造对象\n```\n\n\n#### 6.2 字符串常量池\n- 由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。\n- 出于性能考虑，Java虚拟机(JVM)将**字符串字面量对象**缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。\n\n``` java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\nString str3 = new String(\"Hello\");\nSystem.out.println(str1.equals(str2));//比较内容 true\nSystem.out.println(str1==str2);//比较地址 true，不会重新创建\nSystem.out.println(str1.equals(str3));//比较内容 true\nSystem.out.println(str1==str3);//比较地址 false，使用new会重新创建新的String对象\n    //1.下面的代码中创建了几个对象并分别存放在什么位置？\nString s1 = \"hello\"; //1个对象，常量池。\nString s2 = new String(\"world\"); //2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)\n```\n\n#### 6.3 String类常用方法\n1. 第一梯队(重写): equals  hashCode  compareTo  toString\n2. 第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。\n3. 第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。\n\n- 重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口\n    1. boolean = equals(Object obj);\n        - 继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;\n    2. int = hashCode();\n        - 继承自Object类中的方法，重写了：31*h+和...\n    3. int = compareTo();\n        - 实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差\n    4. String = toString()\n        - Object类中返回类名@hashCode(16进制形式)\n        - String类重写后返回的是String对象的字面值\n\n>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();\n\n|String类的成员方法         |                  |\n|--------------------------|------------------|\n|char charAt(int index)    |返回字符串指定位置|\n|int codePointAt(int index)|\"abc\"0-->97，返回给定index对应位置的那个char所对应的code码|\n|String concat(String)     |将给定的字符串拼接在当前字符串之后|\n|int length()              |返回字符串序列的长度|\n> 注意：区别数组的length是属性，String的length()是方法，集合是size()方法\n\n``` java\nString str6 = new String(\"hello\");\nSystem.out.println(\"下标为0的字符是：\"+str6.charAt(0));// h\nSystem.out.println(\"字符串长度是：\"+str6.length());// 5\n\n    //将字符串\"12345\"转换为整数类型\nString str = new String(\"123456\");\n    //方式一：Integer类中的pareseInt方法\nint ia = Integer.parseInt(str);\nSystem.out.println(\"转换出来结果是：\"+ ia);//123456\n    //方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...\nint res = 0;\nfor(int i=0; i<str.length(); i++){\n    res = res*10 + (str.charAt(i)-'0');\n}\nSystem.out.println(\"转换出来结果是：\"+ res);//123456\n```\n\n|String类的常用基本方法|               |\n|-----------------|------------------|\n|boolean contains(CharSequence s)|判断当前字符串是否包含参数指定的内容|\n|String toLowerCase()|返回小写形式|\n|String toUpperCase()|返回大写形式|\n|String trim()|返回去掉前后空格的字符串|\n|boolean startsWith(String prefix)|判断是否以参数字符开头|\n|boolean endsWith(String suffix)|判断是否以参数字符结尾|\n|boolean equals(Object anObject)|比较字符串内容是否相等，String类已重写|\n|boolean equalsIgnoreCase(String anotherString)|同上，并且忽略大小写|\n|int indexOf(String str)|返回第一次出现str位置，找不到返回-1|\n|int indexOf(String str, int fromIndex)|同上，从fromIndex开始检索|\n|String substring(int beginIndex, int endIndex)|截取字符串，beginIndex开始，endIndex结束|\n|String substring(int beginIndex)|截取字符串，beginIndex开始到结尾|\n\n#### 6.4 正则相关方法\n- 正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。\n\n|正则相关方法|                  |\n|-----------------|------------------|\n|boolean matches(String regex)|用于判断是否匹配正则表达式规则。|\n|String[] split(String regx)|以正则为分割符，将字符串拆分成字符串数组|\n|String replaceAll(String regex, String replacement)|正则替换|\n\n\n<span id=\"id7\"><span>\n### 7. StringBuilder类/StringBuffer类\n#### 7.1 基本概念\n1. java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。\n2. StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable\n    - StringBuffer/StringBuilder没有compareTo方法\n    - StringBuffer/StringBuilder含有一个String没有的方法 append();拼接\n\n#### 7.2 特性\n可变字符串，char[] value;  动态扩容\n#### 7.3 对象的构建\n\n``` java\n    //无参数构造方法  构建一个默认长度16个空间的对象  char[]\nStringBuilder builder = new StringBuilder();\n    //利用给定的参数 构建一个自定义长度空间的对象 char[]\nStringBuilder builder = new StringBuilder(20);\n    //利用带String参数的构造方法  默认数组长度字符串长度+16个\nStringBuilder builder = new StringBuilder(\"abc\");\n```\n\n\n#### 7.4 StringBuilder中常用的方法\n- 最主要的方法 **append()** 频繁的拼接字符串的时候使用此方法 提高性能\n- ensureCapacity(int minimumCapacity)  确保底层数组容量够用\n- capacity();//字符串底层char[]的容量\n- length();//字符串有效元素个数(长度)\n- setLength();//设置字符串的有效元素个数\n- char = charAt(int index);\n- int = codePointAt(int index);\n- String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果\n- StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦\n- StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦\n- int = indexOf(String str [,int fromIndex]);\n- int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找\n- insert(int index,value);//将给定的value插入在index位置之上\n- replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,\"zzt\");\n- setCharAt(int index,char value);//将index位置的字符改成给定的value\n- toString();//将StringBuilder对象 构建成一个string对象 返回\n- trimToSize();//将数组中无用的容量去掉  变成length长度的数组\n\n#### 7.5 总结\n1. StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；\n2. 常用方法\n    * 与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；\n    * 与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致\n    * 不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();\n7. String家族笔试中经常容易考察的知识点\n1. String所属的包 继承关系 实现接口\n    * java.lang 继承Object 接口Serializable,CharSequence,Comparable\n2. String构建方式\n    * 常量  构造方法  \n3. String对象内存结构\n    * 字符串常量区  new堆内存对象\n    * ==  equals()区别\n    * \"a\"+\"b\"+\"c\"\n4. String不可变特性\n    * 长度及内容\n5. String中的常用方法\n    * concat();  toUpperCase();\n6. String和StringBuilder区别   |   String和StringBuffer区别\n    * String不可变字符串\n        - JDK1.0\n        - 有一个接口Comparable\n        - 不可变体现在长度及内容\n        - 有一些方法StringBuilder没有 concat  compareTo  toUpperCase\n    * StringBuilder可变字符串\n        - JDK1.5\n        - 有一个接口Appendable\n        - 可变字符串  没有final修饰  底层可以进行数组扩容\n        - 有一些方法String没有  append() insert() delete() reverse()\n7. StringBuffer和StringBuilder的不同\n    * 它们方法基本相同\n    * StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低\n    * StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高\n\n\n<span id=\"id8\"><span>\n### 8. Optional类\n- 可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。\n- 获取字符串长度：\n  1. 方式1：if(null==str){return 0;}else{return str.length();}\n  2. 方式2：return Optional.ofNullable(str).map(String::length).orElse(0);\n\n``` java\n// 获取两个字符串长度和\nString str1 = \"zhangsan\";\nString str2 = null;\nint str1Length = Optional.ofNullable(str1).map(String::length).orElse(0);\nint str2Length = Optional.ofNullable(str2).map(String::length).orElse(0);\nSystem.out.println(str1Length + str2Length);//8，8+0\n//步骤分解:\n//构建Optional对象\nOptional<String> op1 = Optional.ofNullable(str1);\n//将str1的长度的结果构建成Optional对象\nOptional<Integer> op2 = op1.map(String::length);\n//如果长度不为空，则获取长度值，否则返回默认值\nint len = op2.orElse(0);\nSystem.out.println(len);//8\n```\n\n","source":"_posts/03_JavaSE核心工具类.md","raw":"---\ntitle: 三、JavaSE核心工具类\ndate: 2019-07-08 16:42:47\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\nAPI (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。\n<!-- more -->\n\n1. [Object类与其常用方法](#id1)\n2. [包装类](#id2)\n3. [数学处理类](#id3)\n4. [Scanner类和System类](#id4)\n5. [日期类](#id5)\n6. [String类](#id6)\n7. [StringBuilder类/StringBuffer类](#id7)\n8. [Optional类](#id8)\n\n\n### 常用的包\n- java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类...\n- java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类...\n- java.io包：是输入输出包，包括读写各种设备。\n- java.net包：是网络编程的包，包括各种网络编程。\n- java.sql包：是操作数据库的所有类和接口。\n\n<span id=\"id1\"><span>\n### 1. Object类与其常用方法\n#### 1.1 Object类\n- java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。\n- Object定义了“对象”的基本行为，被子类默认继承。\n\n#### 1.2 equals() 和 hashCode()\n- boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。\n- equals()方法要求：自反性/对称性/传递性/一致性/非空性。\n- Java类可以根据需要重写继承自Object的equals()方法。\n\n> 注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n\n- int hashCode():返回对象的哈希码值，对应一个内存。\n- hashCode规范要求：\n    * 一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的\n    * 如果两个对象判定相等，它们的hashCode应该时同一个值\n    * 如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。\n\n- hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。\n\n#### 1.3 toString()\n- String toString()：用于获取调用对象的字符串形式，返回\"包名.类名@hashCode值的16进制\"。\n- Java类可以根据需要重写toString方法返回更有意义的信息。\n- Java在使用System.out.println()打印对象时或者`+`连接字符串时，默认调用toString()方法。\n\n<span id=\"id2\"><span>\n### 2. 包装类\n#### 2.1 包装类\n- 由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。\n- Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。\n\n|基本类型 |对应包装类         |\n|--------|------------------|\n|byte    |java.lang.Byte    |\n|short   |java.lang.Short   |\n|int     |java.lang.Integer |\n|long    |java.lang.Long    |\n|float   |java.lang.Float   |\n|double  |java.lang.Double  |\n|boolean |java.lang.Boolean |\n|char    |java.lang.Character|\n\n1. 八个包装类都在同一个包下（java.lang包），不需要import导包直接使用\n2. 八个包装类中有六个是与数字相关，都默认继承父类Number\n3. 八个包装类都实现了Serializable, Comparable\n4. 八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型\n5. 八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型\n\n#### 2.2 Integer类\n- java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。\n- Integer类重写了**equals()**方法（重写后比较的是数值）、hashCode()以及toString()方法。\n\n|Integer类的常用方法|                  |\n|-----------------|------------------|\n|Integer(int i)               |根据参数指定整数来构造对象|\n|Integer(String s)            |根据参数指定的字符串来构造对象|\n|int intValue()               |获取调用对象中整数值并返回|\n|static Integer valueOf(int i)|根据参数指定整数值得到Integer类型对象|\n|static int parseInt(String s)|将字符串类型转换为int类型并返回|\n\n#### 2.3 装箱和拆箱\n\n``` java\nint i = 100;\nInteger it = Integer.valueOf(i); //实现了int类型到Integer类型的转换，这个过程叫做装箱\nint ia = it.intValue();//实现了Integer类型到int类型的转换，这个过程叫做拆箱\n//jdk5增加了自动拆箱和装箱功能（编译器预处理）:\nInteger i = 100;//自动装箱\nint ia = i;//自动拆箱\n```\n\n- 笔试考点：\n> * 在Integer类部提供了自动装箱池技术，将**-128~127间的整数已经装箱完毕**，当使用该范围整数时直接取池中的对象即可，从而提高效率。\n> * Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。\n\n``` java\nInteger it1 = 128;\nInteger it2 = 128;\nInteger it3 = new Integer(128);\nInteger it4 = new Integer(128);\nSystem.out.println(it1.equals(it2));//比较内容 true\nSystem.out.println(it1 == it2);//比较地址 false\nSystem.out.println(it3.equals(it4));//比较内容 true\nSystem.out.println(it3 == it4);//比较地址 false\n\nInteger it5 = 127;\nInteger it6 = 127;\nInteger it7 = new Integer(127);\nInteger it8 = new Integer(127);\nSystem.out.println(it5.equals(it6));//比较内容 true\nSystem.out.println(it5 == it6);//比较地址 true, 自动装箱池范围-128~127。\nSystem.out.println(it7.equals(it8));//比较内容 true\nSystem.out.println(it7 == it8);//比较地址 false\n```\n\n<span id=\"id3\"><span>\n### 3. 数学处理类\n- java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。\n\n| 常用的方法             |返回值类型|  |\n|-----------------------|---------|---|\n|Math.abs()             |      |返回给定数字的绝对值(参数 int long float double)|\n|Math.ceil()            |double| 向上取整|\n|Math.floor()           |double| 向下取整|\n|Math.rint()            |double| 临近的整数 如果两边距离一样 则返回偶数|\n|Math.round()           |int   | 四舍五入的整数|\n|Math.max(a,b)/min(a,b) |      | (参数int  long  float  double)|\n|Math.pow(a,b)          |double| a的b次方  (参数double 返回值double)|\n|Math.sqrt(double a)    |      |获取给定参数的平方根|\n|Math.random()          |double|随机产生一个[0.0--1.0)|\n\n- 0-9之间的随机整数：int value = (int)**(Math.random()*10**);\n- Math.random()计算小数的时候精确程度可能有些损失\n\n#### 3.1 Random类\n- java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n\n| 常用的方法                |Random r = new Random();  |\n|--------------------------|--------|\n| r.nextInt();             |随机产生 int取值范围的整数 有正有负(`-2^31`\\~`2^31-1`即`正负21亿`之间)|\n| r.nextInt(int bound);    |随机产生一个[0--bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException|\n| r.nextFloat()            |随机产生一个 [0.0---1.0)|\n| r.nextBoolean()          |随机产生一个boolean值   true  false|\n\n#### 3.2 UUID类\n- java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n- 只有有参构造方法，我们通常不会创建对象\n- UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key\n- 产生一个32位的随机元素 每一个位置是一个16进制的数字\n\n#### 3.3 BigDecimal\n- java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number\n- Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。\n- 提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(\"1.23\");\n\n|BigDecimal类的常用方法|                  |\n|-----------------|------------------|\n|BigDecimal(String val)                       | 根据参数指定的字符串来构造对象|\n|BigDecimal    setScale(int newScale, RoundingMode roundingMode)|两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)|\n|BigDecimal **add**(BigDecimal augend)            | 用于实现**加法**运算 |\n|BigDecimal **subtract**(BigDecimal subtrahend)   | 用于实现**减法**运算 |\n|BigDecimal **multiply**(BigDecimal multiplicand) | 用于实现**乘法**运算 |\n|BigDecimal **divide**(BigDecimal divisor)        | 用于实现**除法**运算，也可传入更多参数设置保留小数点位数和取值模式 |\n\n``` java\nBigDecimal d3 = new BigDecimal(\"3.0\");\nBigDecimal d4 = new BigDecimal(\"2.9\");\nSystem.out.println(d3.add(d4));//加：5.9\nSystem.out.println(d3.subtract(d4));//减：0.1\nSystem.out.println(d3.multiply(d4));//乘：8.70\nSystem.out.println(d3.divide(d4, 8, BigDecimal.ROUND_HALF_UP));//除：1.03448276\n```\n\n对于divide方法，通常需要制定**精度和舍入模式**，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。\n\n#### 3.4 BigInteger\n- java.math.BigInteger类处理大整数，需要import导入，继承自Number\n- java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 \n- 如何创建对象，提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(\"123\");\n- 和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。\n\n#### 3.5 DecimalFormat类\n- 所属的包 java.text，import导入才能使用\n- 通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）\n\n``` java\n    //调用format方法将一个小数格式化成一个字符串\nDecimalFormat df = new DecimalFormat(\"000.000\");\nSystem.out.println(df.format(12.45)); //012.450\nSystem.out.println(df.format(12345.6789)); //12345.679\n\nDecimalFormat df2 = new DecimalFormat(\"###.###\");\nSystem.out.println(df2.format(12.45)); //12.45\nSystem.out.println(df2.format(12345.6789)); //12345.679\n\nDecimalFormat df3 = new DecimalFormat(\"000.###\");\nSystem.out.println(df3.format(12.45)); //012.45\nSystem.out.println(df3.format(12345.6789)); //12345.679    \n```\n\n\n<span id=\"id4\"><span>\n### 4. Scanner类和System类\n#### 4.1 Scanner类\n1. 所属的包java.util包  需要import导包\n2. 通过一个带输入流的构造方法创建对象\n3. 常用方法    nextInt()  nextFloat()   next()   nextLine()\n\n#### 4.1 System类\n1. 所属的包java.lang包 不需要导入\n2. 不需要创建对象  通过类名就可以访问\n3. 有三个属性及若干的方法\n    * 三个属性out   in   err\n    * 方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;\n\n\n<span id=\"id5\"><span>\n### 5. 日期类\n#### 5.1 Date类\n- java.util.Date类表示特定的瞬间，精确到毫秒。\n- 通常使用无参数的构造方法，或者带long构造方法\n- Date类中常用的方法\n    * before();  after();\n    * setTime()  getTime();----->long\n    * compareTo();   //-1  1  0\n- Date类大多数用于进行时间分量计算的方法已经被Calender取代。\n\n``` java\nDate date = new Date();//当前日期信息\n    //Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019\nlong time = date.getTime();//1970年1月1日距今毫秒数。\ndate.setTime(time + 24\\*60\\*60\\*1000);//通过毫秒数设置时间\n```\n\n#### 5.2 SimpleDateFormat类\n- java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类\n- 其构造方法 SimpleDateFormat(String pattern)\n\n``` java\nDate date = new Date();\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");\nString dateStr = sdf.format(date);\n// format用于将日期按指定格式转换为字符串\n\nString str = \"2013-01-06\";\nSimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date2 = sdf2.parse(str);//如果字符串格式不匹配将抛出异常\n```\n\n|常用格式字符串| 含义        |  示例  |\n|----------|------------|---------|\n|y|年      |yyyy年——2013年；yy——13年 |\n|M|月      |MM月——01月；M月——1月|\n|d|日      |dd日——01日；d日——1日|\n|H|小时(24)|HH:mm:ss—12:46:33|\n|h|小时(12)|hh(a):mm:ss—12(下午):47:48|\n|m|分钟    |--|\n|s|秒      |--|\n\n#### 5.3 Calendar类\n- java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。\n- 有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();\n- 通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现\n\n``` java\nCalendar c1 = Calendar.getInstance();\nc1.set(2008,9-1,20,8,8,8);\nSystem.out.println(c1.getTime());\n```\n\n- 常用方法\n    * after()  before()\n    * setTime()  getTime()---->Date\n    * getTimeInMillis()----time\n    * getTimeZone()---TimeZone\n    * Calendar里面包含一个date属性  可以操作date的某一个局部信息\n    * set   get\n        * calendar.set(Calendar.YEAR,2015);\n        *int year = calendar.get(Calendar.YEAR);\n\n- TimeZone\n    1. java.util包\n    2. 可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();\n    3. 常用方法\n        - tz.getID()       ---->    Asia/Shanghai\n        - tz.getDisplayName()    ---->  中国标准时间\n\n\n<span id=\"id6\"><span>\n### 6. String类\n#### 6.1 基本概念\n- String类 ---> 引用类型  ---> java.lang包\n- 没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<String>\n- java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如\"abc\"等，任何一个字符对应2字节定长编码。\n- String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。\n\n``` java\n//如何构建对象\nString str1 = \"abc\"; //直接将字符串常量赋值给str   (字符串常量池)\nString str2 = new String();//无参数构造方法创建空的对象\nString str3 = new String(\"abc\");//带string参数的构造方法创建对象\nbyte[] bArr = {97, 98, 99, 100, 101};//a:97，b:98，c:99，d:100\nString str4 = new String(bArr);//将数组中的每一个元素转化成对应的char 组合成String\nchar[] cArr = {'h', 'e', 'l', 'l', 'o'};\nString str5 = new String(cArr);//将数组中的每一个char元素拼接成最终的String\nString str6 = String(char[], index, count);//使用char数组中下标从index位置开始的count个字符来构造对象\nString str7 = String(byte[], index, length);//使用byte数组下标从index位置开始length个字节来构造对象\n```\n\n\n#### 6.2 字符串常量池\n- 由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。\n- 出于性能考虑，Java虚拟机(JVM)将**字符串字面量对象**缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。\n\n``` java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\nString str3 = new String(\"Hello\");\nSystem.out.println(str1.equals(str2));//比较内容 true\nSystem.out.println(str1==str2);//比较地址 true，不会重新创建\nSystem.out.println(str1.equals(str3));//比较内容 true\nSystem.out.println(str1==str3);//比较地址 false，使用new会重新创建新的String对象\n    //1.下面的代码中创建了几个对象并分别存放在什么位置？\nString s1 = \"hello\"; //1个对象，常量池。\nString s2 = new String(\"world\"); //2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)\n```\n\n#### 6.3 String类常用方法\n1. 第一梯队(重写): equals  hashCode  compareTo  toString\n2. 第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。\n3. 第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。\n\n- 重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口\n    1. boolean = equals(Object obj);\n        - 继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;\n    2. int = hashCode();\n        - 继承自Object类中的方法，重写了：31*h+和...\n    3. int = compareTo();\n        - 实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差\n    4. String = toString()\n        - Object类中返回类名@hashCode(16进制形式)\n        - String类重写后返回的是String对象的字面值\n\n>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();\n\n|String类的成员方法         |                  |\n|--------------------------|------------------|\n|char charAt(int index)    |返回字符串指定位置|\n|int codePointAt(int index)|\"abc\"0-->97，返回给定index对应位置的那个char所对应的code码|\n|String concat(String)     |将给定的字符串拼接在当前字符串之后|\n|int length()              |返回字符串序列的长度|\n> 注意：区别数组的length是属性，String的length()是方法，集合是size()方法\n\n``` java\nString str6 = new String(\"hello\");\nSystem.out.println(\"下标为0的字符是：\"+str6.charAt(0));// h\nSystem.out.println(\"字符串长度是：\"+str6.length());// 5\n\n    //将字符串\"12345\"转换为整数类型\nString str = new String(\"123456\");\n    //方式一：Integer类中的pareseInt方法\nint ia = Integer.parseInt(str);\nSystem.out.println(\"转换出来结果是：\"+ ia);//123456\n    //方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...\nint res = 0;\nfor(int i=0; i<str.length(); i++){\n    res = res*10 + (str.charAt(i)-'0');\n}\nSystem.out.println(\"转换出来结果是：\"+ res);//123456\n```\n\n|String类的常用基本方法|               |\n|-----------------|------------------|\n|boolean contains(CharSequence s)|判断当前字符串是否包含参数指定的内容|\n|String toLowerCase()|返回小写形式|\n|String toUpperCase()|返回大写形式|\n|String trim()|返回去掉前后空格的字符串|\n|boolean startsWith(String prefix)|判断是否以参数字符开头|\n|boolean endsWith(String suffix)|判断是否以参数字符结尾|\n|boolean equals(Object anObject)|比较字符串内容是否相等，String类已重写|\n|boolean equalsIgnoreCase(String anotherString)|同上，并且忽略大小写|\n|int indexOf(String str)|返回第一次出现str位置，找不到返回-1|\n|int indexOf(String str, int fromIndex)|同上，从fromIndex开始检索|\n|String substring(int beginIndex, int endIndex)|截取字符串，beginIndex开始，endIndex结束|\n|String substring(int beginIndex)|截取字符串，beginIndex开始到结尾|\n\n#### 6.4 正则相关方法\n- 正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。\n\n|正则相关方法|                  |\n|-----------------|------------------|\n|boolean matches(String regex)|用于判断是否匹配正则表达式规则。|\n|String[] split(String regx)|以正则为分割符，将字符串拆分成字符串数组|\n|String replaceAll(String regex, String replacement)|正则替换|\n\n\n<span id=\"id7\"><span>\n### 7. StringBuilder类/StringBuffer类\n#### 7.1 基本概念\n1. java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。\n2. StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable\n    - StringBuffer/StringBuilder没有compareTo方法\n    - StringBuffer/StringBuilder含有一个String没有的方法 append();拼接\n\n#### 7.2 特性\n可变字符串，char[] value;  动态扩容\n#### 7.3 对象的构建\n\n``` java\n    //无参数构造方法  构建一个默认长度16个空间的对象  char[]\nStringBuilder builder = new StringBuilder();\n    //利用给定的参数 构建一个自定义长度空间的对象 char[]\nStringBuilder builder = new StringBuilder(20);\n    //利用带String参数的构造方法  默认数组长度字符串长度+16个\nStringBuilder builder = new StringBuilder(\"abc\");\n```\n\n\n#### 7.4 StringBuilder中常用的方法\n- 最主要的方法 **append()** 频繁的拼接字符串的时候使用此方法 提高性能\n- ensureCapacity(int minimumCapacity)  确保底层数组容量够用\n- capacity();//字符串底层char[]的容量\n- length();//字符串有效元素个数(长度)\n- setLength();//设置字符串的有效元素个数\n- char = charAt(int index);\n- int = codePointAt(int index);\n- String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果\n- StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦\n- StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦\n- int = indexOf(String str [,int fromIndex]);\n- int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找\n- insert(int index,value);//将给定的value插入在index位置之上\n- replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,\"zzt\");\n- setCharAt(int index,char value);//将index位置的字符改成给定的value\n- toString();//将StringBuilder对象 构建成一个string对象 返回\n- trimToSize();//将数组中无用的容量去掉  变成length长度的数组\n\n#### 7.5 总结\n1. StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；\n2. 常用方法\n    * 与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；\n    * 与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致\n    * 不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();\n7. String家族笔试中经常容易考察的知识点\n1. String所属的包 继承关系 实现接口\n    * java.lang 继承Object 接口Serializable,CharSequence,Comparable\n2. String构建方式\n    * 常量  构造方法  \n3. String对象内存结构\n    * 字符串常量区  new堆内存对象\n    * ==  equals()区别\n    * \"a\"+\"b\"+\"c\"\n4. String不可变特性\n    * 长度及内容\n5. String中的常用方法\n    * concat();  toUpperCase();\n6. String和StringBuilder区别   |   String和StringBuffer区别\n    * String不可变字符串\n        - JDK1.0\n        - 有一个接口Comparable\n        - 不可变体现在长度及内容\n        - 有一些方法StringBuilder没有 concat  compareTo  toUpperCase\n    * StringBuilder可变字符串\n        - JDK1.5\n        - 有一个接口Appendable\n        - 可变字符串  没有final修饰  底层可以进行数组扩容\n        - 有一些方法String没有  append() insert() delete() reverse()\n7. StringBuffer和StringBuilder的不同\n    * 它们方法基本相同\n    * StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低\n    * StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高\n\n\n<span id=\"id8\"><span>\n### 8. Optional类\n- 可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。\n- 获取字符串长度：\n  1. 方式1：if(null==str){return 0;}else{return str.length();}\n  2. 方式2：return Optional.ofNullable(str).map(String::length).orElse(0);\n\n``` java\n// 获取两个字符串长度和\nString str1 = \"zhangsan\";\nString str2 = null;\nint str1Length = Optional.ofNullable(str1).map(String::length).orElse(0);\nint str2Length = Optional.ofNullable(str2).map(String::length).orElse(0);\nSystem.out.println(str1Length + str2Length);//8，8+0\n//步骤分解:\n//构建Optional对象\nOptional<String> op1 = Optional.ofNullable(str1);\n//将str1的长度的结果构建成Optional对象\nOptional<Integer> op2 = op1.map(String::length);\n//如果长度不为空，则获取长度值，否则返回默认值\nint len = op2.orElse(0);\nSystem.out.println(len);//8\n```\n\n","slug":"03_JavaSE核心工具类","published":1,"updated":"2019-07-20T14:46:02.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylobl003uyot3f7k4uqlg","content":"<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Object类与其常用方法</a></li>\n<li><a href=\"#id2\">包装类</a></li>\n<li><a href=\"#id3\">数学处理类</a></li>\n<li><a href=\"#id4\">Scanner类和System类</a></li>\n<li><a href=\"#id5\">日期类</a></li>\n<li><a href=\"#id6\">String类</a></li>\n<li><a href=\"#id7\">StringBuilder类/StringBuffer类</a></li>\n<li><a href=\"#id8\">Optional类</a></li>\n</ol>\n<h3 id=\"常用的包\"><a href=\"#常用的包\" class=\"headerlink\" title=\"常用的包\"></a>常用的包</h3><ul>\n<li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li>\n<li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li>\n<li>java.io包：是输入输出包，包括读写各种设备。</li>\n<li>java.net包：是网络编程的包，包括各种网络编程。</li>\n<li>java.sql包：是操作数据库的所有类和接口。</li>\n</ul>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Object类与其常用方法\"><a href=\"#1-Object类与其常用方法\" class=\"headerlink\" title=\"1. Object类与其常用方法\"></a>1. Object类与其常用方法</h3><h4 id=\"1-1-Object类\"><a href=\"#1-1-Object类\" class=\"headerlink\" title=\"1.1 Object类\"></a>1.1 Object类</h4><ul>\n<li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li>\n<li>Object定义了“对象”的基本行为，被子类默认继承。</li>\n</ul>\n<h4 id=\"1-2-equals-和-hashCode\"><a href=\"#1-2-equals-和-hashCode\" class=\"headerlink\" title=\"1.2 equals() 和 hashCode()\"></a>1.2 equals() 和 hashCode()</h4><ul>\n<li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li>\n<li>equals()方法要求：自反性/对称性/传递性/一致性/非空性。</li>\n<li>Java类可以根据需要重写继承自Object的equals()方法。</li>\n</ul>\n<blockquote>\n<p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n</blockquote>\n<ul>\n<li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p>\n</li>\n<li><p>hashCode规范要求：</p>\n<ul>\n<li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li>\n<li>如果两个对象判定相等，它们的hashCode应该时同一个值</li>\n<li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li>\n</ul>\n</li>\n<li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p>\n</li>\n</ul>\n<h4 id=\"1-3-toString\"><a href=\"#1-3-toString\" class=\"headerlink\" title=\"1.3 toString()\"></a>1.3 toString()</h4><ul>\n<li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li>\n<li>Java类可以根据需要重写toString方法返回更有意义的信息。</li>\n<li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-包装类\"><a href=\"#2-包装类\" class=\"headerlink\" title=\"2. 包装类\"></a>2. 包装类</h3><h4 id=\"2-1-包装类\"><a href=\"#2-1-包装类\" class=\"headerlink\" title=\"2.1 包装类\"></a>2.1 包装类</h4><ul>\n<li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li>\n<li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>对应包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>java.lang.Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>java.lang.Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>java.lang.Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>java.lang.Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>java.lang.Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>java.lang.Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>java.lang.Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>java.lang.Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li>\n<li>八个包装类中有六个是与数字相关，都默认继承父类Number</li>\n<li>八个包装类都实现了Serializable, Comparable</li>\n<li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li>\n<li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li>\n</ol>\n<h4 id=\"2-2-Integer类\"><a href=\"#2-2-Integer类\" class=\"headerlink\" title=\"2.2 Integer类\"></a>2.2 Integer类</h4><ul>\n<li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li>\n<li>Integer类重写了<strong>equals()</strong>方法（重写后比较的是数值）、hashCode()以及toString()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Integer类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Integer(int i)</td>\n<td>根据参数指定整数来构造对象</td>\n</tr>\n<tr>\n<td>Integer(String s)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>int intValue()</td>\n<td>获取调用对象中整数值并返回</td>\n</tr>\n<tr>\n<td>static Integer valueOf(int i)</td>\n<td>根据参数指定整数值得到Integer类型对象</td>\n</tr>\n<tr>\n<td>static int parseInt(String s)</td>\n<td>将字符串类型转换为int类型并返回</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-装箱和拆箱\"><a href=\"#2-3-装箱和拆箱\" class=\"headerlink\" title=\"2.3 装箱和拆箱\"></a>2.3 装箱和拆箱</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer it = Integer.valueOf(i); <span class=\"comment\">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = it.intValue();<span class=\"comment\">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class=\"line\">Integer i = <span class=\"number\">100</span>;<span class=\"comment\">//自动装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = i;<span class=\"comment\">//自动拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>笔试考点：<blockquote>\n<ul>\n<li>在Integer类部提供了自动装箱池技术，将<strong>-128~127间的整数已经装箱完毕</strong>，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li>\n<li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer it1 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it2 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it3 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">Integer it4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">System.out.println(it1.equals(it2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it1 == it2);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\">System.out.println(it3.equals(it4));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it3 == it4);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Integer it5 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it6 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it7 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">Integer it8 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">System.out.println(it5.equals(it6));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it5 == it6);<span class=\"comment\">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class=\"line\">System.out.println(it7.equals(it8));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it7 == it8);<span class=\"comment\">//比较地址 false</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数学处理类\"><a href=\"#3-数学处理类\" class=\"headerlink\" title=\"3. 数学处理类\"></a>3. 数学处理类</h3><ul>\n<li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>返回值类型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs()</td>\n<td></td>\n<td>返回给定数字的绝对值(参数 int long float double)</td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td>double</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td>double</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>Math.rint()</td>\n<td>double</td>\n<td>临近的整数 如果两边距离一样 则返回偶数</td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>int</td>\n<td>四舍五入的整数</td>\n</tr>\n<tr>\n<td>Math.max(a,b)/min(a,b)</td>\n<td></td>\n<td>(参数int  long  float  double)</td>\n</tr>\n<tr>\n<td>Math.pow(a,b)</td>\n<td>double</td>\n<td>a的b次方  (参数double 返回值double)</td>\n</tr>\n<tr>\n<td>Math.sqrt(double a)</td>\n<td></td>\n<td>获取给定参数的平方根</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>double</td>\n<td>随机产生一个[0.0–1.0)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>0-9之间的随机整数：int value = (int)<strong>(Math.random()*10</strong>);</li>\n<li>Math.random()计算小数的时候精确程度可能有些损失</li>\n</ul>\n<h4 id=\"3-1-Random类\"><a href=\"#3-1-Random类\" class=\"headerlink\" title=\"3.1 Random类\"></a>3.1 Random类</h4><ul>\n<li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>Random r = new Random();</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r.nextInt();</td>\n<td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td>\n</tr>\n<tr>\n<td>r.nextInt(int bound);</td>\n<td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td>\n</tr>\n<tr>\n<td>r.nextFloat()</td>\n<td>随机产生一个 [0.0—1.0)</td>\n</tr>\n<tr>\n<td>r.nextBoolean()</td>\n<td>随机产生一个boolean值   true  false</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-UUID类\"><a href=\"#3-2-UUID类\" class=\"headerlink\" title=\"3.2 UUID类\"></a>3.2 UUID类</h4><ul>\n<li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n<li>只有有参构造方法，我们通常不会创建对象</li>\n<li>UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key</li>\n<li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li>\n</ul>\n<h4 id=\"3-3-BigDecimal\"><a href=\"#3-3-BigDecimal\" class=\"headerlink\" title=\"3.3 BigDecimal\"></a>3.3 BigDecimal</h4><ul>\n<li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li>\n<li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li>\n<li>提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(“1.23”);</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>BigDecimal类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BigDecimal(String val)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td>\n<td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>add</strong>(BigDecimal augend)</td>\n<td>用于实现<strong>加法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td>\n<td>用于实现<strong>减法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td>\n<td>用于实现<strong>乘法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td>\n<td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"3.0\"</span>);</span><br><span class=\"line\">BigDecimal d4 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"2.9\"</span>);</span><br><span class=\"line\">System.out.println(d3.add(d4));<span class=\"comment\">//加：5.9</span></span><br><span class=\"line\">System.out.println(d3.subtract(d4));<span class=\"comment\">//减：0.1</span></span><br><span class=\"line\">System.out.println(d3.multiply(d4));<span class=\"comment\">//乘：8.70</span></span><br><span class=\"line\">System.out.println(d3.divide(d4, <span class=\"number\">8</span>, BigDecimal.ROUND_HALF_UP));<span class=\"comment\">//除：1.03448276</span></span><br></pre></td></tr></table></figure>\n\n<p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p>\n<h4 id=\"3-4-BigInteger\"><a href=\"#3-4-BigInteger\" class=\"headerlink\" title=\"3.4 BigInteger\"></a>3.4 BigInteger</h4><ul>\n<li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li>\n<li>java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li>\n<li>如何创建对象，提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(“123”);</li>\n</ul>\n</li>\n<li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li>\n</ul>\n<h4 id=\"3-5-DecimalFormat类\"><a href=\"#3-5-DecimalFormat类\" class=\"headerlink\" title=\"3.5 DecimalFormat类\"></a>3.5 DecimalFormat类</h4><ul>\n<li>所属的包 java.text，import导入才能使用</li>\n<li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class=\"line\">DecimalFormat df = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.000\"</span>);</span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.450</span></span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df2 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"###.###\"</span>);</span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//12.45</span></span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df3 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.###\"</span>);</span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.45</span></span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Scanner类和System类\"><a href=\"#4-Scanner类和System类\" class=\"headerlink\" title=\"4. Scanner类和System类\"></a>4. Scanner类和System类</h3><h4 id=\"4-1-Scanner类\"><a href=\"#4-1-Scanner类\" class=\"headerlink\" title=\"4.1 Scanner类\"></a>4.1 Scanner类</h4><ol>\n<li>所属的包java.util包  需要import导包</li>\n<li>通过一个带输入流的构造方法创建对象</li>\n<li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li>\n</ol>\n<h4 id=\"4-1-System类\"><a href=\"#4-1-System类\" class=\"headerlink\" title=\"4.1 System类\"></a>4.1 System类</h4><ol>\n<li>所属的包java.lang包 不需要导入</li>\n<li>不需要创建对象  通过类名就可以访问</li>\n<li>有三个属性及若干的方法<ul>\n<li>三个属性out   in   err</li>\n<li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-日期类\"><a href=\"#5-日期类\" class=\"headerlink\" title=\"5. 日期类\"></a>5. 日期类</h3><h4 id=\"5-1-Date类\"><a href=\"#5-1-Date类\" class=\"headerlink\" title=\"5.1 Date类\"></a>5.1 Date类</h4><ul>\n<li>java.util.Date类表示特定的瞬间，精确到毫秒。</li>\n<li>通常使用无参数的构造方法，或者带long构造方法</li>\n<li>Date类中常用的方法<ul>\n<li>before();  after();</li>\n<li>setTime()  getTime();—–&gt;long</li>\n<li>compareTo();   //-1  1  0</li>\n</ul>\n</li>\n<li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();<span class=\"comment\">//当前日期信息</span></span><br><span class=\"line\">    <span class=\"comment\">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> time = date.getTime();<span class=\"comment\">//1970年1月1日距今毫秒数。</span></span><br><span class=\"line\">date.setTime(time + <span class=\"number\">24</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">1000</span>);<span class=\"comment\">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-SimpleDateFormat类\"><a href=\"#5-2-SimpleDateFormat类\" class=\"headerlink\" title=\"5.2 SimpleDateFormat类\"></a>5.2 SimpleDateFormat类</h4><ul>\n<li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li>\n<li>其构造方法 SimpleDateFormat(String pattern)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy年MM月dd日\"</span>);</span><br><span class=\"line\">String dateStr = sdf.format(date);</span><br><span class=\"line\"><span class=\"comment\">// format用于将日期按指定格式转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">String str = <span class=\"string\">\"2013-01-06\"</span>;</span><br><span class=\"line\">SimpleDateFormat sdf2 = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>);</span><br><span class=\"line\">Date date2 = sdf2.parse(str);<span class=\"comment\">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>常用格式字符串</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>年</td>\n<td>yyyy年——2013年；yy——13年</td>\n</tr>\n<tr>\n<td>M</td>\n<td>月</td>\n<td>MM月——01月；M月——1月</td>\n</tr>\n<tr>\n<td>d</td>\n<td>日</td>\n<td>dd日——01日；d日——1日</td>\n</tr>\n<tr>\n<td>H</td>\n<td>小时(24)</td>\n<td>HH:mm:ss—12:46:33</td>\n</tr>\n<tr>\n<td>h</td>\n<td>小时(12)</td>\n<td>hh(a):mm:ss—12(下午):47:48</td>\n</tr>\n<tr>\n<td>m</td>\n<td>分钟</td>\n<td>–</td>\n</tr>\n<tr>\n<td>s</td>\n<td>秒</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-3-Calendar类\"><a href=\"#5-3-Calendar类\" class=\"headerlink\" title=\"5.3 Calendar类\"></a>5.3 Calendar类</h4><ul>\n<li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li>\n<li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li>\n<li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c1 = Calendar.getInstance();</span><br><span class=\"line\">c1.set(<span class=\"number\">2008</span>,<span class=\"number\">9</span>-<span class=\"number\">1</span>,<span class=\"number\">20</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>常用方法</p>\n<ul>\n<li>after()  before()</li>\n<li>setTime()  getTime()—-&gt;Date</li>\n<li>getTimeInMillis()—-time</li>\n<li>getTimeZone()—TimeZone</li>\n<li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li>\n<li>set   get<ul>\n<li>calendar.set(Calendar.YEAR,2015);</li>\n<li>int year = calendar.get(Calendar.YEAR);</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TimeZone</p>\n<ol>\n<li>java.util包</li>\n<li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li>\n<li>常用方法<ul>\n<li>tz.getID()       —-&gt;    Asia/Shanghai</li>\n<li>tz.getDisplayName()    —-&gt;  中国标准时间</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-String类\"><a href=\"#6-String类\" class=\"headerlink\" title=\"6. String类\"></a>6. String类</h3><h4 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h4><ul>\n<li>String类 —&gt; 引用类型  —&gt; java.lang包</li>\n<li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<string></string></li>\n<li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li>\n<li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何构建对象</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"abc\"</span>; <span class=\"comment\">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String();<span class=\"comment\">//无参数构造方法创建空的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//带string参数的构造方法创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bArr = &#123;<span class=\"number\">97</span>, <span class=\"number\">98</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">101</span>&#125;;<span class=\"comment\">//a:97，b:98，c:99，d:100</span></span><br><span class=\"line\">String str4 = <span class=\"keyword\">new</span> String(bArr);<span class=\"comment\">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] cArr = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>&#125;;</span><br><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(cArr);<span class=\"comment\">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class=\"line\">String str6 = String(<span class=\"keyword\">char</span>[], index, count);<span class=\"comment\">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class=\"line\">String str7 = String(<span class=\"keyword\">byte</span>[], index, length);<span class=\"comment\">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符串常量池\"><a href=\"#6-2-字符串常量池\" class=\"headerlink\" title=\"6.2 字符串常量池\"></a>6.2 字符串常量池</h4><ul>\n<li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li>\n<li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">System.out.println(str1.equals(str2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//比较地址 true，不会重新创建</span></span><br><span class=\"line\">System.out.println(str1.equals(str3));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str3);<span class=\"comment\">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class=\"line\">    <span class=\"comment\">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class=\"line\">String s1 = <span class=\"string\">\"hello\"</span>; <span class=\"comment\">//1个对象，常量池。</span></span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-String类常用方法\"><a href=\"#6-3-String类常用方法\" class=\"headerlink\" title=\"6.3 String类常用方法\"></a>6.3 String类常用方法</h4><ol>\n<li>第一梯队(重写): equals  hashCode  compareTo  toString</li>\n<li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li>\n<li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li>\n</ol>\n<ul>\n<li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol>\n<li>boolean = equals(Object obj);<ul>\n<li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;</li>\n</ul>\n</li>\n<li>int = hashCode();<ul>\n<li>继承自Object类中的方法，重写了：31*h+和…</li>\n</ul>\n</li>\n<li>int = compareTo();<ul>\n<li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li>\n</ul>\n</li>\n<li>String = toString()<ul>\n<li>Object类中返回类名@hashCode(16进制形式)</li>\n<li>String类重写后返回的是String对象的字面值</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>String类的成员方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char charAt(int index)</td>\n<td>返回字符串指定位置</td>\n</tr>\n<tr>\n<td>int codePointAt(int index)</td>\n<td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td>\n</tr>\n<tr>\n<td>String concat(String)</td>\n<td>将给定的字符串拼接在当前字符串之后</td>\n</tr>\n<tr>\n<td>int length()</td>\n<td>返回字符串序列的长度</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str6 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"下标为0的字符是：\"</span>+str6.charAt(<span class=\"number\">0</span>));<span class=\"comment\">// h</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"字符串长度是：\"</span>+str6.length());<span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串\"12345\"转换为整数类型</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//方式一：Integer类中的pareseInt方法</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ ia);<span class=\"comment\">//123456</span></span><br><span class=\"line\">    <span class=\"comment\">//方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class=\"line\">    res = res*<span class=\"number\">10</span> + (str.charAt(i)-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ res);<span class=\"comment\">//123456</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>String类的常用基本方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean contains(CharSequence s)</td>\n<td>判断当前字符串是否包含参数指定的内容</td>\n</tr>\n<tr>\n<td>String toLowerCase()</td>\n<td>返回小写形式</td>\n</tr>\n<tr>\n<td>String toUpperCase()</td>\n<td>返回大写形式</td>\n</tr>\n<tr>\n<td>String trim()</td>\n<td>返回去掉前后空格的字符串</td>\n</tr>\n<tr>\n<td>boolean startsWith(String prefix)</td>\n<td>判断是否以参数字符开头</td>\n</tr>\n<tr>\n<td>boolean endsWith(String suffix)</td>\n<td>判断是否以参数字符结尾</td>\n</tr>\n<tr>\n<td>boolean equals(Object anObject)</td>\n<td>比较字符串内容是否相等，String类已重写</td>\n</tr>\n<tr>\n<td>boolean equalsIgnoreCase(String anotherString)</td>\n<td>同上，并且忽略大小写</td>\n</tr>\n<tr>\n<td>int indexOf(String str)</td>\n<td>返回第一次出现str位置，找不到返回-1</td>\n</tr>\n<tr>\n<td>int indexOf(String str, int fromIndex)</td>\n<td>同上，从fromIndex开始检索</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex, int endIndex)</td>\n<td>截取字符串，beginIndex开始，endIndex结束</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex)</td>\n<td>截取字符串，beginIndex开始到结尾</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-4-正则相关方法\"><a href=\"#6-4-正则相关方法\" class=\"headerlink\" title=\"6.4 正则相关方法\"></a>6.4 正则相关方法</h4><ul>\n<li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>正则相关方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean matches(String regex)</td>\n<td>用于判断是否匹配正则表达式规则。</td>\n</tr>\n<tr>\n<td>String[] split(String regx)</td>\n<td>以正则为分割符，将字符串拆分成字符串数组</td>\n</tr>\n<tr>\n<td>String replaceAll(String regex, String replacement)</td>\n<td>正则替换</td>\n</tr>\n</tbody></table>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-StringBuilder类-StringBuffer类\"><a href=\"#7-StringBuilder类-StringBuffer类\" class=\"headerlink\" title=\"7. StringBuilder类/StringBuffer类\"></a>7. StringBuilder类/StringBuffer类</h3><h4 id=\"7-1-基本概念\"><a href=\"#7-1-基本概念\" class=\"headerlink\" title=\"7.1 基本概念\"></a>7.1 基本概念</h4><ol>\n<li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li>\n<li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul>\n<li>StringBuffer/StringBuilder没有compareTo方法</li>\n<li>StringBuffer/StringBuilder含有一个String没有的方法 append();拼接</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-特性\"><a href=\"#7-2-特性\" class=\"headerlink\" title=\"7.2 特性\"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p>\n<h4 id=\"7-3-对象的构建\"><a href=\"#7-3-对象的构建\" class=\"headerlink\" title=\"7.3 对象的构建\"></a>7.3 对象的构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"comment\">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-StringBuilder中常用的方法\"><a href=\"#7-4-StringBuilder中常用的方法\" class=\"headerlink\" title=\"7.4 StringBuilder中常用的方法\"></a>7.4 StringBuilder中常用的方法</h4><ul>\n<li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li>\n<li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li>\n<li>capacity();//字符串底层char[]的容量</li>\n<li>length();//字符串有效元素个数(长度)</li>\n<li>setLength();//设置字符串的有效元素个数</li>\n<li>char = charAt(int index);</li>\n<li>int = codePointAt(int index);</li>\n<li>String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果</li>\n<li>StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li>\n<li>StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦</li>\n<li>int = indexOf(String str [,int fromIndex]);</li>\n<li>int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li>\n<li>insert(int index,value);//将给定的value插入在index位置之上</li>\n<li>replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li>\n<li>setCharAt(int index,char value);//将index位置的字符改成给定的value</li>\n<li>toString();//将StringBuilder对象 构建成一个string对象 返回</li>\n<li>trimToSize();//将数组中无用的容量去掉  变成length长度的数组</li>\n</ul>\n<h4 id=\"7-5-总结\"><a href=\"#7-5-总结\" class=\"headerlink\" title=\"7.5 总结\"></a>7.5 总结</h4><ol>\n<li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li>\n<li>常用方法<ul>\n<li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li>\n<li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li>\n<li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li>\n</ul>\n</li>\n<li>String家族笔试中经常容易考察的知识点</li>\n<li>String所属的包 继承关系 实现接口<ul>\n<li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li>\n</ul>\n</li>\n<li>String构建方式<ul>\n<li>常量  构造方法  </li>\n</ul>\n</li>\n<li>String对象内存结构<ul>\n<li>字符串常量区  new堆内存对象</li>\n<li>==  equals()区别</li>\n<li>“a”+”b”+”c”</li>\n</ul>\n</li>\n<li>String不可变特性<ul>\n<li>长度及内容</li>\n</ul>\n</li>\n<li>String中的常用方法<ul>\n<li>concat();  toUpperCase();</li>\n</ul>\n</li>\n<li>String和StringBuilder区别   |   String和StringBuffer区别<ul>\n<li>String不可变字符串<ul>\n<li>JDK1.0</li>\n<li>有一个接口Comparable</li>\n<li>不可变体现在长度及内容</li>\n<li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li>\n</ul>\n</li>\n<li>StringBuilder可变字符串<ul>\n<li>JDK1.5</li>\n<li>有一个接口Appendable</li>\n<li>可变字符串  没有final修饰  底层可以进行数组扩容</li>\n<li>有一些方法String没有  append() insert() delete() reverse()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>StringBuffer和StringBuilder的不同<ul>\n<li>它们方法基本相同</li>\n<li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li>\n<li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Optional类\"><a href=\"#8-Optional类\" class=\"headerlink\" title=\"8. Optional类\"></a>8. Optional类</h3><ul>\n<li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li>\n<li>获取字符串长度：<ol>\n<li>方式1：if(null==str){return 0;}else{return str.length();}</li>\n<li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取两个字符串长度和</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> str1Length = Optional.ofNullable(str1).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> str2Length = Optional.ofNullable(str2).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(str1Length + str2Length);<span class=\"comment\">//8，8+0</span></span><br><span class=\"line\"><span class=\"comment\">//步骤分解:</span></span><br><span class=\"line\"><span class=\"comment\">//构建Optional对象</span></span><br><span class=\"line\">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class=\"line\"><span class=\"comment\">//将str1的长度的结果构建成Optional对象</span></span><br><span class=\"line\">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class=\"line\"><span class=\"comment\">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> len = op2.orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(len);<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p>","more":"<ol>\n<li><a href=\"#id1\">Object类与其常用方法</a></li>\n<li><a href=\"#id2\">包装类</a></li>\n<li><a href=\"#id3\">数学处理类</a></li>\n<li><a href=\"#id4\">Scanner类和System类</a></li>\n<li><a href=\"#id5\">日期类</a></li>\n<li><a href=\"#id6\">String类</a></li>\n<li><a href=\"#id7\">StringBuilder类/StringBuffer类</a></li>\n<li><a href=\"#id8\">Optional类</a></li>\n</ol>\n<h3 id=\"常用的包\"><a href=\"#常用的包\" class=\"headerlink\" title=\"常用的包\"></a>常用的包</h3><ul>\n<li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li>\n<li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li>\n<li>java.io包：是输入输出包，包括读写各种设备。</li>\n<li>java.net包：是网络编程的包，包括各种网络编程。</li>\n<li>java.sql包：是操作数据库的所有类和接口。</li>\n</ul>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Object类与其常用方法\"><a href=\"#1-Object类与其常用方法\" class=\"headerlink\" title=\"1. Object类与其常用方法\"></a>1. Object类与其常用方法</h3><h4 id=\"1-1-Object类\"><a href=\"#1-1-Object类\" class=\"headerlink\" title=\"1.1 Object类\"></a>1.1 Object类</h4><ul>\n<li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li>\n<li>Object定义了“对象”的基本行为，被子类默认继承。</li>\n</ul>\n<h4 id=\"1-2-equals-和-hashCode\"><a href=\"#1-2-equals-和-hashCode\" class=\"headerlink\" title=\"1.2 equals() 和 hashCode()\"></a>1.2 equals() 和 hashCode()</h4><ul>\n<li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li>\n<li>equals()方法要求：自反性/对称性/传递性/一致性/非空性。</li>\n<li>Java类可以根据需要重写继承自Object的equals()方法。</li>\n</ul>\n<blockquote>\n<p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n</blockquote>\n<ul>\n<li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p>\n</li>\n<li><p>hashCode规范要求：</p>\n<ul>\n<li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li>\n<li>如果两个对象判定相等，它们的hashCode应该时同一个值</li>\n<li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li>\n</ul>\n</li>\n<li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p>\n</li>\n</ul>\n<h4 id=\"1-3-toString\"><a href=\"#1-3-toString\" class=\"headerlink\" title=\"1.3 toString()\"></a>1.3 toString()</h4><ul>\n<li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li>\n<li>Java类可以根据需要重写toString方法返回更有意义的信息。</li>\n<li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-包装类\"><a href=\"#2-包装类\" class=\"headerlink\" title=\"2. 包装类\"></a>2. 包装类</h3><h4 id=\"2-1-包装类\"><a href=\"#2-1-包装类\" class=\"headerlink\" title=\"2.1 包装类\"></a>2.1 包装类</h4><ul>\n<li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li>\n<li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>对应包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>java.lang.Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>java.lang.Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>java.lang.Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>java.lang.Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>java.lang.Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>java.lang.Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>java.lang.Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>java.lang.Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li>\n<li>八个包装类中有六个是与数字相关，都默认继承父类Number</li>\n<li>八个包装类都实现了Serializable, Comparable</li>\n<li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li>\n<li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li>\n</ol>\n<h4 id=\"2-2-Integer类\"><a href=\"#2-2-Integer类\" class=\"headerlink\" title=\"2.2 Integer类\"></a>2.2 Integer类</h4><ul>\n<li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li>\n<li>Integer类重写了<strong>equals()</strong>方法（重写后比较的是数值）、hashCode()以及toString()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Integer类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Integer(int i)</td>\n<td>根据参数指定整数来构造对象</td>\n</tr>\n<tr>\n<td>Integer(String s)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>int intValue()</td>\n<td>获取调用对象中整数值并返回</td>\n</tr>\n<tr>\n<td>static Integer valueOf(int i)</td>\n<td>根据参数指定整数值得到Integer类型对象</td>\n</tr>\n<tr>\n<td>static int parseInt(String s)</td>\n<td>将字符串类型转换为int类型并返回</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-装箱和拆箱\"><a href=\"#2-3-装箱和拆箱\" class=\"headerlink\" title=\"2.3 装箱和拆箱\"></a>2.3 装箱和拆箱</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer it = Integer.valueOf(i); <span class=\"comment\">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = it.intValue();<span class=\"comment\">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class=\"line\">Integer i = <span class=\"number\">100</span>;<span class=\"comment\">//自动装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = i;<span class=\"comment\">//自动拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>笔试考点：<blockquote>\n<ul>\n<li>在Integer类部提供了自动装箱池技术，将<strong>-128~127间的整数已经装箱完毕</strong>，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li>\n<li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer it1 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it2 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it3 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">Integer it4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">System.out.println(it1.equals(it2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it1 == it2);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\">System.out.println(it3.equals(it4));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it3 == it4);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Integer it5 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it6 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it7 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">Integer it8 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">System.out.println(it5.equals(it6));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it5 == it6);<span class=\"comment\">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class=\"line\">System.out.println(it7.equals(it8));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it7 == it8);<span class=\"comment\">//比较地址 false</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数学处理类\"><a href=\"#3-数学处理类\" class=\"headerlink\" title=\"3. 数学处理类\"></a>3. 数学处理类</h3><ul>\n<li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>返回值类型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs()</td>\n<td></td>\n<td>返回给定数字的绝对值(参数 int long float double)</td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td>double</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td>double</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>Math.rint()</td>\n<td>double</td>\n<td>临近的整数 如果两边距离一样 则返回偶数</td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>int</td>\n<td>四舍五入的整数</td>\n</tr>\n<tr>\n<td>Math.max(a,b)/min(a,b)</td>\n<td></td>\n<td>(参数int  long  float  double)</td>\n</tr>\n<tr>\n<td>Math.pow(a,b)</td>\n<td>double</td>\n<td>a的b次方  (参数double 返回值double)</td>\n</tr>\n<tr>\n<td>Math.sqrt(double a)</td>\n<td></td>\n<td>获取给定参数的平方根</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>double</td>\n<td>随机产生一个[0.0–1.0)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>0-9之间的随机整数：int value = (int)<strong>(Math.random()*10</strong>);</li>\n<li>Math.random()计算小数的时候精确程度可能有些损失</li>\n</ul>\n<h4 id=\"3-1-Random类\"><a href=\"#3-1-Random类\" class=\"headerlink\" title=\"3.1 Random类\"></a>3.1 Random类</h4><ul>\n<li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>Random r = new Random();</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r.nextInt();</td>\n<td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td>\n</tr>\n<tr>\n<td>r.nextInt(int bound);</td>\n<td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td>\n</tr>\n<tr>\n<td>r.nextFloat()</td>\n<td>随机产生一个 [0.0—1.0)</td>\n</tr>\n<tr>\n<td>r.nextBoolean()</td>\n<td>随机产生一个boolean值   true  false</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-UUID类\"><a href=\"#3-2-UUID类\" class=\"headerlink\" title=\"3.2 UUID类\"></a>3.2 UUID类</h4><ul>\n<li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n<li>只有有参构造方法，我们通常不会创建对象</li>\n<li>UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key</li>\n<li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li>\n</ul>\n<h4 id=\"3-3-BigDecimal\"><a href=\"#3-3-BigDecimal\" class=\"headerlink\" title=\"3.3 BigDecimal\"></a>3.3 BigDecimal</h4><ul>\n<li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li>\n<li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li>\n<li>提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(“1.23”);</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>BigDecimal类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BigDecimal(String val)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td>\n<td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>add</strong>(BigDecimal augend)</td>\n<td>用于实现<strong>加法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td>\n<td>用于实现<strong>减法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td>\n<td>用于实现<strong>乘法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td>\n<td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"3.0\"</span>);</span><br><span class=\"line\">BigDecimal d4 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"2.9\"</span>);</span><br><span class=\"line\">System.out.println(d3.add(d4));<span class=\"comment\">//加：5.9</span></span><br><span class=\"line\">System.out.println(d3.subtract(d4));<span class=\"comment\">//减：0.1</span></span><br><span class=\"line\">System.out.println(d3.multiply(d4));<span class=\"comment\">//乘：8.70</span></span><br><span class=\"line\">System.out.println(d3.divide(d4, <span class=\"number\">8</span>, BigDecimal.ROUND_HALF_UP));<span class=\"comment\">//除：1.03448276</span></span><br></pre></td></tr></table></figure>\n\n<p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p>\n<h4 id=\"3-4-BigInteger\"><a href=\"#3-4-BigInteger\" class=\"headerlink\" title=\"3.4 BigInteger\"></a>3.4 BigInteger</h4><ul>\n<li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li>\n<li>java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li>\n<li>如何创建对象，提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(“123”);</li>\n</ul>\n</li>\n<li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li>\n</ul>\n<h4 id=\"3-5-DecimalFormat类\"><a href=\"#3-5-DecimalFormat类\" class=\"headerlink\" title=\"3.5 DecimalFormat类\"></a>3.5 DecimalFormat类</h4><ul>\n<li>所属的包 java.text，import导入才能使用</li>\n<li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class=\"line\">DecimalFormat df = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.000\"</span>);</span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.450</span></span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df2 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"###.###\"</span>);</span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//12.45</span></span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df3 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.###\"</span>);</span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.45</span></span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Scanner类和System类\"><a href=\"#4-Scanner类和System类\" class=\"headerlink\" title=\"4. Scanner类和System类\"></a>4. Scanner类和System类</h3><h4 id=\"4-1-Scanner类\"><a href=\"#4-1-Scanner类\" class=\"headerlink\" title=\"4.1 Scanner类\"></a>4.1 Scanner类</h4><ol>\n<li>所属的包java.util包  需要import导包</li>\n<li>通过一个带输入流的构造方法创建对象</li>\n<li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li>\n</ol>\n<h4 id=\"4-1-System类\"><a href=\"#4-1-System类\" class=\"headerlink\" title=\"4.1 System类\"></a>4.1 System类</h4><ol>\n<li>所属的包java.lang包 不需要导入</li>\n<li>不需要创建对象  通过类名就可以访问</li>\n<li>有三个属性及若干的方法<ul>\n<li>三个属性out   in   err</li>\n<li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-日期类\"><a href=\"#5-日期类\" class=\"headerlink\" title=\"5. 日期类\"></a>5. 日期类</h3><h4 id=\"5-1-Date类\"><a href=\"#5-1-Date类\" class=\"headerlink\" title=\"5.1 Date类\"></a>5.1 Date类</h4><ul>\n<li>java.util.Date类表示特定的瞬间，精确到毫秒。</li>\n<li>通常使用无参数的构造方法，或者带long构造方法</li>\n<li>Date类中常用的方法<ul>\n<li>before();  after();</li>\n<li>setTime()  getTime();—–&gt;long</li>\n<li>compareTo();   //-1  1  0</li>\n</ul>\n</li>\n<li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();<span class=\"comment\">//当前日期信息</span></span><br><span class=\"line\">    <span class=\"comment\">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> time = date.getTime();<span class=\"comment\">//1970年1月1日距今毫秒数。</span></span><br><span class=\"line\">date.setTime(time + <span class=\"number\">24</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">1000</span>);<span class=\"comment\">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-SimpleDateFormat类\"><a href=\"#5-2-SimpleDateFormat类\" class=\"headerlink\" title=\"5.2 SimpleDateFormat类\"></a>5.2 SimpleDateFormat类</h4><ul>\n<li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li>\n<li>其构造方法 SimpleDateFormat(String pattern)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy年MM月dd日\"</span>);</span><br><span class=\"line\">String dateStr = sdf.format(date);</span><br><span class=\"line\"><span class=\"comment\">// format用于将日期按指定格式转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">String str = <span class=\"string\">\"2013-01-06\"</span>;</span><br><span class=\"line\">SimpleDateFormat sdf2 = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>);</span><br><span class=\"line\">Date date2 = sdf2.parse(str);<span class=\"comment\">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>常用格式字符串</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>年</td>\n<td>yyyy年——2013年；yy——13年</td>\n</tr>\n<tr>\n<td>M</td>\n<td>月</td>\n<td>MM月——01月；M月——1月</td>\n</tr>\n<tr>\n<td>d</td>\n<td>日</td>\n<td>dd日——01日；d日——1日</td>\n</tr>\n<tr>\n<td>H</td>\n<td>小时(24)</td>\n<td>HH:mm:ss—12:46:33</td>\n</tr>\n<tr>\n<td>h</td>\n<td>小时(12)</td>\n<td>hh(a):mm:ss—12(下午):47:48</td>\n</tr>\n<tr>\n<td>m</td>\n<td>分钟</td>\n<td>–</td>\n</tr>\n<tr>\n<td>s</td>\n<td>秒</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-3-Calendar类\"><a href=\"#5-3-Calendar类\" class=\"headerlink\" title=\"5.3 Calendar类\"></a>5.3 Calendar类</h4><ul>\n<li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li>\n<li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li>\n<li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c1 = Calendar.getInstance();</span><br><span class=\"line\">c1.set(<span class=\"number\">2008</span>,<span class=\"number\">9</span>-<span class=\"number\">1</span>,<span class=\"number\">20</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>常用方法</p>\n<ul>\n<li>after()  before()</li>\n<li>setTime()  getTime()—-&gt;Date</li>\n<li>getTimeInMillis()—-time</li>\n<li>getTimeZone()—TimeZone</li>\n<li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li>\n<li>set   get<ul>\n<li>calendar.set(Calendar.YEAR,2015);</li>\n<li>int year = calendar.get(Calendar.YEAR);</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TimeZone</p>\n<ol>\n<li>java.util包</li>\n<li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li>\n<li>常用方法<ul>\n<li>tz.getID()       —-&gt;    Asia/Shanghai</li>\n<li>tz.getDisplayName()    —-&gt;  中国标准时间</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-String类\"><a href=\"#6-String类\" class=\"headerlink\" title=\"6. String类\"></a>6. String类</h3><h4 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h4><ul>\n<li>String类 —&gt; 引用类型  —&gt; java.lang包</li>\n<li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<string></string></li>\n<li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li>\n<li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何构建对象</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"abc\"</span>; <span class=\"comment\">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String();<span class=\"comment\">//无参数构造方法创建空的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//带string参数的构造方法创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bArr = &#123;<span class=\"number\">97</span>, <span class=\"number\">98</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">101</span>&#125;;<span class=\"comment\">//a:97，b:98，c:99，d:100</span></span><br><span class=\"line\">String str4 = <span class=\"keyword\">new</span> String(bArr);<span class=\"comment\">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] cArr = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>&#125;;</span><br><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(cArr);<span class=\"comment\">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class=\"line\">String str6 = String(<span class=\"keyword\">char</span>[], index, count);<span class=\"comment\">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class=\"line\">String str7 = String(<span class=\"keyword\">byte</span>[], index, length);<span class=\"comment\">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符串常量池\"><a href=\"#6-2-字符串常量池\" class=\"headerlink\" title=\"6.2 字符串常量池\"></a>6.2 字符串常量池</h4><ul>\n<li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li>\n<li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">System.out.println(str1.equals(str2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//比较地址 true，不会重新创建</span></span><br><span class=\"line\">System.out.println(str1.equals(str3));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str3);<span class=\"comment\">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class=\"line\">    <span class=\"comment\">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class=\"line\">String s1 = <span class=\"string\">\"hello\"</span>; <span class=\"comment\">//1个对象，常量池。</span></span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-String类常用方法\"><a href=\"#6-3-String类常用方法\" class=\"headerlink\" title=\"6.3 String类常用方法\"></a>6.3 String类常用方法</h4><ol>\n<li>第一梯队(重写): equals  hashCode  compareTo  toString</li>\n<li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li>\n<li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li>\n</ol>\n<ul>\n<li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol>\n<li>boolean = equals(Object obj);<ul>\n<li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;</li>\n</ul>\n</li>\n<li>int = hashCode();<ul>\n<li>继承自Object类中的方法，重写了：31*h+和…</li>\n</ul>\n</li>\n<li>int = compareTo();<ul>\n<li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li>\n</ul>\n</li>\n<li>String = toString()<ul>\n<li>Object类中返回类名@hashCode(16进制形式)</li>\n<li>String类重写后返回的是String对象的字面值</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>String类的成员方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char charAt(int index)</td>\n<td>返回字符串指定位置</td>\n</tr>\n<tr>\n<td>int codePointAt(int index)</td>\n<td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td>\n</tr>\n<tr>\n<td>String concat(String)</td>\n<td>将给定的字符串拼接在当前字符串之后</td>\n</tr>\n<tr>\n<td>int length()</td>\n<td>返回字符串序列的长度</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str6 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"下标为0的字符是：\"</span>+str6.charAt(<span class=\"number\">0</span>));<span class=\"comment\">// h</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"字符串长度是：\"</span>+str6.length());<span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串\"12345\"转换为整数类型</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//方式一：Integer类中的pareseInt方法</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ ia);<span class=\"comment\">//123456</span></span><br><span class=\"line\">    <span class=\"comment\">//方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class=\"line\">    res = res*<span class=\"number\">10</span> + (str.charAt(i)-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ res);<span class=\"comment\">//123456</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>String类的常用基本方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean contains(CharSequence s)</td>\n<td>判断当前字符串是否包含参数指定的内容</td>\n</tr>\n<tr>\n<td>String toLowerCase()</td>\n<td>返回小写形式</td>\n</tr>\n<tr>\n<td>String toUpperCase()</td>\n<td>返回大写形式</td>\n</tr>\n<tr>\n<td>String trim()</td>\n<td>返回去掉前后空格的字符串</td>\n</tr>\n<tr>\n<td>boolean startsWith(String prefix)</td>\n<td>判断是否以参数字符开头</td>\n</tr>\n<tr>\n<td>boolean endsWith(String suffix)</td>\n<td>判断是否以参数字符结尾</td>\n</tr>\n<tr>\n<td>boolean equals(Object anObject)</td>\n<td>比较字符串内容是否相等，String类已重写</td>\n</tr>\n<tr>\n<td>boolean equalsIgnoreCase(String anotherString)</td>\n<td>同上，并且忽略大小写</td>\n</tr>\n<tr>\n<td>int indexOf(String str)</td>\n<td>返回第一次出现str位置，找不到返回-1</td>\n</tr>\n<tr>\n<td>int indexOf(String str, int fromIndex)</td>\n<td>同上，从fromIndex开始检索</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex, int endIndex)</td>\n<td>截取字符串，beginIndex开始，endIndex结束</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex)</td>\n<td>截取字符串，beginIndex开始到结尾</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-4-正则相关方法\"><a href=\"#6-4-正则相关方法\" class=\"headerlink\" title=\"6.4 正则相关方法\"></a>6.4 正则相关方法</h4><ul>\n<li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>正则相关方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean matches(String regex)</td>\n<td>用于判断是否匹配正则表达式规则。</td>\n</tr>\n<tr>\n<td>String[] split(String regx)</td>\n<td>以正则为分割符，将字符串拆分成字符串数组</td>\n</tr>\n<tr>\n<td>String replaceAll(String regex, String replacement)</td>\n<td>正则替换</td>\n</tr>\n</tbody></table>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-StringBuilder类-StringBuffer类\"><a href=\"#7-StringBuilder类-StringBuffer类\" class=\"headerlink\" title=\"7. StringBuilder类/StringBuffer类\"></a>7. StringBuilder类/StringBuffer类</h3><h4 id=\"7-1-基本概念\"><a href=\"#7-1-基本概念\" class=\"headerlink\" title=\"7.1 基本概念\"></a>7.1 基本概念</h4><ol>\n<li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li>\n<li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul>\n<li>StringBuffer/StringBuilder没有compareTo方法</li>\n<li>StringBuffer/StringBuilder含有一个String没有的方法 append();拼接</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-特性\"><a href=\"#7-2-特性\" class=\"headerlink\" title=\"7.2 特性\"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p>\n<h4 id=\"7-3-对象的构建\"><a href=\"#7-3-对象的构建\" class=\"headerlink\" title=\"7.3 对象的构建\"></a>7.3 对象的构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"comment\">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-StringBuilder中常用的方法\"><a href=\"#7-4-StringBuilder中常用的方法\" class=\"headerlink\" title=\"7.4 StringBuilder中常用的方法\"></a>7.4 StringBuilder中常用的方法</h4><ul>\n<li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li>\n<li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li>\n<li>capacity();//字符串底层char[]的容量</li>\n<li>length();//字符串有效元素个数(长度)</li>\n<li>setLength();//设置字符串的有效元素个数</li>\n<li>char = charAt(int index);</li>\n<li>int = codePointAt(int index);</li>\n<li>String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果</li>\n<li>StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li>\n<li>StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦</li>\n<li>int = indexOf(String str [,int fromIndex]);</li>\n<li>int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li>\n<li>insert(int index,value);//将给定的value插入在index位置之上</li>\n<li>replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li>\n<li>setCharAt(int index,char value);//将index位置的字符改成给定的value</li>\n<li>toString();//将StringBuilder对象 构建成一个string对象 返回</li>\n<li>trimToSize();//将数组中无用的容量去掉  变成length长度的数组</li>\n</ul>\n<h4 id=\"7-5-总结\"><a href=\"#7-5-总结\" class=\"headerlink\" title=\"7.5 总结\"></a>7.5 总结</h4><ol>\n<li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li>\n<li>常用方法<ul>\n<li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li>\n<li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li>\n<li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li>\n</ul>\n</li>\n<li>String家族笔试中经常容易考察的知识点</li>\n<li>String所属的包 继承关系 实现接口<ul>\n<li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li>\n</ul>\n</li>\n<li>String构建方式<ul>\n<li>常量  构造方法  </li>\n</ul>\n</li>\n<li>String对象内存结构<ul>\n<li>字符串常量区  new堆内存对象</li>\n<li>==  equals()区别</li>\n<li>“a”+”b”+”c”</li>\n</ul>\n</li>\n<li>String不可变特性<ul>\n<li>长度及内容</li>\n</ul>\n</li>\n<li>String中的常用方法<ul>\n<li>concat();  toUpperCase();</li>\n</ul>\n</li>\n<li>String和StringBuilder区别   |   String和StringBuffer区别<ul>\n<li>String不可变字符串<ul>\n<li>JDK1.0</li>\n<li>有一个接口Comparable</li>\n<li>不可变体现在长度及内容</li>\n<li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li>\n</ul>\n</li>\n<li>StringBuilder可变字符串<ul>\n<li>JDK1.5</li>\n<li>有一个接口Appendable</li>\n<li>可变字符串  没有final修饰  底层可以进行数组扩容</li>\n<li>有一些方法String没有  append() insert() delete() reverse()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>StringBuffer和StringBuilder的不同<ul>\n<li>它们方法基本相同</li>\n<li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li>\n<li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Optional类\"><a href=\"#8-Optional类\" class=\"headerlink\" title=\"8. Optional类\"></a>8. Optional类</h3><ul>\n<li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li>\n<li>获取字符串长度：<ol>\n<li>方式1：if(null==str){return 0;}else{return str.length();}</li>\n<li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取两个字符串长度和</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> str1Length = Optional.ofNullable(str1).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> str2Length = Optional.ofNullable(str2).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(str1Length + str2Length);<span class=\"comment\">//8，8+0</span></span><br><span class=\"line\"><span class=\"comment\">//步骤分解:</span></span><br><span class=\"line\"><span class=\"comment\">//构建Optional对象</span></span><br><span class=\"line\">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class=\"line\"><span class=\"comment\">//将str1的长度的结果构建成Optional对象</span></span><br><span class=\"line\">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class=\"line\"><span class=\"comment\">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> len = op2.orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(len);<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure>"},{"title":"六、JavaSE输入输出(IO)","date":"2019-07-09T09:31:22.000Z","_content":"\n\n输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。\n<!-- more -->\n\n1. [File类](#id1)\n2. [IO流](#id2)\n3. [文件流](#id3)\n4. [字节型文件流](#id4)\n5. [字符型文件流](#id5)\n6. [*缓冲流](#id6)\n7. [转换流](#id7)\n8. [对象流](#id8)\n9. [打印流(PrintStream类)](#id9)\n10. [Properties类的使用](#id10)\n\n<span id=\"id1\"><span>\n### 1. File类\n- File与真实硬盘中的文件或文件夹  不是一个东西\n    * File是在内存中的一个对象<---映射--->硬盘上的文件或文件夹\n- java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。\n- File类中的常用的方法\n    + canRead()，canWrite()，isHidden()，isFile()，isDirectory()\n    + length()，获取文件中字节的个数\n    + lastModified()，获取文件最后的修改时间--->毫秒值\n    + *String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt\n        * 绝对路径<---->相对路径\n        * 绝对路径可以通过完整的字符串，定位盘符，文件夹，文件\n        * 相对路径没有盘符的写法，当前工程(项目)所在的位置找寻\n    + String name = getName()，获取文件的名字    Test.txt\n    + *boolean = **createNewFile()**，创建新的文件\n    + *boolean = **mkdir** ，创建新的文件夹  外层没有 不能创建\n    + *boolean = **mkdirs**，创建新的文件夹  外层没有 可以自动创建\n    + String pname = getParent()，获取当前file的父亲file名字\n    + *File file = getParentFile()，获取当前file的父亲file对象\n    + String[] names = list()，获取当前file的所有儿子名字\n    + *File[] files = listFiles()，获取当前file的所有儿子对象\n    + *boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹\n- 文件夹的路径(找父目录)\n\n``` java\n//查找当前file的所有父目录\nFile file = new File(\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\");\nFile pfile = file.getParentFile();\nwhile(pfile!=null){\n    System.out.println(pfile.getAbsolutePath());\n    pfile = pfile.getParentFile();//再找一遍\n}\n```\n\n- 文件夹的遍历----需要一个递归\n\n``` java\n//设计一个方法  用来展示(遍历)文件夹,参数-->file(代表文件或文件夹)\npublic void showFile(File file){\n    //获取file的子元素\n    //files==null是个文件\n    //files!=null是个文件夹\n    //files.length!=0是一个带元素的文件夹\n    File[] files = file.listFiles();//test文件夹所有子元素\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.showFile(f);\n        }\n    }\n    //做自己的显示(file是文件或file是一个空的文件夹)\n    System.out.println(file.getAbsolutePath());\n}\n```\n\n- 文件夹的删除----需要一个递归\n\n``` java\n//设计一个方法 删除文件夹,参数 file\npublic void deleteFile(File file){\n    //判断file不是空文件夹\n    File[] files = file.listFiles();\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.deleteFile(f);\n        }\n    }\n    //删除file (file是个文件或file是一个空文件夹)\n    file.delete();\n}\n```\n\n\n<span id=\"id2\"><span>\n### 2. IO流\n- 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 \n- 流的分类:\n    * 根据处理数据类型的不同分为：字符流和字节流\n    * 根据数据流向不同分为：输入流in(读取)和输出流out(写入)\n    * 操作的目标来区分:\n        - 文件流，数组流，字符串流，数据流，对象流，网络流...\n- IO流的框架结构\n\n```\n|——IO流\n    |————字节流\n        |————InputStream\n            |————FileInputStream\n            |————DataInputStream\n            |————ObjectInputStream\n        |————OutputStream\n            |————FileOutputStream\n            |————DataOutputStream\n            |————ObjectOutputStream\n            |————PrintStream\n    |————字符流\n        |————Reader\n            |————BufferedReader\n            |————InputStreamReader\n        |————Writer\n            |————BufferedWriter\n            |————OutputStreamWriter\n```\n\n\n<span id=\"id3\"><span>\n### 3. 文件流\n读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分\n- 字节型文件流(1字节)：FileInputStream/FileOutputStream\n- 字符型文件流(2字节--1字符)：FileReader/FileWriter\n- 字节流和字符流的区别：\n    * 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n    * 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n- 结论：只要是处理**纯文本**数据，就优先考虑使用**字符流**。 除此之外都使用**字节流**。\n- 输入流和输出流\n    * 对输入流只能进行**读**操作，对输出流只能进行**写**操作。 \n\n\n<span id=\"id4\"><span>\n### 4. 字节型文件流\n#### 4.1 字节型文件输入流FileInputStream(读)\n- FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    + int code = read();    每次从流管道中读取一个字节，返回字节的code码\n    + *int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数\n    + int count = available();   返回流管道中还有多少缓存的字节数\n    + skip(long n);跳过几个字节  读取\n        * 多线程--->利用几个线程同时读取文件\n    + *close()    将流管道关闭---必须要做,最好放在finally里\n        * 注意代码的健壮性，判断严谨（eg:非空判断）\n    \n#### 4.2 字节型文件输出流FileOutputStream(写)\n- FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。\n- 创建对象\n    + 调用一个带File参数，还有File boolean重载\n    + 调用一个带String参数，还有String boolean重载\n    + eg: new FileOutputStream(\"D://test//bbb.txt\", true)//第二个参控制每次写入追加还是重载\n- 常用方法\n    + write(int code);  将给定code对应的字符写入文件   '='\n    + write(byte[]);  将数组中的全部字节写入文件   getByte()\n    + write(byte[] b, int off, int len);\n    + flush();    将管道内的字节推入(刷新)文件\n    + close();    注意在finally中关闭\n\n> - 创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException\n> - 创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件\n\n* 设计一个文件复制的方法\n\n``` java\npublic void copyFile(File file, String path) {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n        //创建输入流读取信息\n        fis = new FileInputStream(file);\n        //创建一个新的File对象\n        File newFile = new File(path +\"\\\\\"+ file.getName());//\"E:\\\\test\\\\test.txt\"\n        //创建一个输出流\n        fos = new FileOutputStream(newFile);\n        byte[] b = new byte[1024];//通常1kb-8kb之间\n        int count = fis.read(b);\n        while(count != -1) {\n            fos.write(b, 0, count);//将读取到的有效字节写入\n            fos.flush();\n            count = fis.read(b);\n        }\n        System.out.println(\"复制完毕！\");\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        //关闭\n        if(fis!=null) {\n            try { fis.close(); }\n            catch (IOException e) {e.printStackTrace();}\n        }\n        if(fos!=null) {\n            try {fos.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n    }\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. 字符型文件流\nFileReader/FileWriter：只能操作纯文本的文件 .txt / .properties\n\n#### 5.1 字符型文件输入流FileReader(读)\n- FileReader类在java.io包，继承自InputStreamReader，Reader\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    * read()\n    * read(char[])\n    * close()\n\n``` java\nFile file = new File(\"F://test//Test.txt\");\ntry {\n    FileReader fr = new FileReader(file);\n    // int code = fr.read();\n    // System.out.println(code);\n    char[] c = new char[1024];\n    int count = fr.read(c);\n    while(count!=-1) {\n        System.out.println(new String(c, 0, count));\n        count = fr.read(c);\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n#### 5.2 字符型文件输出流FileWriter(写)\n- FileWriter类在java.io包，继承自OutputStreamWriter，Writer\n- 构造方法\n    * 带file参数，带file,boolean参数\n    * 带String参数，带String,boolean参数\n- 常用方法\n    * write(int)\n    * write(char[])\n    * write(string)\n    * flush()，close()\n\n\n<span id=\"id6\"><span>\n### 6. *缓冲流\n- 缓冲流,也叫高效流，是对4个基本的File...流的增强，所以也是4个流，按照数据类型分类：\n    * 字节缓冲流：BufferedInputStream，BufferedOutputStream \n    * 字符缓冲流：BufferedReader，BufferedWriter\n- 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n- 缓冲流读写方法与基本的流是一致\n\n#### 6.1 字节缓冲流\n- BufferedInputStream，BufferedOutputStream\n- 构造方法\n    * public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 \n    * public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n\n#### 6.2 字符缓冲流\n- BufferedReader，BufferedWriter\n- 构造方法\n    * public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 \n    * public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n- 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n- 特有方法: \n    * BufferedReader：public String readLine(): 读一行文字。 \n    * BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\n\n``` java\n//设计一个方法，用来用户登录认证\npublic String login(String username, String password) {\n    try {\n        BufferedReader br = new BufferedReader(new FileReader(\"F://test//User.txt\"));\n        //User.txt每行存储格式：张三-123\n        String user = br.readLine();//user表示一行记录，记录账号密码\n        while(user!=null) {\n            //将user信息拆分，分别与参数比较\n            String[] value = user.split(\"-\");//value[0]账号，value[1]密码\n            System.out.println(value[0]);\n            if(value[0].equals(username)) {\n                if(value[1].equals(password)) {\n                    return \"登录成功\";\n                }\n            }\n            user = br.readLine();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return \"账号或密码错误！\";\n}\n```\n\n- readLine方法演示:\n\n```\ntry {\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"F://test//User.txt\", true));\n    bw.newLine();\n    bw.write(\"java-888\");\n    bw.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 转换流\n#### 7.1 字符编码\n- 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n- 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n- 常见字符集:\n    * ASCII字符集 ：\n        + ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）\n    * ISO-8859-1字符集：\n        + 拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。\n    * GBxxx字符集：\n        + GB就是国标的意思，是为了显示中文而设计的一套字符集。\n        + GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）\n    * Unicode字符集 ：\n        + Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n        + UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。\n- 编码引出的问题\n    * 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n\n#### 7.2 InputStreamReader类 \n转换流java.io.InputStreamReader，是Reader的子类，是从**字节流到字符流**的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 \n    * InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n- 指定编码读取:\n\n``` java\npublic class ReaderDemo2 {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径,文件为gbk编码\n       String FileName = \"E:\\\\file_gbk.txt\";\n    // 创建流对象,默认UTF8编码\n       InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n    // 创建流对象,指定GBK编码\n       InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n// 定义变量,保存字符\n       int read;\n    // 使用默认编码字符流读取,乱码\n       while ((read = isr.read()) != -1) {\n           System.out.print((char)read); // ��Һ�\n      }\n       isr.close();\n    // 使用指定编码字符流读取,正常解析\n       while ((read = isr2.read()) != -1) {\n           System.out.print((char)read);// 大家好\n      }\n       isr2.close();\n  }\n}\n```\n\n\n#### 7.3 OutputStreamWriter类 \n转换流java.io.OutputStreamWriter ，是Writer的子类，是从**字符流到字节流**的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 \n    * OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n- 指定编码写出\n\n``` java\npublic class OutputDemo {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径\n       String FileName = \"E:\\\\out.txt\";\n    // 创建流对象,默认UTF8编码\n       OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n       // 写出数据\n    osw.write(\"你好\"); // 保存为6个字节\n       osw.close();\n// 定义文件路径\nString FileName2 = \"E:\\\\out2.txt\";\n    // 创建流对象,指定GBK编码\n       OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n       // 写出数据\n    osw2.write(\"你好\");// 保存为4个字节\n       osw2.close();\n  }\n}\n```\n\n\n<span id=\"id8\"><span>\n### 8. 对象流\n- 对象序列化和反序列化\n    * Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 \n    * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象\n    * 简单来讲\n        + 对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中\n        + 对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象\n        + 如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口； \n        如果想要将对象反序列化：需要给对象提供一个序列化的版本号，`private long serialVersionUID = 任意L`;\n\n\n### 8.1 ObjectOutputStream类\n- java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n- 构造方法\n    * public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\n\n``` java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n- 序列化操作\n    1. 一个对象要想序列化，必须满足两个条件:\n        + 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n        + 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n    2. 写出对象方法\n        + public final void writeObject (Object obj) : 将指定的对象写出。\n``` java\n//满足两个条件\npublic class Employee implements java.io.Serializable {\n   public String name;\n   public String address;\n   public transient int age; // transient瞬态修饰成员,不会被序列化\n   public void addressCheck() {\n    System.out.println(\"Address check : \" + name + \" -- \" + address);\n  }\n}\n//写出对象方法\npublic class SerializeDemo{\n  public static void main(String [] args)   {\n  Employee e = new Employee();\n  e.name = \"zhangsan\";\n  e.address = \"beiqinglu\";\n  e.age = 20; \n  try {\n    // 创建序列化流对象\n         ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n      // 写出对象\n      out.writeObject(e);\n      // 释放资源\n      out.close();\n      fileOut.close();\n      System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n      } catch(IOException i)   {\n           i.printStackTrace();\n      }\n  }\n}\n//输出结果：\n//Serialized data is saved\n```\n\n\n#### 8.1 ObjectInputStream类\n- ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n- 构造方法\n    * public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\n- 反序列化操作1\n    * 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。\n    * 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n    * public final Object readObject () : 读取一个对象。\n\n``` java\npublic class DeserializeDemo {\n  public static void main(String [] args)   {\n       Employee e = null;\n       try {\n            // 创建反序列化流\n            FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            // 读取一个对象\n            e = (Employee) in.readObject();\n            // 释放资源\n            in.close();\n            fileIn.close();\n      }catch(IOException i) {\n            // 捕获其他异常\n            i.printStackTrace();\n            return;\n      }catch(ClassNotFoundException c) {\n      // 捕获类找不到异常\n            System.out.println(\"Employee class not found\");\n            c.printStackTrace();\n            return;\n      }\n       // 无异常,直接打印输出\n       System.out.println(\"Name: \" + e.name);// zhangsan\n       System.out.println(\"Address: \" + e.address); // beiqinglu\n       System.out.println(\"age: \" + e.age); // 0\n  }\n}\n```\n\n\n- 反序列化操作2\n    * 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n        + 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n        + 该类包含未知数据类型 \n        + 该类没有可访问的无参数构造方法 \n    * Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n``` java\npublic class Employee implements java.io.Serializable {\n    // 加入序列版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public String address;\n    // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n    public int eid; \n\n    public void addressCheck() {\n        System.out.println(\"Address check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 打印流(PrintStream类)\n- 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n- 构造方法\n    * `public PrintStream(String fileName);`  使用指定的文件名创建一个新的打印流。\n\n``` java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n- 改变打印流向\n    * System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。\n\n``` java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n        // 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n        // 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n        // 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n        // 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Properties类的使用\n- Java.util.Properties，主要用于读取Java的配置文件。\n- Properties类继承自Hashtable\n- 配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用\"#\"来注释。\n- Properties类的主要方法：\n    1. getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\n    2. load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。\n    3. setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\n    4. store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\n    5. clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。\n\n\n","source":"_posts/06_JavaSE输入输出-IO.md","raw":"---\ntitle: 六、JavaSE输入输出(IO)\ndate: 2019-07-09 17:31:22\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。\n<!-- more -->\n\n1. [File类](#id1)\n2. [IO流](#id2)\n3. [文件流](#id3)\n4. [字节型文件流](#id4)\n5. [字符型文件流](#id5)\n6. [*缓冲流](#id6)\n7. [转换流](#id7)\n8. [对象流](#id8)\n9. [打印流(PrintStream类)](#id9)\n10. [Properties类的使用](#id10)\n\n<span id=\"id1\"><span>\n### 1. File类\n- File与真实硬盘中的文件或文件夹  不是一个东西\n    * File是在内存中的一个对象<---映射--->硬盘上的文件或文件夹\n- java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。\n- File类中的常用的方法\n    + canRead()，canWrite()，isHidden()，isFile()，isDirectory()\n    + length()，获取文件中字节的个数\n    + lastModified()，获取文件最后的修改时间--->毫秒值\n    + *String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt\n        * 绝对路径<---->相对路径\n        * 绝对路径可以通过完整的字符串，定位盘符，文件夹，文件\n        * 相对路径没有盘符的写法，当前工程(项目)所在的位置找寻\n    + String name = getName()，获取文件的名字    Test.txt\n    + *boolean = **createNewFile()**，创建新的文件\n    + *boolean = **mkdir** ，创建新的文件夹  外层没有 不能创建\n    + *boolean = **mkdirs**，创建新的文件夹  外层没有 可以自动创建\n    + String pname = getParent()，获取当前file的父亲file名字\n    + *File file = getParentFile()，获取当前file的父亲file对象\n    + String[] names = list()，获取当前file的所有儿子名字\n    + *File[] files = listFiles()，获取当前file的所有儿子对象\n    + *boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹\n- 文件夹的路径(找父目录)\n\n``` java\n//查找当前file的所有父目录\nFile file = new File(\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\");\nFile pfile = file.getParentFile();\nwhile(pfile!=null){\n    System.out.println(pfile.getAbsolutePath());\n    pfile = pfile.getParentFile();//再找一遍\n}\n```\n\n- 文件夹的遍历----需要一个递归\n\n``` java\n//设计一个方法  用来展示(遍历)文件夹,参数-->file(代表文件或文件夹)\npublic void showFile(File file){\n    //获取file的子元素\n    //files==null是个文件\n    //files!=null是个文件夹\n    //files.length!=0是一个带元素的文件夹\n    File[] files = file.listFiles();//test文件夹所有子元素\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.showFile(f);\n        }\n    }\n    //做自己的显示(file是文件或file是一个空的文件夹)\n    System.out.println(file.getAbsolutePath());\n}\n```\n\n- 文件夹的删除----需要一个递归\n\n``` java\n//设计一个方法 删除文件夹,参数 file\npublic void deleteFile(File file){\n    //判断file不是空文件夹\n    File[] files = file.listFiles();\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.deleteFile(f);\n        }\n    }\n    //删除file (file是个文件或file是一个空文件夹)\n    file.delete();\n}\n```\n\n\n<span id=\"id2\"><span>\n### 2. IO流\n- 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 \n- 流的分类:\n    * 根据处理数据类型的不同分为：字符流和字节流\n    * 根据数据流向不同分为：输入流in(读取)和输出流out(写入)\n    * 操作的目标来区分:\n        - 文件流，数组流，字符串流，数据流，对象流，网络流...\n- IO流的框架结构\n\n```\n|——IO流\n    |————字节流\n        |————InputStream\n            |————FileInputStream\n            |————DataInputStream\n            |————ObjectInputStream\n        |————OutputStream\n            |————FileOutputStream\n            |————DataOutputStream\n            |————ObjectOutputStream\n            |————PrintStream\n    |————字符流\n        |————Reader\n            |————BufferedReader\n            |————InputStreamReader\n        |————Writer\n            |————BufferedWriter\n            |————OutputStreamWriter\n```\n\n\n<span id=\"id3\"><span>\n### 3. 文件流\n读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分\n- 字节型文件流(1字节)：FileInputStream/FileOutputStream\n- 字符型文件流(2字节--1字符)：FileReader/FileWriter\n- 字节流和字符流的区别：\n    * 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n    * 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n- 结论：只要是处理**纯文本**数据，就优先考虑使用**字符流**。 除此之外都使用**字节流**。\n- 输入流和输出流\n    * 对输入流只能进行**读**操作，对输出流只能进行**写**操作。 \n\n\n<span id=\"id4\"><span>\n### 4. 字节型文件流\n#### 4.1 字节型文件输入流FileInputStream(读)\n- FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    + int code = read();    每次从流管道中读取一个字节，返回字节的code码\n    + *int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数\n    + int count = available();   返回流管道中还有多少缓存的字节数\n    + skip(long n);跳过几个字节  读取\n        * 多线程--->利用几个线程同时读取文件\n    + *close()    将流管道关闭---必须要做,最好放在finally里\n        * 注意代码的健壮性，判断严谨（eg:非空判断）\n    \n#### 4.2 字节型文件输出流FileOutputStream(写)\n- FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。\n- 创建对象\n    + 调用一个带File参数，还有File boolean重载\n    + 调用一个带String参数，还有String boolean重载\n    + eg: new FileOutputStream(\"D://test//bbb.txt\", true)//第二个参控制每次写入追加还是重载\n- 常用方法\n    + write(int code);  将给定code对应的字符写入文件   '='\n    + write(byte[]);  将数组中的全部字节写入文件   getByte()\n    + write(byte[] b, int off, int len);\n    + flush();    将管道内的字节推入(刷新)文件\n    + close();    注意在finally中关闭\n\n> - 创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException\n> - 创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件\n\n* 设计一个文件复制的方法\n\n``` java\npublic void copyFile(File file, String path) {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n        //创建输入流读取信息\n        fis = new FileInputStream(file);\n        //创建一个新的File对象\n        File newFile = new File(path +\"\\\\\"+ file.getName());//\"E:\\\\test\\\\test.txt\"\n        //创建一个输出流\n        fos = new FileOutputStream(newFile);\n        byte[] b = new byte[1024];//通常1kb-8kb之间\n        int count = fis.read(b);\n        while(count != -1) {\n            fos.write(b, 0, count);//将读取到的有效字节写入\n            fos.flush();\n            count = fis.read(b);\n        }\n        System.out.println(\"复制完毕！\");\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        //关闭\n        if(fis!=null) {\n            try { fis.close(); }\n            catch (IOException e) {e.printStackTrace();}\n        }\n        if(fos!=null) {\n            try {fos.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n    }\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. 字符型文件流\nFileReader/FileWriter：只能操作纯文本的文件 .txt / .properties\n\n#### 5.1 字符型文件输入流FileReader(读)\n- FileReader类在java.io包，继承自InputStreamReader，Reader\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    * read()\n    * read(char[])\n    * close()\n\n``` java\nFile file = new File(\"F://test//Test.txt\");\ntry {\n    FileReader fr = new FileReader(file);\n    // int code = fr.read();\n    // System.out.println(code);\n    char[] c = new char[1024];\n    int count = fr.read(c);\n    while(count!=-1) {\n        System.out.println(new String(c, 0, count));\n        count = fr.read(c);\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n#### 5.2 字符型文件输出流FileWriter(写)\n- FileWriter类在java.io包，继承自OutputStreamWriter，Writer\n- 构造方法\n    * 带file参数，带file,boolean参数\n    * 带String参数，带String,boolean参数\n- 常用方法\n    * write(int)\n    * write(char[])\n    * write(string)\n    * flush()，close()\n\n\n<span id=\"id6\"><span>\n### 6. *缓冲流\n- 缓冲流,也叫高效流，是对4个基本的File...流的增强，所以也是4个流，按照数据类型分类：\n    * 字节缓冲流：BufferedInputStream，BufferedOutputStream \n    * 字符缓冲流：BufferedReader，BufferedWriter\n- 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n- 缓冲流读写方法与基本的流是一致\n\n#### 6.1 字节缓冲流\n- BufferedInputStream，BufferedOutputStream\n- 构造方法\n    * public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 \n    * public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n\n#### 6.2 字符缓冲流\n- BufferedReader，BufferedWriter\n- 构造方法\n    * public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 \n    * public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n- 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n- 特有方法: \n    * BufferedReader：public String readLine(): 读一行文字。 \n    * BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\n\n``` java\n//设计一个方法，用来用户登录认证\npublic String login(String username, String password) {\n    try {\n        BufferedReader br = new BufferedReader(new FileReader(\"F://test//User.txt\"));\n        //User.txt每行存储格式：张三-123\n        String user = br.readLine();//user表示一行记录，记录账号密码\n        while(user!=null) {\n            //将user信息拆分，分别与参数比较\n            String[] value = user.split(\"-\");//value[0]账号，value[1]密码\n            System.out.println(value[0]);\n            if(value[0].equals(username)) {\n                if(value[1].equals(password)) {\n                    return \"登录成功\";\n                }\n            }\n            user = br.readLine();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return \"账号或密码错误！\";\n}\n```\n\n- readLine方法演示:\n\n```\ntry {\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"F://test//User.txt\", true));\n    bw.newLine();\n    bw.write(\"java-888\");\n    bw.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 转换流\n#### 7.1 字符编码\n- 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n- 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n- 常见字符集:\n    * ASCII字符集 ：\n        + ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）\n    * ISO-8859-1字符集：\n        + 拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。\n    * GBxxx字符集：\n        + GB就是国标的意思，是为了显示中文而设计的一套字符集。\n        + GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）\n    * Unicode字符集 ：\n        + Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n        + UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。\n- 编码引出的问题\n    * 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n\n#### 7.2 InputStreamReader类 \n转换流java.io.InputStreamReader，是Reader的子类，是从**字节流到字符流**的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 \n    * InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n- 指定编码读取:\n\n``` java\npublic class ReaderDemo2 {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径,文件为gbk编码\n       String FileName = \"E:\\\\file_gbk.txt\";\n    // 创建流对象,默认UTF8编码\n       InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n    // 创建流对象,指定GBK编码\n       InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n// 定义变量,保存字符\n       int read;\n    // 使用默认编码字符流读取,乱码\n       while ((read = isr.read()) != -1) {\n           System.out.print((char)read); // ��Һ�\n      }\n       isr.close();\n    // 使用指定编码字符流读取,正常解析\n       while ((read = isr2.read()) != -1) {\n           System.out.print((char)read);// 大家好\n      }\n       isr2.close();\n  }\n}\n```\n\n\n#### 7.3 OutputStreamWriter类 \n转换流java.io.OutputStreamWriter ，是Writer的子类，是从**字符流到字节流**的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 \n    * OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n- 指定编码写出\n\n``` java\npublic class OutputDemo {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径\n       String FileName = \"E:\\\\out.txt\";\n    // 创建流对象,默认UTF8编码\n       OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n       // 写出数据\n    osw.write(\"你好\"); // 保存为6个字节\n       osw.close();\n// 定义文件路径\nString FileName2 = \"E:\\\\out2.txt\";\n    // 创建流对象,指定GBK编码\n       OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n       // 写出数据\n    osw2.write(\"你好\");// 保存为4个字节\n       osw2.close();\n  }\n}\n```\n\n\n<span id=\"id8\"><span>\n### 8. 对象流\n- 对象序列化和反序列化\n    * Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 \n    * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象\n    * 简单来讲\n        + 对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中\n        + 对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象\n        + 如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口； \n        如果想要将对象反序列化：需要给对象提供一个序列化的版本号，`private long serialVersionUID = 任意L`;\n\n\n### 8.1 ObjectOutputStream类\n- java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n- 构造方法\n    * public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\n\n``` java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n- 序列化操作\n    1. 一个对象要想序列化，必须满足两个条件:\n        + 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n        + 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n    2. 写出对象方法\n        + public final void writeObject (Object obj) : 将指定的对象写出。\n``` java\n//满足两个条件\npublic class Employee implements java.io.Serializable {\n   public String name;\n   public String address;\n   public transient int age; // transient瞬态修饰成员,不会被序列化\n   public void addressCheck() {\n    System.out.println(\"Address check : \" + name + \" -- \" + address);\n  }\n}\n//写出对象方法\npublic class SerializeDemo{\n  public static void main(String [] args)   {\n  Employee e = new Employee();\n  e.name = \"zhangsan\";\n  e.address = \"beiqinglu\";\n  e.age = 20; \n  try {\n    // 创建序列化流对象\n         ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n      // 写出对象\n      out.writeObject(e);\n      // 释放资源\n      out.close();\n      fileOut.close();\n      System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n      } catch(IOException i)   {\n           i.printStackTrace();\n      }\n  }\n}\n//输出结果：\n//Serialized data is saved\n```\n\n\n#### 8.1 ObjectInputStream类\n- ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n- 构造方法\n    * public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\n- 反序列化操作1\n    * 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。\n    * 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n    * public final Object readObject () : 读取一个对象。\n\n``` java\npublic class DeserializeDemo {\n  public static void main(String [] args)   {\n       Employee e = null;\n       try {\n            // 创建反序列化流\n            FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            // 读取一个对象\n            e = (Employee) in.readObject();\n            // 释放资源\n            in.close();\n            fileIn.close();\n      }catch(IOException i) {\n            // 捕获其他异常\n            i.printStackTrace();\n            return;\n      }catch(ClassNotFoundException c) {\n      // 捕获类找不到异常\n            System.out.println(\"Employee class not found\");\n            c.printStackTrace();\n            return;\n      }\n       // 无异常,直接打印输出\n       System.out.println(\"Name: \" + e.name);// zhangsan\n       System.out.println(\"Address: \" + e.address); // beiqinglu\n       System.out.println(\"age: \" + e.age); // 0\n  }\n}\n```\n\n\n- 反序列化操作2\n    * 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n        + 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n        + 该类包含未知数据类型 \n        + 该类没有可访问的无参数构造方法 \n    * Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n``` java\npublic class Employee implements java.io.Serializable {\n    // 加入序列版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public String address;\n    // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n    public int eid; \n\n    public void addressCheck() {\n        System.out.println(\"Address check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 打印流(PrintStream类)\n- 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n- 构造方法\n    * `public PrintStream(String fileName);`  使用指定的文件名创建一个新的打印流。\n\n``` java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n- 改变打印流向\n    * System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。\n\n``` java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n        // 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n        // 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n        // 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n        // 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Properties类的使用\n- Java.util.Properties，主要用于读取Java的配置文件。\n- Properties类继承自Hashtable\n- 配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用\"#\"来注释。\n- Properties类的主要方法：\n    1. getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\n    2. load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。\n    3. setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\n    4. store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\n    5. clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。\n\n\n","slug":"06_JavaSE输入输出-IO","published":1,"updated":"2019-07-20T14:47:09.875Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylobm003wyot3anmxr8sh","content":"<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">File类</a></li>\n<li><a href=\"#id2\">IO流</a></li>\n<li><a href=\"#id3\">文件流</a></li>\n<li><a href=\"#id4\">字节型文件流</a></li>\n<li><a href=\"#id5\">字符型文件流</a></li>\n<li><a href=\"#id6\">*缓冲流</a></li>\n<li><a href=\"#id7\">转换流</a></li>\n<li><a href=\"#id8\">对象流</a></li>\n<li><a href=\"#id9\">打印流(PrintStream类)</a></li>\n<li><a href=\"#id10\">Properties类的使用</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-File类\"><a href=\"#1-File类\" class=\"headerlink\" title=\"1. File类\"></a>1. File类</h3><ul>\n<li>File与真实硬盘中的文件或文件夹  不是一个东西<ul>\n<li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li>\n</ul>\n</li>\n<li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li>\n<li>File类中的常用的方法<ul>\n<li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li>\n<li>length()，获取文件中字节的个数</li>\n<li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li>\n<li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul>\n<li>绝对路径&lt;—-&gt;相对路径</li>\n<li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li>\n<li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li>\n</ul>\n</li>\n<li>String name = getName()，获取文件的名字    Test.txt</li>\n<li><em>boolean = *</em>createNewFile()**，创建新的文件</li>\n<li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li>\n<li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li>\n<li>String pname = getParent()，获取当前file的父亲file名字</li>\n<li>*File file = getParentFile()，获取当前file的父亲file对象</li>\n<li>String[] names = list()，获取当前file的所有儿子名字</li>\n<li>*File[] files = listFiles()，获取当前file的所有儿子对象</li>\n<li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li>\n</ul>\n</li>\n<li>文件夹的路径(找父目录)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找当前file的所有父目录</span></span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\"</span>);</span><br><span class=\"line\">File pfile = file.getParentFile();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(pfile!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(pfile.getAbsolutePath());</span><br><span class=\"line\">    pfile = pfile.getParentFile();<span class=\"comment\">//再找一遍</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的遍历—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取file的子元素</span></span><br><span class=\"line\">    <span class=\"comment\">//files==null是个文件</span></span><br><span class=\"line\">    <span class=\"comment\">//files!=null是个文件夹</span></span><br><span class=\"line\">    <span class=\"comment\">//files.length!=0是一个带元素的文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();<span class=\"comment\">//test文件夹所有子元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class=\"line\">    System.out.println(file.getAbsolutePath());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的删除—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法 删除文件夹,参数 file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断file不是空文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deleteFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class=\"line\">    file.delete();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-IO流\"><a href=\"#2-IO流\" class=\"headerlink\" title=\"2. IO流\"></a>2. IO流</h3><ul>\n<li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li>\n<li>流的分类:<ul>\n<li>根据处理数据类型的不同分为：字符流和字节流</li>\n<li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li>\n<li>操作的目标来区分:<ul>\n<li>文件流，数组流，字符串流，数据流，对象流，网络流…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO流的框架结构</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|——IO流</span><br><span class=\"line\">    |————字节流</span><br><span class=\"line\">        |————InputStream</span><br><span class=\"line\">            |————FileInputStream</span><br><span class=\"line\">            |————DataInputStream</span><br><span class=\"line\">            |————ObjectInputStream</span><br><span class=\"line\">        |————OutputStream</span><br><span class=\"line\">            |————FileOutputStream</span><br><span class=\"line\">            |————DataOutputStream</span><br><span class=\"line\">            |————ObjectOutputStream</span><br><span class=\"line\">            |————PrintStream</span><br><span class=\"line\">    |————字符流</span><br><span class=\"line\">        |————Reader</span><br><span class=\"line\">            |————BufferedReader</span><br><span class=\"line\">            |————InputStreamReader</span><br><span class=\"line\">        |————Writer</span><br><span class=\"line\">            |————BufferedWriter</span><br><span class=\"line\">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-文件流\"><a href=\"#3-文件流\" class=\"headerlink\" title=\"3. 文件流\"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p>\n<ul>\n<li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li>\n<li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li>\n<li>字节流和字符流的区别：<ul>\n<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>\n<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>\n</ul>\n</li>\n<li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li>\n<li>输入流和输出流<ul>\n<li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-字节型文件流\"><a href=\"#4-字节型文件流\" class=\"headerlink\" title=\"4. 字节型文件流\"></a>4. 字节型文件流</h3><h4 id=\"4-1-字节型文件输入流FileInputStream-读\"><a href=\"#4-1-字节型文件输入流FileInputStream-读\" class=\"headerlink\" title=\"4.1 字节型文件输入流FileInputStream(读)\"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul>\n<li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li>\n<li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li>\n<li>int count = available();   返回流管道中还有多少缓存的字节数</li>\n<li>skip(long n);跳过几个字节  读取<ul>\n<li>多线程—&gt;利用几个线程同时读取文件</li>\n</ul>\n</li>\n<li>*close()    将流管道关闭—必须要做,最好放在finally里<ul>\n<li>注意代码的健壮性，判断严谨（eg:非空判断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-字节型文件输出流FileOutputStream-写\"><a href=\"#4-2-字节型文件输出流FileOutputStream-写\" class=\"headerlink\" title=\"4.2 字节型文件输出流FileOutputStream(写)\"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul>\n<li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File参数，还有File boolean重载</li>\n<li>调用一个带String参数，还有String boolean重载</li>\n<li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int code);  将给定code对应的字符写入文件   ‘=’</li>\n<li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li>\n<li>write(byte[] b, int off, int len);</li>\n<li>flush();    将管道内的字节推入(刷新)文件</li>\n<li>close();    注意在finally中关闭</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li>\n<li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li>\n</ul>\n</blockquote>\n<ul>\n<li>设计一个文件复制的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File file, String path)</span> </span>&#123;</span><br><span class=\"line\">    FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileOutputStream fos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建输入流读取信息</span></span><br><span class=\"line\">        fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个新的File对象</span></span><br><span class=\"line\">        File newFile = <span class=\"keyword\">new</span> File(path +<span class=\"string\">\"\\\\\"</span>+ file.getName());<span class=\"comment\">//\"E:\\\\test\\\\test.txt\"</span></span><br><span class=\"line\">        <span class=\"comment\">//创建一个输出流</span></span><br><span class=\"line\">        fos = <span class=\"keyword\">new</span> FileOutputStream(newFile);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//通常1kb-8kb之间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = fis.read(b);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(count != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fos.write(b, <span class=\"number\">0</span>, count);<span class=\"comment\">//将读取到的有效字节写入</span></span><br><span class=\"line\">            fos.flush();</span><br><span class=\"line\">            count = fis.read(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"复制完毕！\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fis!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123; fis.close(); &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fos!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;fos.close();&#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-字符型文件流\"><a href=\"#5-字符型文件流\" class=\"headerlink\" title=\"5. 字符型文件流\"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p>\n<h4 id=\"5-1-字符型文件输入流FileReader-读\"><a href=\"#5-1-字符型文件输入流FileReader-读\" class=\"headerlink\" title=\"5.1 字符型文件输入流FileReader(读)\"></a>5.1 字符型文件输入流FileReader(读)</h4><ul>\n<li>FileReader类在java.io包，继承自InputStreamReader，Reader</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>read()</li>\n<li>read(char[])</li>\n<li>close()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F://test//Test.txt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    FileReader fr = <span class=\"keyword\">new</span> FileReader(file);</span><br><span class=\"line\">    <span class=\"comment\">// int code = fr.read();</span></span><br><span class=\"line\">    <span class=\"comment\">// System.out.println(code);</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = fr.read(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(c, <span class=\"number\">0</span>, count));</span><br><span class=\"line\">        count = fr.read(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-字符型文件输出流FileWriter-写\"><a href=\"#5-2-字符型文件输出流FileWriter-写\" class=\"headerlink\" title=\"5.2 字符型文件输出流FileWriter(写)\"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul>\n<li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li>\n<li>构造方法<ul>\n<li>带file参数，带file,boolean参数</li>\n<li>带String参数，带String,boolean参数</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int)</li>\n<li>write(char[])</li>\n<li>write(string)</li>\n<li>flush()，close()</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-缓冲流\"><a href=\"#6-缓冲流\" class=\"headerlink\" title=\"6. *缓冲流\"></a>6. *缓冲流</h3><ul>\n<li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul>\n<li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li>\n<li>字符缓冲流：BufferedReader，BufferedWriter</li>\n</ul>\n</li>\n<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>\n<li>缓冲流读写方法与基本的流是一致</li>\n</ul>\n<h4 id=\"6-1-字节缓冲流\"><a href=\"#6-1-字节缓冲流\" class=\"headerlink\" title=\"6.1 字节缓冲流\"></a>6.1 字节缓冲流</h4><ul>\n<li>BufferedInputStream，BufferedOutputStream</li>\n<li>构造方法<ul>\n<li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输入流</span></span><br><span class=\"line\">BufferedInputStream bis = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"bis.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输出流</span></span><br><span class=\"line\">BufferedOutputStream bos = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"bos.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符缓冲流\"><a href=\"#6-2-字符缓冲流\" class=\"headerlink\" title=\"6.2 字符缓冲流\"></a>6.2 字符缓冲流</h4><ul>\n<li>BufferedReader，BufferedWriter</li>\n<li>构造方法<ul>\n<li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输入流</span></span><br><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"br.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输出流</span></span><br><span class=\"line\">BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"bw.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li>\n<li>特有方法: <ul>\n<li>BufferedReader：public String readLine(): 读一行文字。 </li>\n<li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法，用来用户登录认证</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"F://test//User.txt\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//User.txt每行存储格式：张三-123</span></span><br><span class=\"line\">        String user = br.readLine();<span class=\"comment\">//user表示一行记录，记录账号密码</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(user!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将user信息拆分，分别与参数比较</span></span><br><span class=\"line\">            String[] value = user.split(<span class=\"string\">\"-\"</span>);<span class=\"comment\">//value[0]账号，value[1]密码</span></span><br><span class=\"line\">            System.out.println(value[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value[<span class=\"number\">0</span>].equals(username)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(value[<span class=\"number\">1</span>].equals(password)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"登录成功\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            user = br.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"账号或密码错误！\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>readLine方法演示:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class=\"line\">    bw.newLine();</span><br><span class=\"line\">    bw.write(&quot;java-888&quot;);</span><br><span class=\"line\">    bw.flush();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-转换流\"><a href=\"#7-转换流\" class=\"headerlink\" title=\"7. 转换流\"></a>7. 转换流</h3><h4 id=\"7-1-字符编码\"><a href=\"#7-1-字符编码\" class=\"headerlink\" title=\"7.1 字符编码\"></a>7.1 字符编码</h4><ul>\n<li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li>\n<li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>\n<li>常见字符集:<ul>\n<li>ASCII字符集 ：<ul>\n<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li>\n</ul>\n</li>\n<li>ISO-8859-1字符集：<ul>\n<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li>\n</ul>\n</li>\n<li>GBxxx字符集：<ul>\n<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>\n<li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li>\n</ul>\n</li>\n<li>Unicode字符集 ：<ul>\n<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>\n<li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码引出的问题<ul>\n<li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-2-InputStreamReader类\"><a href=\"#7-2-InputStreamReader类\" class=\"headerlink\" title=\"7.2 InputStreamReader类\"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>));</span><br><span class=\"line\">InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码读取:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderDemo2</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径,文件为gbk编码</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\file_gbk.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName));</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName) , <span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 定义变量,保存字符</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> read;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认编码字符流读取,乱码</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read); <span class=\"comment\">// ��Һ�</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr.close();</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定编码字符流读取,正常解析</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr2.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read);<span class=\"comment\">// 大家好</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-OutputStreamWriter类\"><a href=\"#7-3-OutputStreamWriter类\" class=\"headerlink\" title=\"7.3 OutputStreamWriter类\"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter isr = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>));</span><br><span class=\"line\">OutputStreamWriter isr2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码写出</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutputDemo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\out.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName));</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw.write(<span class=\"string\">\"你好\"</span>); <span class=\"comment\">// 保存为6个字节</span></span><br><span class=\"line\">       osw.close();</span><br><span class=\"line\"><span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">String FileName2 = <span class=\"string\">\"E:\\\\out2.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       OutputStreamWriter osw2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName2),<span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw2.write(<span class=\"string\">\"你好\"</span>);<span class=\"comment\">// 保存为4个字节</span></span><br><span class=\"line\">       osw2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-对象流\"><a href=\"#8-对象流\" class=\"headerlink\" title=\"8. 对象流\"></a>8. 对象流</h3><ul>\n<li>对象序列化和反序列化<ul>\n<li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li>\n<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li>\n<li>简单来讲<ul>\n<li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li>\n<li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li>\n<li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-ObjectOutputStream类\"><a href=\"#8-1-ObjectOutputStream类\" class=\"headerlink\" title=\"8.1 ObjectOutputStream类\"></a>8.1 ObjectOutputStream类</h3><ul>\n<li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>\n<li>构造方法<ul>\n<li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fileOut = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>序列化操作<ol>\n<li>一个对象要想序列化，必须满足两个条件:<ul>\n<li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li>\n</ul>\n</li>\n<li>写出对象方法<ul>\n<li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//满足两个条件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// transient瞬态修饰成员,不会被序列化</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//写出对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializeDemo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">  Employee e = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">  e.name = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">  e.address = <span class=\"string\">\"beiqinglu\"</span>;</span><br><span class=\"line\">  e.age = <span class=\"number\">20</span>; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建序列化流对象</span></span><br><span class=\"line\">         ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 写出对象</span></span><br><span class=\"line\">      out.writeObject(e);</span><br><span class=\"line\">      <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">      out.close();</span><br><span class=\"line\">      fileOut.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Serialized data is saved\"</span>); <span class=\"comment\">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(IOException i)   &#123;</span><br><span class=\"line\">           i.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//Serialized data is saved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-ObjectInputStream类\"><a href=\"#8-1-ObjectInputStream类\" class=\"headerlink\" title=\"8.1 ObjectInputStream类\"></a>8.1 ObjectInputStream类</h4><ul>\n<li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li>\n<li>构造方法<ul>\n<li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li>\n</ul>\n</li>\n<li>反序列化操作1<ul>\n<li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li>\n<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li>\n<li>public final Object readObject () : 读取一个对象。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializeDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">       Employee e = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建反序列化流</span></span><br><span class=\"line\">            FileInputStream fileIn = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">            ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(fileIn);</span><br><span class=\"line\">            <span class=\"comment\">// 读取一个对象</span></span><br><span class=\"line\">            e = (Employee) in.readObject();</span><br><span class=\"line\">            <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            fileIn.close();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 捕获其他异常</span></span><br><span class=\"line\">            i.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException c) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 捕获类找不到异常</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Employee class not found\"</span>);</span><br><span class=\"line\">            c.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 无异常,直接打印输出</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Name: \"</span> + e.name);<span class=\"comment\">// zhangsan</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Address: \"</span> + e.address); <span class=\"comment\">// beiqinglu</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"age: \"</span> + e.age); <span class=\"comment\">// 0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>反序列化操作2<ul>\n<li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul>\n<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>\n<li>该类包含未知数据类型 </li>\n<li>该类没有可访问的无参数构造方法 </li>\n</ul>\n</li>\n<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加入序列版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> eid; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-打印流-PrintStream类\"><a href=\"#9-打印流-PrintStream类\" class=\"headerlink\" title=\"9. 打印流(PrintStream类)\"></a>9. 打印流(PrintStream类)</h3><ul>\n<li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li>\n<li>构造方法<ul>\n<li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>)；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改变打印流向<ul>\n<li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,控制台直接输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建打印流,指定文件的名称</span></span><br><span class=\"line\">        PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class=\"line\">        System.setOut(ps);</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Properties类的使用\"><a href=\"#10-Properties类的使用\" class=\"headerlink\" title=\"10. Properties类的使用\"></a>10. Properties类的使用</h3><ul>\n<li>Java.util.Properties，主要用于读取Java的配置文件。</li>\n<li>Properties类继承自Hashtable</li>\n<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>\n<li>Properties类的主要方法：<ol>\n<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>\n<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>\n<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>\n<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>\n<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p>","more":"<ol>\n<li><a href=\"#id1\">File类</a></li>\n<li><a href=\"#id2\">IO流</a></li>\n<li><a href=\"#id3\">文件流</a></li>\n<li><a href=\"#id4\">字节型文件流</a></li>\n<li><a href=\"#id5\">字符型文件流</a></li>\n<li><a href=\"#id6\">*缓冲流</a></li>\n<li><a href=\"#id7\">转换流</a></li>\n<li><a href=\"#id8\">对象流</a></li>\n<li><a href=\"#id9\">打印流(PrintStream类)</a></li>\n<li><a href=\"#id10\">Properties类的使用</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-File类\"><a href=\"#1-File类\" class=\"headerlink\" title=\"1. File类\"></a>1. File类</h3><ul>\n<li>File与真实硬盘中的文件或文件夹  不是一个东西<ul>\n<li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li>\n</ul>\n</li>\n<li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li>\n<li>File类中的常用的方法<ul>\n<li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li>\n<li>length()，获取文件中字节的个数</li>\n<li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li>\n<li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul>\n<li>绝对路径&lt;—-&gt;相对路径</li>\n<li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li>\n<li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li>\n</ul>\n</li>\n<li>String name = getName()，获取文件的名字    Test.txt</li>\n<li><em>boolean = *</em>createNewFile()**，创建新的文件</li>\n<li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li>\n<li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li>\n<li>String pname = getParent()，获取当前file的父亲file名字</li>\n<li>*File file = getParentFile()，获取当前file的父亲file对象</li>\n<li>String[] names = list()，获取当前file的所有儿子名字</li>\n<li>*File[] files = listFiles()，获取当前file的所有儿子对象</li>\n<li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li>\n</ul>\n</li>\n<li>文件夹的路径(找父目录)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找当前file的所有父目录</span></span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\"</span>);</span><br><span class=\"line\">File pfile = file.getParentFile();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(pfile!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(pfile.getAbsolutePath());</span><br><span class=\"line\">    pfile = pfile.getParentFile();<span class=\"comment\">//再找一遍</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的遍历—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取file的子元素</span></span><br><span class=\"line\">    <span class=\"comment\">//files==null是个文件</span></span><br><span class=\"line\">    <span class=\"comment\">//files!=null是个文件夹</span></span><br><span class=\"line\">    <span class=\"comment\">//files.length!=0是一个带元素的文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();<span class=\"comment\">//test文件夹所有子元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class=\"line\">    System.out.println(file.getAbsolutePath());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的删除—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法 删除文件夹,参数 file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断file不是空文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deleteFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class=\"line\">    file.delete();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-IO流\"><a href=\"#2-IO流\" class=\"headerlink\" title=\"2. IO流\"></a>2. IO流</h3><ul>\n<li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li>\n<li>流的分类:<ul>\n<li>根据处理数据类型的不同分为：字符流和字节流</li>\n<li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li>\n<li>操作的目标来区分:<ul>\n<li>文件流，数组流，字符串流，数据流，对象流，网络流…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO流的框架结构</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|——IO流</span><br><span class=\"line\">    |————字节流</span><br><span class=\"line\">        |————InputStream</span><br><span class=\"line\">            |————FileInputStream</span><br><span class=\"line\">            |————DataInputStream</span><br><span class=\"line\">            |————ObjectInputStream</span><br><span class=\"line\">        |————OutputStream</span><br><span class=\"line\">            |————FileOutputStream</span><br><span class=\"line\">            |————DataOutputStream</span><br><span class=\"line\">            |————ObjectOutputStream</span><br><span class=\"line\">            |————PrintStream</span><br><span class=\"line\">    |————字符流</span><br><span class=\"line\">        |————Reader</span><br><span class=\"line\">            |————BufferedReader</span><br><span class=\"line\">            |————InputStreamReader</span><br><span class=\"line\">        |————Writer</span><br><span class=\"line\">            |————BufferedWriter</span><br><span class=\"line\">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-文件流\"><a href=\"#3-文件流\" class=\"headerlink\" title=\"3. 文件流\"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p>\n<ul>\n<li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li>\n<li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li>\n<li>字节流和字符流的区别：<ul>\n<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>\n<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>\n</ul>\n</li>\n<li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li>\n<li>输入流和输出流<ul>\n<li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-字节型文件流\"><a href=\"#4-字节型文件流\" class=\"headerlink\" title=\"4. 字节型文件流\"></a>4. 字节型文件流</h3><h4 id=\"4-1-字节型文件输入流FileInputStream-读\"><a href=\"#4-1-字节型文件输入流FileInputStream-读\" class=\"headerlink\" title=\"4.1 字节型文件输入流FileInputStream(读)\"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul>\n<li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li>\n<li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li>\n<li>int count = available();   返回流管道中还有多少缓存的字节数</li>\n<li>skip(long n);跳过几个字节  读取<ul>\n<li>多线程—&gt;利用几个线程同时读取文件</li>\n</ul>\n</li>\n<li>*close()    将流管道关闭—必须要做,最好放在finally里<ul>\n<li>注意代码的健壮性，判断严谨（eg:非空判断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-字节型文件输出流FileOutputStream-写\"><a href=\"#4-2-字节型文件输出流FileOutputStream-写\" class=\"headerlink\" title=\"4.2 字节型文件输出流FileOutputStream(写)\"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul>\n<li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File参数，还有File boolean重载</li>\n<li>调用一个带String参数，还有String boolean重载</li>\n<li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int code);  将给定code对应的字符写入文件   ‘=’</li>\n<li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li>\n<li>write(byte[] b, int off, int len);</li>\n<li>flush();    将管道内的字节推入(刷新)文件</li>\n<li>close();    注意在finally中关闭</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li>\n<li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li>\n</ul>\n</blockquote>\n<ul>\n<li>设计一个文件复制的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File file, String path)</span> </span>&#123;</span><br><span class=\"line\">    FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileOutputStream fos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建输入流读取信息</span></span><br><span class=\"line\">        fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个新的File对象</span></span><br><span class=\"line\">        File newFile = <span class=\"keyword\">new</span> File(path +<span class=\"string\">\"\\\\\"</span>+ file.getName());<span class=\"comment\">//\"E:\\\\test\\\\test.txt\"</span></span><br><span class=\"line\">        <span class=\"comment\">//创建一个输出流</span></span><br><span class=\"line\">        fos = <span class=\"keyword\">new</span> FileOutputStream(newFile);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//通常1kb-8kb之间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = fis.read(b);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(count != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fos.write(b, <span class=\"number\">0</span>, count);<span class=\"comment\">//将读取到的有效字节写入</span></span><br><span class=\"line\">            fos.flush();</span><br><span class=\"line\">            count = fis.read(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"复制完毕！\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fis!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123; fis.close(); &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fos!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;fos.close();&#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-字符型文件流\"><a href=\"#5-字符型文件流\" class=\"headerlink\" title=\"5. 字符型文件流\"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p>\n<h4 id=\"5-1-字符型文件输入流FileReader-读\"><a href=\"#5-1-字符型文件输入流FileReader-读\" class=\"headerlink\" title=\"5.1 字符型文件输入流FileReader(读)\"></a>5.1 字符型文件输入流FileReader(读)</h4><ul>\n<li>FileReader类在java.io包，继承自InputStreamReader，Reader</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>read()</li>\n<li>read(char[])</li>\n<li>close()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F://test//Test.txt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    FileReader fr = <span class=\"keyword\">new</span> FileReader(file);</span><br><span class=\"line\">    <span class=\"comment\">// int code = fr.read();</span></span><br><span class=\"line\">    <span class=\"comment\">// System.out.println(code);</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = fr.read(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(c, <span class=\"number\">0</span>, count));</span><br><span class=\"line\">        count = fr.read(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-字符型文件输出流FileWriter-写\"><a href=\"#5-2-字符型文件输出流FileWriter-写\" class=\"headerlink\" title=\"5.2 字符型文件输出流FileWriter(写)\"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul>\n<li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li>\n<li>构造方法<ul>\n<li>带file参数，带file,boolean参数</li>\n<li>带String参数，带String,boolean参数</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int)</li>\n<li>write(char[])</li>\n<li>write(string)</li>\n<li>flush()，close()</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-缓冲流\"><a href=\"#6-缓冲流\" class=\"headerlink\" title=\"6. *缓冲流\"></a>6. *缓冲流</h3><ul>\n<li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul>\n<li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li>\n<li>字符缓冲流：BufferedReader，BufferedWriter</li>\n</ul>\n</li>\n<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>\n<li>缓冲流读写方法与基本的流是一致</li>\n</ul>\n<h4 id=\"6-1-字节缓冲流\"><a href=\"#6-1-字节缓冲流\" class=\"headerlink\" title=\"6.1 字节缓冲流\"></a>6.1 字节缓冲流</h4><ul>\n<li>BufferedInputStream，BufferedOutputStream</li>\n<li>构造方法<ul>\n<li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输入流</span></span><br><span class=\"line\">BufferedInputStream bis = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"bis.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输出流</span></span><br><span class=\"line\">BufferedOutputStream bos = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"bos.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符缓冲流\"><a href=\"#6-2-字符缓冲流\" class=\"headerlink\" title=\"6.2 字符缓冲流\"></a>6.2 字符缓冲流</h4><ul>\n<li>BufferedReader，BufferedWriter</li>\n<li>构造方法<ul>\n<li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输入流</span></span><br><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"br.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输出流</span></span><br><span class=\"line\">BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"bw.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li>\n<li>特有方法: <ul>\n<li>BufferedReader：public String readLine(): 读一行文字。 </li>\n<li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法，用来用户登录认证</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"F://test//User.txt\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//User.txt每行存储格式：张三-123</span></span><br><span class=\"line\">        String user = br.readLine();<span class=\"comment\">//user表示一行记录，记录账号密码</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(user!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将user信息拆分，分别与参数比较</span></span><br><span class=\"line\">            String[] value = user.split(<span class=\"string\">\"-\"</span>);<span class=\"comment\">//value[0]账号，value[1]密码</span></span><br><span class=\"line\">            System.out.println(value[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value[<span class=\"number\">0</span>].equals(username)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(value[<span class=\"number\">1</span>].equals(password)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"登录成功\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            user = br.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"账号或密码错误！\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>readLine方法演示:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class=\"line\">    bw.newLine();</span><br><span class=\"line\">    bw.write(&quot;java-888&quot;);</span><br><span class=\"line\">    bw.flush();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-转换流\"><a href=\"#7-转换流\" class=\"headerlink\" title=\"7. 转换流\"></a>7. 转换流</h3><h4 id=\"7-1-字符编码\"><a href=\"#7-1-字符编码\" class=\"headerlink\" title=\"7.1 字符编码\"></a>7.1 字符编码</h4><ul>\n<li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li>\n<li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>\n<li>常见字符集:<ul>\n<li>ASCII字符集 ：<ul>\n<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li>\n</ul>\n</li>\n<li>ISO-8859-1字符集：<ul>\n<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li>\n</ul>\n</li>\n<li>GBxxx字符集：<ul>\n<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>\n<li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li>\n</ul>\n</li>\n<li>Unicode字符集 ：<ul>\n<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>\n<li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码引出的问题<ul>\n<li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-2-InputStreamReader类\"><a href=\"#7-2-InputStreamReader类\" class=\"headerlink\" title=\"7.2 InputStreamReader类\"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>));</span><br><span class=\"line\">InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码读取:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderDemo2</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径,文件为gbk编码</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\file_gbk.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName));</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName) , <span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 定义变量,保存字符</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> read;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认编码字符流读取,乱码</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read); <span class=\"comment\">// ��Һ�</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr.close();</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定编码字符流读取,正常解析</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr2.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read);<span class=\"comment\">// 大家好</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-OutputStreamWriter类\"><a href=\"#7-3-OutputStreamWriter类\" class=\"headerlink\" title=\"7.3 OutputStreamWriter类\"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter isr = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>));</span><br><span class=\"line\">OutputStreamWriter isr2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码写出</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutputDemo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\out.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName));</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw.write(<span class=\"string\">\"你好\"</span>); <span class=\"comment\">// 保存为6个字节</span></span><br><span class=\"line\">       osw.close();</span><br><span class=\"line\"><span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">String FileName2 = <span class=\"string\">\"E:\\\\out2.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       OutputStreamWriter osw2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName2),<span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw2.write(<span class=\"string\">\"你好\"</span>);<span class=\"comment\">// 保存为4个字节</span></span><br><span class=\"line\">       osw2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-对象流\"><a href=\"#8-对象流\" class=\"headerlink\" title=\"8. 对象流\"></a>8. 对象流</h3><ul>\n<li>对象序列化和反序列化<ul>\n<li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li>\n<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li>\n<li>简单来讲<ul>\n<li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li>\n<li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li>\n<li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-ObjectOutputStream类\"><a href=\"#8-1-ObjectOutputStream类\" class=\"headerlink\" title=\"8.1 ObjectOutputStream类\"></a>8.1 ObjectOutputStream类</h3><ul>\n<li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>\n<li>构造方法<ul>\n<li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fileOut = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>序列化操作<ol>\n<li>一个对象要想序列化，必须满足两个条件:<ul>\n<li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li>\n</ul>\n</li>\n<li>写出对象方法<ul>\n<li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//满足两个条件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// transient瞬态修饰成员,不会被序列化</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//写出对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializeDemo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">  Employee e = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">  e.name = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">  e.address = <span class=\"string\">\"beiqinglu\"</span>;</span><br><span class=\"line\">  e.age = <span class=\"number\">20</span>; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建序列化流对象</span></span><br><span class=\"line\">         ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 写出对象</span></span><br><span class=\"line\">      out.writeObject(e);</span><br><span class=\"line\">      <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">      out.close();</span><br><span class=\"line\">      fileOut.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Serialized data is saved\"</span>); <span class=\"comment\">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(IOException i)   &#123;</span><br><span class=\"line\">           i.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//Serialized data is saved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-ObjectInputStream类\"><a href=\"#8-1-ObjectInputStream类\" class=\"headerlink\" title=\"8.1 ObjectInputStream类\"></a>8.1 ObjectInputStream类</h4><ul>\n<li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li>\n<li>构造方法<ul>\n<li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li>\n</ul>\n</li>\n<li>反序列化操作1<ul>\n<li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li>\n<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li>\n<li>public final Object readObject () : 读取一个对象。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializeDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">       Employee e = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建反序列化流</span></span><br><span class=\"line\">            FileInputStream fileIn = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">            ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(fileIn);</span><br><span class=\"line\">            <span class=\"comment\">// 读取一个对象</span></span><br><span class=\"line\">            e = (Employee) in.readObject();</span><br><span class=\"line\">            <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            fileIn.close();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 捕获其他异常</span></span><br><span class=\"line\">            i.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException c) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 捕获类找不到异常</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Employee class not found\"</span>);</span><br><span class=\"line\">            c.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 无异常,直接打印输出</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Name: \"</span> + e.name);<span class=\"comment\">// zhangsan</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Address: \"</span> + e.address); <span class=\"comment\">// beiqinglu</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"age: \"</span> + e.age); <span class=\"comment\">// 0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>反序列化操作2<ul>\n<li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul>\n<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>\n<li>该类包含未知数据类型 </li>\n<li>该类没有可访问的无参数构造方法 </li>\n</ul>\n</li>\n<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加入序列版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> eid; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-打印流-PrintStream类\"><a href=\"#9-打印流-PrintStream类\" class=\"headerlink\" title=\"9. 打印流(PrintStream类)\"></a>9. 打印流(PrintStream类)</h3><ul>\n<li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li>\n<li>构造方法<ul>\n<li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>)；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改变打印流向<ul>\n<li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,控制台直接输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建打印流,指定文件的名称</span></span><br><span class=\"line\">        PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class=\"line\">        System.setOut(ps);</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Properties类的使用\"><a href=\"#10-Properties类的使用\" class=\"headerlink\" title=\"10. Properties类的使用\"></a>10. Properties类的使用</h3><ul>\n<li>Java.util.Properties，主要用于读取Java的配置文件。</li>\n<li>Properties类继承自Hashtable</li>\n<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>\n<li>Properties类的主要方法：<ol>\n<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>\n<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>\n<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>\n<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>\n<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>\n</ol>\n</li>\n</ul>"},{"title":"十二、JavaWeb编程基础","date":"2019-07-20T12:59:40.000Z","_content":"\n\nJavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。\n<!-- more -->\n\n1. [http协议](#id1)\n2. [Servlet](#id2)\n3. [get和post区别](#id3)\n4. [上下文对象ServletContext](#id4)\n5. [会话跟踪（状态管理）](#id5)\n6. [JSP](#id6)\n7. [内置对象(隐含对象)](#id7)\n8. [taglib指令](#id8)\n9. [JavaWeb三大组件](#id9)\n10. [JSON在Java中的使用](#id10)\n11. [AJAX](#id11)\n\n<span id=\"id1\"><span>\n### 1. http协议\n超文本传输协议，是一种应用层的网络传输协议\n\n- http协议的特点：\n  1. 简单，快速：支持多种不同的的数据提交方式，如get/post\n  2. 数据传输灵活，支持任意类型数据的传输\n  3. 无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。\n  4. 无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。\n- http协议的组成部分：\n  1. 请求：浏览器连接服务器的过程\n  2. 响应：服务器回复浏览器的过程\n- http协议的请求：\n  1. 请求头：描述客户端的信息\n  2. 请求体：GET没有请求体，请求体用于存储POST请求发送的数据。\n  3. 请求空行：请求头与请求体之间的一行空白\n  4. 请求行：描述请求方式，服务器地址，协议版本等\n- http协议的响应：\n  1. 响应头：描述服务器的信息\n  2. 响应体：响应的内容，文本，json数据等。\n  3. 响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。\n\n<span id=\"id2\"><span>\n### 2. Servlet\nservlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。\n\n#### 2.1 Servlet编写步骤：\n1. 编写一个Java类，继承HttpServlet类\n2. 重新service方法\n3. 在service方法中，对用户请求进行响应。\n\n``` java\n//注解：添加访问的网址\n@WebServlet(\"/hello\")\npublic class MyServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t@Override\n    public void service(ServletRequest req, ServletResponse res) throws IOException {\n\t\t//1.设置响应体的编码，以及内容类型\n\t\tres.setContentType(\"text/html;charset=utf-8\");\n\t\t//2.得到响应体输出的打印流\n\t\tPrintWriter out = res.getWriter();\n\t\t//3.打印文字\n\t\tout.println(\"<h1>Hello Servlet!</h1>\");\n\t}\n\n}\n```\n\n\n#### 2.2 配置ervlet类的访问网址\n- web3.0版本之后使用注解的方式配置ervlet类的访问网址\n- web3.0版本之前配置Servlet访问网址的方式：\n  * 将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 \n  * 配置Servlet类的别名，并给指定别名的Servlet添加映射网址。\n\n``` xml\n  <!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 -->\n  <servlet>\n  \t<!-- Servlet类别名，用于后续添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<!-- Servlet类全名 -->\n  \t<servlet-class>day01_Servlet.demo1.MyServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<!-- 给指定别名的Servlet添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<url-pattern>/hello</url-pattern>\n  </servlet-mapping>\n```\n\n\n#### 2.3 Servlet生命周期\n- 实例化 --> 初始化(init) --> 服务(service) --> 销毁(销毁之前调用destory) --> 不可用\n- 创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。\n- 销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。\n- tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：\n  * init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。\n  * service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。\n  * destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。\n\n\n#### 2.4 get和post区别\n- GET请求：\n  * 没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&连接键值对。\n  * 只能传输字符串类型参数\n  * 浏览器url地址最大长度4kb\n  * 数据传输时，参数在url中明文显示，不安全。\n- POST请求：\n  * 有请求体，是一个单独的数据包，用于存储请求中的多个参数\n  * 可传输任意类型的数据，进行文件上传必须POST请求\n  * 可以传递的数据大小，理论上没有上限\n  * 数据传输时在单独的数据包，较为安全。\n\n\n#### 2.5 接收请求中的参数\n1. 根据参数的名称，接收参数的单个值\n  - String value = **request.getParameter(String name)**;\n2. 根据参数的名称，接收一组参数的值\n  - String[] values = **request.getParameterValues(String name)**;\n\n``` java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  request.setCharacterEncoding(\"UTF-8\");\n  response.setContentType(\"text/html;charset=utf-8\");\n  //1.接收\n  String username = request.getParameter(\"username\");\n  String[] password = request.getParameterValues(\"password\");\n  //2.打印\n  System.out.println(\"username:\" + username);\n  System.out.println(\"password:\" + password[0]);\n  System.out.println(\"password2:\" + password[1]);\n  //3.浏览器输出\n  response.getWriter().append(\"<div>很遗憾注册失败，点击<a href=\\\"demo1.html\\\">重新注册</a></div>\");\n\n}\n```\n\n\n#### 2.6 乱码处理\n#### 2.6.1 乱码情况：\n* 浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。\n* tomcat8版本之前(不包含tomcat8版本), GET请求乱码\n* 任何版本, POST请求乱码\n\n#### 2.6.2 请求乱码处理：\n* 适用于所有乱码问题：(Tomcat8之后get无乱码)\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. 将接收到的中文乱码重新编码：\n\n``` java\nString name = request.getParameter(\"userName\");\nString userName = new String( name.getByte(\"ISO-8859-1\"),\"utf-8\");\n```\n\n* 仅适用于POST请求：\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. Servlet接收之前设置解码（需在调用request.getParameter(\"key\")之前设置）`request.setCharacterEncoding(\"utf-8\")`;\n\n#### 2.6.3 响应乱码的处理：\n* 方式一：设置响应的内容类型, 以及编码格式:`response.setContentType(\"text/html;charset=utf-8\")`;\n* 方式二：进设置编码格式, 不设置响应内容类型:`response.setCharacterEncoding(\"UTF-8\")`(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);\n\n\n#### 2.7 Servlet的创建时机\n- 通过web.xml配置Servlet, 可以修改Servlet加载的时机。\n- 可以给Servlet节点，添加`<load-on-startup>`节点来制定servlet启动顺序。\n- 节点中的值为数字：\n  * `-1`：默认-1，表示当用户第一次请求时，创建对象\n  * `>=0`：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建\n\n``` xml\n<servlet>\n    <servlet>\n        <servlet-name>s1</servlet-name>\n        <servlet-class>demo.ServletDemo</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>s1</servlet-name>\n        <url-pattern>/s1</url-pattern>\n    </servlet-mapping>\n</servlet>\n<servlet-mapping></servlet-mapping>\n```\n\n\n<span id=\"id3\"><span>\n### 3. 请求的转发与重定向\n#### 3.1 请求对象request的常用操作\n1. getMethod() : 得到请求的方式\n2. getRequestURI() : 获取浏览器请求地址\n3. getRemoteAddr() : 获取客户端ip地址\n4. getRemoteHost() : 获取客户端名称\n5. getServerName() : 获取服务器名称\n6. getServerPort() : 获取服务器端口号\n7. getQueryString() : 获取get请求参数字符串，其他请求返回null\n\n\n#### 3.1 请求的转发与重定向注意事项\n* 请求转发与重定向操作，必须要有出口。\n* 当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了\n\n\n#### 3.2 转发*\n- 一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理\n- 步骤：\n  1. 获取请求转发器：`RequestDispather rd = request.getRequestDispacher(\"转发地址\");`\n  2. 进行转发操作：`rd.forward(request, response);`\n- 因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:\n  * `request.getRequestDispacher(\"转发地址\").forward(request, response);`\n- 特点：\n  * 转发过程中，多个web组件之间共享一个请求对象request与响应对象response\n  * 在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变\n  * 转发不能跨项目实现\n  * 比重定向效率更高\n\n\n#### 3.3 重定向*\n- 一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址\n- 格式：`response.sendRedirect(\"重定向地址\")`；\n- 原理：当客户端请求服务器时，发起重定向流程：\n  1. 给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.\n  2. 当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.\n  3. 浏览器自动发起新的请求 , 跳转到新地址.\n- 特点：\n  1. 重定向会产生两个请求对象，多个请求对象中数据不互通\n  2. 浏览器地址发生了改变\n  3. 重定向可以跨域实现\n  4. 比转发效率低\n\n\n<span id=\"id4\"><span>\n### 4. 上下文对象ServletContext\n- 用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享\n- 每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。\n\n获取ServletContext对象：`ServletContext context = getServletContext();`\n\n- 常用方法\n  * context.setAttributes(String key, Objexct value); //设置替换数据\n  * context.getAttributes(String key); //获取数据\n  * context.removeAttributes(String key); //删除数据\n  * context.getRealPath(\"/\"); //获取项目运行时所在文件路径\n\n\n<span id=\"id5\"><span>\n### 5. 会话跟踪（状态管理）\n- 存在两种实现：\n  1. cookie: 将浏览器产生的状态存储在浏览器中\n  2. Session: 将浏览器产生的状态存储在服务器中\n\n- cookie技术原理：\n  * 服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，\n  * 浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来\n  * 当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器\n- Session技术原理：\n  * 当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，\n  * 该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器\n  * 浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。\n\n#### 5.1 Cookie\n- 创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对\n  * `Cookie cookie = new Cookie(String key, String value);`\n  * 注意：tomcat8.5版本之前，cookie无法出场中文\n- 通过响应对象，将cookie添加到响应头,可添加多个\n  * **response.addCookie(Cookie cookie)**;\n- 通过请求头得到cookie数组，没有则返回null\n  * **Cookie[] cookies = request.getCookies()**;\n  * 取键：cookie.getName();\n  * 取值：cookie.getValue()\n- Cookie的存储时长：\n  * cookie.setMaxAge(int 秒)；\n    + 正数：倒计时秒数\n    + 0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它\n    + 负数：默认-1，表示会话结束时自动删除（关闭浏览器）\n- Cookie的存储路径问题\n  * 存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同\n  * 为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(\"/\");\n\n#### 5.2 Cookie的优缺点\n- 缺点：\n  1. Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。\n  2. 数据存储在客户的计算机中，不安全，不建议存储安全敏感数据\n  3. 保存数据量有限制，大约4kb左右\n  3. 依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除\n- 优点：\n  1. 分散服务器的压力\n\n#### 5.3 Session\n- 获取Session\n  * 格式1：**request.getSession()**;//等价参数传true\n  * 格式2：request.getSession(boolean isNew);\n    + true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回\n    + false，根据浏览器的SessionId查找一个session，若没有就返回null\n- Session常用方法\n  * **session.setAttribute(String key, object value)**;//设置/替换值\n  * **session.getAttribute(String key)**;//获取值\n  * session.invalidate();//销毁\n- 设置session存活时长\n  * 默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。\n  * 可以通过修改配置文件，修改所有的session时长\n    + 修改`conf/web.xml`的`<session-config><session-tiomeout>数值分钟</session-tiomeout></session-config>`\n  * 可以通过session对象，修改单个对象的session时长\n    + void session.setMaxInactiveInterval(int seconds)\n\n#### 5.4 Session的优缺点\n- 缺点：\n  * 数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源\n- 优点：\n  1. 数据存储在服务器中，安全\n  2. 数据类型为Object，在Java中表示可以存储所有类型的数据\n  3. session存储的数据大小，理论上无限的。\n\n#### 5.5 Cookie和Session的使用\n- Cookie和Session不是互斥的，是相辅相成的\n- 在项目开发时：\n  * 对安全敏感的数据，存储在session中\n  * 对安全不敏感的字符串数据，可以选择存储在Cookie中\n  * 对于大的数据，应该存在数据库和文件中\n\n> 注意：cookie和session是为了管理状态而非存储数据。\n\n\n<span id=\"id6\"><span>\n### 6.JSP\n#### 6.1 JSP语法基础\n- Java Server Pages：java动态网页技术\n- JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应\n- 注意：\n  1. JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet\n  2. 执行流程：浏览器请求-->tomcat-->JSP引擎转换为Servlet-->转换的Servlet-->准备响应体-->响应给浏览器-->浏览器解析html\n\n- JSP语法结构\n  1. html代码\n  2. Java代码\n  3. Jsp特有的语法结构\n\n- Java代码声明区：指的是类的成员位置\n\n``` jsp\n<%!\n  // Java代码声明区\n%>\n```\n\n- Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来\n\n``` jsp\n<%\n  // Java代码执行区\n%>\n```\n\n- JSP输出表达式\n  * 用于快速的将Java中的数据，输出到网页中..\n  * 语法格式：`<%=数据 %>`，编译后被转换成out.print(数据)\n- JSP注释：\n  * html中可以用`<!-- -->`\n  * java中可以用`//，/**/，/** */`\n  * jsp注释`<%-- --%>`\n    + html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略\n\n#### 6.2 JSP三大指令\n* page指令\n* include指令\n* taglib指令\n\n- 指令使用格式：<%@ 指令名称 属性1=值 属性2=值 属性n=值 %>\n  *语法上，JSP允许在单个页面出现多个相同的JSP指令\n  \n##### 6.2.1 page指令\n- 用于配置页面信息\n\n``` jsp\n<%@ page\n  language=\"java\"：语言\n  contentType=\"text/html;charset=utf-8\"：响应的内容类型，以及响应的编码格式\n  pageEncoding=\"UTF-8\"：文件存储的编码格式\n  extends=\"继承的父类\"\n  buffer=\"数字/none\"：是否允许缓存，默认值8kb\n  autoFlush=\"true/false\"：是否自动清除缓存，默认true\n  session=\"true/false\"：是否提前准备session对象，默认true\n  isThreadSafe=\"true/false\"：是否线程安全的\n  import=\"java.util.List\"：用于导包，多个包使用\",\"隔开\n  errorPage=\"网址\"：当页面发生BUG后，显示哪个页面\n  isErrorPage=\"true/false\"：当前页面是否是一个错误处理页面，如果结果为true，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息\n%>\n```\n\n#### 6.3 项目发生错误时，统一的处理方式\n  1. 打开项目的web.xml\n  2. 加入子节点`<error-page><error-code>错误码</error-code><location>处理网址</location></error-page>`\n\n``` xml\n<error-page>\n    <error-code>500</error-code>\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n</error-page>\n```\n\n- include指令：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<%@ include file=\"地址\" %>`\n- include动作：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<jsp:include page=\"地址\">`\n  \n>include指令 与 include动作区别：\n- include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp => 一个Servlet）\n- include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp => 多个Servlet）\n\n\n<span id=\"id7\"><span>\n### 7.内置对象(隐含对象)\n- 在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。\n- 内置对象通常是我们会主动创建的对象\n\n#### 7.1 九大内置对象\n1. request\n  * 对象类型：java.servlet.**HttpServletRequest**\n  * request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。\n2. response\n  * 对象类型：javax.servlet.**HttpServletResponse**\n  * response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。\n3. config\n  * 对象类型：javax.servlet.**ServletConfig**\n  * 在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。\n4. out\n  * 对象类型：javax.servlet.jsp.**JspWriter**\n  * 在JSP开发过程中使用得最为频繁的对象\n5. page\n  * 对象类型：java.lang.**Object**\n  * page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。\n6. pageContext\n  * 对象类型：**pageContext**\n  * pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象\n7. session\n  * 对象类型：java.servlet.http.**HttpSession**\n  * session是与请求有关的会话期，用来表示和存储当前页面的请求信息。\n8. application\n  * 对象类型：javax.servlet.**ServletContext**\n  * 用于实现用户之间的数据共享（多使用于网络聊天系统）。\n9. exception\n  * 对象类型：java.lang.**Throwable**\n  * 作用 exception内置对象是用来处理页面出现的异常错误。\n\n#### 7.2 JSP四大域对象\n* 九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据\n* 域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：\n  1. 存储数据：setAttribute(String key, Object value);\n  2. 获取数据：Object value = getAttribute(String);\n  3. 删除数据： removeAttribute(String key);\n* 四大内置对象，分别指的是：\n  1. pageContext: (作用域：1个页面)\n    * 页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.\n  2. request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)\n    * 请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.\n  3. session: (作用域：一次会话，一次会话可能包含多个请求)\n    * 会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。\n  4. application: (域范围：一次服务，应用从启动到关闭application一直都在)\n    * Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.\n\n\n#### 7.3 EL表达式\n* 用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。\n* 格式：`${表达式}`\n* EL表达式用于运算\n  - 在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 \n* 用于取出域对象中的数据\n  - 取出数据直接输出：`${域对象中存储的键}`\n  - 如果取出的数据不存在, 则不输出 (不可能显示null)\n* 取出对象数据的属性值:\n  - 格式1： ${对象存储的键.属性名}\n  - 格式2： ${对象存储的键[\"属性名\"]}\n  - 格式3(动态取值)： ${对象存储的键[属性存储的键]}\n* 取出集合中的数据\n  - 格式: ${集合存储时的key[下标]}\n\n#### 7.4 EL表达式取出数据的流程\n* 四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.\n* 步骤:\n  1. 先从pageContext中, 寻找数据是否存在.\n  2. 如果pageContext中数据不存在, 则去request中寻找数据是否存在\n  3. 如果request 中数据不存在, 则去session中寻找数据是否存在\n  4. 如果session中数据不存在, 则去application中寻找数据是否存在\n  5. 如果application中数据不存在,则不输出任何数据.\n\n\n<span id=\"id8\"><span>\n### 8. taglib指令\n用于在JSP文件中，引入标签库文件。\n\n* 格式： `<%@ taglib prefix=\"\" uri=\"\" %>`\n  - prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：`<标签库名称:标签名>`\n  - uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性\n* JSTL(JSP Standard Tag Library): JSP标准标签库\n  + 使用时，需要引入jar文件\n  + if 标签，格式：<库名称:if text=\"${ booble }\">\n  + forEach 标签，格式：<库名称:forEach items=\"${ List }\" var=\"item\">\n* 自定义标签库:\n  1. 编写一个Java类, 继承SimpleTagSupport类.\n  2. 重写父类的doTag方法.\n  3. 在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文\n  4. 通过上下文对象, 得到JSP中的out对象, \n  5. 通过out对象,  向网页中输出内容\n  6. 编写tld文件 , 描述标签库 以及 标签.\n\n自定义标签库案例:\n``` java\npublic class MyTag1 extends SimpleTagSupport {\n    private  static ArrayList<String> data = new ArrayList<>();\n    static {\n        data.add(\"流水在碰到底处时才会释放活力。——歌德\");\n    }\n    @Override\n    public void doTag() throws JspException, IOException {\n        JspContext context = getJspContext();\n        JspWriter out = context.getOut();\n        Random r = new Random();\n        int index = r.nextInt(data.size());\n        out.println(\"<span>\"+data.get(index)+\"</span>\");\n    }\n}\n```\n``` xml\n<taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\nversion=\"2.0\">\n    <!-- 描述标签库 -->\n    <!-- 是对于标签库的介绍 -->\n    <description>我们这个标签库, 是闲的慌 , 所以写的.</description>\n    <!-- 描述标签库的名称 -->\n    <display-name>xdl</display-name>\n    <!-- 标签库的版本 -->\n    <tlib-version>11.88</tlib-version>\n    <!-- 建议的短命名称 -->\n    <short-name>xdl</short-name>\n    <!-- 标签库的表示, 用于引入时匹配标签库 -->\n    <uri>http://shuidianshuisg.com</uri>\n\n    <!-- 开始描述标签 -->\n    <tag>\n        <!-- 对于标签的介绍 -->\n        <description>这个标签用于随机向网页中, 输出一句名言</description>\n        <!-- 标签名称 -->\n        <name>heiheihei</name>\n        <!-- 标签所对应的的Java类 -->\n        <tag-class>cn.xdl.tag.MyTag1</tag-class>\n        <!-- 标签的内容 -->\n        <body-content>empty</body-content>\n    </tag>\n</taglib>\n```\n\n\n\n<span id=\"id9\"><span>\n### 9. JavaWeb三大组件(Servlet,filter,Lister)\n#### 9.1 Filter过滤器\n* 请求的过滤器，面向切面编程思想（AOP）\n* 使用步骤：\n  1. 编写一个类，实现Filter接口\n  2. 通过注解或web.xml配置过滤器规则\n* 过滤器链：\n  + 当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求\n* 过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）\n  + 注解方式：按照类名的自然顺序先后\n  + web.xml配置方式：按照web.xml配置顺序，先后执行\n* 案例：\n\n``` java\n@WebFilter(\"/home.jsp\")\npublic class AdminFilter implements Filter {\n    /**\n     * 当Filter即将销毁时执行\n     */\n    @Override\n    public void destroy() { }\n    \n    /**\n     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤\n     * 参数1.   请求对象\n     * 参数2. 响应对象\n     * 参数3.  过滤器链对象\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"过滤管理员登录的过滤器 正在执行\");\n        //1.    从请求中, 得到session\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpSession session = req.getSession();\n        //2.    判断session中是否存在username\n        Object username = session.getAttribute(\"username\");\n        //3.    如果存在, 且值为admin , 则放行 \n        if(username !=null && username.equals(\"admin\")) {\n            //放行\n            chain.doFilter(request, response);\n        }else {\n        //4.    否则拦截, 并响应, 提示请先以管理员身份登录\n            response.getWriter().append(\"<script>alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'</script>\");\n        }\n    }\n    \n    /**\n     * 当Filter初始化时 执行\n     */\n    @Override\n    public void init(FilterConfig arg0) throws ServletException { }\n}\n```\n\n* web.xml配置方式\n\n``` xml\n<filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>cn.xdl.demo1.EnCodingFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/home.jsp</url-pattern>\n</filter-mapping>\n```\n\n\n\n#### 9.2 Listener监听器\n* 监听服务器的一些状态事件，事件驱动机制。\n* 分为两类状态事件：\n  + 服务器中组件的生命周期\n  + 一些域对象中数据变化的事件\n* 监听服务器的启动与关闭：ServletContextListener\n* 监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener\n* 监听Session会话的开启与关闭：HttpSessionListener \n* 监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener \n\n\n<span id=\"id10\"><span>\n### 10. JSON在Java中的使用\n* JSON：JavaScript Object Notation\n* GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象\n\n``` java\n//引入jar文件\nGson g = new Gson();\nString str = g.toJson(Java对象);//转换JSON字符串\n类型 对象名 = g.fromJson(Json字符串, 类型.class);//转换为Java对象\n```\n\n<span id=\"id11\"><span>\n### 11. AJAX\n* 一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作\n* Ajax请求的状态（readyState）\n  + 0：正在初始化\n  + 1：请求正在发送\n  + 2：请求发送完毕\n  + 3：服务器开始响应\n  + 4：响应接收完毕，连接断开\n* Ajax响应的状态（status）\n  + 200：成功\n  + 404：找不到资源\n  + 500：服务器错误\n\n#### 11.1 GET请求AJAX\n\n``` javaScript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"地址?参数列表\");\nxhr.onreadystatechange = function(){\n  if(xhr.readyState === 4 && xhr.status === 200){\n      //通过xhr.responseText接收响应体\n  }else{\n      //失败处理\n  }\n}\nxhr.send();\n```\n\n#### 11.2 POST请求AJAX\n\n``` javaScript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"地址\");\nxhr.onreadystatechange = function(){\n  if(xhr.readyState === 4 && xhr.status === 200){\n      //通过xhr.responseText接收响应体\n  }else{\n      //失败处理\n  }\n}\n//POST请求设置请求头\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); \nxhr.send(参数列表); //发送请求参数\n```\n\n\n#### 11.2 Jquery中的AJAX\n1. `$.ajax({url,[settings]})`\n\n``` javaScript\n$.ajax({\n    url:\"请求的网址\",\n    type:\"请求方式GET/POST...\",\n    async:\"请求是否异步, 默认true\",\n    data:\"请求的参数列表, 格式与GET请求?后的格式一致\",\n    dataType:\"TEXT或JSON\",//服务器返回的数据类型\n    success:function(data){//当服务器响应状态码在200-299之间时, 这里执行\n        //参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object\n    },\n    error:function(){} //当服务器响应状态码不再200-299之间时, 这里执行\n});\n```\n\n2. `$.get(url, [data], [callback], [type])`\n\n``` javaScript\n$.get(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n});\n```\n\n3. `$.post(url, [data], [callback], [type])`\n\n``` javaScript\n$.post(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n}, \"json\");\n```\n\n4. `$.getJSON(url, [data], [callback])`\n\n``` javaScript\n$.getJSON(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n});\n```\n\n5. `jquery对象.load(url, [data], [callback])`\n- 载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。\n\n``` javaScript\n $(\"#dom\").load(\"请求的网址\", { 请求参数键值对 },function(){\n   //加载成功\n });\n```\n\n\n#### 11.3 Vue中的AJAX\n- 使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js\n- 不创建Vue对象的情况下, 使用的ajax:\n  * `Vue.http.get(\"请求地址\",[\"请求的参数\"]).then(success,error)`;\n  * `Vue.http.post(\"请求地址\",[\"请求的参数\"],{\"emulateJSON\":true}).then(success,error)`;\n- 创建Vue实例, 使用ajax\n  * `this.$http.get(\"请求地址\",[\"请求的参数\"]).then(success,error)`;\n  * `this.$http.post(\"请求地址\",[\"请求的参数\"],{\"emulateJSON\":true}).then(success,error)`;\n\n``` javaScript\n//GET请求: 传递参数列表: \n{\n    params:{\n        参数名1:值1,\n        参数名2:值2\n        ...\n    } \n}\nPOST请求: 传递参数列表:\n{\n    参数名1:值1,\n    参数名2:值2\n    ...\n}\n```\n\n- success函数 与 error函数\n  * 格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息\n  * 响应对象的常用属性:\n    1. url : 响应的网址\n    2. body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string\n    3. ok  : boolean值, 响应码在200-299之间时  为 true\n    4. status : 响应码, 例如: 200,302,404,500\n    5. statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok\n  * 响应对象的常用函数:\n    1. text() : 以字符串的形式, 返回响应体\n    2. json() : 以对象的形式, 返回响应体\n    3. blob() : 以二进制的形式 , 返回响应体.\n\n\n#### 11.4 AJAX缓存问题\n- 浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。\n- 缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。\n- 在请求地址加上随机参数可以比避免缓存，如:`\"s1.do?time=\"+new Date().getTime();`\n\n#### 11.5 AJAX跨域问题\n- 默认编写的Servlet . 不允许其他网站的ajax跨域请求.\n- 我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:\n  * `response.addHeader(\"Access-Control-allow-Origin\",\"*\")`;\n  * `response.addHeader(\"Access-Control-allow-Methods\",\"GET,POST\")`;\n\n","source":"_posts/12_JavaWeb编程基础.md","raw":"---\ntitle: 十二、JavaWeb编程基础\ndate: 2019-07-20 20:59:40\ntags: [javaEE, 后端开发]\ncategories: JavaWeb编程\n---\n\n\nJavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。\n<!-- more -->\n\n1. [http协议](#id1)\n2. [Servlet](#id2)\n3. [get和post区别](#id3)\n4. [上下文对象ServletContext](#id4)\n5. [会话跟踪（状态管理）](#id5)\n6. [JSP](#id6)\n7. [内置对象(隐含对象)](#id7)\n8. [taglib指令](#id8)\n9. [JavaWeb三大组件](#id9)\n10. [JSON在Java中的使用](#id10)\n11. [AJAX](#id11)\n\n<span id=\"id1\"><span>\n### 1. http协议\n超文本传输协议，是一种应用层的网络传输协议\n\n- http协议的特点：\n  1. 简单，快速：支持多种不同的的数据提交方式，如get/post\n  2. 数据传输灵活，支持任意类型数据的传输\n  3. 无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。\n  4. 无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。\n- http协议的组成部分：\n  1. 请求：浏览器连接服务器的过程\n  2. 响应：服务器回复浏览器的过程\n- http协议的请求：\n  1. 请求头：描述客户端的信息\n  2. 请求体：GET没有请求体，请求体用于存储POST请求发送的数据。\n  3. 请求空行：请求头与请求体之间的一行空白\n  4. 请求行：描述请求方式，服务器地址，协议版本等\n- http协议的响应：\n  1. 响应头：描述服务器的信息\n  2. 响应体：响应的内容，文本，json数据等。\n  3. 响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。\n\n<span id=\"id2\"><span>\n### 2. Servlet\nservlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。\n\n#### 2.1 Servlet编写步骤：\n1. 编写一个Java类，继承HttpServlet类\n2. 重新service方法\n3. 在service方法中，对用户请求进行响应。\n\n``` java\n//注解：添加访问的网址\n@WebServlet(\"/hello\")\npublic class MyServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t@Override\n    public void service(ServletRequest req, ServletResponse res) throws IOException {\n\t\t//1.设置响应体的编码，以及内容类型\n\t\tres.setContentType(\"text/html;charset=utf-8\");\n\t\t//2.得到响应体输出的打印流\n\t\tPrintWriter out = res.getWriter();\n\t\t//3.打印文字\n\t\tout.println(\"<h1>Hello Servlet!</h1>\");\n\t}\n\n}\n```\n\n\n#### 2.2 配置ervlet类的访问网址\n- web3.0版本之后使用注解的方式配置ervlet类的访问网址\n- web3.0版本之前配置Servlet访问网址的方式：\n  * 将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 \n  * 配置Servlet类的别名，并给指定别名的Servlet添加映射网址。\n\n``` xml\n  <!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 -->\n  <servlet>\n  \t<!-- Servlet类别名，用于后续添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<!-- Servlet类全名 -->\n  \t<servlet-class>day01_Servlet.demo1.MyServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<!-- 给指定别名的Servlet添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<url-pattern>/hello</url-pattern>\n  </servlet-mapping>\n```\n\n\n#### 2.3 Servlet生命周期\n- 实例化 --> 初始化(init) --> 服务(service) --> 销毁(销毁之前调用destory) --> 不可用\n- 创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。\n- 销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。\n- tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：\n  * init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。\n  * service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。\n  * destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。\n\n\n#### 2.4 get和post区别\n- GET请求：\n  * 没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&连接键值对。\n  * 只能传输字符串类型参数\n  * 浏览器url地址最大长度4kb\n  * 数据传输时，参数在url中明文显示，不安全。\n- POST请求：\n  * 有请求体，是一个单独的数据包，用于存储请求中的多个参数\n  * 可传输任意类型的数据，进行文件上传必须POST请求\n  * 可以传递的数据大小，理论上没有上限\n  * 数据传输时在单独的数据包，较为安全。\n\n\n#### 2.5 接收请求中的参数\n1. 根据参数的名称，接收参数的单个值\n  - String value = **request.getParameter(String name)**;\n2. 根据参数的名称，接收一组参数的值\n  - String[] values = **request.getParameterValues(String name)**;\n\n``` java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  request.setCharacterEncoding(\"UTF-8\");\n  response.setContentType(\"text/html;charset=utf-8\");\n  //1.接收\n  String username = request.getParameter(\"username\");\n  String[] password = request.getParameterValues(\"password\");\n  //2.打印\n  System.out.println(\"username:\" + username);\n  System.out.println(\"password:\" + password[0]);\n  System.out.println(\"password2:\" + password[1]);\n  //3.浏览器输出\n  response.getWriter().append(\"<div>很遗憾注册失败，点击<a href=\\\"demo1.html\\\">重新注册</a></div>\");\n\n}\n```\n\n\n#### 2.6 乱码处理\n#### 2.6.1 乱码情况：\n* 浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。\n* tomcat8版本之前(不包含tomcat8版本), GET请求乱码\n* 任何版本, POST请求乱码\n\n#### 2.6.2 请求乱码处理：\n* 适用于所有乱码问题：(Tomcat8之后get无乱码)\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. 将接收到的中文乱码重新编码：\n\n``` java\nString name = request.getParameter(\"userName\");\nString userName = new String( name.getByte(\"ISO-8859-1\"),\"utf-8\");\n```\n\n* 仅适用于POST请求：\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. Servlet接收之前设置解码（需在调用request.getParameter(\"key\")之前设置）`request.setCharacterEncoding(\"utf-8\")`;\n\n#### 2.6.3 响应乱码的处理：\n* 方式一：设置响应的内容类型, 以及编码格式:`response.setContentType(\"text/html;charset=utf-8\")`;\n* 方式二：进设置编码格式, 不设置响应内容类型:`response.setCharacterEncoding(\"UTF-8\")`(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);\n\n\n#### 2.7 Servlet的创建时机\n- 通过web.xml配置Servlet, 可以修改Servlet加载的时机。\n- 可以给Servlet节点，添加`<load-on-startup>`节点来制定servlet启动顺序。\n- 节点中的值为数字：\n  * `-1`：默认-1，表示当用户第一次请求时，创建对象\n  * `>=0`：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建\n\n``` xml\n<servlet>\n    <servlet>\n        <servlet-name>s1</servlet-name>\n        <servlet-class>demo.ServletDemo</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>s1</servlet-name>\n        <url-pattern>/s1</url-pattern>\n    </servlet-mapping>\n</servlet>\n<servlet-mapping></servlet-mapping>\n```\n\n\n<span id=\"id3\"><span>\n### 3. 请求的转发与重定向\n#### 3.1 请求对象request的常用操作\n1. getMethod() : 得到请求的方式\n2. getRequestURI() : 获取浏览器请求地址\n3. getRemoteAddr() : 获取客户端ip地址\n4. getRemoteHost() : 获取客户端名称\n5. getServerName() : 获取服务器名称\n6. getServerPort() : 获取服务器端口号\n7. getQueryString() : 获取get请求参数字符串，其他请求返回null\n\n\n#### 3.1 请求的转发与重定向注意事项\n* 请求转发与重定向操作，必须要有出口。\n* 当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了\n\n\n#### 3.2 转发*\n- 一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理\n- 步骤：\n  1. 获取请求转发器：`RequestDispather rd = request.getRequestDispacher(\"转发地址\");`\n  2. 进行转发操作：`rd.forward(request, response);`\n- 因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:\n  * `request.getRequestDispacher(\"转发地址\").forward(request, response);`\n- 特点：\n  * 转发过程中，多个web组件之间共享一个请求对象request与响应对象response\n  * 在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变\n  * 转发不能跨项目实现\n  * 比重定向效率更高\n\n\n#### 3.3 重定向*\n- 一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址\n- 格式：`response.sendRedirect(\"重定向地址\")`；\n- 原理：当客户端请求服务器时，发起重定向流程：\n  1. 给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.\n  2. 当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.\n  3. 浏览器自动发起新的请求 , 跳转到新地址.\n- 特点：\n  1. 重定向会产生两个请求对象，多个请求对象中数据不互通\n  2. 浏览器地址发生了改变\n  3. 重定向可以跨域实现\n  4. 比转发效率低\n\n\n<span id=\"id4\"><span>\n### 4. 上下文对象ServletContext\n- 用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享\n- 每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。\n\n获取ServletContext对象：`ServletContext context = getServletContext();`\n\n- 常用方法\n  * context.setAttributes(String key, Objexct value); //设置替换数据\n  * context.getAttributes(String key); //获取数据\n  * context.removeAttributes(String key); //删除数据\n  * context.getRealPath(\"/\"); //获取项目运行时所在文件路径\n\n\n<span id=\"id5\"><span>\n### 5. 会话跟踪（状态管理）\n- 存在两种实现：\n  1. cookie: 将浏览器产生的状态存储在浏览器中\n  2. Session: 将浏览器产生的状态存储在服务器中\n\n- cookie技术原理：\n  * 服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，\n  * 浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来\n  * 当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器\n- Session技术原理：\n  * 当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，\n  * 该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器\n  * 浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。\n\n#### 5.1 Cookie\n- 创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对\n  * `Cookie cookie = new Cookie(String key, String value);`\n  * 注意：tomcat8.5版本之前，cookie无法出场中文\n- 通过响应对象，将cookie添加到响应头,可添加多个\n  * **response.addCookie(Cookie cookie)**;\n- 通过请求头得到cookie数组，没有则返回null\n  * **Cookie[] cookies = request.getCookies()**;\n  * 取键：cookie.getName();\n  * 取值：cookie.getValue()\n- Cookie的存储时长：\n  * cookie.setMaxAge(int 秒)；\n    + 正数：倒计时秒数\n    + 0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它\n    + 负数：默认-1，表示会话结束时自动删除（关闭浏览器）\n- Cookie的存储路径问题\n  * 存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同\n  * 为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(\"/\");\n\n#### 5.2 Cookie的优缺点\n- 缺点：\n  1. Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。\n  2. 数据存储在客户的计算机中，不安全，不建议存储安全敏感数据\n  3. 保存数据量有限制，大约4kb左右\n  3. 依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除\n- 优点：\n  1. 分散服务器的压力\n\n#### 5.3 Session\n- 获取Session\n  * 格式1：**request.getSession()**;//等价参数传true\n  * 格式2：request.getSession(boolean isNew);\n    + true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回\n    + false，根据浏览器的SessionId查找一个session，若没有就返回null\n- Session常用方法\n  * **session.setAttribute(String key, object value)**;//设置/替换值\n  * **session.getAttribute(String key)**;//获取值\n  * session.invalidate();//销毁\n- 设置session存活时长\n  * 默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。\n  * 可以通过修改配置文件，修改所有的session时长\n    + 修改`conf/web.xml`的`<session-config><session-tiomeout>数值分钟</session-tiomeout></session-config>`\n  * 可以通过session对象，修改单个对象的session时长\n    + void session.setMaxInactiveInterval(int seconds)\n\n#### 5.4 Session的优缺点\n- 缺点：\n  * 数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源\n- 优点：\n  1. 数据存储在服务器中，安全\n  2. 数据类型为Object，在Java中表示可以存储所有类型的数据\n  3. session存储的数据大小，理论上无限的。\n\n#### 5.5 Cookie和Session的使用\n- Cookie和Session不是互斥的，是相辅相成的\n- 在项目开发时：\n  * 对安全敏感的数据，存储在session中\n  * 对安全不敏感的字符串数据，可以选择存储在Cookie中\n  * 对于大的数据，应该存在数据库和文件中\n\n> 注意：cookie和session是为了管理状态而非存储数据。\n\n\n<span id=\"id6\"><span>\n### 6.JSP\n#### 6.1 JSP语法基础\n- Java Server Pages：java动态网页技术\n- JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应\n- 注意：\n  1. JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet\n  2. 执行流程：浏览器请求-->tomcat-->JSP引擎转换为Servlet-->转换的Servlet-->准备响应体-->响应给浏览器-->浏览器解析html\n\n- JSP语法结构\n  1. html代码\n  2. Java代码\n  3. Jsp特有的语法结构\n\n- Java代码声明区：指的是类的成员位置\n\n``` jsp\n<%!\n  // Java代码声明区\n%>\n```\n\n- Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来\n\n``` jsp\n<%\n  // Java代码执行区\n%>\n```\n\n- JSP输出表达式\n  * 用于快速的将Java中的数据，输出到网页中..\n  * 语法格式：`<%=数据 %>`，编译后被转换成out.print(数据)\n- JSP注释：\n  * html中可以用`<!-- -->`\n  * java中可以用`//，/**/，/** */`\n  * jsp注释`<%-- --%>`\n    + html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略\n\n#### 6.2 JSP三大指令\n* page指令\n* include指令\n* taglib指令\n\n- 指令使用格式：<%@ 指令名称 属性1=值 属性2=值 属性n=值 %>\n  *语法上，JSP允许在单个页面出现多个相同的JSP指令\n  \n##### 6.2.1 page指令\n- 用于配置页面信息\n\n``` jsp\n<%@ page\n  language=\"java\"：语言\n  contentType=\"text/html;charset=utf-8\"：响应的内容类型，以及响应的编码格式\n  pageEncoding=\"UTF-8\"：文件存储的编码格式\n  extends=\"继承的父类\"\n  buffer=\"数字/none\"：是否允许缓存，默认值8kb\n  autoFlush=\"true/false\"：是否自动清除缓存，默认true\n  session=\"true/false\"：是否提前准备session对象，默认true\n  isThreadSafe=\"true/false\"：是否线程安全的\n  import=\"java.util.List\"：用于导包，多个包使用\",\"隔开\n  errorPage=\"网址\"：当页面发生BUG后，显示哪个页面\n  isErrorPage=\"true/false\"：当前页面是否是一个错误处理页面，如果结果为true，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息\n%>\n```\n\n#### 6.3 项目发生错误时，统一的处理方式\n  1. 打开项目的web.xml\n  2. 加入子节点`<error-page><error-code>错误码</error-code><location>处理网址</location></error-page>`\n\n``` xml\n<error-page>\n    <error-code>500</error-code>\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n</error-page>\n```\n\n- include指令：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<%@ include file=\"地址\" %>`\n- include动作：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<jsp:include page=\"地址\">`\n  \n>include指令 与 include动作区别：\n- include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp => 一个Servlet）\n- include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp => 多个Servlet）\n\n\n<span id=\"id7\"><span>\n### 7.内置对象(隐含对象)\n- 在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。\n- 内置对象通常是我们会主动创建的对象\n\n#### 7.1 九大内置对象\n1. request\n  * 对象类型：java.servlet.**HttpServletRequest**\n  * request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。\n2. response\n  * 对象类型：javax.servlet.**HttpServletResponse**\n  * response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。\n3. config\n  * 对象类型：javax.servlet.**ServletConfig**\n  * 在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。\n4. out\n  * 对象类型：javax.servlet.jsp.**JspWriter**\n  * 在JSP开发过程中使用得最为频繁的对象\n5. page\n  * 对象类型：java.lang.**Object**\n  * page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。\n6. pageContext\n  * 对象类型：**pageContext**\n  * pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象\n7. session\n  * 对象类型：java.servlet.http.**HttpSession**\n  * session是与请求有关的会话期，用来表示和存储当前页面的请求信息。\n8. application\n  * 对象类型：javax.servlet.**ServletContext**\n  * 用于实现用户之间的数据共享（多使用于网络聊天系统）。\n9. exception\n  * 对象类型：java.lang.**Throwable**\n  * 作用 exception内置对象是用来处理页面出现的异常错误。\n\n#### 7.2 JSP四大域对象\n* 九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据\n* 域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：\n  1. 存储数据：setAttribute(String key, Object value);\n  2. 获取数据：Object value = getAttribute(String);\n  3. 删除数据： removeAttribute(String key);\n* 四大内置对象，分别指的是：\n  1. pageContext: (作用域：1个页面)\n    * 页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.\n  2. request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)\n    * 请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.\n  3. session: (作用域：一次会话，一次会话可能包含多个请求)\n    * 会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。\n  4. application: (域范围：一次服务，应用从启动到关闭application一直都在)\n    * Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.\n\n\n#### 7.3 EL表达式\n* 用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。\n* 格式：`${表达式}`\n* EL表达式用于运算\n  - 在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 \n* 用于取出域对象中的数据\n  - 取出数据直接输出：`${域对象中存储的键}`\n  - 如果取出的数据不存在, 则不输出 (不可能显示null)\n* 取出对象数据的属性值:\n  - 格式1： ${对象存储的键.属性名}\n  - 格式2： ${对象存储的键[\"属性名\"]}\n  - 格式3(动态取值)： ${对象存储的键[属性存储的键]}\n* 取出集合中的数据\n  - 格式: ${集合存储时的key[下标]}\n\n#### 7.4 EL表达式取出数据的流程\n* 四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.\n* 步骤:\n  1. 先从pageContext中, 寻找数据是否存在.\n  2. 如果pageContext中数据不存在, 则去request中寻找数据是否存在\n  3. 如果request 中数据不存在, 则去session中寻找数据是否存在\n  4. 如果session中数据不存在, 则去application中寻找数据是否存在\n  5. 如果application中数据不存在,则不输出任何数据.\n\n\n<span id=\"id8\"><span>\n### 8. taglib指令\n用于在JSP文件中，引入标签库文件。\n\n* 格式： `<%@ taglib prefix=\"\" uri=\"\" %>`\n  - prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：`<标签库名称:标签名>`\n  - uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性\n* JSTL(JSP Standard Tag Library): JSP标准标签库\n  + 使用时，需要引入jar文件\n  + if 标签，格式：<库名称:if text=\"${ booble }\">\n  + forEach 标签，格式：<库名称:forEach items=\"${ List }\" var=\"item\">\n* 自定义标签库:\n  1. 编写一个Java类, 继承SimpleTagSupport类.\n  2. 重写父类的doTag方法.\n  3. 在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文\n  4. 通过上下文对象, 得到JSP中的out对象, \n  5. 通过out对象,  向网页中输出内容\n  6. 编写tld文件 , 描述标签库 以及 标签.\n\n自定义标签库案例:\n``` java\npublic class MyTag1 extends SimpleTagSupport {\n    private  static ArrayList<String> data = new ArrayList<>();\n    static {\n        data.add(\"流水在碰到底处时才会释放活力。——歌德\");\n    }\n    @Override\n    public void doTag() throws JspException, IOException {\n        JspContext context = getJspContext();\n        JspWriter out = context.getOut();\n        Random r = new Random();\n        int index = r.nextInt(data.size());\n        out.println(\"<span>\"+data.get(index)+\"</span>\");\n    }\n}\n```\n``` xml\n<taglib xmlns=\"http://java.sun.com/xml/ns/j2ee\"\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"\nversion=\"2.0\">\n    <!-- 描述标签库 -->\n    <!-- 是对于标签库的介绍 -->\n    <description>我们这个标签库, 是闲的慌 , 所以写的.</description>\n    <!-- 描述标签库的名称 -->\n    <display-name>xdl</display-name>\n    <!-- 标签库的版本 -->\n    <tlib-version>11.88</tlib-version>\n    <!-- 建议的短命名称 -->\n    <short-name>xdl</short-name>\n    <!-- 标签库的表示, 用于引入时匹配标签库 -->\n    <uri>http://shuidianshuisg.com</uri>\n\n    <!-- 开始描述标签 -->\n    <tag>\n        <!-- 对于标签的介绍 -->\n        <description>这个标签用于随机向网页中, 输出一句名言</description>\n        <!-- 标签名称 -->\n        <name>heiheihei</name>\n        <!-- 标签所对应的的Java类 -->\n        <tag-class>cn.xdl.tag.MyTag1</tag-class>\n        <!-- 标签的内容 -->\n        <body-content>empty</body-content>\n    </tag>\n</taglib>\n```\n\n\n\n<span id=\"id9\"><span>\n### 9. JavaWeb三大组件(Servlet,filter,Lister)\n#### 9.1 Filter过滤器\n* 请求的过滤器，面向切面编程思想（AOP）\n* 使用步骤：\n  1. 编写一个类，实现Filter接口\n  2. 通过注解或web.xml配置过滤器规则\n* 过滤器链：\n  + 当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求\n* 过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）\n  + 注解方式：按照类名的自然顺序先后\n  + web.xml配置方式：按照web.xml配置顺序，先后执行\n* 案例：\n\n``` java\n@WebFilter(\"/home.jsp\")\npublic class AdminFilter implements Filter {\n    /**\n     * 当Filter即将销毁时执行\n     */\n    @Override\n    public void destroy() { }\n    \n    /**\n     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤\n     * 参数1.   请求对象\n     * 参数2. 响应对象\n     * 参数3.  过滤器链对象\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n            throws IOException, ServletException {\n        System.out.println(\"过滤管理员登录的过滤器 正在执行\");\n        //1.    从请求中, 得到session\n        HttpServletRequest req = (HttpServletRequest) request;\n        HttpSession session = req.getSession();\n        //2.    判断session中是否存在username\n        Object username = session.getAttribute(\"username\");\n        //3.    如果存在, 且值为admin , 则放行 \n        if(username !=null && username.equals(\"admin\")) {\n            //放行\n            chain.doFilter(request, response);\n        }else {\n        //4.    否则拦截, 并响应, 提示请先以管理员身份登录\n            response.getWriter().append(\"<script>alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'</script>\");\n        }\n    }\n    \n    /**\n     * 当Filter初始化时 执行\n     */\n    @Override\n    public void init(FilterConfig arg0) throws ServletException { }\n}\n```\n\n* web.xml配置方式\n\n``` xml\n<filter>\n    <filter-name>encoding</filter-name>\n    <filter-class>cn.xdl.demo1.EnCodingFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>encoding</filter-name>\n    <url-pattern>/home.jsp</url-pattern>\n</filter-mapping>\n```\n\n\n\n#### 9.2 Listener监听器\n* 监听服务器的一些状态事件，事件驱动机制。\n* 分为两类状态事件：\n  + 服务器中组件的生命周期\n  + 一些域对象中数据变化的事件\n* 监听服务器的启动与关闭：ServletContextListener\n* 监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener\n* 监听Session会话的开启与关闭：HttpSessionListener \n* 监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener \n\n\n<span id=\"id10\"><span>\n### 10. JSON在Java中的使用\n* JSON：JavaScript Object Notation\n* GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象\n\n``` java\n//引入jar文件\nGson g = new Gson();\nString str = g.toJson(Java对象);//转换JSON字符串\n类型 对象名 = g.fromJson(Json字符串, 类型.class);//转换为Java对象\n```\n\n<span id=\"id11\"><span>\n### 11. AJAX\n* 一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作\n* Ajax请求的状态（readyState）\n  + 0：正在初始化\n  + 1：请求正在发送\n  + 2：请求发送完毕\n  + 3：服务器开始响应\n  + 4：响应接收完毕，连接断开\n* Ajax响应的状态（status）\n  + 200：成功\n  + 404：找不到资源\n  + 500：服务器错误\n\n#### 11.1 GET请求AJAX\n\n``` javaScript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"地址?参数列表\");\nxhr.onreadystatechange = function(){\n  if(xhr.readyState === 4 && xhr.status === 200){\n      //通过xhr.responseText接收响应体\n  }else{\n      //失败处理\n  }\n}\nxhr.send();\n```\n\n#### 11.2 POST请求AJAX\n\n``` javaScript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"地址\");\nxhr.onreadystatechange = function(){\n  if(xhr.readyState === 4 && xhr.status === 200){\n      //通过xhr.responseText接收响应体\n  }else{\n      //失败处理\n  }\n}\n//POST请求设置请求头\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); \nxhr.send(参数列表); //发送请求参数\n```\n\n\n#### 11.2 Jquery中的AJAX\n1. `$.ajax({url,[settings]})`\n\n``` javaScript\n$.ajax({\n    url:\"请求的网址\",\n    type:\"请求方式GET/POST...\",\n    async:\"请求是否异步, 默认true\",\n    data:\"请求的参数列表, 格式与GET请求?后的格式一致\",\n    dataType:\"TEXT或JSON\",//服务器返回的数据类型\n    success:function(data){//当服务器响应状态码在200-299之间时, 这里执行\n        //参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object\n    },\n    error:function(){} //当服务器响应状态码不再200-299之间时, 这里执行\n});\n```\n\n2. `$.get(url, [data], [callback], [type])`\n\n``` javaScript\n$.get(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n});\n```\n\n3. `$.post(url, [data], [callback], [type])`\n\n``` javaScript\n$.post(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n}, \"json\");\n```\n\n4. `$.getJSON(url, [data], [callback])`\n\n``` javaScript\n$.getJSON(\"请求的网址\", { 请求参数键值对 },function(data){\n    //data:响应的内容\n});\n```\n\n5. `jquery对象.load(url, [data], [callback])`\n- 载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。\n\n``` javaScript\n $(\"#dom\").load(\"请求的网址\", { 请求参数键值对 },function(){\n   //加载成功\n });\n```\n\n\n#### 11.3 Vue中的AJAX\n- 使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js\n- 不创建Vue对象的情况下, 使用的ajax:\n  * `Vue.http.get(\"请求地址\",[\"请求的参数\"]).then(success,error)`;\n  * `Vue.http.post(\"请求地址\",[\"请求的参数\"],{\"emulateJSON\":true}).then(success,error)`;\n- 创建Vue实例, 使用ajax\n  * `this.$http.get(\"请求地址\",[\"请求的参数\"]).then(success,error)`;\n  * `this.$http.post(\"请求地址\",[\"请求的参数\"],{\"emulateJSON\":true}).then(success,error)`;\n\n``` javaScript\n//GET请求: 传递参数列表: \n{\n    params:{\n        参数名1:值1,\n        参数名2:值2\n        ...\n    } \n}\nPOST请求: 传递参数列表:\n{\n    参数名1:值1,\n    参数名2:值2\n    ...\n}\n```\n\n- success函数 与 error函数\n  * 格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息\n  * 响应对象的常用属性:\n    1. url : 响应的网址\n    2. body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string\n    3. ok  : boolean值, 响应码在200-299之间时  为 true\n    4. status : 响应码, 例如: 200,302,404,500\n    5. statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok\n  * 响应对象的常用函数:\n    1. text() : 以字符串的形式, 返回响应体\n    2. json() : 以对象的形式, 返回响应体\n    3. blob() : 以二进制的形式 , 返回响应体.\n\n\n#### 11.4 AJAX缓存问题\n- 浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。\n- 缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。\n- 在请求地址加上随机参数可以比避免缓存，如:`\"s1.do?time=\"+new Date().getTime();`\n\n#### 11.5 AJAX跨域问题\n- 默认编写的Servlet . 不允许其他网站的ajax跨域请求.\n- 我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:\n  * `response.addHeader(\"Access-Control-allow-Origin\",\"*\")`;\n  * `response.addHeader(\"Access-Control-allow-Methods\",\"GET,POST\")`;\n\n","slug":"12_JavaWeb编程基础","published":1,"updated":"2019-07-25T11:59:55.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjztylobv0045yot3abh06uyd","content":"<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">http协议</a></li>\n<li><a href=\"#id2\">Servlet</a></li>\n<li><a href=\"#id3\">get和post区别</a></li>\n<li><a href=\"#id4\">上下文对象ServletContext</a></li>\n<li><a href=\"#id5\">会话跟踪（状态管理）</a></li>\n<li><a href=\"#id6\">JSP</a></li>\n<li><a href=\"#id7\">内置对象(隐含对象)</a></li>\n<li><a href=\"#id8\">taglib指令</a></li>\n<li><a href=\"#id9\">JavaWeb三大组件</a></li>\n<li><a href=\"#id10\">JSON在Java中的使用</a></li>\n<li><a href=\"#id11\">AJAX</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-http协议\"><a href=\"#1-http协议\" class=\"headerlink\" title=\"1. http协议\"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p>\n<ul>\n<li>http协议的特点：<ol>\n<li>简单，快速：支持多种不同的的数据提交方式，如get/post</li>\n<li>数据传输灵活，支持任意类型数据的传输</li>\n<li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li>\n<li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li>\n</ol>\n</li>\n<li>http协议的组成部分：<ol>\n<li>请求：浏览器连接服务器的过程</li>\n<li>响应：服务器回复浏览器的过程</li>\n</ol>\n</li>\n<li>http协议的请求：<ol>\n<li>请求头：描述客户端的信息</li>\n<li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li>\n<li>请求空行：请求头与请求体之间的一行空白</li>\n<li>请求行：描述请求方式，服务器地址，协议版本等</li>\n</ol>\n</li>\n<li>http协议的响应：<ol>\n<li>响应头：描述服务器的信息</li>\n<li>响应体：响应的内容，文本，json数据等。</li>\n<li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Servlet\"><a href=\"#2-Servlet\" class=\"headerlink\" title=\"2. Servlet\"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p>\n<h4 id=\"2-1-Servlet编写步骤：\"><a href=\"#2-1-Servlet编写步骤：\" class=\"headerlink\" title=\"2.1 Servlet编写步骤：\"></a>2.1 Servlet编写步骤：</h4><ol>\n<li>编写一个Java类，继承HttpServlet类</li>\n<li>重新service方法</li>\n<li>在service方法中，对用户请求进行响应。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解：添加访问的网址</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1.设置响应体的编码，以及内容类型</span></span><br><span class=\"line\">\t\tres.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2.得到响应体输出的打印流</span></span><br><span class=\"line\">\t\tPrintWriter out = res.getWriter();</span><br><span class=\"line\">\t\t<span class=\"comment\">//3.打印文字</span></span><br><span class=\"line\">\t\tout.println(<span class=\"string\">\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-配置ervlet类的访问网址\"><a href=\"#2-2-配置ervlet类的访问网址\" class=\"headerlink\" title=\"2.2 配置ervlet类的访问网址\"></a>2.2 配置ervlet类的访问网址</h4><ul>\n<li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li>\n<li>web3.0版本之前配置Servlet访问网址的方式：<ul>\n<li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li>\n<li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-Servlet生命周期\"><a href=\"#2-3-Servlet生命周期\" class=\"headerlink\" title=\"2.3 Servlet生命周期\"></a>2.3 Servlet生命周期</h4><ul>\n<li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li>\n<li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li>\n<li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li>\n<li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul>\n<li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li>\n<li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li>\n<li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-get和post区别\"><a href=\"#2-4-get和post区别\" class=\"headerlink\" title=\"2.4 get和post区别\"></a>2.4 get和post区别</h4><ul>\n<li>GET请求：<ul>\n<li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li>\n<li>只能传输字符串类型参数</li>\n<li>浏览器url地址最大长度4kb</li>\n<li>数据传输时，参数在url中明文显示，不安全。</li>\n</ul>\n</li>\n<li>POST请求：<ul>\n<li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li>\n<li>可传输任意类型的数据，进行文件上传必须POST请求</li>\n<li>可以传递的数据大小，理论上没有上限</li>\n<li>数据传输时在单独的数据包，较为安全。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-接收请求中的参数\"><a href=\"#2-5-接收请求中的参数\" class=\"headerlink\" title=\"2.5 接收请求中的参数\"></a>2.5 接收请求中的参数</h4><ol>\n<li>根据参数的名称，接收参数的单个值<ul>\n<li>String value = <strong>request.getParameter(String name)</strong>;</li>\n</ul>\n</li>\n<li>根据参数的名称，接收一组参数的值<ul>\n<li>String[] values = <strong>request.getParameterValues(String name)</strong>;</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">  request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">  response.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//1.接收</span></span><br><span class=\"line\">  String username = request.getParameter(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">  String[] password = request.getParameterValues(<span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//2.打印</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password:\"</span> + password[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password2:\"</span> + password[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"comment\">//3.浏览器输出</span></span><br><span class=\"line\">  response.getWriter().append(<span class=\"string\">\"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\\\"demo1.html\\\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-乱码处理\"><a href=\"#2-6-乱码处理\" class=\"headerlink\" title=\"2.6 乱码处理\"></a>2.6 乱码处理</h4><h4 id=\"2-6-1-乱码情况：\"><a href=\"#2-6-1-乱码情况：\" class=\"headerlink\" title=\"2.6.1 乱码情况：\"></a>2.6.1 乱码情况：</h4><ul>\n<li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li>\n<li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li>\n<li>任何版本, POST请求乱码</li>\n</ul>\n<h4 id=\"2-6-2-请求乱码处理：\"><a href=\"#2-6-2-请求乱码处理：\" class=\"headerlink\" title=\"2.6.2 请求乱码处理：\"></a>2.6.2 请求乱码处理：</h4><ul>\n<li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>将接收到的中文乱码重新编码：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = request.getParameter(<span class=\"string\">\"userName\"</span>);</span><br><span class=\"line\">String userName = <span class=\"keyword\">new</span> String( name.getByte(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"utf-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>仅适用于POST请求：<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-6-3-响应乱码的处理：\"><a href=\"#2-6-3-响应乱码的处理：\" class=\"headerlink\" title=\"2.6.3 响应乱码的处理：\"></a>2.6.3 响应乱码的处理：</h4><ul>\n<li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li>\n<li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li>\n</ul>\n<h4 id=\"2-7-Servlet的创建时机\"><a href=\"#2-7-Servlet的创建时机\" class=\"headerlink\" title=\"2.7 Servlet的创建时机\"></a>2.7 Servlet的创建时机</h4><ul>\n<li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li>\n<li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li>\n<li>节点中的值为数字：<ul>\n<li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li>\n<li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>demo.ServletDemo<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/s1<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-请求的转发与重定向\"><a href=\"#3-请求的转发与重定向\" class=\"headerlink\" title=\"3. 请求的转发与重定向\"></a>3. 请求的转发与重定向</h3><h4 id=\"3-1-请求对象request的常用操作\"><a href=\"#3-1-请求对象request的常用操作\" class=\"headerlink\" title=\"3.1 请求对象request的常用操作\"></a>3.1 请求对象request的常用操作</h4><ol>\n<li>getMethod() : 得到请求的方式</li>\n<li>getRequestURI() : 获取浏览器请求地址</li>\n<li>getRemoteAddr() : 获取客户端ip地址</li>\n<li>getRemoteHost() : 获取客户端名称</li>\n<li>getServerName() : 获取服务器名称</li>\n<li>getServerPort() : 获取服务器端口号</li>\n<li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li>\n</ol>\n<h4 id=\"3-1-请求的转发与重定向注意事项\"><a href=\"#3-1-请求的转发与重定向注意事项\" class=\"headerlink\" title=\"3.1 请求的转发与重定向注意事项\"></a>3.1 请求的转发与重定向注意事项</h4><ul>\n<li>请求转发与重定向操作，必须要有出口。</li>\n<li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li>\n</ul>\n<h4 id=\"3-2-转发\"><a href=\"#3-2-转发\" class=\"headerlink\" title=\"3.2 转发*\"></a>3.2 转发*</h4><ul>\n<li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li>\n<li>步骤：<ol>\n<li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li>\n<li>进行转发操作：<code>rd.forward(request, response);</code></li>\n</ol>\n</li>\n<li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul>\n<li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li>\n<li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li>\n<li>转发不能跨项目实现</li>\n<li>比重定向效率更高</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-重定向\"><a href=\"#3-3-重定向\" class=\"headerlink\" title=\"3.3 重定向*\"></a>3.3 重定向*</h4><ul>\n<li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li>\n<li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li>\n<li>原理：当客户端请求服务器时，发起重定向流程：<ol>\n<li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li>\n<li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li>\n<li>浏览器自动发起新的请求 , 跳转到新地址.</li>\n</ol>\n</li>\n<li>特点：<ol>\n<li>重定向会产生两个请求对象，多个请求对象中数据不互通</li>\n<li>浏览器地址发生了改变</li>\n<li>重定向可以跨域实现</li>\n<li>比转发效率低</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-上下文对象ServletContext\"><a href=\"#4-上下文对象ServletContext\" class=\"headerlink\" title=\"4. 上下文对象ServletContext\"></a>4. 上下文对象ServletContext</h3><ul>\n<li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li>\n<li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li>\n</ul>\n<p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p>\n<ul>\n<li>常用方法<ul>\n<li>context.setAttributes(String key, Objexct value); //设置替换数据</li>\n<li>context.getAttributes(String key); //获取数据</li>\n<li>context.removeAttributes(String key); //删除数据</li>\n<li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-会话跟踪（状态管理）\"><a href=\"#5-会话跟踪（状态管理）\" class=\"headerlink\" title=\"5. 会话跟踪（状态管理）\"></a>5. 会话跟踪（状态管理）</h3><ul>\n<li><p>存在两种实现：</p>\n<ol>\n<li>cookie: 将浏览器产生的状态存储在浏览器中</li>\n<li>Session: 将浏览器产生的状态存储在服务器中</li>\n</ol>\n</li>\n<li><p>cookie技术原理：</p>\n<ul>\n<li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li>\n<li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li>\n<li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li>\n</ul>\n</li>\n<li><p>Session技术原理：</p>\n<ul>\n<li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li>\n<li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li>\n<li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-Cookie\"><a href=\"#5-1-Cookie\" class=\"headerlink\" title=\"5.1 Cookie\"></a>5.1 Cookie</h4><ul>\n<li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul>\n<li><code>Cookie cookie = new Cookie(String key, String value);</code></li>\n<li>注意：tomcat8.5版本之前，cookie无法出场中文</li>\n</ul>\n</li>\n<li>通过响应对象，将cookie添加到响应头,可添加多个<ul>\n<li><strong>response.addCookie(Cookie cookie)</strong>;</li>\n</ul>\n</li>\n<li>通过请求头得到cookie数组，没有则返回null<ul>\n<li><strong>Cookie[] cookies = request.getCookies()</strong>;</li>\n<li>取键：cookie.getName();</li>\n<li>取值：cookie.getValue()</li>\n</ul>\n</li>\n<li>Cookie的存储时长：<ul>\n<li>cookie.setMaxAge(int 秒)；<ul>\n<li>正数：倒计时秒数</li>\n<li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li>\n<li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Cookie的存储路径问题<ul>\n<li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li>\n<li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-Cookie的优缺点\"><a href=\"#5-2-Cookie的优缺点\" class=\"headerlink\" title=\"5.2 Cookie的优缺点\"></a>5.2 Cookie的优缺点</h4><ul>\n<li>缺点：<ol>\n<li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li>\n<li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li>\n<li>保存数据量有限制，大约4kb左右</li>\n<li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>分散服务器的压力</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-3-Session\"><a href=\"#5-3-Session\" class=\"headerlink\" title=\"5.3 Session\"></a>5.3 Session</h4><ul>\n<li>获取Session<ul>\n<li>格式1：<strong>request.getSession()</strong>;//等价参数传true</li>\n<li>格式2：request.getSession(boolean isNew);<ul>\n<li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li>\n<li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Session常用方法<ul>\n<li><strong>session.setAttribute(String key, object value)</strong>;//设置/替换值</li>\n<li><strong>session.getAttribute(String key)</strong>;//获取值</li>\n<li>session.invalidate();//销毁</li>\n</ul>\n</li>\n<li>设置session存活时长<ul>\n<li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li>\n<li>可以通过修改配置文件，修改所有的session时长<ul>\n<li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li>\n</ul>\n</li>\n<li>可以通过session对象，修改单个对象的session时长<ul>\n<li>void session.setMaxInactiveInterval(int seconds)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-4-Session的优缺点\"><a href=\"#5-4-Session的优缺点\" class=\"headerlink\" title=\"5.4 Session的优缺点\"></a>5.4 Session的优缺点</h4><ul>\n<li>缺点：<ul>\n<li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li>\n</ul>\n</li>\n<li>优点：<ol>\n<li>数据存储在服务器中，安全</li>\n<li>数据类型为Object，在Java中表示可以存储所有类型的数据</li>\n<li>session存储的数据大小，理论上无限的。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-5-Cookie和Session的使用\"><a href=\"#5-5-Cookie和Session的使用\" class=\"headerlink\" title=\"5.5 Cookie和Session的使用\"></a>5.5 Cookie和Session的使用</h4><ul>\n<li>Cookie和Session不是互斥的，是相辅相成的</li>\n<li>在项目开发时：<ul>\n<li>对安全敏感的数据，存储在session中</li>\n<li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li>\n<li>对于大的数据，应该存在数据库和文件中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：cookie和session是为了管理状态而非存储数据。</p>\n</blockquote>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-JSP\"><a href=\"#6-JSP\" class=\"headerlink\" title=\"6.JSP\"></a>6.JSP</h3><h4 id=\"6-1-JSP语法基础\"><a href=\"#6-1-JSP语法基础\" class=\"headerlink\" title=\"6.1 JSP语法基础\"></a>6.1 JSP语法基础</h4><ul>\n<li><p>Java Server Pages：java动态网页技术</p>\n</li>\n<li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p>\n</li>\n<li><p>注意：</p>\n<ol>\n<li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li>\n<li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li>\n</ol>\n</li>\n<li><p>JSP语法结构</p>\n<ol>\n<li>html代码</li>\n<li>Java代码</li>\n<li>Jsp特有的语法结构</li>\n</ol>\n</li>\n<li><p>Java代码声明区：指的是类的成员位置</p>\n</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">  <span class=\"comment\">// Java代码声明区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">  <span class=\"comment\">// Java代码执行区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JSP输出表达式<ul>\n<li>用于快速的将Java中的数据，输出到网页中..</li>\n<li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li>\n</ul>\n</li>\n<li>JSP注释：<ul>\n<li>html中可以用<code>&lt;!-- --&gt;</code></li>\n<li>java中可以用<code>//，/**/，/** */</code></li>\n<li>jsp注释<code>&lt;%-- --%&gt;</code><ul>\n<li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-JSP三大指令\"><a href=\"#6-2-JSP三大指令\" class=\"headerlink\" title=\"6.2 JSP三大指令\"></a>6.2 JSP三大指令</h4><ul>\n<li>page指令</li>\n<li>include指令</li>\n<li>taglib指令</li>\n</ul>\n<ul>\n<li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li>\n</ul>\n<h5 id=\"6-2-1-page指令\"><a href=\"#6-2-1-page指令\" class=\"headerlink\" title=\"6.2.1 page指令\"></a>6.2.1 page指令</h5><ul>\n<li>用于配置页面信息</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page</span><br><span class=\"line\">  language=<span class=\"string\">\"java\"</span>：语言</span><br><span class=\"line\">  contentType=<span class=\"string\">\"text/html;charset=utf-8\"</span>：响应的内容类型，以及响应的编码格式</span><br><span class=\"line\">  pageEncoding=<span class=\"string\">\"UTF-8\"</span>：文件存储的编码格式</span><br><span class=\"line\">  extends=<span class=\"string\">\"继承的父类\"</span></span><br><span class=\"line\">  buffer=<span class=\"string\">\"数字/none\"</span>：是否允许缓存，默认值<span class=\"number\">8</span>kb</span><br><span class=\"line\">  autoFlush=<span class=\"string\">\"true/false\"</span>：是否自动清除缓存，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  session=<span class=\"string\">\"true/false\"</span>：是否提前准备session对象，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  isThreadSafe=<span class=\"string\">\"true/false\"</span>：是否线程安全的</span><br><span class=\"line\">  <span class=\"keyword\">import</span>=<span class=\"string\">\"java.util.List\"</span>：用于导包，多个包使用<span class=\"string\">\",\"</span>隔开</span><br><span class=\"line\">  errorPage=<span class=\"string\">\"网址\"</span>：当页面发生BUG后，显示哪个页面</span><br><span class=\"line\">  isErrorPage=<span class=\"string\">\"true/false\"</span>：当前页面是否是一个错误处理页面，如果结果为<span class=\"keyword\">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-项目发生错误时，统一的处理方式\"><a href=\"#6-3-项目发生错误时，统一的处理方式\" class=\"headerlink\" title=\"6.3 项目发生错误时，统一的处理方式\"></a>6.3 项目发生错误时，统一的处理方式</h4><ol>\n<li>打开项目的web.xml</li>\n<li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>500<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>404<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>include指令：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li>\n</ul>\n</li>\n<li>include动作：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>include指令 与 include动作区别：</p>\n<ul>\n<li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）</li>\n<li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</li>\n</ul>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-内置对象-隐含对象\"><a href=\"#7-内置对象-隐含对象\" class=\"headerlink\" title=\"7.内置对象(隐含对象)\"></a>7.内置对象(隐含对象)</h3><ul>\n<li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li>\n<li>内置对象通常是我们会主动创建的对象</li>\n</ul>\n<h4 id=\"7-1-九大内置对象\"><a href=\"#7-1-九大内置对象\" class=\"headerlink\" title=\"7.1 九大内置对象\"></a>7.1 九大内置对象</h4><ol>\n<li>request<ul>\n<li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li>\n<li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li>\n</ul>\n</li>\n<li>response<ul>\n<li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li>\n<li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li>\n</ul>\n</li>\n<li>config<ul>\n<li>对象类型：javax.servlet.<strong>ServletConfig</strong></li>\n<li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li>\n</ul>\n</li>\n<li>out<ul>\n<li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li>\n<li>在JSP开发过程中使用得最为频繁的对象</li>\n</ul>\n</li>\n<li>page<ul>\n<li>对象类型：java.lang.<strong>Object</strong></li>\n<li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li>\n</ul>\n</li>\n<li>pageContext<ul>\n<li>对象类型：<strong>pageContext</strong></li>\n<li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li>\n</ul>\n</li>\n<li>session<ul>\n<li>对象类型：java.servlet.http.<strong>HttpSession</strong></li>\n<li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li>\n</ul>\n</li>\n<li>application<ul>\n<li>对象类型：javax.servlet.<strong>ServletContext</strong></li>\n<li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li>\n</ul>\n</li>\n<li>exception<ul>\n<li>对象类型：java.lang.<strong>Throwable</strong></li>\n<li>作用 exception内置对象是用来处理页面出现的异常错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-JSP四大域对象\"><a href=\"#7-2-JSP四大域对象\" class=\"headerlink\" title=\"7.2 JSP四大域对象\"></a>7.2 JSP四大域对象</h4><ul>\n<li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li>\n<li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol>\n<li>存储数据：setAttribute(String key, Object value);</li>\n<li>获取数据：Object value = getAttribute(String);</li>\n<li>删除数据： removeAttribute(String key);</li>\n</ol>\n</li>\n<li>四大内置对象，分别指的是：<ol>\n<li>pageContext: (作用域：1个页面)<ul>\n<li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li>\n</ul>\n</li>\n<li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)<ul>\n<li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li>\n</ul>\n</li>\n<li>session: (作用域：一次会话，一次会话可能包含多个请求)<ul>\n<li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li>\n</ul>\n</li>\n<li>application: (域范围：一次服务，应用从启动到关闭application一直都在)<ul>\n<li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-3-EL表达式\"><a href=\"#7-3-EL表达式\" class=\"headerlink\" title=\"7.3 EL表达式\"></a>7.3 EL表达式</h4><ul>\n<li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li>\n<li>格式：<code>${表达式}</code></li>\n<li>EL表达式用于运算<ul>\n<li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 </li>\n</ul>\n</li>\n<li>用于取出域对象中的数据<ul>\n<li>取出数据直接输出：<code>${域对象中存储的键}</code></li>\n<li>如果取出的数据不存在, 则不输出 (不可能显示null)</li>\n</ul>\n</li>\n<li>取出对象数据的属性值:<ul>\n<li>格式1： ${对象存储的键.属性名}</li>\n<li>格式2： ${对象存储的键[“属性名”]}</li>\n<li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li>\n</ul>\n</li>\n<li>取出集合中的数据<ul>\n<li>格式: ${集合存储时的key[下标]}</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-4-EL表达式取出数据的流程\"><a href=\"#7-4-EL表达式取出数据的流程\" class=\"headerlink\" title=\"7.4 EL表达式取出数据的流程\"></a>7.4 EL表达式取出数据的流程</h4><ul>\n<li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li>\n<li>步骤:<ol>\n<li>先从pageContext中, 寻找数据是否存在.</li>\n<li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li>\n<li>如果request 中数据不存在, 则去session中寻找数据是否存在</li>\n<li>如果session中数据不存在, 则去application中寻找数据是否存在</li>\n<li>如果application中数据不存在,则不输出任何数据.</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-taglib指令\"><a href=\"#8-taglib指令\" class=\"headerlink\" title=\"8. taglib指令\"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p>\n<ul>\n<li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul>\n<li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li>\n<li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li>\n</ul>\n</li>\n<li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul>\n<li>使用时，需要引入jar文件</li>\n<li>if 标签，格式：&lt;库名称:if text=”${ booble }”&gt;</li>\n<li>forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt;</li>\n</ul>\n</li>\n<li>自定义标签库:<ol>\n<li>编写一个Java类, 继承SimpleTagSupport类.</li>\n<li>重写父类的doTag方法.</li>\n<li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li>\n<li>通过上下文对象, 得到JSP中的out对象, </li>\n<li>通过out对象,  向网页中输出内容</li>\n<li>编写tld文件 , 描述标签库 以及 标签.</li>\n</ol>\n</li>\n</ul>\n<p>自定义标签库案例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTag1</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleTagSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"keyword\">static</span> ArrayList&lt;String&gt; data = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        data.add(<span class=\"string\">\"流水在碰到底处时才会释放活力。——歌德\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doTag</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> JspException, IOException </span>&#123;</span><br><span class=\"line\">        JspContext context = getJspContext();</span><br><span class=\"line\">        JspWriter out = context.getOut();</span><br><span class=\"line\">        Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = r.nextInt(data.size());</span><br><span class=\"line\">        out.println(<span class=\"string\">\"&lt;span&gt;\"</span>+data.get(index)+<span class=\"string\">\"&lt;/span&gt;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">taglib</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/j2ee\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">version</span>=<span class=\"string\">\"2.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 描述标签库 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>xdl<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tlib-version</span>&gt;</span>11.88<span class=\"tag\">&lt;/<span class=\"name\">tlib-version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">short-name</span>&gt;</span>xdl<span class=\"tag\">&lt;/<span class=\"name\">short-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uri</span>&gt;</span>http://shuidianshuisg.com<span class=\"tag\">&lt;/<span class=\"name\">uri</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签名称 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>heiheihei<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class=\"tag\">&lt;/<span class=\"name\">tag-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签的内容 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">body-content</span>&gt;</span>empty<span class=\"tag\">&lt;/<span class=\"name\">body-content</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-JavaWeb三大组件-Servlet-filter-Lister\"><a href=\"#9-JavaWeb三大组件-Servlet-filter-Lister\" class=\"headerlink\" title=\"9. JavaWeb三大组件(Servlet,filter,Lister)\"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id=\"9-1-Filter过滤器\"><a href=\"#9-1-Filter过滤器\" class=\"headerlink\" title=\"9.1 Filter过滤器\"></a>9.1 Filter过滤器</h4><ul>\n<li>请求的过滤器，面向切面编程思想（AOP）</li>\n<li>使用步骤：<ol>\n<li>编写一个类，实现Filter接口</li>\n<li>通过注解或web.xml配置过滤器规则</li>\n</ol>\n</li>\n<li>过滤器链：<ul>\n<li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li>\n</ul>\n</li>\n<li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul>\n<li>注解方式：按照类名的自然顺序先后</li>\n<li>web.xml配置方式：按照web.xml配置顺序，先后执行</li>\n</ul>\n</li>\n<li>案例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebFilter</span>(<span class=\"string\">\"/home.jsp\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当Filter即将销毁时执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数1.   请求对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数2. 响应对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数3.  过滤器链对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"过滤管理员登录的过滤器 正在执行\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//1.    从请求中, 得到session</span></span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        HttpSession session = req.getSession();</span><br><span class=\"line\">        <span class=\"comment\">//2.    判断session中是否存在username</span></span><br><span class=\"line\">        Object username = session.getAttribute(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(username !=<span class=\"keyword\">null</span> &amp;&amp; username.equals(<span class=\"string\">\"admin\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//放行</span></span><br><span class=\"line\">            chain.doFilter(request, response);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class=\"line\">            response.getWriter().append(<span class=\"string\">\"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当Filter初始化时 执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig arg0)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>web.xml配置方式</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/home.jsp<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-2-Listener监听器\"><a href=\"#9-2-Listener监听器\" class=\"headerlink\" title=\"9.2 Listener监听器\"></a>9.2 Listener监听器</h4><ul>\n<li>监听服务器的一些状态事件，事件驱动机制。</li>\n<li>分为两类状态事件：<ul>\n<li>服务器中组件的生命周期</li>\n<li>一些域对象中数据变化的事件</li>\n</ul>\n</li>\n<li>监听服务器的启动与关闭：ServletContextListener</li>\n<li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li>\n<li>监听Session会话的开启与关闭：HttpSessionListener </li>\n<li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener </li>\n</ul>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-JSON在Java中的使用\"><a href=\"#10-JSON在Java中的使用\" class=\"headerlink\" title=\"10. JSON在Java中的使用\"></a>10. JSON在Java中的使用</h3><ul>\n<li>JSON：JavaScript Object Notation</li>\n<li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入jar文件</span></span><br><span class=\"line\">Gson g = <span class=\"keyword\">new</span> Gson();</span><br><span class=\"line\">String str = g.toJson(Java对象);<span class=\"comment\">//转换JSON字符串</span></span><br><span class=\"line\">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class=\"comment\">//转换为Java对象</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-AJAX\"><a href=\"#11-AJAX\" class=\"headerlink\" title=\"11. AJAX\"></a>11. AJAX</h3><ul>\n<li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li>\n<li>Ajax请求的状态（readyState）<ul>\n<li>0：正在初始化</li>\n<li>1：请求正在发送</li>\n<li>2：请求发送完毕</li>\n<li>3：服务器开始响应</li>\n<li>4：响应接收完毕，连接断开</li>\n</ul>\n</li>\n<li>Ajax响应的状态（status）<ul>\n<li>200：成功</li>\n<li>404：找不到资源</li>\n<li>500：服务器错误</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-1-GET请求AJAX\"><a href=\"#11-1-GET请求AJAX\" class=\"headerlink\" title=\"11.1 GET请求AJAX\"></a>11.1 GET请求AJAX</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"地址?参数列表\"</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xhr.readyState === <span class=\"number\">4</span> &amp;&amp; xhr.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//通过xhr.responseText接收响应体</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//失败处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-2-POST请求AJAX\"><a href=\"#11-2-POST请求AJAX\" class=\"headerlink\" title=\"11.2 POST请求AJAX\"></a>11.2 POST请求AJAX</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"地址\"</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xhr.readyState === <span class=\"number\">4</span> &amp;&amp; xhr.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//通过xhr.responseText接收响应体</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//失败处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//POST请求设置请求头</span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>); </span><br><span class=\"line\">xhr.send(参数列表); <span class=\"comment\">//发送请求参数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-2-Jquery中的AJAX\"><a href=\"#11-2-Jquery中的AJAX\" class=\"headerlink\" title=\"11.2 Jquery中的AJAX\"></a>11.2 Jquery中的AJAX</h4><ol>\n<li><code>$.ajax({url,[settings]})</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:<span class=\"string\">\"请求的网址\"</span>,</span><br><span class=\"line\">    type:<span class=\"string\">\"请求方式GET/POST...\"</span>,</span><br><span class=\"line\">    <span class=\"keyword\">async</span>:<span class=\"string\">\"请求是否异步, 默认true\"</span>,</span><br><span class=\"line\">    data:<span class=\"string\">\"请求的参数列表, 格式与GET请求?后的格式一致\"</span>,</span><br><span class=\"line\">    dataType:<span class=\"string\">\"TEXT或JSON\"</span>,<span class=\"comment\">//服务器返回的数据类型</span></span><br><span class=\"line\">    success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;<span class=\"comment\">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class=\"line\">        <span class=\"comment\">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; <span class=\"comment\">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>$.get(url, [data], [callback], [type])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.<span class=\"keyword\">get</span>(\"请求的网址\", &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>$.post(url, [data], [callback], [type])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.post(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;, <span class=\"string\">\"json\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><code>$.getJSON(url, [data], [callback])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.getJSON(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><code>jquery对象.load(url, [data], [callback])</code></li>\n</ol>\n<ul>\n<li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#dom\"</span>).load(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载成功</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-3-Vue中的AJAX\"><a href=\"#11-3-Vue中的AJAX\" class=\"headerlink\" title=\"11.3 Vue中的AJAX\"></a>11.3 Vue中的AJAX</h4><ul>\n<li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li>\n<li>不创建Vue对象的情况下, 使用的ajax:<ul>\n<li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>\n<li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>\n</ul>\n</li>\n<li>创建Vue实例, 使用ajax<ul>\n<li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>\n<li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GET请求: 传递参数列表: </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    params:&#123;</span><br><span class=\"line\">        参数名<span class=\"number\">1</span>:值<span class=\"number\">1</span>,</span><br><span class=\"line\">        参数名<span class=\"number\">2</span>:值<span class=\"number\">2</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">POST请求: 传递参数列表:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    参数名<span class=\"number\">1</span>:值<span class=\"number\">1</span>,</span><br><span class=\"line\">    参数名<span class=\"number\">2</span>:值<span class=\"number\">2</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>success函数 与 error函数<ul>\n<li>格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息</li>\n<li>响应对象的常用属性:<ol>\n<li>url : 响应的网址</li>\n<li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li>\n<li>ok  : boolean值, 响应码在200-299之间时  为 true</li>\n<li>status : 响应码, 例如: 200,302,404,500</li>\n<li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li>\n</ol>\n</li>\n<li>响应对象的常用函数:<ol>\n<li>text() : 以字符串的形式, 返回响应体</li>\n<li>json() : 以对象的形式, 返回响应体</li>\n<li>blob() : 以二进制的形式 , 返回响应体.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-4-AJAX缓存问题\"><a href=\"#11-4-AJAX缓存问题\" class=\"headerlink\" title=\"11.4 AJAX缓存问题\"></a>11.4 AJAX缓存问题</h4><ul>\n<li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li>\n<li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li>\n<li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li>\n</ul>\n<h4 id=\"11-5-AJAX跨域问题\"><a href=\"#11-5-AJAX跨域问题\" class=\"headerlink\" title=\"11.5 AJAX跨域问题\"></a>11.5 AJAX跨域问题</h4><ul>\n<li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li>\n<li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul>\n<li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li>\n<li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p>","more":"<ol>\n<li><a href=\"#id1\">http协议</a></li>\n<li><a href=\"#id2\">Servlet</a></li>\n<li><a href=\"#id3\">get和post区别</a></li>\n<li><a href=\"#id4\">上下文对象ServletContext</a></li>\n<li><a href=\"#id5\">会话跟踪（状态管理）</a></li>\n<li><a href=\"#id6\">JSP</a></li>\n<li><a href=\"#id7\">内置对象(隐含对象)</a></li>\n<li><a href=\"#id8\">taglib指令</a></li>\n<li><a href=\"#id9\">JavaWeb三大组件</a></li>\n<li><a href=\"#id10\">JSON在Java中的使用</a></li>\n<li><a href=\"#id11\">AJAX</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-http协议\"><a href=\"#1-http协议\" class=\"headerlink\" title=\"1. http协议\"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p>\n<ul>\n<li>http协议的特点：<ol>\n<li>简单，快速：支持多种不同的的数据提交方式，如get/post</li>\n<li>数据传输灵活，支持任意类型数据的传输</li>\n<li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li>\n<li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li>\n</ol>\n</li>\n<li>http协议的组成部分：<ol>\n<li>请求：浏览器连接服务器的过程</li>\n<li>响应：服务器回复浏览器的过程</li>\n</ol>\n</li>\n<li>http协议的请求：<ol>\n<li>请求头：描述客户端的信息</li>\n<li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li>\n<li>请求空行：请求头与请求体之间的一行空白</li>\n<li>请求行：描述请求方式，服务器地址，协议版本等</li>\n</ol>\n</li>\n<li>http协议的响应：<ol>\n<li>响应头：描述服务器的信息</li>\n<li>响应体：响应的内容，文本，json数据等。</li>\n<li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Servlet\"><a href=\"#2-Servlet\" class=\"headerlink\" title=\"2. Servlet\"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p>\n<h4 id=\"2-1-Servlet编写步骤：\"><a href=\"#2-1-Servlet编写步骤：\" class=\"headerlink\" title=\"2.1 Servlet编写步骤：\"></a>2.1 Servlet编写步骤：</h4><ol>\n<li>编写一个Java类，继承HttpServlet类</li>\n<li>重新service方法</li>\n<li>在service方法中，对用户请求进行响应。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解：添加访问的网址</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1.设置响应体的编码，以及内容类型</span></span><br><span class=\"line\">\t\tres.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2.得到响应体输出的打印流</span></span><br><span class=\"line\">\t\tPrintWriter out = res.getWriter();</span><br><span class=\"line\">\t\t<span class=\"comment\">//3.打印文字</span></span><br><span class=\"line\">\t\tout.println(<span class=\"string\">\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-配置ervlet类的访问网址\"><a href=\"#2-2-配置ervlet类的访问网址\" class=\"headerlink\" title=\"2.2 配置ervlet类的访问网址\"></a>2.2 配置ervlet类的访问网址</h4><ul>\n<li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li>\n<li>web3.0版本之前配置Servlet访问网址的方式：<ul>\n<li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li>\n<li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-Servlet生命周期\"><a href=\"#2-3-Servlet生命周期\" class=\"headerlink\" title=\"2.3 Servlet生命周期\"></a>2.3 Servlet生命周期</h4><ul>\n<li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li>\n<li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li>\n<li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li>\n<li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul>\n<li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li>\n<li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li>\n<li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-get和post区别\"><a href=\"#2-4-get和post区别\" class=\"headerlink\" title=\"2.4 get和post区别\"></a>2.4 get和post区别</h4><ul>\n<li>GET请求：<ul>\n<li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li>\n<li>只能传输字符串类型参数</li>\n<li>浏览器url地址最大长度4kb</li>\n<li>数据传输时，参数在url中明文显示，不安全。</li>\n</ul>\n</li>\n<li>POST请求：<ul>\n<li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li>\n<li>可传输任意类型的数据，进行文件上传必须POST请求</li>\n<li>可以传递的数据大小，理论上没有上限</li>\n<li>数据传输时在单独的数据包，较为安全。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-接收请求中的参数\"><a href=\"#2-5-接收请求中的参数\" class=\"headerlink\" title=\"2.5 接收请求中的参数\"></a>2.5 接收请求中的参数</h4><ol>\n<li>根据参数的名称，接收参数的单个值<ul>\n<li>String value = <strong>request.getParameter(String name)</strong>;</li>\n</ul>\n</li>\n<li>根据参数的名称，接收一组参数的值<ul>\n<li>String[] values = <strong>request.getParameterValues(String name)</strong>;</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">  request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">  response.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//1.接收</span></span><br><span class=\"line\">  String username = request.getParameter(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">  String[] password = request.getParameterValues(<span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//2.打印</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password:\"</span> + password[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password2:\"</span> + password[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"comment\">//3.浏览器输出</span></span><br><span class=\"line\">  response.getWriter().append(<span class=\"string\">\"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\\\"demo1.html\\\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-乱码处理\"><a href=\"#2-6-乱码处理\" class=\"headerlink\" title=\"2.6 乱码处理\"></a>2.6 乱码处理</h4><h4 id=\"2-6-1-乱码情况：\"><a href=\"#2-6-1-乱码情况：\" class=\"headerlink\" title=\"2.6.1 乱码情况：\"></a>2.6.1 乱码情况：</h4><ul>\n<li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li>\n<li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li>\n<li>任何版本, POST请求乱码</li>\n</ul>\n<h4 id=\"2-6-2-请求乱码处理：\"><a href=\"#2-6-2-请求乱码处理：\" class=\"headerlink\" title=\"2.6.2 请求乱码处理：\"></a>2.6.2 请求乱码处理：</h4><ul>\n<li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>将接收到的中文乱码重新编码：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = request.getParameter(<span class=\"string\">\"userName\"</span>);</span><br><span class=\"line\">String userName = <span class=\"keyword\">new</span> String( name.getByte(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"utf-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>仅适用于POST请求：<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-6-3-响应乱码的处理：\"><a href=\"#2-6-3-响应乱码的处理：\" class=\"headerlink\" title=\"2.6.3 响应乱码的处理：\"></a>2.6.3 响应乱码的处理：</h4><ul>\n<li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li>\n<li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li>\n</ul>\n<h4 id=\"2-7-Servlet的创建时机\"><a href=\"#2-7-Servlet的创建时机\" class=\"headerlink\" title=\"2.7 Servlet的创建时机\"></a>2.7 Servlet的创建时机</h4><ul>\n<li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li>\n<li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li>\n<li>节点中的值为数字：<ul>\n<li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li>\n<li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>demo.ServletDemo<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/s1<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-请求的转发与重定向\"><a href=\"#3-请求的转发与重定向\" class=\"headerlink\" title=\"3. 请求的转发与重定向\"></a>3. 请求的转发与重定向</h3><h4 id=\"3-1-请求对象request的常用操作\"><a href=\"#3-1-请求对象request的常用操作\" class=\"headerlink\" title=\"3.1 请求对象request的常用操作\"></a>3.1 请求对象request的常用操作</h4><ol>\n<li>getMethod() : 得到请求的方式</li>\n<li>getRequestURI() : 获取浏览器请求地址</li>\n<li>getRemoteAddr() : 获取客户端ip地址</li>\n<li>getRemoteHost() : 获取客户端名称</li>\n<li>getServerName() : 获取服务器名称</li>\n<li>getServerPort() : 获取服务器端口号</li>\n<li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li>\n</ol>\n<h4 id=\"3-1-请求的转发与重定向注意事项\"><a href=\"#3-1-请求的转发与重定向注意事项\" class=\"headerlink\" title=\"3.1 请求的转发与重定向注意事项\"></a>3.1 请求的转发与重定向注意事项</h4><ul>\n<li>请求转发与重定向操作，必须要有出口。</li>\n<li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li>\n</ul>\n<h4 id=\"3-2-转发\"><a href=\"#3-2-转发\" class=\"headerlink\" title=\"3.2 转发*\"></a>3.2 转发*</h4><ul>\n<li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li>\n<li>步骤：<ol>\n<li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li>\n<li>进行转发操作：<code>rd.forward(request, response);</code></li>\n</ol>\n</li>\n<li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul>\n<li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li>\n<li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li>\n<li>转发不能跨项目实现</li>\n<li>比重定向效率更高</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-重定向\"><a href=\"#3-3-重定向\" class=\"headerlink\" title=\"3.3 重定向*\"></a>3.3 重定向*</h4><ul>\n<li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li>\n<li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li>\n<li>原理：当客户端请求服务器时，发起重定向流程：<ol>\n<li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li>\n<li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li>\n<li>浏览器自动发起新的请求 , 跳转到新地址.</li>\n</ol>\n</li>\n<li>特点：<ol>\n<li>重定向会产生两个请求对象，多个请求对象中数据不互通</li>\n<li>浏览器地址发生了改变</li>\n<li>重定向可以跨域实现</li>\n<li>比转发效率低</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-上下文对象ServletContext\"><a href=\"#4-上下文对象ServletContext\" class=\"headerlink\" title=\"4. 上下文对象ServletContext\"></a>4. 上下文对象ServletContext</h3><ul>\n<li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li>\n<li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li>\n</ul>\n<p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p>\n<ul>\n<li>常用方法<ul>\n<li>context.setAttributes(String key, Objexct value); //设置替换数据</li>\n<li>context.getAttributes(String key); //获取数据</li>\n<li>context.removeAttributes(String key); //删除数据</li>\n<li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-会话跟踪（状态管理）\"><a href=\"#5-会话跟踪（状态管理）\" class=\"headerlink\" title=\"5. 会话跟踪（状态管理）\"></a>5. 会话跟踪（状态管理）</h3><ul>\n<li><p>存在两种实现：</p>\n<ol>\n<li>cookie: 将浏览器产生的状态存储在浏览器中</li>\n<li>Session: 将浏览器产生的状态存储在服务器中</li>\n</ol>\n</li>\n<li><p>cookie技术原理：</p>\n<ul>\n<li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li>\n<li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li>\n<li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li>\n</ul>\n</li>\n<li><p>Session技术原理：</p>\n<ul>\n<li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li>\n<li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li>\n<li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-Cookie\"><a href=\"#5-1-Cookie\" class=\"headerlink\" title=\"5.1 Cookie\"></a>5.1 Cookie</h4><ul>\n<li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul>\n<li><code>Cookie cookie = new Cookie(String key, String value);</code></li>\n<li>注意：tomcat8.5版本之前，cookie无法出场中文</li>\n</ul>\n</li>\n<li>通过响应对象，将cookie添加到响应头,可添加多个<ul>\n<li><strong>response.addCookie(Cookie cookie)</strong>;</li>\n</ul>\n</li>\n<li>通过请求头得到cookie数组，没有则返回null<ul>\n<li><strong>Cookie[] cookies = request.getCookies()</strong>;</li>\n<li>取键：cookie.getName();</li>\n<li>取值：cookie.getValue()</li>\n</ul>\n</li>\n<li>Cookie的存储时长：<ul>\n<li>cookie.setMaxAge(int 秒)；<ul>\n<li>正数：倒计时秒数</li>\n<li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li>\n<li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Cookie的存储路径问题<ul>\n<li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li>\n<li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-Cookie的优缺点\"><a href=\"#5-2-Cookie的优缺点\" class=\"headerlink\" title=\"5.2 Cookie的优缺点\"></a>5.2 Cookie的优缺点</h4><ul>\n<li>缺点：<ol>\n<li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li>\n<li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li>\n<li>保存数据量有限制，大约4kb左右</li>\n<li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>分散服务器的压力</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-3-Session\"><a href=\"#5-3-Session\" class=\"headerlink\" title=\"5.3 Session\"></a>5.3 Session</h4><ul>\n<li>获取Session<ul>\n<li>格式1：<strong>request.getSession()</strong>;//等价参数传true</li>\n<li>格式2：request.getSession(boolean isNew);<ul>\n<li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li>\n<li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Session常用方法<ul>\n<li><strong>session.setAttribute(String key, object value)</strong>;//设置/替换值</li>\n<li><strong>session.getAttribute(String key)</strong>;//获取值</li>\n<li>session.invalidate();//销毁</li>\n</ul>\n</li>\n<li>设置session存活时长<ul>\n<li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li>\n<li>可以通过修改配置文件，修改所有的session时长<ul>\n<li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li>\n</ul>\n</li>\n<li>可以通过session对象，修改单个对象的session时长<ul>\n<li>void session.setMaxInactiveInterval(int seconds)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-4-Session的优缺点\"><a href=\"#5-4-Session的优缺点\" class=\"headerlink\" title=\"5.4 Session的优缺点\"></a>5.4 Session的优缺点</h4><ul>\n<li>缺点：<ul>\n<li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li>\n</ul>\n</li>\n<li>优点：<ol>\n<li>数据存储在服务器中，安全</li>\n<li>数据类型为Object，在Java中表示可以存储所有类型的数据</li>\n<li>session存储的数据大小，理论上无限的。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-5-Cookie和Session的使用\"><a href=\"#5-5-Cookie和Session的使用\" class=\"headerlink\" title=\"5.5 Cookie和Session的使用\"></a>5.5 Cookie和Session的使用</h4><ul>\n<li>Cookie和Session不是互斥的，是相辅相成的</li>\n<li>在项目开发时：<ul>\n<li>对安全敏感的数据，存储在session中</li>\n<li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li>\n<li>对于大的数据，应该存在数据库和文件中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：cookie和session是为了管理状态而非存储数据。</p>\n</blockquote>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-JSP\"><a href=\"#6-JSP\" class=\"headerlink\" title=\"6.JSP\"></a>6.JSP</h3><h4 id=\"6-1-JSP语法基础\"><a href=\"#6-1-JSP语法基础\" class=\"headerlink\" title=\"6.1 JSP语法基础\"></a>6.1 JSP语法基础</h4><ul>\n<li><p>Java Server Pages：java动态网页技术</p>\n</li>\n<li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p>\n</li>\n<li><p>注意：</p>\n<ol>\n<li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li>\n<li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li>\n</ol>\n</li>\n<li><p>JSP语法结构</p>\n<ol>\n<li>html代码</li>\n<li>Java代码</li>\n<li>Jsp特有的语法结构</li>\n</ol>\n</li>\n<li><p>Java代码声明区：指的是类的成员位置</p>\n</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">  <span class=\"comment\">// Java代码声明区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">  <span class=\"comment\">// Java代码执行区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JSP输出表达式<ul>\n<li>用于快速的将Java中的数据，输出到网页中..</li>\n<li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li>\n</ul>\n</li>\n<li>JSP注释：<ul>\n<li>html中可以用<code>&lt;!-- --&gt;</code></li>\n<li>java中可以用<code>//，/**/，/** */</code></li>\n<li>jsp注释<code>&lt;%-- --%&gt;</code><ul>\n<li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-JSP三大指令\"><a href=\"#6-2-JSP三大指令\" class=\"headerlink\" title=\"6.2 JSP三大指令\"></a>6.2 JSP三大指令</h4><ul>\n<li>page指令</li>\n<li>include指令</li>\n<li>taglib指令</li>\n</ul>\n<ul>\n<li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li>\n</ul>\n<h5 id=\"6-2-1-page指令\"><a href=\"#6-2-1-page指令\" class=\"headerlink\" title=\"6.2.1 page指令\"></a>6.2.1 page指令</h5><ul>\n<li>用于配置页面信息</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page</span><br><span class=\"line\">  language=<span class=\"string\">\"java\"</span>：语言</span><br><span class=\"line\">  contentType=<span class=\"string\">\"text/html;charset=utf-8\"</span>：响应的内容类型，以及响应的编码格式</span><br><span class=\"line\">  pageEncoding=<span class=\"string\">\"UTF-8\"</span>：文件存储的编码格式</span><br><span class=\"line\">  extends=<span class=\"string\">\"继承的父类\"</span></span><br><span class=\"line\">  buffer=<span class=\"string\">\"数字/none\"</span>：是否允许缓存，默认值<span class=\"number\">8</span>kb</span><br><span class=\"line\">  autoFlush=<span class=\"string\">\"true/false\"</span>：是否自动清除缓存，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  session=<span class=\"string\">\"true/false\"</span>：是否提前准备session对象，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  isThreadSafe=<span class=\"string\">\"true/false\"</span>：是否线程安全的</span><br><span class=\"line\">  <span class=\"keyword\">import</span>=<span class=\"string\">\"java.util.List\"</span>：用于导包，多个包使用<span class=\"string\">\",\"</span>隔开</span><br><span class=\"line\">  errorPage=<span class=\"string\">\"网址\"</span>：当页面发生BUG后，显示哪个页面</span><br><span class=\"line\">  isErrorPage=<span class=\"string\">\"true/false\"</span>：当前页面是否是一个错误处理页面，如果结果为<span class=\"keyword\">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-项目发生错误时，统一的处理方式\"><a href=\"#6-3-项目发生错误时，统一的处理方式\" class=\"headerlink\" title=\"6.3 项目发生错误时，统一的处理方式\"></a>6.3 项目发生错误时，统一的处理方式</h4><ol>\n<li>打开项目的web.xml</li>\n<li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>500<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>404<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>include指令：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li>\n</ul>\n</li>\n<li>include动作：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>include指令 与 include动作区别：</p>\n<ul>\n<li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）</li>\n<li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</li>\n</ul>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-内置对象-隐含对象\"><a href=\"#7-内置对象-隐含对象\" class=\"headerlink\" title=\"7.内置对象(隐含对象)\"></a>7.内置对象(隐含对象)</h3><ul>\n<li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li>\n<li>内置对象通常是我们会主动创建的对象</li>\n</ul>\n<h4 id=\"7-1-九大内置对象\"><a href=\"#7-1-九大内置对象\" class=\"headerlink\" title=\"7.1 九大内置对象\"></a>7.1 九大内置对象</h4><ol>\n<li>request<ul>\n<li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li>\n<li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li>\n</ul>\n</li>\n<li>response<ul>\n<li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li>\n<li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li>\n</ul>\n</li>\n<li>config<ul>\n<li>对象类型：javax.servlet.<strong>ServletConfig</strong></li>\n<li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名/值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li>\n</ul>\n</li>\n<li>out<ul>\n<li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li>\n<li>在JSP开发过程中使用得最为频繁的对象</li>\n</ul>\n</li>\n<li>page<ul>\n<li>对象类型：java.lang.<strong>Object</strong></li>\n<li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li>\n</ul>\n</li>\n<li>pageContext<ul>\n<li>对象类型：<strong>pageContext</strong></li>\n<li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li>\n</ul>\n</li>\n<li>session<ul>\n<li>对象类型：java.servlet.http.<strong>HttpSession</strong></li>\n<li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li>\n</ul>\n</li>\n<li>application<ul>\n<li>对象类型：javax.servlet.<strong>ServletContext</strong></li>\n<li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li>\n</ul>\n</li>\n<li>exception<ul>\n<li>对象类型：java.lang.<strong>Throwable</strong></li>\n<li>作用 exception内置对象是用来处理页面出现的异常错误。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-JSP四大域对象\"><a href=\"#7-2-JSP四大域对象\" class=\"headerlink\" title=\"7.2 JSP四大域对象\"></a>7.2 JSP四大域对象</h4><ul>\n<li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li>\n<li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol>\n<li>存储数据：setAttribute(String key, Object value);</li>\n<li>获取数据：Object value = getAttribute(String);</li>\n<li>删除数据： removeAttribute(String key);</li>\n</ol>\n</li>\n<li>四大内置对象，分别指的是：<ol>\n<li>pageContext: (作用域：1个页面)<ul>\n<li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li>\n</ul>\n</li>\n<li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)<ul>\n<li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li>\n</ul>\n</li>\n<li>session: (作用域：一次会话，一次会话可能包含多个请求)<ul>\n<li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li>\n</ul>\n</li>\n<li>application: (域范围：一次服务，应用从启动到关闭application一直都在)<ul>\n<li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-3-EL表达式\"><a href=\"#7-3-EL表达式\" class=\"headerlink\" title=\"7.3 EL表达式\"></a>7.3 EL表达式</h4><ul>\n<li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li>\n<li>格式：<code>${表达式}</code></li>\n<li>EL表达式用于运算<ul>\n<li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246 </li>\n</ul>\n</li>\n<li>用于取出域对象中的数据<ul>\n<li>取出数据直接输出：<code>${域对象中存储的键}</code></li>\n<li>如果取出的数据不存在, 则不输出 (不可能显示null)</li>\n</ul>\n</li>\n<li>取出对象数据的属性值:<ul>\n<li>格式1： ${对象存储的键.属性名}</li>\n<li>格式2： ${对象存储的键[“属性名”]}</li>\n<li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li>\n</ul>\n</li>\n<li>取出集合中的数据<ul>\n<li>格式: ${集合存储时的key[下标]}</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-4-EL表达式取出数据的流程\"><a href=\"#7-4-EL表达式取出数据的流程\" class=\"headerlink\" title=\"7.4 EL表达式取出数据的流程\"></a>7.4 EL表达式取出数据的流程</h4><ul>\n<li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li>\n<li>步骤:<ol>\n<li>先从pageContext中, 寻找数据是否存在.</li>\n<li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li>\n<li>如果request 中数据不存在, 则去session中寻找数据是否存在</li>\n<li>如果session中数据不存在, 则去application中寻找数据是否存在</li>\n<li>如果application中数据不存在,则不输出任何数据.</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-taglib指令\"><a href=\"#8-taglib指令\" class=\"headerlink\" title=\"8. taglib指令\"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p>\n<ul>\n<li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul>\n<li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li>\n<li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li>\n</ul>\n</li>\n<li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul>\n<li>使用时，需要引入jar文件</li>\n<li>if 标签，格式：&lt;库名称:if text=”${ booble }”&gt;</li>\n<li>forEach 标签，格式：&lt;库名称:forEach items=”${ List }” var=”item”&gt;</li>\n</ul>\n</li>\n<li>自定义标签库:<ol>\n<li>编写一个Java类, 继承SimpleTagSupport类.</li>\n<li>重写父类的doTag方法.</li>\n<li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li>\n<li>通过上下文对象, 得到JSP中的out对象, </li>\n<li>通过out对象,  向网页中输出内容</li>\n<li>编写tld文件 , 描述标签库 以及 标签.</li>\n</ol>\n</li>\n</ul>\n<p>自定义标签库案例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTag1</span> <span class=\"keyword\">extends</span> <span class=\"title\">SimpleTagSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>  <span class=\"keyword\">static</span> ArrayList&lt;String&gt; data = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        data.add(<span class=\"string\">\"流水在碰到底处时才会释放活力。——歌德\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doTag</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> JspException, IOException </span>&#123;</span><br><span class=\"line\">        JspContext context = getJspContext();</span><br><span class=\"line\">        JspWriter out = context.getOut();</span><br><span class=\"line\">        Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = r.nextInt(data.size());</span><br><span class=\"line\">        out.println(<span class=\"string\">\"&lt;span&gt;\"</span>+data.get(index)+<span class=\"string\">\"&lt;/span&gt;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">taglib</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/j2ee\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"attr\">version</span>=<span class=\"string\">\"2.0\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 描述标签库 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>xdl<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tlib-version</span>&gt;</span>11.88<span class=\"tag\">&lt;/<span class=\"name\">tlib-version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">short-name</span>&gt;</span>xdl<span class=\"tag\">&lt;/<span class=\"name\">short-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">uri</span>&gt;</span>http://shuidianshuisg.com<span class=\"tag\">&lt;/<span class=\"name\">uri</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签名称 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>heiheihei<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class=\"tag\">&lt;/<span class=\"name\">tag-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 标签的内容 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">body-content</span>&gt;</span>empty<span class=\"tag\">&lt;/<span class=\"name\">body-content</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-JavaWeb三大组件-Servlet-filter-Lister\"><a href=\"#9-JavaWeb三大组件-Servlet-filter-Lister\" class=\"headerlink\" title=\"9. JavaWeb三大组件(Servlet,filter,Lister)\"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id=\"9-1-Filter过滤器\"><a href=\"#9-1-Filter过滤器\" class=\"headerlink\" title=\"9.1 Filter过滤器\"></a>9.1 Filter过滤器</h4><ul>\n<li>请求的过滤器，面向切面编程思想（AOP）</li>\n<li>使用步骤：<ol>\n<li>编写一个类，实现Filter接口</li>\n<li>通过注解或web.xml配置过滤器规则</li>\n</ol>\n</li>\n<li>过滤器链：<ul>\n<li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li>\n</ul>\n</li>\n<li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul>\n<li>注解方式：按照类名的自然顺序先后</li>\n<li>web.xml配置方式：按照web.xml配置顺序，先后执行</li>\n</ul>\n</li>\n<li>案例：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebFilter</span>(<span class=\"string\">\"/home.jsp\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当Filter即将销毁时执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数1.   请求对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数2. 响应对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 参数3.  过滤器链对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"过滤管理员登录的过滤器 正在执行\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//1.    从请求中, 得到session</span></span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        HttpSession session = req.getSession();</span><br><span class=\"line\">        <span class=\"comment\">//2.    判断session中是否存在username</span></span><br><span class=\"line\">        Object username = session.getAttribute(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(username !=<span class=\"keyword\">null</span> &amp;&amp; username.equals(<span class=\"string\">\"admin\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//放行</span></span><br><span class=\"line\">            chain.doFilter(request, response);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class=\"line\">            response.getWriter().append(<span class=\"string\">\"&lt;script&gt;alert('请先以管理员身份登录, 再访问管理页面');window.location.href='login.jsp'&lt;/script&gt;\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当Filter初始化时 执行</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(FilterConfig arg0)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>web.xml配置方式</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/home.jsp<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-2-Listener监听器\"><a href=\"#9-2-Listener监听器\" class=\"headerlink\" title=\"9.2 Listener监听器\"></a>9.2 Listener监听器</h4><ul>\n<li>监听服务器的一些状态事件，事件驱动机制。</li>\n<li>分为两类状态事件：<ul>\n<li>服务器中组件的生命周期</li>\n<li>一些域对象中数据变化的事件</li>\n</ul>\n</li>\n<li>监听服务器的启动与关闭：ServletContextListener</li>\n<li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li>\n<li>监听Session会话的开启与关闭：HttpSessionListener </li>\n<li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener </li>\n</ul>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-JSON在Java中的使用\"><a href=\"#10-JSON在Java中的使用\" class=\"headerlink\" title=\"10. JSON在Java中的使用\"></a>10. JSON在Java中的使用</h3><ul>\n<li>JSON：JavaScript Object Notation</li>\n<li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//引入jar文件</span></span><br><span class=\"line\">Gson g = <span class=\"keyword\">new</span> Gson();</span><br><span class=\"line\">String str = g.toJson(Java对象);<span class=\"comment\">//转换JSON字符串</span></span><br><span class=\"line\">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class=\"comment\">//转换为Java对象</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-AJAX\"><a href=\"#11-AJAX\" class=\"headerlink\" title=\"11. AJAX\"></a>11. AJAX</h3><ul>\n<li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li>\n<li>Ajax请求的状态（readyState）<ul>\n<li>0：正在初始化</li>\n<li>1：请求正在发送</li>\n<li>2：请求发送完毕</li>\n<li>3：服务器开始响应</li>\n<li>4：响应接收完毕，连接断开</li>\n</ul>\n</li>\n<li>Ajax响应的状态（status）<ul>\n<li>200：成功</li>\n<li>404：找不到资源</li>\n<li>500：服务器错误</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-1-GET请求AJAX\"><a href=\"#11-1-GET请求AJAX\" class=\"headerlink\" title=\"11.1 GET请求AJAX\"></a>11.1 GET请求AJAX</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"GET\"</span>, <span class=\"string\">\"地址?参数列表\"</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xhr.readyState === <span class=\"number\">4</span> &amp;&amp; xhr.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//通过xhr.responseText接收响应体</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//失败处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.send();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-2-POST请求AJAX\"><a href=\"#11-2-POST请求AJAX\" class=\"headerlink\" title=\"11.2 POST请求AJAX\"></a>11.2 POST请求AJAX</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"地址\"</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(xhr.readyState === <span class=\"number\">4</span> &amp;&amp; xhr.status === <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">      <span class=\"comment\">//通过xhr.responseText接收响应体</span></span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//失败处理</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//POST请求设置请求头</span></span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>); </span><br><span class=\"line\">xhr.send(参数列表); <span class=\"comment\">//发送请求参数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-2-Jquery中的AJAX\"><a href=\"#11-2-Jquery中的AJAX\" class=\"headerlink\" title=\"11.2 Jquery中的AJAX\"></a>11.2 Jquery中的AJAX</h4><ol>\n<li><code>$.ajax({url,[settings]})</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    url:<span class=\"string\">\"请求的网址\"</span>,</span><br><span class=\"line\">    type:<span class=\"string\">\"请求方式GET/POST...\"</span>,</span><br><span class=\"line\">    <span class=\"keyword\">async</span>:<span class=\"string\">\"请求是否异步, 默认true\"</span>,</span><br><span class=\"line\">    data:<span class=\"string\">\"请求的参数列表, 格式与GET请求?后的格式一致\"</span>,</span><br><span class=\"line\">    dataType:<span class=\"string\">\"TEXT或JSON\"</span>,<span class=\"comment\">//服务器返回的数据类型</span></span><br><span class=\"line\">    success:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;<span class=\"comment\">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class=\"line\">        <span class=\"comment\">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; <span class=\"comment\">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>$.get(url, [data], [callback], [type])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.<span class=\"keyword\">get</span>(\"请求的网址\", &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>$.post(url, [data], [callback], [type])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.post(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;, <span class=\"string\">\"json\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><code>$.getJSON(url, [data], [callback])</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.getJSON(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//data:响应的内容</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><code>jquery对象.load(url, [data], [callback])</code></li>\n</ol>\n<ul>\n<li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">\"#dom\"</span>).load(<span class=\"string\">\"请求的网址\"</span>, &#123; 请求参数键值对 &#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载成功</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-3-Vue中的AJAX\"><a href=\"#11-3-Vue中的AJAX\" class=\"headerlink\" title=\"11.3 Vue中的AJAX\"></a>11.3 Vue中的AJAX</h4><ul>\n<li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li>\n<li>不创建Vue对象的情况下, 使用的ajax:<ul>\n<li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>\n<li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>\n</ul>\n</li>\n<li>创建Vue实例, 使用ajax<ul>\n<li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li>\n<li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],{&quot;emulateJSON&quot;:true}).then(success,error)</code>;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//GET请求: 传递参数列表: </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    params:&#123;</span><br><span class=\"line\">        参数名<span class=\"number\">1</span>:值<span class=\"number\">1</span>,</span><br><span class=\"line\">        参数名<span class=\"number\">2</span>:值<span class=\"number\">2</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">POST请求: 传递参数列表:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    参数名<span class=\"number\">1</span>:值<span class=\"number\">1</span>,</span><br><span class=\"line\">    参数名<span class=\"number\">2</span>:值<span class=\"number\">2</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>success函数 与 error函数<ul>\n<li>格式: function(res){} //res , 就是响应对象, 包含了响应的相关信息</li>\n<li>响应对象的常用属性:<ol>\n<li>url : 响应的网址</li>\n<li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li>\n<li>ok  : boolean值, 响应码在200-299之间时  为 true</li>\n<li>status : 响应码, 例如: 200,302,404,500</li>\n<li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li>\n</ol>\n</li>\n<li>响应对象的常用函数:<ol>\n<li>text() : 以字符串的形式, 返回响应体</li>\n<li>json() : 以对象的形式, 返回响应体</li>\n<li>blob() : 以二进制的形式 , 返回响应体.</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"11-4-AJAX缓存问题\"><a href=\"#11-4-AJAX缓存问题\" class=\"headerlink\" title=\"11.4 AJAX缓存问题\"></a>11.4 AJAX缓存问题</h4><ul>\n<li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li>\n<li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li>\n<li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li>\n</ul>\n<h4 id=\"11-5-AJAX跨域问题\"><a href=\"#11-5-AJAX跨域问题\" class=\"headerlink\" title=\"11.5 AJAX跨域问题\"></a>11.5 AJAX跨域问题</h4><ul>\n<li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li>\n<li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul>\n<li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li>\n<li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li>\n</ul>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjztylo3h0000yot31hcwfkoa","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo4i000cyot343scy5ss"},{"post_id":"cjztylo3v0002yot3ioxkvzls","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo4u000kyot3tn0tbmvk"},{"post_id":"cjztylo440005yot38c0vif3e","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo50000oyot3nvbk0sr1"},{"post_id":"cjztylo460006yot35ah1y69o","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo51000qyot3wi0gdjhq"},{"post_id":"cjztylo4a0007yot3we83ldek","category_id":"cjztylo4z000nyot34nzjpwvu","_id":"cjztylo53000uyot32d0l1dys"},{"post_id":"cjztylo4d000ayot3l7k2kakk","category_id":"cjztylo52000ryot31zchuvcs","_id":"cjztylo560010yot37eta2d7m"},{"post_id":"cjztylo4h000byot3myi9tohy","category_id":"cjztylo4z000nyot34nzjpwvu","_id":"cjztylo570013yot3sp6obun9"},{"post_id":"cjztylo4m000fyot3mc39jr1o","category_id":"cjztylo52000ryot31zchuvcs","_id":"cjztylo590018yot30jy4xxgv"},{"post_id":"cjztylo4q000hyot39t1w2q44","category_id":"cjztylo4z000nyot34nzjpwvu","_id":"cjztylo5a001byot3zrmhjy4w"},{"post_id":"cjztylo4w000myot31udo3vdg","category_id":"cjztylo590017yot3yiv9h3u0","_id":"cjztylo5c001eyot3dj0c9bns"},{"post_id":"cjztylo5s001vyot35wyaqwsa","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo5y0021yot3t3oafcz1"},{"post_id":"cjztylo5t001wyot3kug0u8j7","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo610024yot3j1pe50ct"},{"post_id":"cjztylo5v001yyot32p5tj7fu","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo640027yot38zc1tlme"},{"post_id":"cjztylo5x0020yot3i961o30j","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo66002ayot3uw139nor"},{"post_id":"cjztylo600023yot3psrfgvcu","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylo68002dyot3fhc5d5ui"},{"post_id":"cjztylo630026yot32cgkhae7","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo6b002gyot3u9ltmczd"},{"post_id":"cjztylo650029yot3mq6l7gqq","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo6j002jyot3i6ht9lfp"},{"post_id":"cjztylo67002cyot3o635mc00","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylo6m002nyot3g5e3llbq"},{"post_id":"cjztylo6a002fyot3m18vjdbo","category_id":"cjztylo4z000nyot34nzjpwvu","_id":"cjztylo6p002qyot3k4y2wt0a"},{"post_id":"cjztylo6c002iyot3syqn37ca","category_id":"cjztylo6o002oyot3qiolm8ld","_id":"cjztylo6s002wyot3p416aj0k"},{"post_id":"cjztyloah0036yot3pnupxikw","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztyloap003eyot3btj1ug2o"},{"post_id":"cjztyloaj0039yot3kf5dlpgi","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztyloaq003gyot38d1t8jda"},{"post_id":"cjztyloam003byot3wi3pli3q","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztyloas003iyot3xw857i0k"},{"post_id":"cjztyloag0035yot3edfc0tb5","category_id":"cjztyloaj0037yot3ve1joalp","_id":"cjztyloas003kyot3csvwo5nz"},{"post_id":"cjztyloao003dyot3ktr5watk","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztyloat003myot3y1vzlhk9"},{"post_id":"cjztylobj003tyot3mzgdvlqa","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylobo003yyot3vd5s5bmk"},{"post_id":"cjztylobl003uyot3f7k4uqlg","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylobo0040yot34gomejh0"},{"post_id":"cjztylobm003wyot3anmxr8sh","category_id":"cjztylo3z0003yot3ajbds344","_id":"cjztylobp0042yot3w2wgh1b7"},{"post_id":"cjztylobv0045yot3abh06uyd","category_id":"cjztylo4b0008yot3imj3n5ti","_id":"cjztylobz0048yot3x08tk1k2"}],"PostTag":[{"post_id":"cjztylo3h0000yot31hcwfkoa","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo4p000gyot3dxo5ijqk"},{"post_id":"cjztylo3h0000yot31hcwfkoa","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo4t000iyot3fjcqmqbt"},{"post_id":"cjztylo3v0002yot3ioxkvzls","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo53000tyot3z7vsl6wx"},{"post_id":"cjztylo3v0002yot3ioxkvzls","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo54000vyot379pcggcr"},{"post_id":"cjztylo3v0002yot3ioxkvzls","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo55000yyot3kg40u1ee"},{"post_id":"cjztylo440005yot38c0vif3e","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo580015yot37719b3as"},{"post_id":"cjztylo440005yot38c0vif3e","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo590016yot3skthgsm4"},{"post_id":"cjztylo440005yot38c0vif3e","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo5a001ayot33bap50dr"},{"post_id":"cjztylo460006yot35ah1y69o","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo5d001fyot3e8ooe3we"},{"post_id":"cjztylo460006yot35ah1y69o","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo5d001gyot3m1c6dhoh"},{"post_id":"cjztylo460006yot35ah1y69o","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo5e001iyot3zmq05ft2"},{"post_id":"cjztylo4a0007yot3we83ldek","tag_id":"cjztylo5b001dyot3bjfd7ce1","_id":"cjztylo5e001jyot3wnrwrujr"},{"post_id":"cjztylo4d000ayot3l7k2kakk","tag_id":"cjztylo5e001hyot36daai2nv","_id":"cjztylo5f001lyot3827ydnfj"},{"post_id":"cjztylo4h000byot3myi9tohy","tag_id":"cjztylo5b001dyot3bjfd7ce1","_id":"cjztylo5g001nyot3vr0ga3oz"},{"post_id":"cjztylo4m000fyot3mc39jr1o","tag_id":"cjztylo5g001myot3sq5y0vlu","_id":"cjztylo5h001pyot3venc21mg"},{"post_id":"cjztylo4q000hyot39t1w2q44","tag_id":"cjztylo5h001oyot38ks16utv","_id":"cjztylo5i001syot3jqshub60"},{"post_id":"cjztylo4q000hyot39t1w2q44","tag_id":"cjztylo5b001dyot3bjfd7ce1","_id":"cjztylo5j001tyot30lqomhvu"},{"post_id":"cjztylo4w000myot31udo3vdg","tag_id":"cjztylo5i001ryot3hctotk6w","_id":"cjztylo5j001uyot3cgwv0mrq"},{"post_id":"cjztylo5s001vyot35wyaqwsa","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo5v001xyot3k76ttd9i"},{"post_id":"cjztylo5s001vyot35wyaqwsa","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo5w001zyot3zivl5zgv"},{"post_id":"cjztylo5t001wyot3kug0u8j7","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo5z0022yot3otq7k6iz"},{"post_id":"cjztylo5t001wyot3kug0u8j7","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo620025yot34orh8pba"},{"post_id":"cjztylo5v001yyot32p5tj7fu","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo650028yot3bw9mol6w"},{"post_id":"cjztylo5v001yyot32p5tj7fu","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo67002byot3dbwgxu57"},{"post_id":"cjztylo5x0020yot3i961o30j","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo69002eyot30bj32a6q"},{"post_id":"cjztylo5x0020yot3i961o30j","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo6c002hyot32rsiidwy"},{"post_id":"cjztylo600023yot3psrfgvcu","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylo6k002lyot3haj4eo0e"},{"post_id":"cjztylo600023yot3psrfgvcu","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo6p002pyot3xz51px2z"},{"post_id":"cjztylo630026yot32cgkhae7","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo6p002ryot3sw1xl825"},{"post_id":"cjztylo630026yot32cgkhae7","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo6q002tyot3oxylajvw"},{"post_id":"cjztylo630026yot32cgkhae7","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo6r002uyot39ygajpao"},{"post_id":"cjztylo650029yot3mq6l7gqq","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo6s002vyot359aamhzp"},{"post_id":"cjztylo650029yot3mq6l7gqq","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo6s002xyot34m8nw3y9"},{"post_id":"cjztylo650029yot3mq6l7gqq","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo6t002yyot3psaqxs43"},{"post_id":"cjztylo67002cyot3o635mc00","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylo6t002zyot3lhmviba4"},{"post_id":"cjztylo67002cyot3o635mc00","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylo6t0030yot3mekcooil"},{"post_id":"cjztylo67002cyot3o635mc00","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztylo6u0031yot314zndcfe"},{"post_id":"cjztylo6a002fyot3m18vjdbo","tag_id":"cjztylo5b001dyot3bjfd7ce1","_id":"cjztylo6u0032yot3hl1kk8hh"},{"post_id":"cjztylo6a002fyot3m18vjdbo","tag_id":"cjztylo6j002kyot3fse2sa52","_id":"cjztylo6u0033yot36smobhib"},{"post_id":"cjztylo6c002iyot3syqn37ca","tag_id":"cjztylo6q002syot3lhokrg0m","_id":"cjztylo6u0034yot3h3opz9o0"},{"post_id":"cjztyloah0036yot3pnupxikw","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztyloam003ayot3nfj60o3i"},{"post_id":"cjztyloah0036yot3pnupxikw","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztyloao003cyot382xvp7oy"},{"post_id":"cjztyloaj0039yot3kf5dlpgi","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztyloaq003fyot3fblrky5v"},{"post_id":"cjztyloaj0039yot3kf5dlpgi","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztyloar003hyot3jq4etplb"},{"post_id":"cjztyloam003byot3wi3pli3q","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztyloas003jyot3lv1wpvdk"},{"post_id":"cjztyloam003byot3wi3pli3q","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztyloat003lyot3i2fuoj6m"},{"post_id":"cjztyloam003byot3wi3pli3q","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztyloat003nyot3vqbeiow9"},{"post_id":"cjztyloag0035yot3edfc0tb5","tag_id":"cjztyloaj0038yot39uqvzz1r","_id":"cjztyloat003oyot3lw0y0yi6"},{"post_id":"cjztyloag0035yot3edfc0tb5","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztyloau003pyot3ngl1pzwx"},{"post_id":"cjztyloao003dyot3ktr5watk","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztyloau003qyot344x407wh"},{"post_id":"cjztyloao003dyot3ktr5watk","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztyloau003ryot3oykafn6z"},{"post_id":"cjztyloao003dyot3ktr5watk","tag_id":"cjztylo50000pyot3f8fu33c0","_id":"cjztyloav003syot3ivsc89vf"},{"post_id":"cjztylobj003tyot3mzgdvlqa","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylobm003vyot39ucpbogb"},{"post_id":"cjztylobj003tyot3mzgdvlqa","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylobn003xyot32buc8l7s"},{"post_id":"cjztylobl003uyot3f7k4uqlg","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylobo003zyot3x7i2ig1d"},{"post_id":"cjztylobl003uyot3f7k4uqlg","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylobp0041yot3sn6a1o9a"},{"post_id":"cjztylobm003wyot3anmxr8sh","tag_id":"cjztylo420004yot3k84xjf7f","_id":"cjztylobp0043yot3n2qdmw6d"},{"post_id":"cjztylobm003wyot3anmxr8sh","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylobu0044yot32dygwiva"},{"post_id":"cjztylobv0045yot3abh06uyd","tag_id":"cjztylo4j000eyot3m17rqz86","_id":"cjztylobx0046yot3irwd1us4"},{"post_id":"cjztylobv0045yot3abh06uyd","tag_id":"cjztylo4c0009yot3qk7oiit3","_id":"cjztylobz0047yot3ac5ygdux"}],"Tag":[{"name":"javaSE","_id":"cjztylo420004yot3k84xjf7f"},{"name":"后端开发","_id":"cjztylo4c0009yot3qk7oiit3"},{"name":"javaEE","_id":"cjztylo4j000eyot3m17rqz86"},{"name":"Spring","_id":"cjztylo50000pyot3f8fu33c0"},{"name":"hexo","_id":"cjztylo5b001dyot3bjfd7ce1"},{"name":"bower","_id":"cjztylo5e001hyot36daai2nv"},{"name":"sublime","_id":"cjztylo5g001myot3sq5y0vlu"},{"name":"javascript","_id":"cjztylo5h001oyot38ks16utv"},{"name":"开源","_id":"cjztylo5i001ryot3hctotk6w"},{"name":"BlueLake","_id":"cjztylo6j002kyot3fse2sa52"},{"name":"mongodb","_id":"cjztylo6q002syot3lhokrg0m"},{"name":"数据库","_id":"cjztyloaj0038yot39uqvzz1r"}]}}