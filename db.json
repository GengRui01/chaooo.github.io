{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style-dark.styl","path":"css/style-dark.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","path":"img/bg-dark.jpg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/css/share.styl","path":"share/css/share.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","path":"share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","path":"share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","path":"share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","path":"share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/js/qrcode.js","path":"share/js/qrcode.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/share/js/social-share.js","path":"share/js/social-share.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1562469885966},{"_id":"themes/BlueLake/README.en.md","hash":"76269fd9d9f7f6f457b242ae73d0e90f104de5fb","modified":1562469885967},{"_id":"themes/BlueLake/README.md","hash":"18a900a2987acb5d43086f141929627df38c179d","modified":1562469885969},{"_id":"themes/BlueLake/_config.yml","hash":"11ae55cf053accd4aa2ccb64bc9318a0a95bb500","modified":1562575730873},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1562469886004},{"_id":"source/_posts/01_JavaSE语法基础.md","hash":"d8792c5c3ede2f5b3a0cd96d41a9f19139b83aa1","modified":1563633938313},{"_id":"source/_posts/02_JavaSE面向对象.md","hash":"cb0e5b2e259bda4de5af812bac03ef0636902648","modified":1563633951139},{"_id":"source/_posts/03_JavaSE核心工具类.md","hash":"75b5de0302952f7f9ebc3ca86c253f4513778dfa","modified":1563633962537},{"_id":"source/_posts/04_JavaSE集合框架.md","hash":"a9b3ed5e9f9987089fa51ec705d50f098b21fee1","modified":1563634003086},{"_id":"source/_posts/05_JavaSE异常处理机制.md","hash":"495aec297457c5b43e8347e13d77e89df7e2500b","modified":1563634011992},{"_id":"source/_posts/06_JavaSE输入输出-IO.md","hash":"28d932f4e494069a23289d4c89dc4ffedbbe5482","modified":1563634029875},{"_id":"source/_posts/07_JavaSE多线程.md","hash":"204210a552f7795bc8834ab144734209a49c94a9","modified":1563634315308},{"_id":"source/_posts/08_JavaSE反射机制.md","hash":"c083db1e82b5078e3c049adfa3b3405422fd081e","modified":1563634600906},{"_id":"source/_posts/09_JavaSE网络编程.md","hash":"f978e9a1627317403de1cbd18f85a50eca805800","modified":1563634912870},{"_id":"source/_posts/10_JavaSE常用设计模式.md","hash":"ac509f94622374f4d98b4646132c132ef299c4c9","modified":1563635016395},{"_id":"source/_posts/11_JavaSE数据结构与算法入门.md","hash":"7cc83fefb9ca9253ba35526278cbd52c2164d39f","modified":1563635285419},{"_id":"source/_posts/12_JavaWeb编程基础.md","hash":"e5bae675de8948456b61669916c60dd979be2337","modified":1563635296463},{"_id":"source/_posts/BlueLake博客主题的详细配置.md","hash":"9d59601ce904b64eef4ad750ae85d7945a438f69","modified":1563631762498},{"_id":"source/_posts/Hexo3-2-github搭建静态博客.md","hash":"d6e8eac054081ce193035a1c3e43571af05353c6","modified":1562468771430},{"_id":"source/_posts/MongoDB学习笔记.md","hash":"39011edebf356d56bf4f7173f6a4dab0323193bb","modified":1562481374618},{"_id":"source/_posts/Web包管理器-Bower.md","hash":"c217401b1a6d971c97c69b37a1fa0f9030bcefac","modified":1562468771447},{"_id":"source/_posts/Win10下配置Nginx-php7-mysql-5-6.md","hash":"2b8d194c452cb7c58839ab1f6c8abb8c30bc4acd","modified":1562468771448},{"_id":"source/_posts/hello-world.md","hash":"a571d5a7c330d8906075139a7f69c5cc4b3cf87f","modified":1562468771449},{"_id":"source/_posts/sublime-text3个人习惯配置-C.md","hash":"d4acd3ecea1ca691ec17878f4d33444538cb3e35","modified":1562551351461},{"_id":"source/_posts/自定义HEXO站内搜索Javascript-json.md","hash":"1e2403133c932229249893d8e083d3cb16ebca59","modified":1562468771450},{"_id":"source/_posts/谈谈开源.md","hash":"ebb2d92abce9e0fc78abcee30620f827d164ab2b","modified":1563631917528},{"_id":"source/about/index.md","hash":"083adf2e49d2a4b6d47af102abc5ebc11fa47ff8","modified":1562468771451},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"85f06e2ea9a45bb55761b29cda4487f782557b2b","modified":1562469885971},{"_id":"themes/BlueLake/languages/en.yml","hash":"fe087d478a81ffc15f93f2295bc2b6f49a149c3d","modified":1562469885972},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"a57b9b768346adfe1c1553c4b727d5c113a52480","modified":1562469885973},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"fff49dfae21808bb1edd74dfe4f14c457b64c191","modified":1562469885974},{"_id":"themes/BlueLake/languages/ko.yml","hash":"bd3c4058a43a0f6e239f360261f3260c87c185f0","modified":1562469885975},{"_id":"themes/BlueLake/languages/tr.yml","hash":"47d1dfd33fb1f0acbb1dfd400854d265ae8ccd45","modified":1562469885976},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"b388d0e44084026dedaf4ffdf7536e06bc8b37a8","modified":1562469885977},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"9a7ffb9f16af9fdca51d818e4fd2eb9f7e8ba9cf","modified":1562469885978},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1562469885997},{"_id":"themes/BlueLake/layout/base.jade","hash":"fd0d4e3878e48c5aa40bb1946703b9543fb5d3c7","modified":1562481829157},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1562469885999},{"_id":"themes/BlueLake/layout/index.jade","hash":"6406182f71d0f36757e91c5ec999f244c1f83c68","modified":1562469886000},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1562469886001},{"_id":"themes/BlueLake/layout/post.jade","hash":"2099b699b9d22ec60e9970f4877cfd091a8622bf","modified":1562485541543},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1562469886003},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1562469886005},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1562469886010},{"_id":"themes/BlueLake/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1562469885882},{"_id":"themes/BlueLake/.git/config","hash":"7e25608fae05296ec4af5a16d8ecf5042faf30a3","modified":1562469885893},{"_id":"themes/BlueLake/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1562469873988},{"_id":"themes/BlueLake/.git/index","hash":"79b2516e716b33233c4adb15499edd12aac79faa","modified":1562491125764},{"_id":"themes/BlueLake/.git/packed-refs","hash":"6fb50c49066dc1d6109757f03a9a2ae69c6eb0d4","modified":1562469885873},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"0c80970e25b8532e3009220eaa100fc64520ee95","modified":1562485550493},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1562469885980},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"3fa65886665e8165640d22ede8dd3b06a0554583","modified":1562481831332},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"f95aa1d48752fe47046c0ba89199ad765351b510","modified":1562482109311},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"138e32ba7f01ced06558a8bbcf85423f697abb00","modified":1562485602196},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1562469885984},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1562469885985},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1562469885986},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1562469885987},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"44de0851108bca8404f5614d5101c7a7ee67754d","modified":1562482168921},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1562469885989},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1562469885988},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1562469885990},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1562469885991},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1562469885992},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1562469885993},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1562469885993},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1562469885994},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1562469885995},{"_id":"themes/BlueLake/source/css/highlight-dark.styl","hash":"11dfe68ade914332c484a4dceaec215bf8b62ee7","modified":1562469886006},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1562469886007},{"_id":"themes/BlueLake/source/css/style-dark.styl","hash":"3f45549a1aff27a14eae81d9be74977337d14464","modified":1563171730301},{"_id":"themes/BlueLake/source/css/style.styl","hash":"a990d649eb2d4dacfec0910d05d839a5f677c02b","modified":1563172208518},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1562469886012},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1562469886013},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1562469886014},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1562469886016},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1562469886021},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1562469886022},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1562469886023},{"_id":"themes/BlueLake/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1562469873990},{"_id":"themes/BlueLake/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1562469873997},{"_id":"themes/BlueLake/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1562469873999},{"_id":"themes/BlueLake/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1562469874001},{"_id":"themes/BlueLake/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1562469874002},{"_id":"themes/BlueLake/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1562469874003},{"_id":"themes/BlueLake/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1562469874013},{"_id":"themes/BlueLake/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1562469874015},{"_id":"themes/BlueLake/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1562469874017},{"_id":"themes/BlueLake/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1562469874019},{"_id":"themes/BlueLake/.git/logs/HEAD","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885888},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1562469886020},{"_id":"themes/BlueLake/source/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1562469886018},{"_id":"themes/BlueLake/source/share/css/share.styl","hash":"e1337f4029ddd37e8d9657d1b05023b5ea715acf","modified":1562469886025},{"_id":"themes/BlueLake/source/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1562469886026},{"_id":"themes/BlueLake/source/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1562469886027},{"_id":"themes/BlueLake/source/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1562469886028},{"_id":"themes/BlueLake/source/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1562469886029},{"_id":"themes/BlueLake/source/share/js/qrcode.js","hash":"962ad9cb87afa140a644178e5f3c53e2514ea1e5","modified":1562469886031},{"_id":"themes/BlueLake/source/share/js/social-share.js","hash":"fe73d3b1c63a498f18f885fc83d631c2b63535e7","modified":1562469886032},{"_id":"themes/BlueLake/.git/objects/pack/pack-a8648c582315762d09a3092df6c5cdc5460c3b90.idx","hash":"6c886117ec82a594e268a026b2ae258365b5f898","modified":1562469885599},{"_id":"themes/BlueLake/.git/refs/heads/master","hash":"c267bddbfc3cc43de3f7124c4449d3b343552f72","modified":1562469885886},{"_id":"themes/BlueLake/.git/logs/refs/heads/master","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885887},{"_id":"themes/BlueLake/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1562469885880},{"_id":"themes/BlueLake/.git/logs/refs/remotes/origin/HEAD","hash":"7f013086f2e2750e6b4b6db9701607eb3ec6bb50","modified":1562469885879},{"_id":"themes/BlueLake/.git/objects/pack/pack-a8648c582315762d09a3092df6c5cdc5460c3b90.pack","hash":"3b75145e7fa3a9bb5347db68bcf9e6ac5eef9d62","modified":1562469885722},{"_id":"public/baidusitemap.xml","hash":"14637047d98d89699c80f89e451a1e6b3ae59493","modified":1563635380911},{"_id":"public/atom.xml","hash":"fd3ba27a30a78bfe2f07971a1a4ea57abd5f9717","modified":1563635380911},{"_id":"public/search.xml","hash":"87895e40f9a9f34f493252e9fdf9aba45eae5620","modified":1563635380940},{"_id":"public/content.json","hash":"b1311766160cfa2d7b7cb3d5b825b1529b389dc7","modified":1563635380915},{"_id":"public/sitemap.xml","hash":"011b852e49a7bfcdb1d97016fe32f64f20e8e9e3","modified":1563635380940},{"_id":"public/about/index.html","hash":"78149c6b1d66183a9366717567a0f691547c77a6","modified":1563635380956},{"_id":"public/2019/07/11/谈谈开源.html","hash":"afc036a36225d418cc9c9c8b2bc4b4a759289b14","modified":1563635380956},{"_id":"public/2015/12/31/hello-world.html","hash":"15558b1afd53050f401a50e982e210657ac4bb00","modified":1563635380957},{"_id":"public/archives/index.html","hash":"43b1b7d3b4c98ef494bca6ed1f7c7bef5114bbcd","modified":1563635380959},{"_id":"public/archives/2015/index.html","hash":"c3dc8f3a0c2f6f60fe64661276aeab1b3c86cde3","modified":1563635380958},{"_id":"public/archives/2015/12/index.html","hash":"c3dc8f3a0c2f6f60fe64661276aeab1b3c86cde3","modified":1563635380958},{"_id":"public/archives/2016/index.html","hash":"c33eb5c02512e707c6aa0022cf004f14ddaf6b58","modified":1563635380958},{"_id":"public/archives/2016/05/index.html","hash":"80a15e3137a20f8ca1cff69a9f432728da1dbae1","modified":1563635380958},{"_id":"public/archives/2016/06/index.html","hash":"52760f055e4245ba49583641ab65e088ccc0287b","modified":1563635380958},{"_id":"public/archives/2016/07/index.html","hash":"31b12d86a973037ba895bb6ee3db515a1cb557a7","modified":1563635380958},{"_id":"public/archives/2016/08/index.html","hash":"b1ba9caf34ab0a28f71ac93188e6e1176c2fcf59","modified":1563635380958},{"_id":"public/archives/2016/11/index.html","hash":"eab9ad52b2335571189279fa8499e57159117c5e","modified":1563635380959},{"_id":"public/archives/2016/12/index.html","hash":"81ad07a8cefe8c91c935812b85cd1679750ea5aa","modified":1563635380959},{"_id":"public/archives/2019/index.html","hash":"578d71961570852dd075c1f5d16192207407a694","modified":1563635380959},{"_id":"public/archives/2019/02/index.html","hash":"5ee5df8689ad5cf42d8cf5f8fc9bcc26b23f1f7c","modified":1563635380959},{"_id":"public/archives/2019/07/index.html","hash":"723d433c0a7488a63d7aa1b96f022b81d6560ccd","modified":1563635380959},{"_id":"public/categories/javaSE知识梳理/index.html","hash":"814a47536ed5881112b8261e2c00e113b4d603db","modified":1563635380957},{"_id":"public/categories/hexo博客折腾/index.html","hash":"265373d9ff0deab30361f805c61d2f361d32dc73","modified":1563635380957},{"_id":"public/categories/前端工具/index.html","hash":"20c5decd3663f6d825514bb805a56061f19a626b","modified":1563635380957},{"_id":"public/categories/杂谈/index.html","hash":"6439c7146ed97bd84a3ae668bf86fc5e87975ef7","modified":1563635380961},{"_id":"public/categories/数据库/index.html","hash":"b4837510d98e59cc30a3b559cc7d8bce10dfdd07","modified":1563635380961},{"_id":"public/categories/JavaWeb编程/index.html","hash":"fa58e00d3c9e32c77ffafd087abc7120e524589d","modified":1563635380957},{"_id":"public/index.html","hash":"2c02d572439fd4992f4d631e26ce81c00359b604","modified":1563635380959},{"_id":"public/page/2/index.html","hash":"e3eac5f4fb6c0fedd8cb0bfd287156f36b0cf602","modified":1563635380959},{"_id":"public/page/3/index.html","hash":"3ebd1fd5eb98a54cb936d136d5d8cf61736ea04b","modified":1563635380959},{"_id":"public/page/4/index.html","hash":"476d65f316b23866ad3ffd776f70e9de6a1e1030","modified":1563635380959},{"_id":"public/tags/javaSE/index.html","hash":"19eac6edae06ff29ce9644794ac29ae28116ed6a","modified":1563635380961},{"_id":"public/tags/后端开发/index.html","hash":"e348658da899ec59f8adca83b1ff9eb1f99cdb12","modified":1563635380962},{"_id":"public/tags/hexo/index.html","hash":"908ca09ac2661cafca10a66a7d78daf91493e37e","modified":1563635380962},{"_id":"public/tags/bower/index.html","hash":"93c102f110071a164bd816dc8428556e32139db1","modified":1563635380962},{"_id":"public/tags/sublime/index.html","hash":"7266e70d6a1b13aff1a2b3cd6db783967205d4df","modified":1563635380962},{"_id":"public/tags/javascript/index.html","hash":"5d16328006acc1f291bf4ca742e05eacf9b36754","modified":1563635380965},{"_id":"public/tags/开源/index.html","hash":"ae9caa47a598ae23220a05e0c4214e92b43f081e","modified":1563635380965},{"_id":"public/tags/BlueLake/index.html","hash":"5bf7919b7e1d30281fab67869d2f357fb4c72ec4","modified":1563635380965},{"_id":"public/tags/mongodb/index.html","hash":"467619a63436eef4008a62091290585f505f5d7d","modified":1563635380965},{"_id":"public/tags/javaEE/index.html","hash":"1bfbee209da57800ca6ee74d2a9a3e35050c7a74","modified":1563635380965},{"_id":"public/2019/07/20/12_JavaWeb编程基础.html","hash":"00cc8ceeafa12c1d103afbba7162c95a6a58cae9","modified":1563635380968},{"_id":"public/2019/07/15/11_JavaSE数据结构与算法入门.html","hash":"8064774f35660b91a321c063f6faa05ebbf37d61","modified":1563635380967},{"_id":"public/2019/07/15/10_JavaSE常用设计模式.html","hash":"0f9af73d3827df163b3c8ce0f58afd7438d23fe1","modified":1563635380968},{"_id":"public/2019/07/12/09_JavaSE网络编程.html","hash":"ff8c63398a51cc37c44c698be38175da32ba6e9a","modified":1563635380965},{"_id":"public/2019/07/10/08_JavaSE反射机制.html","hash":"fe01a1a574eb7b5add21119c08b6d9ec58f06c5f","modified":1563635380966},{"_id":"public/2019/07/09/07_JavaSE多线程.html","hash":"91127601fdb2865dba25c5ecee41566cf0a42526","modified":1563635380966},{"_id":"public/2019/07/09/06_JavaSE输入输出-IO.html","hash":"b336bd8766996d15765e95991986beadb441e0e1","modified":1563635380966},{"_id":"public/2019/07/09/05_JavaSE异常处理机制.html","hash":"0aef493061dfcc07448d73d826f7ba68f71cb8d1","modified":1563635380966},{"_id":"public/2019/07/08/04_JavaSE集合框架.html","hash":"d1cb01b13f476fc0b682857bc9895b6d6a58acb1","modified":1563635380966},{"_id":"public/2019/07/08/03_JavaSE核心工具类.html","hash":"4b2ee1016f092fe09817eb798fec6468ab6078cc","modified":1563635380966},{"_id":"public/2019/07/07/02_JavaSE面向对象.html","hash":"c5a1647ad4cf196085b9c65250117b4f6dd58ba3","modified":1563635380967},{"_id":"public/2019/07/07/01_JavaSE语法基础.html","hash":"699c9f7a4b517e80a2d79336ead808b36252e35b","modified":1563635380967},{"_id":"public/2019/02/22/Win10下配置Nginx-php7-mysql-5-6.html","hash":"cdc473dfc7718b3a03185b51740d4a7f7fc39b03","modified":1563635380967},{"_id":"public/2016/12/29/BlueLake博客主题的详细配置.html","hash":"f6026bdb44cd171f916cbe57f1bf9071f707b3a9","modified":1563635380967},{"_id":"public/2016/11/09/自定义HEXO站内搜索Javascript-json.html","hash":"5f702c639de0be59f19a9d13e82c227700cf171a","modified":1563635380967},{"_id":"public/2016/08/12/Web包管理器-Bower.html","hash":"1603141cbd49f1edc28747d4c9b63524abdbc786","modified":1563635380968},{"_id":"public/2016/07/30/MongoDB学习笔记.html","hash":"36d99cad20b59f4f5287acf1bea599fd1ba46152","modified":1563635380968},{"_id":"public/2016/06/29/sublime-text3个人习惯配置-C.html","hash":"3a4f5ef8fb22a24a06b23c374b52391e7d266781","modified":1563635380968},{"_id":"public/2016/05/23/Hexo3-2-github搭建静态博客.html","hash":"9e445177f752bc7f35ffed3f279b178b7ba45df9","modified":1563635380969},{"_id":"public/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1563631229004},{"_id":"public/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1563631229004},{"_id":"public/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1563631229004},{"_id":"public/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1563631229005},{"_id":"public/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1563631229005},{"_id":"public/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1563631229005},{"_id":"public/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1563631229005},{"_id":"public/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1563631229005},{"_id":"public/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1563631229005},{"_id":"public/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1563631229005},{"_id":"public/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1563631229447},{"_id":"public/css/highlight-dark.css","hash":"0fabf7a922ac0703492ba406608ce972f749bbb9","modified":1563631229453},{"_id":"public/css/highlight.css","hash":"fb0403feb34cc8bb8b1f28f238540d36588b86df","modified":1563631229453},{"_id":"public/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1563631229454},{"_id":"public/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1563631229454},{"_id":"public/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1563631229454},{"_id":"public/share/css/share.css","hash":"31af1d5174b1f7d3d62813dda5339f911ce0e668","modified":1563631229455},{"_id":"public/img/bg-dark.jpg","hash":"0d2c406f1a9b3b74d6defda398239b0113737787","modified":1563631229455},{"_id":"public/share/js/social-share.js","hash":"9bfe34fe7691833e90815c5c862545bde581cf29","modified":1563631229457},{"_id":"public/css/style-dark.css","hash":"fe766cb081431bdf98fc1aebe7be991af6a789f4","modified":1563631229855},{"_id":"public/css/style.css","hash":"97c009cd85c252083b08d8c156767692bd5ec24e","modified":1563631229855},{"_id":"public/share/js/qrcode.js","hash":"9caa0d9a9ba4409a3f77540a1b15a7617aeb28e8","modified":1563631229869}],"Category":[{"name":"javaSE知识梳理","_id":"cjyblnrrb0003xwt3avk43gs4"},{"name":"hexo博客折腾","_id":"cjyblnrrs000cxwt3ea019jh0"},{"name":"前端工具","_id":"cjyblnrrz000jxwt35y2tdo0f"},{"name":"杂谈","_id":"cjyblnrs8000yxwt38jqz9kar"},{"name":"数据库","_id":"cjyblnrt1001sxwt30xadspjk"},{"name":"JavaWeb编程","_id":"cjyblnrx00028xwt32hw2il0x"}],"Data":[],"Page":[{"title":"about","date":"2016-11-09T09:29:51.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-09 17:29:51\n---\n","updated":"2019-07-07T03:06:11.451Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjyblnrr60001xwt3v9ck3euw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"一、JavaSE语法基础","date":"2019-07-07T09:33:54.000Z","_content":"\n这是**javaSE知识梳理**的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。\n<!-- more -->\n\n1. [数据类型](#id1)\n2. [变量与常量](#id2)\n3. [数据类型之间的转换](#id3)\n4. [运算符](#id4)\n5. [循环](#id5)\n6. [数组](#id6)\n7. [函数](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 数据类型\n#### 1.1 分为两大类：\n1. 基本数据类型：byte，short，int，long，float，double，boolean，char\n2. 引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface\n\n> 注：`单个字节`表示`8位二进制`位，最左边表示符号位（0：正，1：负）。\n\n#### 1.2 整数类型（byte，short，int，long）\n1. **byte**： 1个字节，范围`-2^7~2^7-1`，即`-128~127`。\n2. **short**：2个字节，范围`-2^15~2^15-1`，即`-32768~32767`。\n3. **int**:   4个字节，范围`-2^31~2^31-1`，即`正负21亿`之间。\n4. **long**： 8个字节，范围`-2^63~2^63-1`，比int更大。如果要表示long直接量，需要`L`或`l`结尾。\n\n#### 1.3 浮点类型（float，double）\n1. **float**： 4个字节，单精度浮点数，取到`小数点后7`位有效数字。如果要表示float直接量，需要`F`或`f`结尾\n2. **double**：8个字节，双精度浮点数，取到`小数点后15`位有效数字。\n\n> 扩展：浮点运算有时会有误差，为了实现精确运算可使用`java.math.BigDecimal`类型加以描述。\n\n#### 1.4 布尔类型（boolean）\n1. **boolean**：1个字节（未明确规定），值只有`true`和`false`。\n\n#### 1.5 字符类型（char）\n1. **char**：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：'a','1','中' 等。\n- 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号\"\"引起来。\n- 需记住的ASII码字符：'a':97，'A':65，'0':48，空格:32，换行符:10\n- 常用转义符(逃逸字符)：`\\t`:制表符，`\\n`:换行，`\\\"`，`\\'`，`\\\\`:反斜杠本身，`\\b`:回退一格，`\\r`:回车\n- 字符类型计算\n  * 一个字符加一个数字，得到Unicode码表中那个数之后的字符\n  * 两个字符相减得到它们在表中的距离\n  * char也可以和int之间相互赋值\n\n\n<span id=\"id2\"><span>\n### 2. 变量与常量\n#### 2.1 常量\n- 常量是一个值，在程序运行的过程中不能再次发生改变\n- 基本类型的值都可以认为是常量   4  3.4  'a'  true，String类(引用数据类型)值\"abc\"视为常量\n- 常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit--int   64bit--double\n\n#### 2.2 变量\n- 变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的\n- 变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字\n- 变量空间   里面只能存储一个内容(值/引用)\n- 空间内的内容的类型与定义时一致 内容可以改变 \n- 内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值\n\n#### 2.3 标识符（变量）命名规则\n1. 必须字母，数字，下划线以及美元$等组成，且首位非数字。\n2. 不能使用Java语言中的关键字，如class，static，void，int等。\n3. 区分大小写，长度无限制，但不能过长，尽量见名知意。\n\n#### 2.3 命名的规约\n- 类名字：首字母大写，如果两个以上的单词，所有首字母都大写\n- 变量名：首字母小写，如果两个以上的单词，之后的首字母大写\n- 遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性\n\n\n<span id=\"id3\"><span>\n### 3. 数据类型之间的转换\n#### 3.1 基本数据类型之间转换\n1. 自动类型转换：从小类型到大类型自动转换\n\n```\nbyte --> short --> int --> long --> float --> double\n          char -----^\n```\n\n2. 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出\n\n```\nlong big = 1024L\\*1024\\*1024;\nint i = (int)big;\n```\n\n#### 3.2其他数据类型之间转换\n- 同种大数据类型之间才能发生转换\n- 类型转换之前，保证大前提：同种大数据类型一致\n    * 基本--基本   可以直接转换(自动 强制)\n    * 引用--引用   可以直接转化(自动 强制 -- 上转型 下转型)\n    * 基本--引用   不可以直接进行转化(间接-桥梁-包装类)\n- 保证大数据类型一致的前提下(都是基本类型)\n* 小数据类型一致:整型-->整型 / 浮点-->浮点\n    + 比较内存空间的大小\n    + 大数据类型空间可以直接接受小数据类型的值(自动转换)\n    + 小数据类型空间不可以直接接受大数据类型的值(强制类型转换)\n    + 强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据\n    ```\n    byte a = 1;   int b = a;//自动直接转化就可以\n    int a = 1;  byte b = (byte)a;//需要强制类型转换\n    float x = 3.4F;   double y = x;//自动直接转化\n    double x = 3.4; float y = (float)x;//强制转换\n    ```\n* 小数据类型不一致:整型-->浮点\n    + 比较精确程度\n    + 浮点型的精确程度更高\n    + 任何一个浮点型空间都可以直接接受一个整型的值\n    + 反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)\n    ```\n    int a = 1;  float b = a;//自动直接转化\n    float a =1.0F;  int b = (int)a;//强制类型转换\n    ```\n* 整型-->字符\n    + 每一个字符都对应这一个Unicode码   a--97\n    ```\n    char x = 'a';  int y = x;//自动转化  y--97\n    int x = 97; char y = (char)x;//强制的转化\n    ```\n* 布尔类型很特殊\n    + 不能与其他基本类型之间发生转化\n\n\n<span id=\"id4\"><span>\n### 4. 运算符\n1. 算术运算符： `+`，`-`，`*`，`/`，`%`\n2. 关系运算符： `>`，`<`，`>=`，`<=`，`==`，`!=`\n3. 自增减运算符： `++`，`--`\n4. 逻辑运算符： `&&`，`||`，`！`（短路特性：逻辑与`&&`运算，若第一个条件为假,跳过第二个条件；逻辑或`||`运算，若第一个条件为真，跳过第二个条件）\n5. 三目运算符： 条件 ? 表达式1 ： 表达式2\n6. 赋值运算符：`=`，`+=`，`-=`，`*=`，`=` \n\n<span id=\"id5\"><span>\n### 5. 循环\n1. while循环和for循环完全可以互换。\n2. while循环主要用于明确循环条件，但不明确循环次数的场合\n3. for循环主要用于明确次数或范围的场合\n4. while(true) 等价于 for(;;)，表示无限循环。\n\n<span id=\"id6\"><span>\n### 6. 数组\n#### 6.1 一维数组\n- `数组类型[] 数组名 = new 数据类型[长度]` ：动态方式\n\n``` java\n数组类型[] 数组名 = new 数据类型[长度] //动态方式\nint[] arr = new int[5];\n```\n\n``` java\n数组类型[] 数组名 = {初始值1, 初始值1, 初始值1, ...} //静态方式\nint[] arr = {10, 20, 30, 40};\n/*特殊方式：*/ int[] arr = new int[]{10, 20, 30};\n```\n\n#### 6.2 二维数组\n\n``` java\n数组类型[][] 数组名 = new 数据类型[行数][列数]\nint[][] arr = new int[5][6];\n```\n\n``` java\n数组类型[][] 数组名 = {{初始值1, 初始值1, 初始值1},{值2,...} ...}\nint[] arr = {{10, 20, 30}, {01, 5, 3}, {8, 20, 6}};\n```\n\n> 二维数组arr.length表示行数，arr[0].length表示此行的长度\n\n\n<span id=\"id7\"><span>\n### 7. 函数\n- 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。\n\n``` java\npublic static int sum(int a, int b){\n  int i;\n  int sum=0;\n  for(i=a; i<=b; i++){\n    sum += i;\n  }\n  System.out.println(a +\"到\"+ b +\"的和是\"+ sum);\n  return sum;\n}\n```\n\n- 函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序\n- 函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用\n","source":"_posts/01_JavaSE语法基础.md","raw":"---\ntitle: 一、JavaSE语法基础\ndate: 2019-07-07 17:33:54\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n这是**javaSE知识梳理**的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。\n<!-- more -->\n\n1. [数据类型](#id1)\n2. [变量与常量](#id2)\n3. [数据类型之间的转换](#id3)\n4. [运算符](#id4)\n5. [循环](#id5)\n6. [数组](#id6)\n7. [函数](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 数据类型\n#### 1.1 分为两大类：\n1. 基本数据类型：byte，short，int，long，float，double，boolean，char\n2. 引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface\n\n> 注：`单个字节`表示`8位二进制`位，最左边表示符号位（0：正，1：负）。\n\n#### 1.2 整数类型（byte，short，int，long）\n1. **byte**： 1个字节，范围`-2^7~2^7-1`，即`-128~127`。\n2. **short**：2个字节，范围`-2^15~2^15-1`，即`-32768~32767`。\n3. **int**:   4个字节，范围`-2^31~2^31-1`，即`正负21亿`之间。\n4. **long**： 8个字节，范围`-2^63~2^63-1`，比int更大。如果要表示long直接量，需要`L`或`l`结尾。\n\n#### 1.3 浮点类型（float，double）\n1. **float**： 4个字节，单精度浮点数，取到`小数点后7`位有效数字。如果要表示float直接量，需要`F`或`f`结尾\n2. **double**：8个字节，双精度浮点数，取到`小数点后15`位有效数字。\n\n> 扩展：浮点运算有时会有误差，为了实现精确运算可使用`java.math.BigDecimal`类型加以描述。\n\n#### 1.4 布尔类型（boolean）\n1. **boolean**：1个字节（未明确规定），值只有`true`和`false`。\n\n#### 1.5 字符类型（char）\n1. **char**：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：'a','1','中' 等。\n- 开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号\"\"引起来。\n- 需记住的ASII码字符：'a':97，'A':65，'0':48，空格:32，换行符:10\n- 常用转义符(逃逸字符)：`\\t`:制表符，`\\n`:换行，`\\\"`，`\\'`，`\\\\`:反斜杠本身，`\\b`:回退一格，`\\r`:回车\n- 字符类型计算\n  * 一个字符加一个数字，得到Unicode码表中那个数之后的字符\n  * 两个字符相减得到它们在表中的距离\n  * char也可以和int之间相互赋值\n\n\n<span id=\"id2\"><span>\n### 2. 变量与常量\n#### 2.1 常量\n- 常量是一个值，在程序运行的过程中不能再次发生改变\n- 基本类型的值都可以认为是常量   4  3.4  'a'  true，String类(引用数据类型)值\"abc\"视为常量\n- 常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit--int   64bit--double\n\n#### 2.2 变量\n- 变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的\n- 变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字\n- 变量空间   里面只能存储一个内容(值/引用)\n- 空间内的内容的类型与定义时一致 内容可以改变 \n- 内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值\n\n#### 2.3 标识符（变量）命名规则\n1. 必须字母，数字，下划线以及美元$等组成，且首位非数字。\n2. 不能使用Java语言中的关键字，如class，static，void，int等。\n3. 区分大小写，长度无限制，但不能过长，尽量见名知意。\n\n#### 2.3 命名的规约\n- 类名字：首字母大写，如果两个以上的单词，所有首字母都大写\n- 变量名：首字母小写，如果两个以上的单词，之后的首字母大写\n- 遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性\n\n\n<span id=\"id3\"><span>\n### 3. 数据类型之间的转换\n#### 3.1 基本数据类型之间转换\n1. 自动类型转换：从小类型到大类型自动转换\n\n```\nbyte --> short --> int --> long --> float --> double\n          char -----^\n```\n\n2. 强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出\n\n```\nlong big = 1024L\\*1024\\*1024;\nint i = (int)big;\n```\n\n#### 3.2其他数据类型之间转换\n- 同种大数据类型之间才能发生转换\n- 类型转换之前，保证大前提：同种大数据类型一致\n    * 基本--基本   可以直接转换(自动 强制)\n    * 引用--引用   可以直接转化(自动 强制 -- 上转型 下转型)\n    * 基本--引用   不可以直接进行转化(间接-桥梁-包装类)\n- 保证大数据类型一致的前提下(都是基本类型)\n* 小数据类型一致:整型-->整型 / 浮点-->浮点\n    + 比较内存空间的大小\n    + 大数据类型空间可以直接接受小数据类型的值(自动转换)\n    + 小数据类型空间不可以直接接受大数据类型的值(强制类型转换)\n    + 强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据\n    ```\n    byte a = 1;   int b = a;//自动直接转化就可以\n    int a = 1;  byte b = (byte)a;//需要强制类型转换\n    float x = 3.4F;   double y = x;//自动直接转化\n    double x = 3.4; float y = (float)x;//强制转换\n    ```\n* 小数据类型不一致:整型-->浮点\n    + 比较精确程度\n    + 浮点型的精确程度更高\n    + 任何一个浮点型空间都可以直接接受一个整型的值\n    + 反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)\n    ```\n    int a = 1;  float b = a;//自动直接转化\n    float a =1.0F;  int b = (int)a;//强制类型转换\n    ```\n* 整型-->字符\n    + 每一个字符都对应这一个Unicode码   a--97\n    ```\n    char x = 'a';  int y = x;//自动转化  y--97\n    int x = 97; char y = (char)x;//强制的转化\n    ```\n* 布尔类型很特殊\n    + 不能与其他基本类型之间发生转化\n\n\n<span id=\"id4\"><span>\n### 4. 运算符\n1. 算术运算符： `+`，`-`，`*`，`/`，`%`\n2. 关系运算符： `>`，`<`，`>=`，`<=`，`==`，`!=`\n3. 自增减运算符： `++`，`--`\n4. 逻辑运算符： `&&`，`||`，`！`（短路特性：逻辑与`&&`运算，若第一个条件为假,跳过第二个条件；逻辑或`||`运算，若第一个条件为真，跳过第二个条件）\n5. 三目运算符： 条件 ? 表达式1 ： 表达式2\n6. 赋值运算符：`=`，`+=`，`-=`，`*=`，`=` \n\n<span id=\"id5\"><span>\n### 5. 循环\n1. while循环和for循环完全可以互换。\n2. while循环主要用于明确循环条件，但不明确循环次数的场合\n3. for循环主要用于明确次数或范围的场合\n4. while(true) 等价于 for(;;)，表示无限循环。\n\n<span id=\"id6\"><span>\n### 6. 数组\n#### 6.1 一维数组\n- `数组类型[] 数组名 = new 数据类型[长度]` ：动态方式\n\n``` java\n数组类型[] 数组名 = new 数据类型[长度] //动态方式\nint[] arr = new int[5];\n```\n\n``` java\n数组类型[] 数组名 = {初始值1, 初始值1, 初始值1, ...} //静态方式\nint[] arr = {10, 20, 30, 40};\n/*特殊方式：*/ int[] arr = new int[]{10, 20, 30};\n```\n\n#### 6.2 二维数组\n\n``` java\n数组类型[][] 数组名 = new 数据类型[行数][列数]\nint[][] arr = new int[5][6];\n```\n\n``` java\n数组类型[][] 数组名 = {{初始值1, 初始值1, 初始值1},{值2,...} ...}\nint[] arr = {{10, 20, 30}, {01, 5, 3}, {8, 20, 6}};\n```\n\n> 二维数组arr.length表示行数，arr[0].length表示此行的长度\n\n\n<span id=\"id7\"><span>\n### 7. 函数\n- 函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。\n\n``` java\npublic static int sum(int a, int b){\n  int i;\n  int sum=0;\n  for(i=a; i<=b; i++){\n    sum += i;\n  }\n  System.out.println(a +\"到\"+ b +\"的和是\"+ sum);\n  return sum;\n}\n```\n\n- 函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序\n- 函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用\n","slug":"01_JavaSE语法基础","published":1,"updated":"2019-07-20T14:45:38.313Z","_id":"cjyblnrqt0000xwt3j2t1ly4k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这是<strong>javaSE知识梳理</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">数据类型</a></li>\n<li><a href=\"#id2\">变量与常量</a></li>\n<li><a href=\"#id3\">数据类型之间的转换</a></li>\n<li><a href=\"#id4\">运算符</a></li>\n<li><a href=\"#id5\">循环</a></li>\n<li><a href=\"#id6\">数组</a></li>\n<li><a href=\"#id7\">函数</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><h4 id=\"1-1-分为两大类：\"><a href=\"#1-1-分为两大类：\" class=\"headerlink\" title=\"1.1 分为两大类：\"></a>1.1 分为两大类：</h4><ol>\n<li>基本数据类型：byte，short，int，long，float，double，boolean，char</li>\n<li>引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface</li>\n</ol>\n<blockquote>\n<p>注：<code>单个字节</code>表示<code>8位二进制</code>位，最左边表示符号位（0：正，1：负）。</p>\n</blockquote>\n<h4 id=\"1-2-整数类型（byte，short，int，long）\"><a href=\"#1-2-整数类型（byte，short，int，long）\" class=\"headerlink\" title=\"1.2 整数类型（byte，short，int，long）\"></a>1.2 整数类型（byte，short，int，long）</h4><ol>\n<li><strong>byte</strong>： 1个字节，范围<code>-2^7~2^7-1</code>，即<code>-128~127</code>。</li>\n<li><strong>short</strong>：2个字节，范围<code>-2^15~2^15-1</code>，即<code>-32768~32767</code>。</li>\n<li><strong>int</strong>:   4个字节，范围<code>-2^31~2^31-1</code>，即<code>正负21亿</code>之间。</li>\n<li><strong>long</strong>： 8个字节，范围<code>-2^63~2^63-1</code>，比int更大。如果要表示long直接量，需要<code>L</code>或<code>l</code>结尾。</li>\n</ol>\n<h4 id=\"1-3-浮点类型（float，double）\"><a href=\"#1-3-浮点类型（float，double）\" class=\"headerlink\" title=\"1.3 浮点类型（float，double）\"></a>1.3 浮点类型（float，double）</h4><ol>\n<li><strong>float</strong>： 4个字节，单精度浮点数，取到<code>小数点后7</code>位有效数字。如果要表示float直接量，需要<code>F</code>或<code>f</code>结尾</li>\n<li><strong>double</strong>：8个字节，双精度浮点数，取到<code>小数点后15</code>位有效数字。</li>\n</ol>\n<blockquote>\n<p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p>\n</blockquote>\n<h4 id=\"1-4-布尔类型（boolean）\"><a href=\"#1-4-布尔类型（boolean）\" class=\"headerlink\" title=\"1.4 布尔类型（boolean）\"></a>1.4 布尔类型（boolean）</h4><ol>\n<li><strong>boolean</strong>：1个字节（未明确规定），值只有<code>true</code>和<code>false</code>。</li>\n</ol>\n<h4 id=\"1-5-字符类型（char）\"><a href=\"#1-5-字符类型（char）\" class=\"headerlink\" title=\"1.5 字符类型（char）\"></a>1.5 字符类型（char）</h4><ol>\n<li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。</li>\n</ol>\n<ul>\n<li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。</li>\n<li>需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10</li>\n<li>常用转义符(逃逸字符)：<code>\\t</code>:制表符，<code>\\n</code>:换行，<code>\\&quot;</code>，<code>\\&#39;</code>，<code>\\\\</code>:反斜杠本身，<code>\\b</code>:回退一格，<code>\\r</code>:回车</li>\n<li>字符类型计算<ul>\n<li>一个字符加一个数字，得到Unicode码表中那个数之后的字符</li>\n<li>两个字符相减得到它们在表中的距离</li>\n<li>char也可以和int之间相互赋值</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-变量与常量\"><a href=\"#2-变量与常量\" class=\"headerlink\" title=\"2. 变量与常量\"></a>2. 变量与常量</h3><h4 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h4><ul>\n<li>常量是一个值，在程序运行的过程中不能再次发生改变</li>\n<li>基本类型的值都可以认为是常量   4  3.4  ‘a’  true，String类(引用数据类型)值”abc”视为常量</li>\n<li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit–int   64bit–double</li>\n</ul>\n<h4 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h4><ul>\n<li>变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的</li>\n<li>变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字</li>\n<li>变量空间   里面只能存储一个内容(值/引用)</li>\n<li>空间内的内容的类型与定义时一致 内容可以改变 </li>\n<li>内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值</li>\n</ul>\n<h4 id=\"2-3-标识符（变量）命名规则\"><a href=\"#2-3-标识符（变量）命名规则\" class=\"headerlink\" title=\"2.3 标识符（变量）命名规则\"></a>2.3 标识符（变量）命名规则</h4><ol>\n<li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li>\n<li>不能使用Java语言中的关键字，如class，static，void，int等。</li>\n<li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li>\n</ol>\n<h4 id=\"2-3-命名的规约\"><a href=\"#2-3-命名的规约\" class=\"headerlink\" title=\"2.3 命名的规约\"></a>2.3 命名的规约</h4><ul>\n<li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li>\n<li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li>\n<li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数据类型之间的转换\"><a href=\"#3-数据类型之间的转换\" class=\"headerlink\" title=\"3. 数据类型之间的转换\"></a>3. 数据类型之间的转换</h3><h4 id=\"3-1-基本数据类型之间转换\"><a href=\"#3-1-基本数据类型之间转换\" class=\"headerlink\" title=\"3.1 基本数据类型之间转换\"></a>3.1 基本数据类型之间转换</h4><ol>\n<li>自动类型转换：从小类型到大类型自动转换</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class=\"line\">          char -----^</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long big = 1024L\\*1024\\*1024;</span><br><span class=\"line\">int i = (int)big;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2其他数据类型之间转换\"><a href=\"#3-2其他数据类型之间转换\" class=\"headerlink\" title=\"3.2其他数据类型之间转换\"></a>3.2其他数据类型之间转换</h4><ul>\n<li>同种大数据类型之间才能发生转换</li>\n<li>类型转换之前，保证大前提：同种大数据类型一致<ul>\n<li>基本–基本   可以直接转换(自动 强制)</li>\n<li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li>\n<li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li>\n</ul>\n</li>\n<li>保证大数据类型一致的前提下(都是基本类型)</li>\n</ul>\n<ul>\n<li><p>小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点</p>\n<ul>\n<li>比较内存空间的大小</li>\n<li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li>\n<li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li>\n<li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class=\"line\">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class=\"line\">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class=\"line\">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>小数据类型不一致:整型–&gt;浮点</p>\n<ul>\n<li>比较精确程度</li>\n<li>浮点型的精确程度更高</li>\n<li>任何一个浮点型空间都可以直接接受一个整型的值</li>\n<li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 1;  float b = a;//自动直接转化</span><br><span class=\"line\">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>整型–&gt;字符</p>\n<ul>\n<li>每一个字符都对应这一个Unicode码   a–97<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char x = &apos;a&apos;;  int y = x;//自动转化  y--97</span><br><span class=\"line\">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>布尔类型很特殊</p>\n<ul>\n<li>不能与其他基本类型之间发生转化</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4. 运算符\"></a>4. 运算符</h3><ol>\n<li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>\n<li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>\n<li>自增减运算符： <code>++</code>，<code>--</code></li>\n<li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li>\n<li>三目运算符： 条件 ? 表达式1 ： 表达式2</li>\n<li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code> </li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-循环\"><a href=\"#5-循环\" class=\"headerlink\" title=\"5. 循环\"></a>5. 循环</h3><ol>\n<li>while循环和for循环完全可以互换。</li>\n<li>while循环主要用于明确循环条件，但不明确循环次数的场合</li>\n<li>for循环主要用于明确次数或范围的场合</li>\n<li>while(true) 等价于 for(;;)，表示无限循环。</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h3><h4 id=\"6-1-一维数组\"><a href=\"#6-1-一维数组\" class=\"headerlink\" title=\"6.1 一维数组\"></a>6.1 一维数组</h4><ul>\n<li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = <span class=\"keyword\">new</span> 数据类型[长度] <span class=\"comment\">//动态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = &#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, ...&#125; <span class=\"comment\">//静态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*特殊方式：*/</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-二维数组\"><a href=\"#6-2-二维数组\" class=\"headerlink\" title=\"6.2 二维数组\"></a>6.2 二维数组</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = <span class=\"keyword\">new</span> 数据类型[行数][列数]</span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>][<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = &#123;&#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>&#125;,&#123;值<span class=\"number\">2</span>,...&#125; ...&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"number\">01</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">8</span>, <span class=\"number\">20</span>, <span class=\"number\">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二维数组arr.length表示行数，arr[0].length表示此行的长度</p>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h3><ul>\n<li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(a +<span class=\"string\">\"到\"</span>+ b +<span class=\"string\">\"的和是\"</span>+ sum);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li>\n<li>函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这是<strong>javaSE知识梳理</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p>","more":"<ol>\n<li><a href=\"#id1\">数据类型</a></li>\n<li><a href=\"#id2\">变量与常量</a></li>\n<li><a href=\"#id3\">数据类型之间的转换</a></li>\n<li><a href=\"#id4\">运算符</a></li>\n<li><a href=\"#id5\">循环</a></li>\n<li><a href=\"#id6\">数组</a></li>\n<li><a href=\"#id7\">函数</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-数据类型\"><a href=\"#1-数据类型\" class=\"headerlink\" title=\"1. 数据类型\"></a>1. 数据类型</h3><h4 id=\"1-1-分为两大类：\"><a href=\"#1-1-分为两大类：\" class=\"headerlink\" title=\"1.1 分为两大类：\"></a>1.1 分为两大类：</h4><ol>\n<li>基本数据类型：byte，short，int，long，float，double，boolean，char</li>\n<li>引用数据类型：数组，类(抽象类)class，接口interface，枚举enum，标注@interface</li>\n</ol>\n<blockquote>\n<p>注：<code>单个字节</code>表示<code>8位二进制</code>位，最左边表示符号位（0：正，1：负）。</p>\n</blockquote>\n<h4 id=\"1-2-整数类型（byte，short，int，long）\"><a href=\"#1-2-整数类型（byte，short，int，long）\" class=\"headerlink\" title=\"1.2 整数类型（byte，short，int，long）\"></a>1.2 整数类型（byte，short，int，long）</h4><ol>\n<li><strong>byte</strong>： 1个字节，范围<code>-2^7~2^7-1</code>，即<code>-128~127</code>。</li>\n<li><strong>short</strong>：2个字节，范围<code>-2^15~2^15-1</code>，即<code>-32768~32767</code>。</li>\n<li><strong>int</strong>:   4个字节，范围<code>-2^31~2^31-1</code>，即<code>正负21亿</code>之间。</li>\n<li><strong>long</strong>： 8个字节，范围<code>-2^63~2^63-1</code>，比int更大。如果要表示long直接量，需要<code>L</code>或<code>l</code>结尾。</li>\n</ol>\n<h4 id=\"1-3-浮点类型（float，double）\"><a href=\"#1-3-浮点类型（float，double）\" class=\"headerlink\" title=\"1.3 浮点类型（float，double）\"></a>1.3 浮点类型（float，double）</h4><ol>\n<li><strong>float</strong>： 4个字节，单精度浮点数，取到<code>小数点后7</code>位有效数字。如果要表示float直接量，需要<code>F</code>或<code>f</code>结尾</li>\n<li><strong>double</strong>：8个字节，双精度浮点数，取到<code>小数点后15</code>位有效数字。</li>\n</ol>\n<blockquote>\n<p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p>\n</blockquote>\n<h4 id=\"1-4-布尔类型（boolean）\"><a href=\"#1-4-布尔类型（boolean）\" class=\"headerlink\" title=\"1.4 布尔类型（boolean）\"></a>1.4 布尔类型（boolean）</h4><ol>\n<li><strong>boolean</strong>：1个字节（未明确规定），值只有<code>true</code>和<code>false</code>。</li>\n</ol>\n<h4 id=\"1-5-字符类型（char）\"><a href=\"#1-5-字符类型（char）\" class=\"headerlink\" title=\"1.5 字符类型（char）\"></a>1.5 字符类型（char）</h4><ol>\n<li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：’a’,’1’,’中’ 等。</li>\n</ol>\n<ul>\n<li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号””引起来。</li>\n<li>需记住的ASII码字符：’a’:97，’A’:65，’0’:48，空格:32，换行符:10</li>\n<li>常用转义符(逃逸字符)：<code>\\t</code>:制表符，<code>\\n</code>:换行，<code>\\&quot;</code>，<code>\\&#39;</code>，<code>\\\\</code>:反斜杠本身，<code>\\b</code>:回退一格，<code>\\r</code>:回车</li>\n<li>字符类型计算<ul>\n<li>一个字符加一个数字，得到Unicode码表中那个数之后的字符</li>\n<li>两个字符相减得到它们在表中的距离</li>\n<li>char也可以和int之间相互赋值</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-变量与常量\"><a href=\"#2-变量与常量\" class=\"headerlink\" title=\"2. 变量与常量\"></a>2. 变量与常量</h3><h4 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h4><ul>\n<li>常量是一个值，在程序运行的过程中不能再次发生改变</li>\n<li>基本类型的值都可以认为是常量   4  3.4  ‘a’  true，String类(引用数据类型)值”abc”视为常量</li>\n<li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小  32bit–int   64bit–double</li>\n</ul>\n<h4 id=\"2-2-变量\"><a href=\"#2-2-变量\" class=\"headerlink\" title=\"2.2 变量\"></a>2.2 变量</h4><ul>\n<li>变量是在栈内存中开辟的一块内存空间(小容器),程序执行过程中可以改变的</li>\n<li>变量空间在创建(变量声明)的时候,必须指定数据类型,变量空间的名字</li>\n<li>变量空间   里面只能存储一个内容(值/引用)</li>\n<li>空间内的内容的类型与定义时一致 内容可以改变 </li>\n<li>内存结构与执行过程：类的定义，编译，加载 空间各个区，变量 赋值</li>\n</ul>\n<h4 id=\"2-3-标识符（变量）命名规则\"><a href=\"#2-3-标识符（变量）命名规则\" class=\"headerlink\" title=\"2.3 标识符（变量）命名规则\"></a>2.3 标识符（变量）命名规则</h4><ol>\n<li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li>\n<li>不能使用Java语言中的关键字，如class，static，void，int等。</li>\n<li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li>\n</ol>\n<h4 id=\"2-3-命名的规约\"><a href=\"#2-3-命名的规约\" class=\"headerlink\" title=\"2.3 命名的规约\"></a>2.3 命名的规约</h4><ul>\n<li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li>\n<li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li>\n<li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数据类型之间的转换\"><a href=\"#3-数据类型之间的转换\" class=\"headerlink\" title=\"3. 数据类型之间的转换\"></a>3. 数据类型之间的转换</h3><h4 id=\"3-1-基本数据类型之间转换\"><a href=\"#3-1-基本数据类型之间转换\" class=\"headerlink\" title=\"3.1 基本数据类型之间转换\"></a>3.1 基本数据类型之间转换</h4><ol>\n<li>自动类型转换：从小类型到大类型自动转换</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class=\"line\">          char -----^</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long big = 1024L\\*1024\\*1024;</span><br><span class=\"line\">int i = (int)big;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2其他数据类型之间转换\"><a href=\"#3-2其他数据类型之间转换\" class=\"headerlink\" title=\"3.2其他数据类型之间转换\"></a>3.2其他数据类型之间转换</h4><ul>\n<li>同种大数据类型之间才能发生转换</li>\n<li>类型转换之前，保证大前提：同种大数据类型一致<ul>\n<li>基本–基本   可以直接转换(自动 强制)</li>\n<li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li>\n<li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li>\n</ul>\n</li>\n<li>保证大数据类型一致的前提下(都是基本类型)</li>\n</ul>\n<ul>\n<li><p>小数据类型一致:整型–&gt;整型 / 浮点–&gt;浮点</p>\n<ul>\n<li>比较内存空间的大小</li>\n<li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li>\n<li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li>\n<li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class=\"line\">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class=\"line\">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class=\"line\">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>小数据类型不一致:整型–&gt;浮点</p>\n<ul>\n<li>比较精确程度</li>\n<li>浮点型的精确程度更高</li>\n<li>任何一个浮点型空间都可以直接接受一个整型的值</li>\n<li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int a = 1;  float b = a;//自动直接转化</span><br><span class=\"line\">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>整型–&gt;字符</p>\n<ul>\n<li>每一个字符都对应这一个Unicode码   a–97<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char x = &apos;a&apos;;  int y = x;//自动转化  y--97</span><br><span class=\"line\">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>布尔类型很特殊</p>\n<ul>\n<li>不能与其他基本类型之间发生转化</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-运算符\"><a href=\"#4-运算符\" class=\"headerlink\" title=\"4. 运算符\"></a>4. 运算符</h3><ol>\n<li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li>\n<li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>\n<li>自增减运算符： <code>++</code>，<code>--</code></li>\n<li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li>\n<li>三目运算符： 条件 ? 表达式1 ： 表达式2</li>\n<li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code> </li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-循环\"><a href=\"#5-循环\" class=\"headerlink\" title=\"5. 循环\"></a>5. 循环</h3><ol>\n<li>while循环和for循环完全可以互换。</li>\n<li>while循环主要用于明确循环条件，但不明确循环次数的场合</li>\n<li>for循环主要用于明确次数或范围的场合</li>\n<li>while(true) 等价于 for(;;)，表示无限循环。</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-数组\"><a href=\"#6-数组\" class=\"headerlink\" title=\"6. 数组\"></a>6. 数组</h3><h4 id=\"6-1-一维数组\"><a href=\"#6-1-一维数组\" class=\"headerlink\" title=\"6.1 一维数组\"></a>6.1 一维数组</h4><ul>\n<li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = <span class=\"keyword\">new</span> 数据类型[长度] <span class=\"comment\">//动态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[] 数组名 = &#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, ...&#125; <span class=\"comment\">//静态方式</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*特殊方式：*/</span> <span class=\"keyword\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-二维数组\"><a href=\"#6-2-二维数组\" class=\"headerlink\" title=\"6.2 二维数组\"></a>6.2 二维数组</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = <span class=\"keyword\">new</span> 数据类型[行数][列数]</span><br><span class=\"line\"><span class=\"keyword\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>][<span class=\"number\">6</span>];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数组类型[][] 数组名 = &#123;&#123;初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>, 初始值<span class=\"number\">1</span>&#125;,&#123;值<span class=\"number\">2</span>,...&#125; ...&#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>&#125;, &#123;<span class=\"number\">01</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">8</span>, <span class=\"number\">20</span>, <span class=\"number\">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二维数组arr.length表示行数，arr[0].length表示此行的长度</p>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h3><ul>\n<li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class=\"line\">    sum += i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  System.out.println(a +<span class=\"string\">\"到\"</span>+ b +<span class=\"string\">\"的和是\"</span>+ sum);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数的调用：函数名(参数值); 即使没有参数也需要(),()起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li>\n<li>函数的返回：return停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用</li>\n</ul>"},{"title":"五、JavaSE异常处理机制","date":"2019-07-09T00:34:31.000Z","_content":"\n\nJava语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [异常的分支结构](#id2)\n3. [添加处理异常的手段](#id3)\n4. [异常的捕获](#id4)\n5. [异常的抛出](#id5)\n6. [自定义异常](#id6)\n7. [总结](#id7)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 异常用于在Java语言中描述运行阶段发生的错误。\n- 在Java中有一个定义好的规则Throwable（可以抛出的）\n- java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。\n    * Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。\n    * Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。\n- java.lang.Exception类是所有异常的超类，主要分为两大类：\n    * RuntimeException - 运行时异常，也叫非检测性异常\n    * IOException和其他异常 - 其他异常也叫做检测性异常\n\n> 注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。\n\n```\nThrowable类\n    |————Exception类\n        |————RuntimeException异常\n            |————ArithmeticException类\n            |————ArrayIndexOutOfBoundsException类\n            |————NullPointerException类\n            |————ClassCastException类\n            |————NumberFormatException类\n        |————IOException和其他异常\n    |————Error类\n```\n\n\n<span id=\"id2\"><span>\n### 2. 异常的分支结构\n#### 2.1 运行时异常（非检查异常）\n1. Error和RuntimeException都算作运行时异常\n2. javac编译的时候，不会提示和发现的，\n3. 在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)\n4. 要求大家出现这样异常的时候 知道怎么产生及如何修改\n    + InputMisMatchException 输入不匹配\n        - int value = input.nextInt();//   abc\n    + *NumberFormatException 数字格式化\n        - int value = Integer.parseInt(\"123.45\");\n    + NegativeArraySizeException 数组长度负数\n        - int[] array = new int[-2];\n    + *ArrayIndexOutOfBoundsException 数组索引越界\n        - int[] array = {1,2,3};\n        - array[5];\n    + *5NullPointerException 空指针异常\n        - int[][] array = new int[3][];\n        - array[0][0] =10;\n        - Person p = null;\n        - p.getName();\n    + ArithmeticException 数字异常\n        - 10/0    整数不允许除以0    Infinity小数除以0会产生无穷\n    + *ClassCastException 造型异常\n        - Person p = new Teacher();\n        - Student s = (Student)p;\n    + *StringIndexOutOfBoundsException 字符串越界\n        - String str = \"abc\";\n        - str.charAt(5);\n    + *IndexOutOfBoundsException 集合越界\n        - List家族\n        - ArrayList  list = new ArrayList();\n        - list.add(); list.add(); list.add();\n        - list.get(5);\n    + IllegalArgumentException 非法参数异常\n        - ArrayList  list = new ArrayList(-1);\n\n#### 2.2 编译时异常(检查异常)\n- 除了Error和RuntimeException以外其他的异常\n- javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)\n- 因为这样的异常在程序运行过程中极有可能产生问题的\n- 异常产生后后续的所有执行就停止\n\n``` java\n//eg: InterruptException\ntry{\n    Thread.sleep(5000);\n}catch(Exception e){\n    //...\n}\n```\n\n\n<span id=\"id3\"><span>\n### 3. 添加处理异常的手段\n- 处理异常不是 异常消失了\n- 处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行\n- 两种手段：\n    * 异常的捕获：try{}catch(){}[ finally{} ]\n    * throws抛出\n- final，finally，finalize区别\n    * final：特征修饰符，修饰变量，属性，方法，类\n        + 修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)\n        + 修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)\n        + 修饰方法：不能被子类重写\n        + 修饰类：不能被其他的子类继承\n    * finally：处理异常手段的一部分\n        + try{}catch(){}后面的一个部分\n        + 这个部分可有可无，如果有只能含有一份，且必须执行\n    * finalize：是Object类中的一个protected方法\n        + 对象没有任何引用指向的时候 -- 会被GC回收\n        + 当对象回收的时候 默认调用finalize方法\n        + 若想要看到对象回收的效果，可以重写 public void finalize(){}\n\n\n<span id=\"id4\"><span>\n### 4. 异常的捕获\n``` java\ntry{\n    可能发生异常的代码;\n}catch(异常类型 引用变量){\n    针对该异常的处理代码;\n}catch ...\nfinally{\n    无论是否发生异常都要执行的代码;\n}\n```\n\n- 处理异常放在方法内部 可能会出现的小问题\n    * 如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。\n\n```\npublic String test() {\n    try {\n        //...可能产生异常的的代码\n        return \"值1\";//事先约定好 返回值\n    }catch(Exception e){\n        e.printStackTrace();//打印输出异常的名字\n    }finally {\n        System.out.println(\"finally块执行啦\");\n    }\n    return \"值2\";\n}\n```\n\n- 上述执行结果：若try中代码块产生异常return返回 **值2**，若try中无异常则return返回 **值1**，无论return在哪finally都会执行。\n\n> 异常捕获的注意事项：\n> - 当需要多分catch分子时，切记小类型应该放在大类型的前面；\n> - 懒人写法：catch(Exception e){...}\n> - finally通常用于善后处理，如：关闭已经打开的文件等。\n\n\n<span id=\"id5\"><span>\n### 5. 异常的抛出\n- 当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。\n- 语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,...{} ，\n<br>如：`public void show() throw Exception {}`\n- 重写方法的抛出规则：\n    * 不抛出异常\n    * 抛出父类异常中的子类异常\n    * 抛出和父类一样的异常\n    * 不能抛出同级不一样的异常\n    * 不能抛出更大的异常\n\n\n<span id=\"id6\"><span>\n### 6. 自定义异常\n- 可以根据需要自定义异常类。\n- 自定义异常的方式：\n    * 继承Exception或者异常的子类。\n    * 提供两个构造，无参构造和String做参数的构造。 \n- 异常的手段\n    * 如果继承是RuntimeException---->运行时异常(不需要必须添加处理手段)\n    * 如果继承是Exception----->编译时异常(必须添加处理手段)\n- 类中可以写带String参数的构造方法，可以做细致的说明\n- 通过throw关键字，new一个异常的对象\n- 主动产生异常：`throw new 异常类型();`\n\n\n<span id=\"id7\"><span>\n### 7. 总结\n- 1.在开发中尽量使用条件判断避免异常的发生;\n- 2.若实在避免不了，则进行异常捕获；\n- 3.若实在捕获不了，则进行异常抛出；\n- 4.若需要使用针对性异常，则自定义异常。\n\n","source":"_posts/05_JavaSE异常处理机制.md","raw":"---\ntitle: 五、JavaSE异常处理机制\ndate: 2019-07-09 08:34:31\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\nJava语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [异常的分支结构](#id2)\n3. [添加处理异常的手段](#id3)\n4. [异常的捕获](#id4)\n5. [异常的抛出](#id5)\n6. [自定义异常](#id6)\n7. [总结](#id7)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 异常用于在Java语言中描述运行阶段发生的错误。\n- 在Java中有一个定义好的规则Throwable（可以抛出的）\n- java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。\n    * Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。\n    * Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。\n- java.lang.Exception类是所有异常的超类，主要分为两大类：\n    * RuntimeException - 运行时异常，也叫非检测性异常\n    * IOException和其他异常 - 其他异常也叫做检测性异常\n\n> 注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。\n\n```\nThrowable类\n    |————Exception类\n        |————RuntimeException异常\n            |————ArithmeticException类\n            |————ArrayIndexOutOfBoundsException类\n            |————NullPointerException类\n            |————ClassCastException类\n            |————NumberFormatException类\n        |————IOException和其他异常\n    |————Error类\n```\n\n\n<span id=\"id2\"><span>\n### 2. 异常的分支结构\n#### 2.1 运行时异常（非检查异常）\n1. Error和RuntimeException都算作运行时异常\n2. javac编译的时候，不会提示和发现的，\n3. 在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)\n4. 要求大家出现这样异常的时候 知道怎么产生及如何修改\n    + InputMisMatchException 输入不匹配\n        - int value = input.nextInt();//   abc\n    + *NumberFormatException 数字格式化\n        - int value = Integer.parseInt(\"123.45\");\n    + NegativeArraySizeException 数组长度负数\n        - int[] array = new int[-2];\n    + *ArrayIndexOutOfBoundsException 数组索引越界\n        - int[] array = {1,2,3};\n        - array[5];\n    + *5NullPointerException 空指针异常\n        - int[][] array = new int[3][];\n        - array[0][0] =10;\n        - Person p = null;\n        - p.getName();\n    + ArithmeticException 数字异常\n        - 10/0    整数不允许除以0    Infinity小数除以0会产生无穷\n    + *ClassCastException 造型异常\n        - Person p = new Teacher();\n        - Student s = (Student)p;\n    + *StringIndexOutOfBoundsException 字符串越界\n        - String str = \"abc\";\n        - str.charAt(5);\n    + *IndexOutOfBoundsException 集合越界\n        - List家族\n        - ArrayList  list = new ArrayList();\n        - list.add(); list.add(); list.add();\n        - list.get(5);\n    + IllegalArgumentException 非法参数异常\n        - ArrayList  list = new ArrayList(-1);\n\n#### 2.2 编译时异常(检查异常)\n- 除了Error和RuntimeException以外其他的异常\n- javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)\n- 因为这样的异常在程序运行过程中极有可能产生问题的\n- 异常产生后后续的所有执行就停止\n\n``` java\n//eg: InterruptException\ntry{\n    Thread.sleep(5000);\n}catch(Exception e){\n    //...\n}\n```\n\n\n<span id=\"id3\"><span>\n### 3. 添加处理异常的手段\n- 处理异常不是 异常消失了\n- 处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行\n- 两种手段：\n    * 异常的捕获：try{}catch(){}[ finally{} ]\n    * throws抛出\n- final，finally，finalize区别\n    * final：特征修饰符，修饰变量，属性，方法，类\n        + 修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)\n        + 修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)\n        + 修饰方法：不能被子类重写\n        + 修饰类：不能被其他的子类继承\n    * finally：处理异常手段的一部分\n        + try{}catch(){}后面的一个部分\n        + 这个部分可有可无，如果有只能含有一份，且必须执行\n    * finalize：是Object类中的一个protected方法\n        + 对象没有任何引用指向的时候 -- 会被GC回收\n        + 当对象回收的时候 默认调用finalize方法\n        + 若想要看到对象回收的效果，可以重写 public void finalize(){}\n\n\n<span id=\"id4\"><span>\n### 4. 异常的捕获\n``` java\ntry{\n    可能发生异常的代码;\n}catch(异常类型 引用变量){\n    针对该异常的处理代码;\n}catch ...\nfinally{\n    无论是否发生异常都要执行的代码;\n}\n```\n\n- 处理异常放在方法内部 可能会出现的小问题\n    * 如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。\n\n```\npublic String test() {\n    try {\n        //...可能产生异常的的代码\n        return \"值1\";//事先约定好 返回值\n    }catch(Exception e){\n        e.printStackTrace();//打印输出异常的名字\n    }finally {\n        System.out.println(\"finally块执行啦\");\n    }\n    return \"值2\";\n}\n```\n\n- 上述执行结果：若try中代码块产生异常return返回 **值2**，若try中无异常则return返回 **值1**，无论return在哪finally都会执行。\n\n> 异常捕获的注意事项：\n> - 当需要多分catch分子时，切记小类型应该放在大类型的前面；\n> - 懒人写法：catch(Exception e){...}\n> - finally通常用于善后处理，如：关闭已经打开的文件等。\n\n\n<span id=\"id5\"><span>\n### 5. 异常的抛出\n- 当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。\n- 语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,...{} ，\n<br>如：`public void show() throw Exception {}`\n- 重写方法的抛出规则：\n    * 不抛出异常\n    * 抛出父类异常中的子类异常\n    * 抛出和父类一样的异常\n    * 不能抛出同级不一样的异常\n    * 不能抛出更大的异常\n\n\n<span id=\"id6\"><span>\n### 6. 自定义异常\n- 可以根据需要自定义异常类。\n- 自定义异常的方式：\n    * 继承Exception或者异常的子类。\n    * 提供两个构造，无参构造和String做参数的构造。 \n- 异常的手段\n    * 如果继承是RuntimeException---->运行时异常(不需要必须添加处理手段)\n    * 如果继承是Exception----->编译时异常(必须添加处理手段)\n- 类中可以写带String参数的构造方法，可以做细致的说明\n- 通过throw关键字，new一个异常的对象\n- 主动产生异常：`throw new 异常类型();`\n\n\n<span id=\"id7\"><span>\n### 7. 总结\n- 1.在开发中尽量使用条件判断避免异常的发生;\n- 2.若实在避免不了，则进行异常捕获；\n- 3.若实在捕获不了，则进行异常抛出；\n- 4.若需要使用针对性异常，则自定义异常。\n\n","slug":"05_JavaSE异常处理机制","published":1,"updated":"2019-07-20T14:46:51.992Z","_id":"cjyblnrr80002xwt3l5zlgrak","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">异常的分支结构</a></li>\n<li><a href=\"#id3\">添加处理异常的手段</a></li>\n<li><a href=\"#id4\">异常的捕获</a></li>\n<li><a href=\"#id5\">异常的抛出</a></li>\n<li><a href=\"#id6\">自定义异常</a></li>\n<li><a href=\"#id7\">总结</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>异常用于在Java语言中描述运行阶段发生的错误。</li>\n<li>在Java中有一个定义好的规则Throwable（可以抛出的）</li>\n<li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul>\n<li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li>\n<li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li>\n</ul>\n</li>\n<li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul>\n<li>RuntimeException - 运行时异常，也叫非检测性异常</li>\n<li>IOException和其他异常 - 其他异常也叫做检测性异常</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable类</span><br><span class=\"line\">    |————Exception类</span><br><span class=\"line\">        |————RuntimeException异常</span><br><span class=\"line\">            |————ArithmeticException类</span><br><span class=\"line\">            |————ArrayIndexOutOfBoundsException类</span><br><span class=\"line\">            |————NullPointerException类</span><br><span class=\"line\">            |————ClassCastException类</span><br><span class=\"line\">            |————NumberFormatException类</span><br><span class=\"line\">        |————IOException和其他异常</span><br><span class=\"line\">    |————Error类</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-异常的分支结构\"><a href=\"#2-异常的分支结构\" class=\"headerlink\" title=\"2. 异常的分支结构\"></a>2. 异常的分支结构</h3><h4 id=\"2-1-运行时异常（非检查异常）\"><a href=\"#2-1-运行时异常（非检查异常）\" class=\"headerlink\" title=\"2.1 运行时异常（非检查异常）\"></a>2.1 运行时异常（非检查异常）</h4><ol>\n<li>Error和RuntimeException都算作运行时异常</li>\n<li>javac编译的时候，不会提示和发现的，</li>\n<li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li>\n<li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul>\n<li>InputMisMatchException 输入不匹配<ul>\n<li>int value = input.nextInt();//   abc</li>\n</ul>\n</li>\n<li>*NumberFormatException 数字格式化<ul>\n<li>int value = Integer.parseInt(“123.45”);</li>\n</ul>\n</li>\n<li>NegativeArraySizeException 数组长度负数<ul>\n<li>int[] array = new int[-2];</li>\n</ul>\n</li>\n<li>*ArrayIndexOutOfBoundsException 数组索引越界<ul>\n<li>int[] array = {1,2,3};</li>\n<li>array[5];</li>\n</ul>\n</li>\n<li>*5NullPointerException 空指针异常<ul>\n<li>int[][] array = new int[3][];</li>\n<li>array[0][0] =10;</li>\n<li>Person p = null;</li>\n<li>p.getName();</li>\n</ul>\n</li>\n<li>ArithmeticException 数字异常<ul>\n<li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li>\n</ul>\n</li>\n<li>*ClassCastException 造型异常<ul>\n<li>Person p = new Teacher();</li>\n<li>Student s = (Student)p;</li>\n</ul>\n</li>\n<li>*StringIndexOutOfBoundsException 字符串越界<ul>\n<li>String str = “abc”;</li>\n<li>str.charAt(5);</li>\n</ul>\n</li>\n<li>*IndexOutOfBoundsException 集合越界<ul>\n<li>List家族</li>\n<li>ArrayList  list = new ArrayList();</li>\n<li>list.add(); list.add(); list.add();</li>\n<li>list.get(5);</li>\n</ul>\n</li>\n<li>IllegalArgumentException 非法参数异常<ul>\n<li>ArrayList  list = new ArrayList(-1);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-编译时异常-检查异常\"><a href=\"#2-2-编译时异常-检查异常\" class=\"headerlink\" title=\"2.2 编译时异常(检查异常)\"></a>2.2 编译时异常(检查异常)</h4><ul>\n<li>除了Error和RuntimeException以外其他的异常</li>\n<li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li>\n<li>因为这样的异常在程序运行过程中极有可能产生问题的</li>\n<li>异常产生后后续的所有执行就停止</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg: InterruptException</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-添加处理异常的手段\"><a href=\"#3-添加处理异常的手段\" class=\"headerlink\" title=\"3. 添加处理异常的手段\"></a>3. 添加处理异常的手段</h3><ul>\n<li>处理异常不是 异常消失了</li>\n<li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li>\n<li>两种手段：<ul>\n<li>异常的捕获：try{}catch(){}[ finally{} ]</li>\n<li>throws抛出</li>\n</ul>\n</li>\n<li>final，finally，finalize区别<ul>\n<li>final：特征修饰符，修饰变量，属性，方法，类<ul>\n<li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li>\n<li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li>\n<li>修饰方法：不能被子类重写</li>\n<li>修饰类：不能被其他的子类继承</li>\n</ul>\n</li>\n<li>finally：处理异常手段的一部分<ul>\n<li>try{}catch(){}后面的一个部分</li>\n<li>这个部分可有可无，如果有只能含有一份，且必须执行</li>\n</ul>\n</li>\n<li>finalize：是Object类中的一个protected方法<ul>\n<li>对象没有任何引用指向的时候 – 会被GC回收</li>\n<li>当对象回收的时候 默认调用finalize方法</li>\n<li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-异常的捕获\"><a href=\"#4-异常的捕获\" class=\"headerlink\" title=\"4. 异常的捕获\"></a>4. 异常的捕获</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    可能发生异常的代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常类型 引用变量)&#123;</span><br><span class=\"line\">    针对该异常的处理代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> ...</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    无论是否发生异常都要执行的代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理异常放在方法内部 可能会出现的小问题<ul>\n<li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String test() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //...可能产生异常的的代码</span><br><span class=\"line\">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();//打印输出异常的名字</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;值2&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li>\n</ul>\n<blockquote>\n<p>异常捕获的注意事项：</p>\n<ul>\n<li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li>\n<li>懒人写法：catch(Exception e){…}</li>\n<li>finally通常用于善后处理，如：关闭已经打开的文件等。</li>\n</ul>\n</blockquote>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常的抛出\"><a href=\"#5-异常的抛出\" class=\"headerlink\" title=\"5. 异常的抛出\"></a>5. 异常的抛出</h3><ul>\n<li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li>\n<li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li>\n<li>重写方法的抛出规则：<ul>\n<li>不抛出异常</li>\n<li>抛出父类异常中的子类异常</li>\n<li>抛出和父类一样的异常</li>\n<li>不能抛出同级不一样的异常</li>\n<li>不能抛出更大的异常</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-自定义异常\"><a href=\"#6-自定义异常\" class=\"headerlink\" title=\"6. 自定义异常\"></a>6. 自定义异常</h3><ul>\n<li>可以根据需要自定义异常类。</li>\n<li>自定义异常的方式：<ul>\n<li>继承Exception或者异常的子类。</li>\n<li>提供两个构造，无参构造和String做参数的构造。 </li>\n</ul>\n</li>\n<li>异常的手段<ul>\n<li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li>\n<li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li>\n</ul>\n</li>\n<li>类中可以写带String参数的构造方法，可以做细致的说明</li>\n<li>通过throw关键字，new一个异常的对象</li>\n<li>主动产生异常：<code>throw new 异常类型();</code></li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><ul>\n<li>1.在开发中尽量使用条件判断避免异常的发生;</li>\n<li>2.若实在避免不了，则进行异常捕获；</li>\n<li>3.若实在捕获不了，则进行异常抛出；</li>\n<li>4.若需要使用针对性异常，则自定义异常。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">异常的分支结构</a></li>\n<li><a href=\"#id3\">添加处理异常的手段</a></li>\n<li><a href=\"#id4\">异常的捕获</a></li>\n<li><a href=\"#id5\">异常的抛出</a></li>\n<li><a href=\"#id6\">自定义异常</a></li>\n<li><a href=\"#id7\">总结</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>异常用于在Java语言中描述运行阶段发生的错误。</li>\n<li>在Java中有一个定义好的规则Throwable（可以抛出的）</li>\n<li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul>\n<li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li>\n<li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li>\n</ul>\n</li>\n<li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul>\n<li>RuntimeException - 运行时异常，也叫非检测性异常</li>\n<li>IOException和其他异常 - 其他异常也叫做检测性异常</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Throwable类</span><br><span class=\"line\">    |————Exception类</span><br><span class=\"line\">        |————RuntimeException异常</span><br><span class=\"line\">            |————ArithmeticException类</span><br><span class=\"line\">            |————ArrayIndexOutOfBoundsException类</span><br><span class=\"line\">            |————NullPointerException类</span><br><span class=\"line\">            |————ClassCastException类</span><br><span class=\"line\">            |————NumberFormatException类</span><br><span class=\"line\">        |————IOException和其他异常</span><br><span class=\"line\">    |————Error类</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-异常的分支结构\"><a href=\"#2-异常的分支结构\" class=\"headerlink\" title=\"2. 异常的分支结构\"></a>2. 异常的分支结构</h3><h4 id=\"2-1-运行时异常（非检查异常）\"><a href=\"#2-1-运行时异常（非检查异常）\" class=\"headerlink\" title=\"2.1 运行时异常（非检查异常）\"></a>2.1 运行时异常（非检查异常）</h4><ol>\n<li>Error和RuntimeException都算作运行时异常</li>\n<li>javac编译的时候，不会提示和发现的，</li>\n<li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li>\n<li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul>\n<li>InputMisMatchException 输入不匹配<ul>\n<li>int value = input.nextInt();//   abc</li>\n</ul>\n</li>\n<li>*NumberFormatException 数字格式化<ul>\n<li>int value = Integer.parseInt(“123.45”);</li>\n</ul>\n</li>\n<li>NegativeArraySizeException 数组长度负数<ul>\n<li>int[] array = new int[-2];</li>\n</ul>\n</li>\n<li>*ArrayIndexOutOfBoundsException 数组索引越界<ul>\n<li>int[] array = {1,2,3};</li>\n<li>array[5];</li>\n</ul>\n</li>\n<li>*5NullPointerException 空指针异常<ul>\n<li>int[][] array = new int[3][];</li>\n<li>array[0][0] =10;</li>\n<li>Person p = null;</li>\n<li>p.getName();</li>\n</ul>\n</li>\n<li>ArithmeticException 数字异常<ul>\n<li>10/0    整数不允许除以0    Infinity小数除以0会产生无穷</li>\n</ul>\n</li>\n<li>*ClassCastException 造型异常<ul>\n<li>Person p = new Teacher();</li>\n<li>Student s = (Student)p;</li>\n</ul>\n</li>\n<li>*StringIndexOutOfBoundsException 字符串越界<ul>\n<li>String str = “abc”;</li>\n<li>str.charAt(5);</li>\n</ul>\n</li>\n<li>*IndexOutOfBoundsException 集合越界<ul>\n<li>List家族</li>\n<li>ArrayList  list = new ArrayList();</li>\n<li>list.add(); list.add(); list.add();</li>\n<li>list.get(5);</li>\n</ul>\n</li>\n<li>IllegalArgumentException 非法参数异常<ul>\n<li>ArrayList  list = new ArrayList(-1);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-2-编译时异常-检查异常\"><a href=\"#2-2-编译时异常-检查异常\" class=\"headerlink\" title=\"2.2 编译时异常(检查异常)\"></a>2.2 编译时异常(检查异常)</h4><ul>\n<li>除了Error和RuntimeException以外其他的异常</li>\n<li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li>\n<li>因为这样的异常在程序运行过程中极有可能产生问题的</li>\n<li>异常产生后后续的所有执行就停止</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//eg: InterruptException</span></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-添加处理异常的手段\"><a href=\"#3-添加处理异常的手段\" class=\"headerlink\" title=\"3. 添加处理异常的手段\"></a>3. 添加处理异常的手段</h3><ul>\n<li>处理异常不是 异常消失了</li>\n<li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li>\n<li>两种手段：<ul>\n<li>异常的捕获：try{}catch(){}[ finally{} ]</li>\n<li>throws抛出</li>\n</ul>\n</li>\n<li>final，finally，finalize区别<ul>\n<li>final：特征修饰符，修饰变量，属性，方法，类<ul>\n<li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li>\n<li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li>\n<li>修饰方法：不能被子类重写</li>\n<li>修饰类：不能被其他的子类继承</li>\n</ul>\n</li>\n<li>finally：处理异常手段的一部分<ul>\n<li>try{}catch(){}后面的一个部分</li>\n<li>这个部分可有可无，如果有只能含有一份，且必须执行</li>\n</ul>\n</li>\n<li>finalize：是Object类中的一个protected方法<ul>\n<li>对象没有任何引用指向的时候 – 会被GC回收</li>\n<li>当对象回收的时候 默认调用finalize方法</li>\n<li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-异常的捕获\"><a href=\"#4-异常的捕获\" class=\"headerlink\" title=\"4. 异常的捕获\"></a>4. 异常的捕获</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    可能发生异常的代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(异常类型 引用变量)&#123;</span><br><span class=\"line\">    针对该异常的处理代码;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> ...</span><br><span class=\"line\"><span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">    无论是否发生异常都要执行的代码;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理异常放在方法内部 可能会出现的小问题<ul>\n<li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public String test() &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        //...可能产生异常的的代码</span><br><span class=\"line\">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class=\"line\">    &#125;catch(Exception e)&#123;</span><br><span class=\"line\">        e.printStackTrace();//打印输出异常的名字</span><br><span class=\"line\">    &#125;finally &#123;</span><br><span class=\"line\">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &quot;值2&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li>\n</ul>\n<blockquote>\n<p>异常捕获的注意事项：</p>\n<ul>\n<li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li>\n<li>懒人写法：catch(Exception e){…}</li>\n<li>finally通常用于善后处理，如：关闭已经打开的文件等。</li>\n</ul>\n</blockquote>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-异常的抛出\"><a href=\"#5-异常的抛出\" class=\"headerlink\" title=\"5. 异常的抛出\"></a>5. 异常的抛出</h3><ul>\n<li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li>\n<li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception {}</code></li>\n<li>重写方法的抛出规则：<ul>\n<li>不抛出异常</li>\n<li>抛出父类异常中的子类异常</li>\n<li>抛出和父类一样的异常</li>\n<li>不能抛出同级不一样的异常</li>\n<li>不能抛出更大的异常</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-自定义异常\"><a href=\"#6-自定义异常\" class=\"headerlink\" title=\"6. 自定义异常\"></a>6. 自定义异常</h3><ul>\n<li>可以根据需要自定义异常类。</li>\n<li>自定义异常的方式：<ul>\n<li>继承Exception或者异常的子类。</li>\n<li>提供两个构造，无参构造和String做参数的构造。 </li>\n</ul>\n</li>\n<li>异常的手段<ul>\n<li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li>\n<li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li>\n</ul>\n</li>\n<li>类中可以写带String参数的构造方法，可以做细致的说明</li>\n<li>通过throw关键字，new一个异常的对象</li>\n<li>主动产生异常：<code>throw new 异常类型();</code></li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7. 总结\"></a>7. 总结</h3><ul>\n<li>1.在开发中尽量使用条件判断避免异常的发生;</li>\n<li>2.若实在避免不了，则进行异常捕获；</li>\n<li>3.若实在捕获不了，则进行异常抛出；</li>\n<li>4.若需要使用针对性异常，则自定义异常。</li>\n</ul>"},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","_content":"\n### 开始之前\n\n在安装[hexo](https://hexo.io/zh-cn/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n<!-- more --> \n#### 1.创建GitHub仓库\n注册[GitHub](https://github.com/)账号，创建一个以\"用户名.github.io\"命名的仓库，如我的用户名为chaooo,那我的仓库名为：[chaooo.github.io](https://github.com/chaooo/chaooo.github.io)，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n#### 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 3.本地Git与GitHub建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH\n``` bash\n$ ls -al ~/.ssh\n```\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。\n输入以下指令后，一路回车就好：\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n然后键入以下指令：\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n如果出现这个错误:`Could not open a connection to your authentication agent`，则先执行如下命令即可：\n``` bash\n$ ssh-agent bash\n```\n再重新输入指令：\n``` bash\n$ ssh-add ~/.ssh/id_rsa\n```\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：\n``` bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n在github上点击你的头像-->Your profile-->Edit profile-->SSH and GPG keys-->New SSH key\nTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。\n最后还是测试一下吧，键入以下命令：\n``` bash\n$ ssh -T git@github.com\n```\n你可能会看到有警告，没事，输入“yes”就好。\n#### 4.初始化hexo文件夹\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。\n在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop <刚复制的地址>\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n### Hexo安装配置\n\n#### 1.Hexo初始化\n进入Hexo-admin文件夹\n``` bash\n$ cd Hexo-admin\n```\n接下来只需要使用 npm 即可完成 Hexo 的安装:\n``` bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:\n``` bash\n$ hexo init\n$ npm install\n```\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。\n``` bash\n$ hexo generate\n$ hexo server\n```\n输入Ctrl+C停止服务。\n#### 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: \n  repository:\n```\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/chaooo/chaooo.github.io.git\n  branch: master\n```\n#### 3.完成部署\n最后一步，快要成功了，键入指令：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n输入弹出框的用户名与密码(首次使用git会弹出)。\nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[chaooo.github.io/](http://chaooo.github.io/)\n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：\n``` bash\n    To https://github.com/chaooo/chaooo.github.io.git\n       7f3b50a..128a10d  HEAD -> master\n    INFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n### 日常操作\n\n#### 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。 \n``` bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n然后用编辑器打开“文章标题.md”按照[Markdown语法](http://www.appinn.com/markdown/)书写文章。\n 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，\n 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md\n``` bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\n``` bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用\"将其包围。\n`请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。`\n#### 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。\n``` bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n然后才执行hexo generate -d发布网站到master分支上。\n``` bash\n$ hexo generate -d\n```\n#### 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n##### 3.1拷贝仓库\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git \n```\n##### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:\n``` bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n##### 小Tips:hexo 命令\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","source":"_posts/Hexo3-2-github搭建静态博客.md","raw":"---\ntitle: Hexo3.2+GitHub搭建静态博客\ndate: 2016-05-23 11:16:51\ntags: hexo\ncategories: hexo博客折腾\n---\n\n### 开始之前\n\n在安装[hexo](https://hexo.io/zh-cn/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n<!-- more --> \n#### 1.创建GitHub仓库\n注册[GitHub](https://github.com/)账号，创建一个以\"用户名.github.io\"命名的仓库，如我的用户名为chaooo,那我的仓库名为：[chaooo.github.io](https://github.com/chaooo/chaooo.github.io)，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。\n#### 2.配置Git\n设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：\n``` bash\n$ git config --global user.name \"username\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 3.本地Git与GitHub建立联系\n这里介绍SSH的配置，先检查电脑是否已经有SSH\n``` bash\n$ ls -al ~/.ssh\n```\n如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。\n输入以下指令后，一路回车就好：\n``` bash\n$ ssh-keygen -t rsa -C \"emailt@example.com\"\n```\n然后键入以下指令：\n``` bash\n$ ssh-agent -s\n$ ssh-add ~/.ssh/id_rsa\n```\n如果出现这个错误:`Could not open a connection to your authentication agent`，则先执行如下命令即可：\n``` bash\n$ ssh-agent bash\n```\n再重新输入指令：\n``` bash\n$ ssh-add ~/.ssh/id_rsa\n```\n到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：\n``` bash\n$ clip < ~/.ssh/id_rsa.pub\n```\n在github上点击你的头像-->Your profile-->Edit profile-->SSH and GPG keys-->New SSH key\nTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。\n最后还是测试一下吧，键入以下命令：\n``` bash\n$ ssh -T git@github.com\n```\n你可能会看到有警告，没事，输入“yes”就好。\n#### 4.初始化hexo文件夹\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。\n在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop <刚复制的地址>\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git\n$ mkdir Hexo-admin\n```\n\n### Hexo安装配置\n\n#### 1.Hexo初始化\n进入Hexo-admin文件夹\n``` bash\n$ cd Hexo-admin\n```\n接下来只需要使用 npm 即可完成 Hexo 的安装:\n``` bash\n$ npm install -g hexo-cli\n```\n安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:\n``` bash\n$ hexo init\n$ npm install\n```\n接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。\n``` bash\n$ hexo generate\n$ hexo server\n```\n输入Ctrl+C停止服务。\n#### 2.Hexo配置\n用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: \n  repository:\n```\n到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。\n``` bash\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: https://github.com/chaooo/chaooo.github.io.git\n  branch: master\n```\n#### 3.完成部署\n最后一步，快要成功了，键入指令：\n``` bash\n$ npm install hexo-deployer-git --save\n$ hexo generate\n$ hexo deploy\n```\n输入弹出框的用户名与密码(首次使用git会弹出)。\nOK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：[chaooo.github.io/](http://chaooo.github.io/)\n每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：\n``` bash\n    To https://github.com/chaooo/chaooo.github.io.git\n       7f3b50a..128a10d  HEAD -> master\n    INFO  Deploy done: git\n```\n当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。\n\n### 日常操作\n\n#### 1.写文章\n执行new命令，生成指定名称的文章至 Admin-blog\\source\\_posts\\文章标题.md 。 \n``` bash\n$ hexo new [layout] \"文章标题\" #新建文章\n```\n然后用编辑器打开“文章标题.md”按照[Markdown语法](http://www.appinn.com/markdown/)书写文章。\n 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，\n 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md\n``` bash\ntitle: { { title } }\ndate: { { date } }\ntags:\n---\n```\n我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：\n``` bash\ntitle: { { title } }\ndate: { { date } }\ncategories:\ntags:\n---\n```\n文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用\"将其包围。\n`请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件\"：\"后面都必须有个空格，不然会报错。`\n#### 2.提交\n每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。\n``` bash\n$ git add .\n$ git commit -m \"...\"\n$ git push origin develop\n```\n然后才执行hexo generate -d发布网站到master分支上。\n``` bash\n$ hexo generate -d\n```\n#### 3.本地仓库丢失\n当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：\n##### 3.1拷贝仓库\n``` bash\n$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git \n```\n##### 3.2配置Hexo\n在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:\n``` bash\n$ npm install -g hexo-cli\n$ npm install hexo\n$ npm install\n$ npm install hexo-deployer-git --save\n```\n\n##### 小Tips:hexo 命令\n``` bash\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\nhexo deploy -g  #生成加部署\nhexo server -g  #生成加预览\n#命令的简写\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```","slug":"Hexo3-2-github搭建静态博客","published":1,"updated":"2019-07-07T03:06:11.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrrf0005xwt3kkx8ysmz","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<a id=\"more\"></a> \n<h4 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h4><p>注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href=\"https://github.com/chaooo/chaooo.github.io\" target=\"_blank\" rel=\"noopener\">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地Git与GitHub建立联系\"><a href=\"#3-本地Git与GitHub建立联系\" class=\"headerlink\" title=\"3.本地Git与GitHub建立联系\"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n\n<p>再重新输入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h4 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h3><h4 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>输入Ctrl+C停止服务。</p>\n<h4 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: </span><br><span class=\"line\">  repository:</span><br></pre></td></tr></table></figure>\n\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://chaooo.github.io/\">chaooo.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<h3 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h3><h4 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n\n<p>然后用编辑器打开“文章标题.md”按照<a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p>\n<h4 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n\n<p>然后才执行hexo generate -d发布网站到master分支上。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h5 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>","more":"<h4 id=\"1-创建GitHub仓库\"><a href=\"#1-创建GitHub仓库\" class=\"headerlink\" title=\"1.创建GitHub仓库\"></a>1.创建GitHub仓库</h4><p>注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href=\"https://github.com/chaooo/chaooo.github.io\" target=\"_blank\" rel=\"noopener\">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>\n<h4 id=\"2-配置Git\"><a href=\"#2-配置Git\" class=\"headerlink\" title=\"2.配置Git\"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name <span class=\"string\">\"username\"</span></span><br><span class=\"line\">$ git config --global user.email <span class=\"string\">\"email@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地Git与GitHub建立联系\"><a href=\"#3-本地Git与GitHub建立联系\" class=\"headerlink\" title=\"3.本地Git与GitHub建立联系\"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls -al ~/.ssh</span><br></pre></td></tr></table></figure>\n\n<p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-keygen -t rsa -C <span class=\"string\">\"emailt@example.com\"</span></span><br></pre></td></tr></table></figure>\n\n<p>然后键入以下指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent -s</span><br><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-agent bash</span><br></pre></td></tr></table></figure>\n\n<p>再重新输入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>\n\n<p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n<p>你可能会看到有警告，没事，输入“yes”就好。</p>\n<h4 id=\"4-初始化hexo文件夹\"><a href=\"#4-初始化hexo文件夹\" class=\"headerlink\" title=\"4.初始化hexo文件夹\"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">$ mkdir Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hexo安装配置\"><a href=\"#Hexo安装配置\" class=\"headerlink\" title=\"Hexo安装配置\"></a>Hexo安装配置</h3><h4 id=\"1-Hexo初始化\"><a href=\"#1-Hexo初始化\" class=\"headerlink\" title=\"1.Hexo初始化\"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure>\n\n<p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo init</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n\n<p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>输入Ctrl+C停止服务。</p>\n<h4 id=\"2-Hexo配置\"><a href=\"#2-Hexo配置\" class=\"headerlink\" title=\"2.Hexo配置\"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: </span><br><span class=\"line\">  repository:</span><br></pre></td></tr></table></figure>\n\n<p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Deployment</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-完成部署\"><a href=\"#3-完成部署\" class=\"headerlink\" title=\"3.完成部署\"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href=\"http://chaooo.github.io/\">chaooo.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class=\"line\">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class=\"line\">INFO  Deploy <span class=\"keyword\">done</span>: git</span><br></pre></td></tr></table></figure>\n\n<p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>\n<h3 id=\"日常操作\"><a href=\"#日常操作\" class=\"headerlink\" title=\"日常操作\"></a>日常操作</h3><h4 id=\"1-写文章\"><a href=\"#1-写文章\" class=\"headerlink\" title=\"1.写文章\"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] <span class=\"string\">\"文章标题\"</span> <span class=\"comment\">#新建文章</span></span><br></pre></td></tr></table></figure>\n\n<p>然后用编辑器打开“文章标题.md”按照<a href=\"http://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title: &#123; &#123; title &#125; &#125;</span><br><span class=\"line\">date: &#123; &#123; date &#125; &#125;</span><br><span class=\"line\">categories:</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p>\n<h4 id=\"2-提交\"><a href=\"#2-提交\" class=\"headerlink\" title=\"2.提交\"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">$ git push origin develop</span><br></pre></td></tr></table></figure>\n\n<p>然后才执行hexo generate -d发布网站到master分支上。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate -d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-本地仓库丢失\"><a href=\"#3-本地仓库丢失\" class=\"headerlink\" title=\"3.本地仓库丢失\"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>\n<h5 id=\"3-1拷贝仓库\"><a href=\"#3-1拷贝仓库\" class=\"headerlink\" title=\"3.1拷贝仓库\"></a>3.1拷贝仓库</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2配置Hexo\"><a href=\"#3-2配置Hexo\" class=\"headerlink\" title=\"3.2配置Hexo\"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br><span class=\"line\">$ npm install hexo</span><br><span class=\"line\">$ npm install</span><br><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"小Tips-hexo-命令\"><a href=\"#小Tips-hexo-命令\" class=\"headerlink\" title=\"小Tips:hexo 命令\"></a>小Tips:hexo 命令</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span> <span class=\"comment\">#新建文章</span></span><br><span class=\"line\">hexo new page <span class=\"string\">\"pageName\"</span> <span class=\"comment\">#新建页面</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成静态页面至public目录</span></span><br><span class=\"line\">hexo server <span class=\"comment\">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#将.deploy目录部署到GitHub</span></span><br><span class=\"line\">hexo <span class=\"built_in\">help</span>  <span class=\"comment\"># 查看帮助</span></span><br><span class=\"line\">hexo version  <span class=\"comment\">#查看Hexo的版本</span></span><br><span class=\"line\">hexo deploy -g  <span class=\"comment\">#生成加部署</span></span><br><span class=\"line\">hexo server -g  <span class=\"comment\">#生成加预览</span></span><br><span class=\"line\"><span class=\"comment\">#命令的简写</span></span><br><span class=\"line\">hexo n == hexo new</span><br><span class=\"line\">hexo g == hexo generate</span><br><span class=\"line\">hexo s == hexo server</span><br><span class=\"line\">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>"},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","_content":"\nBower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n<!-- more --> \n### 开始之前\n\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` bash\nnpm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。   \n``` bash\nbower help\n\nUsage:\n    bower <command> [<args>] [<options>]\nCommands:\n    cache                   Manage bower cache\n    help                    Display help information about Bower\n    home                    Opens a package homepage into your favorite browser\n    info                    Info of a particular package\n    init                    Interactively create a bower.json file\n    install                 Install a package locally\n    link                    Symlink a package folder\n    list                    List local packages - and possible updates\n    login                   Authenticate with GitHub and store credentials\n    lookup                  Look up a package URL by name\n    prune                   Removes local extraneous packages\n    register                Register a package\n    search                  Search for a package by name\n    update                  Update a local package\n    uninstall               Remove a local package\n    unregister              Remove a package from the registry\n    version                 Bump a package version\nOptions:\n    -f, --force             Makes various commands more forceful\n    -j, --json              Output consumable JSON\n    -l, --loglevel          What level of logs to report\n    -o, --offline           Do not hit the network\n    -q, --quiet             Only output important information\n    -s, --silent            Do not output anything, besides errors\n    -V, --verbose           Makes output more verbose\n    --allow-root            Allows running commands as root\n    -v, --version           Output Bower version\n    --no-color              Disable colors\nSee 'bower help <command>' for more information on a specific command.\n```\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\nbower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n安装选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Save installed packages into the project’s bower.json dependencies\n    -D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n    -E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行`bower install`就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上`--save`即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n``` html\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行`update`命令即可更新，例如：\n``` bash \nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Update dependencies in bower.json\n    -D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里:https://bower.io/search/](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n    -S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n    -D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```\n","source":"_posts/Web包管理器-Bower.md","raw":"---\ntitle: 好用的Web包管理器-Bower\ndate: 2016-08-12 15:32:41\ntags: bower\ncategories: 前端工具\n---\n\nBower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。\n<!-- more --> \n### 开始之前\n\n在安装[bower](https://bower.io/)之前，必须确认你已经安装了[Node.js](http://nodejs.org/)和[Git](http://git-scm.com/)。\n\n### 1.安装Bower\n使用npm，打开终端，键入：\n``` bash\nnpm install -g bower   #全局安装bower\n```\n移步[这里](https://github.com/bower/bower/wiki/Troubleshooting)查看不同平台上安装的问题。\n\n### 2.使用Bower\n使用help命令查看帮助。   \n``` bash\nbower help\n\nUsage:\n    bower <command> [<args>] [<options>]\nCommands:\n    cache                   Manage bower cache\n    help                    Display help information about Bower\n    home                    Opens a package homepage into your favorite browser\n    info                    Info of a particular package\n    init                    Interactively create a bower.json file\n    install                 Install a package locally\n    link                    Symlink a package folder\n    list                    List local packages - and possible updates\n    login                   Authenticate with GitHub and store credentials\n    lookup                  Look up a package URL by name\n    prune                   Removes local extraneous packages\n    register                Register a package\n    search                  Search for a package by name\n    update                  Update a local package\n    uninstall               Remove a local package\n    unregister              Remove a package from the registry\n    version                 Bump a package version\nOptions:\n    -f, --force             Makes various commands more forceful\n    -j, --json              Output consumable JSON\n    -l, --loglevel          What level of logs to report\n    -o, --offline           Do not hit the network\n    -q, --quiet             Only output important information\n    -s, --silent            Do not output anything, besides errors\n    -V, --verbose           Makes output more verbose\n    --allow-root            Allows running commands as root\n    -v, --version           Output Bower version\n    --no-color              Disable colors\nSee 'bower help <command>' for more information on a specific command.\n```\n### 3.安装包到本地\n通过命令bower install安装软件包默认到bower_components/目录。\n``` bash\nbower install <package>    #package为包名\n```\n想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.\n``` bash\nbower install  # 通过 bower.json 文件安装\nbower install jquery   # 通过在github上注册的包名安装\nbower install desandro/masonry   # GitHub短链接\nbower install git://github.com/user/package.git   # Github上的 .git\nbower install http://example.com/script.js   # URL\n```\n安装选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Save installed packages into the project’s bower.json dependencies\n    -D, --save-dev: Save installed packages into the project’s bower.json devDependencies\n    -E, --save-exact: Configure installed packages with an exact version rather than semver\n```\n\n### 4.用bower.json文件来管理依赖\n发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行`bower install`就可根据bower.json来安装依赖的包。\n在项目中执行\n``` bash\nbower init\n```\n会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.\n如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上`--save`即可。\n\n### 5.使用下载好的包\n对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：\n``` html\n<link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\">\n<script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"></script>\n```\n\n### 6.更新包\n若下载的包升级了，只需执行`update`命令即可更新，例如：\n``` bash \nbower update jquery\n```\n这样就可以自动升级到最新版的jquery了。\n更新选项\n``` bash\n    -F, --force-latest: Force latest version on conflict\n    -p, --production: Do not install project devDependencies\n    -S, --save: Update dependencies in bower.json\n    -D, --save-dev: Update devDependencies in bower.json\n```\n\n### 7.搜索包\n``` bash\nbower search               #搜索所有包\nbower search <packageName> #搜索指定名称的包\n```\n或者可以在[这里:https://bower.io/search/](https://bower.io/search/)搜索喜欢的包.\n\n### 8.卸载包\n``` bash\nbower uninstall <name> [<name> ..] [<options>]\n```\n卸载选项\n``` bash\n    -S, --save: Remove uninstalled packages from the project’s bower.json dependencies\n    -D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies\n```\n","slug":"Web包管理器-Bower","published":1,"updated":"2019-07-07T03:06:11.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrri0006xwt39mhtfbyy","content":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>\n<a id=\"more\"></a> \n<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure>\n\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure>\n\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n\n<p>安装选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure>\n\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里:https://bower.io/search/</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>卸载选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p>","more":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>在安装<a href=\"https://bower.io/\" target=\"_blank\" rel=\"noopener\">bower</a>之前，必须确认你已经安装了<a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a>和<a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a>。</p>\n<h3 id=\"1-安装Bower\"><a href=\"#1-安装Bower\" class=\"headerlink\" title=\"1.安装Bower\"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g bower   <span class=\"comment\">#全局安装bower</span></span><br></pre></td></tr></table></figure>\n\n<p>移步<a href=\"https://github.com/bower/bower/wiki/Troubleshooting\" target=\"_blank\" rel=\"noopener\">这里</a>查看不同平台上安装的问题。</p>\n<h3 id=\"2-使用Bower\"><a href=\"#2-使用Bower\" class=\"headerlink\" title=\"2.使用Bower\"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower <span class=\"built_in\">help</span></span><br><span class=\"line\"></span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    bower &lt;<span class=\"built_in\">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class=\"line\">Commands:</span><br><span class=\"line\">    cache                   Manage bower cache</span><br><span class=\"line\">    <span class=\"built_in\">help</span>                    Display <span class=\"built_in\">help</span> information about Bower</span><br><span class=\"line\">    home                    Opens a package homepage into your favorite browser</span><br><span class=\"line\">    info                    Info of a particular package</span><br><span class=\"line\">    init                    Interactively create a bower.json file</span><br><span class=\"line\">    install                 Install a package locally</span><br><span class=\"line\">    link                    Symlink a package folder</span><br><span class=\"line\">    list                    List <span class=\"built_in\">local</span> packages - and possible updates</span><br><span class=\"line\">    login                   Authenticate with GitHub and store credentials</span><br><span class=\"line\">    lookup                  Look up a package URL by name</span><br><span class=\"line\">    prune                   Removes <span class=\"built_in\">local</span> extraneous packages</span><br><span class=\"line\">    register                Register a package</span><br><span class=\"line\">    search                  Search <span class=\"keyword\">for</span> a package by name</span><br><span class=\"line\">    update                  Update a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    uninstall               Remove a <span class=\"built_in\">local</span> package</span><br><span class=\"line\">    unregister              Remove a package from the registry</span><br><span class=\"line\">    version                 Bump a package version</span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -f, --force             Makes various commands more forceful</span><br><span class=\"line\">    -j, --json              Output consumable JSON</span><br><span class=\"line\">    -l, --loglevel          What level of logs to report</span><br><span class=\"line\">    -o, --offline           Do not hit the network</span><br><span class=\"line\">    -q, --quiet             Only output important information</span><br><span class=\"line\">    -s, --silent            Do not output anything, besides errors</span><br><span class=\"line\">    -V, --verbose           Makes output more verbose</span><br><span class=\"line\">    --allow-root            Allows running commands as root</span><br><span class=\"line\">    -v, --version           Output Bower version</span><br><span class=\"line\">    --no-color              Disable colors</span><br><span class=\"line\">See <span class=\"string\">'bower help &lt;command&gt;'</span> <span class=\"keyword\">for</span> more information on a specific <span class=\"built_in\">command</span>.</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-安装包到本地\"><a href=\"#3-安装包到本地\" class=\"headerlink\" title=\"3.安装包到本地\"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components/目录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install &lt;package&gt;    <span class=\"comment\">#package为包名</span></span><br></pre></td></tr></table></figure>\n\n<p>想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower install  <span class=\"comment\"># 通过 bower.json 文件安装</span></span><br><span class=\"line\">bower install jquery   <span class=\"comment\"># 通过在github上注册的包名安装</span></span><br><span class=\"line\">bower install desandro/masonry   <span class=\"comment\"># GitHub短链接</span></span><br><span class=\"line\">bower install git://github.com/user/package.git   <span class=\"comment\"># Github上的 .git</span></span><br><span class=\"line\">bower install http://example.com/script.js   <span class=\"comment\"># URL</span></span><br></pre></td></tr></table></figure>\n\n<p>安装选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class=\"line\">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-用bower-json文件来管理依赖\"><a href=\"#4-用bower-json文件来管理依赖\" class=\"headerlink\" title=\"4.用bower.json文件来管理依赖\"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower init</span><br></pre></td></tr></table></figure>\n\n<p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p>\n<h3 id=\"5-使用下载好的包\"><a href=\"#5-使用下载好的包\" class=\"headerlink\" title=\"5.使用下载好的包\"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"bower_components/bootstrap/dist/css/bootstrap.min.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"bower_components/jquery/dist/jquery.min.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-更新包\"><a href=\"#6-更新包\" class=\"headerlink\" title=\"6.更新包\"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower update jquery</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-F, --force-latest: Force latest version on conflict</span><br><span class=\"line\">-p, --production: Do not install project devDependencies</span><br><span class=\"line\">-S, --save: Update dependencies <span class=\"keyword\">in</span> bower.json</span><br><span class=\"line\">-D, --save-dev: Update devDependencies <span class=\"keyword\">in</span> bower.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-搜索包\"><a href=\"#7-搜索包\" class=\"headerlink\" title=\"7.搜索包\"></a>7.搜索包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower search               <span class=\"comment\">#搜索所有包</span></span><br><span class=\"line\">bower search &lt;packageName&gt; <span class=\"comment\">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure>\n\n<p>或者可以在<a href=\"https://bower.io/search/\" target=\"_blank\" rel=\"noopener\">这里:https://bower.io/search/</a>搜索喜欢的包.</p>\n<h3 id=\"8-卸载包\"><a href=\"#8-卸载包\" class=\"headerlink\" title=\"8.卸载包\"></a>8.卸载包</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>卸载选项</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class=\"line\">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>"},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-12-31 23:59:59\ntags: hexo\ncategories: hexo博客折腾\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-07-07T03:06:11.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrrj0007xwt3wkg8uf4r","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"sublime text3个人习惯配置","date":"2016-06-29T01:41:48.000Z","_content":"\n### 1、安装\n\n分别在官网下载并安装 [nodejs](https://nodejs.org/en/download/) 和 [sublime text3](https://www.sublimetext.com/3)。\n\n### 2、sublime text3注册：\n<!-- more --> \n点击菜单【help】－>【Enter License】，粘贴注册码。\n\n### 3、安装package control组件，用于管理所有插件\n\n按ctrl + ~调出控制台(或点击菜单栏的【View】->【Show Console】)，在Console窗口中输入以下代码，按回车键：\n``` bash\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n等待安装完毕，重启Sublime Text3。\n按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：\n\n### 4、用Package Control安装插件\n\n按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）\n`Material Theme`\n`Emmet`\n`CSS Format`\n`CSScomb`\n`jsFormat`\n`AutoFileName`\n`Autoprefixer`\n`Doc Blockr`\n`SublimeLinter`\n`SublimeLinter-jshint`\n`SublimeLinter-csslint`\n`Color Highlighter`\n`BracketHighlighter`\n\n### 5、配置nodejs\n\n##### 方法1\n(1)下载sublime Text的[nodejs插件](https://github.com/tanepiper/SublimeText-Nodejs)\n(2)下载后解压:直接改名为nodejs 放到 Preferences–>浏览程序包Browse Packages所在的文件夹\n(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"cp1252\", \n  \"windows\": \n    { \n        \"cmd\": [\"taskkill /F /IM node.exe & node\", \"$file\"] \n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(4)修改为：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(5)完成:随便写一段nodejs代码，ctrl+B运行\n(6)注意：在手动解压sublime Text插件后，需要在preference->package settings->package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。\n\n##### 方法2\n首先需要先安装[nodejs](https://nodejs.org/en/download/)。\n(1)运行Sublime,菜单上找到Tools ---> Build System ---> new Build System\n(2)输入：\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    }\n}\n(3)保存文件为NodeJs.sublime-build\n(4)菜单上找到Tools ---> Build System --->选择 NodeJs\n(5)安装sublime插件 JavaScript & NodeJs Snippets\n(6)新建test.js文件，输入 console.log('Hello Node.js'); 按快捷键 Ctrl + B 运行，成功输出","source":"_posts/sublime-text3个人习惯配置-C.md","raw":"---\ntitle: sublime text3个人习惯配置\ndate: 2016-06-29 09:41:48\ntags: sublime\ncategories: 前端工具\n---\n\n### 1、安装\n\n分别在官网下载并安装 [nodejs](https://nodejs.org/en/download/) 和 [sublime text3](https://www.sublimetext.com/3)。\n\n### 2、sublime text3注册：\n<!-- more --> \n点击菜单【help】－>【Enter License】，粘贴注册码。\n\n### 3、安装package control组件，用于管理所有插件\n\n按ctrl + ~调出控制台(或点击菜单栏的【View】->【Show Console】)，在Console窗口中输入以下代码，按回车键：\n``` bash\nimport urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)\n```\n等待安装完毕，重启Sublime Text3。\n按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：\n\n### 4、用Package Control安装插件\n\n按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）\n`Material Theme`\n`Emmet`\n`CSS Format`\n`CSScomb`\n`jsFormat`\n`AutoFileName`\n`Autoprefixer`\n`Doc Blockr`\n`SublimeLinter`\n`SublimeLinter-jshint`\n`SublimeLinter-csslint`\n`Color Highlighter`\n`BracketHighlighter`\n\n### 5、配置nodejs\n\n##### 方法1\n(1)下载sublime Text的[nodejs插件](https://github.com/tanepiper/SublimeText-Nodejs)\n(2)下载后解压:直接改名为nodejs 放到 Preferences–>浏览程序包Browse Packages所在的文件夹\n(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"cp1252\", \n  \"windows\": \n    { \n        \"cmd\": [\"taskkill /F /IM node.exe & node\", \"$file\"] \n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(4)修改为：\n``` json\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    },\n  \"linux\":\n    {\n        \"cmd\": [\"killall node; node\", \"$file\"]\n    },\n    \"osx\":\n    {\n  \"cmd\": [\"killall node; node $file\"]\n    }\n}\n```\n(5)完成:随便写一段nodejs代码，ctrl+B运行\n(6)注意：在手动解压sublime Text插件后，需要在preference->package settings->package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。\n\n##### 方法2\n首先需要先安装[nodejs](https://nodejs.org/en/download/)。\n(1)运行Sublime,菜单上找到Tools ---> Build System ---> new Build System\n(2)输入：\n{\n  \"cmd\": [\"node\", \"$file\"],\n  \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\",\n  \"selector\": \"source.js\",\n  \"shell\":true,\n  \"encoding\": \"utf-8\",\n  \"windows\":\n    {\n      \"cmd\": [\"taskkill /F /IM node.exe\", \"\"],\n      \"cmd\": [\"node\", \"$file\"]\n    }\n}\n(3)保存文件为NodeJs.sublime-build\n(4)菜单上找到Tools ---> Build System --->选择 NodeJs\n(5)安装sublime插件 JavaScript & NodeJs Snippets\n(6)新建test.js文件，输入 console.log('Hello Node.js'); 按快捷键 Ctrl + B 运行，成功输出","slug":"sublime-text3个人习惯配置-C","published":1,"updated":"2019-07-08T02:02:31.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrrn000axwt3taro17n0","content":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>分别在官网下载并安装 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a> 和 <a href=\"https://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">sublime text3</a>。</p>\n<h3 id=\"2、sublime-text3注册：\"><a href=\"#2、sublime-text3注册：\" class=\"headerlink\" title=\"2、sublime text3注册：\"></a>2、sublime text3注册：</h3><a id=\"more\"></a> \n<p>点击菜单【help】－&gt;【Enter License】，粘贴注册码。</p>\n<h3 id=\"3、安装package-control组件，用于管理所有插件\"><a href=\"#3、安装package-control组件，用于管理所有插件\" class=\"headerlink\" title=\"3、安装package control组件，用于管理所有插件\"></a>3、安装package control组件，用于管理所有插件</h3><p>按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.replace(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class=\"built_in\">print</span>(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> open(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>\n\n<p>等待安装完毕，重启Sublime Text3。<br>按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：</p>\n<h3 id=\"4、用Package-Control安装插件\"><a href=\"#4、用Package-Control安装插件\" class=\"headerlink\" title=\"4、用Package Control安装插件\"></a>4、用Package Control安装插件</h3><p>按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）<br><code>Material Theme</code><br><code>Emmet</code><br><code>CSS Format</code><br><code>CSScomb</code><br><code>jsFormat</code><br><code>AutoFileName</code><br><code>Autoprefixer</code><br><code>Doc Blockr</code><br><code>SublimeLinter</code><br><code>SublimeLinter-jshint</code><br><code>SublimeLinter-csslint</code><br><code>Color Highlighter</code><br><code>BracketHighlighter</code></p>\n<h3 id=\"5、配置nodejs\"><a href=\"#5、配置nodejs\" class=\"headerlink\" title=\"5、配置nodejs\"></a>5、配置nodejs</h3><h5 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h5><p>(1)下载sublime Text的<a href=\"https://github.com/tanepiper/SublimeText-Nodejs\" target=\"_blank\" rel=\"noopener\">nodejs插件</a><br>(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹<br>(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"cp1252\"</span>, </span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>: </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe &amp; node\"</span>, <span class=\"string\">\"$file\"</span>] </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(4)修改为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"utf-8\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe\"</span>, <span class=\"string\">\"\"</span>],</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(5)完成:随便写一段nodejs代码，ctrl+B运行<br>(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。</p>\n<h5 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h5><p>首先需要先安装<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a>。<br>(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System<br>(2)输入：<br>{<br>  “cmd”: [“node”, “$file”],<br>  “file_regex”: “^[ ]<em>File &quot;(…</em>?)&quot;, line ([0-9]*)”,<br>  “selector”: “source.js”,<br>  “shell”:true,<br>  “encoding”: “utf-8”,<br>  “windows”:<br>    {<br>      “cmd”: [“taskkill /F /IM node.exe”, “”],<br>      “cmd”: [“node”, “$file”]<br>    }<br>}<br>(3)保存文件为NodeJs.sublime-build<br>(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs<br>(5)安装sublime插件 JavaScript &amp; NodeJs Snippets<br>(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"1、安装\"><a href=\"#1、安装\" class=\"headerlink\" title=\"1、安装\"></a>1、安装</h3><p>分别在官网下载并安装 <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a> 和 <a href=\"https://www.sublimetext.com/3\" target=\"_blank\" rel=\"noopener\">sublime text3</a>。</p>\n<h3 id=\"2、sublime-text3注册：\"><a href=\"#2、sublime-text3注册：\" class=\"headerlink\" title=\"2、sublime text3注册：\"></a>2、sublime text3注册：</h3>","more":"<p>点击菜单【help】－&gt;【Enter License】，粘贴注册码。</p>\n<h3 id=\"3、安装package-control组件，用于管理所有插件\"><a href=\"#3、安装package-control组件，用于管理所有插件\" class=\"headerlink\" title=\"3、安装package control组件，用于管理所有插件\"></a>3、安装package control组件，用于管理所有插件</h3><p>按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib.request,os,hashlib; h = <span class=\"string\">'2915d1851351e5ee549c20394736b442'</span> + <span class=\"string\">'8bc59f460fa1548d1514676163dafc88'</span>; pf = <span class=\"string\">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class=\"string\">'http://packagecontrol.io/'</span> + pf.replace(<span class=\"string\">' '</span>, <span class=\"string\">'%20'</span>)).<span class=\"built_in\">read</span>(); dh = hashlib.sha256(by).hexdigest(); <span class=\"built_in\">print</span>(<span class=\"string\">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class=\"keyword\">if</span> dh != h <span class=\"keyword\">else</span> open(os.path.join( ipp, pf), <span class=\"string\">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure>\n\n<p>等待安装完毕，重启Sublime Text3。<br>按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control：</p>\n<h3 id=\"4、用Package-Control安装插件\"><a href=\"#4、用Package-Control安装插件\" class=\"headerlink\" title=\"4、用Package Control安装插件\"></a>4、用Package Control安装插件</h3><p>按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）<br><code>Material Theme</code><br><code>Emmet</code><br><code>CSS Format</code><br><code>CSScomb</code><br><code>jsFormat</code><br><code>AutoFileName</code><br><code>Autoprefixer</code><br><code>Doc Blockr</code><br><code>SublimeLinter</code><br><code>SublimeLinter-jshint</code><br><code>SublimeLinter-csslint</code><br><code>Color Highlighter</code><br><code>BracketHighlighter</code></p>\n<h3 id=\"5、配置nodejs\"><a href=\"#5、配置nodejs\" class=\"headerlink\" title=\"5、配置nodejs\"></a>5、配置nodejs</h3><h5 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h5><p>(1)下载sublime Text的<a href=\"https://github.com/tanepiper/SublimeText-Nodejs\" target=\"_blank\" rel=\"noopener\">nodejs插件</a><br>(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹<br>(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"cp1252\"</span>, </span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>: </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe &amp; node\"</span>, <span class=\"string\">\"$file\"</span>] </span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(4)修改为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>],</span><br><span class=\"line\">  <span class=\"attr\">\"file_regex\"</span>: <span class=\"string\">\"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"selector\"</span>: <span class=\"string\">\"source.js\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"shell\"</span>:<span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"encoding\"</span>: <span class=\"string\">\"utf-8\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"windows\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"taskkill /F /IM node.exe\"</span>, <span class=\"string\">\"\"</span>],</span><br><span class=\"line\">      <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"linux\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node\"</span>, <span class=\"string\">\"$file\"</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">\"osx\"</span>:</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">  <span class=\"attr\">\"cmd\"</span>: [<span class=\"string\">\"killall node; node $file\"</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(5)完成:随便写一段nodejs代码，ctrl+B运行<br>(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。</p>\n<h5 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h5><p>首先需要先安装<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">nodejs</a>。<br>(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System<br>(2)输入：<br>{<br>  “cmd”: [“node”, “$file”],<br>  “file_regex”: “^[ ]<em>File &quot;(…</em>?)&quot;, line ([0-9]*)”,<br>  “selector”: “source.js”,<br>  “shell”:true,<br>  “encoding”: “utf-8”,<br>  “windows”:<br>    {<br>      “cmd”: [“taskkill /F /IM node.exe”, “”],<br>      “cmd”: [“node”, “$file”]<br>    }<br>}<br>(3)保存文件为NodeJs.sublime-build<br>(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs<br>(5)安装sublime插件 JavaScript &amp; NodeJs Snippets<br>(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出</p>"},{"title":"自定义HEXO站内搜索Javascript+json","date":"2016-11-09T01:24:56.000Z","_content":"\n### 开始之前\n\n目前很多[Hexo](https://hexo.io/)博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：\n    [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)生成`xml`格式的数据文件。\n    [hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content) 生成`json`格式的数据文件。 \n今天的主角是[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。\n<!-- more -->\n### 1.安装 \n\n``` bash \n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后执行`hexo generate`时会自动生成`content.json`文件，若使用默认设置，生成的数据结构如下 \n``` json\nmeta: {\n    title: hexo.config.title,\n    subtitle: hexo.config.subtitle,\n    description: hexo.config.description,\n    author: hexo.config.author,\n    url: hexo.config.url\n},\npages: [{ //-> all pages\n    title: page.title,\n    slug: page.slug,\n    date: page.date,\n    updated: page.updated,\n    comments: page.comments,\n    permalink: page.permalink,\n    path: page.path,\n    excerpt: page.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: page.content, //-> only text minified ;)\n    raw: page.raw, //-> original MD content\n    content: page.content //-> final HTML content\n}],\nposts: [{ //-> only published posts\n    title: post.title,\n    slug: post.slug,\n    date: post.date,\n    updated: post.updated,\n    comments: post.comments,\n    permalink: post.permalink,\n    path: post.path,\n    excerpt: post.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: post.content, //-> only text minified ;)\n    raw: post.raw, //-> original MD content\n    content: post.content, //-> final HTML content\n    categories: [{\n        name: category.name,\n        slug: category.slug,\n        permalink: category.permalink\n    }],\n    tags: [{\n        name: tag.name,\n        slug: tag.slug,\n        permalink: tag.permalink\n    }]\n}]\n```\n### 2.配置 \n\nhexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：\n``` yml\njsonContent:\n  meta: true\n  keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)\n  pages:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n  posts:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n    categories: true\n    tags: true\n```\n因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在`hexo/_config.yml`中加入：\n``` yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true #文章标题\n    date: true #发表日期\n    path: true #路径\n    text: true #文本字段\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true #标签\n```\n这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。\n例如：\n``` json\n{\n  \"title\": \"自定义HEXO站内搜索Javascript+json\",\n  \"date\": \"2016-11-09T01:24:56.000Z\",\n  \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\",\n  \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\",\n  \"tags\": [{\n    \"name\": \"javascript,hexo\",\n    \"slug\": \"javascript-hexo\",\n    \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\"\n  }]\n}\n```\n### 3.JavaScript实现代码\n\n接下来就是用JS实现查询方法并把结果渲染到页面。\n#### 3.1 xhr加载数据\n``` javascript\nvar searchData;\nfunction loadData(success) {\n    if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', '/content.json', true);\n        xhr.onload = function() {\n            if (this.status >= 200 && this.status < 300) {\n                var res = JSON.parse(this.response || this.responseText);\n                searchData = res instanceof Array ? res : res.posts;\n                success(searchData);\n            } else {\n                console.error(this.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            console.error(this.statusText);\n        };\n        xhr.send();\n    } else {\n        success(searchData);\n    }\n}\n```\n#### 3.2 匹配文章内容返回结果\n``` javascript\nfunction matcher(post, regExp) {\n    // 匹配优先级：title > tags > text\n    return regtest(post.title, regExp) || post.tags.some(function(tag) {\n        return regtest(tag.name, regExp);\n    }) || regtest(post.text, regExp);\n}\nfunction regtest(raw, regExp) {\n    regExp.lastIndex = 0;\n    return regExp.test(raw);\n}\n```\n#### 3.3 结果渲染到页面\n``` javascript\nfunction render(data) {\n    var html = '';\n    if (data.length) {\n        html = data.map(function(post) {\n            return tpl(searchTpl, {\n                title: post.title,\n                path: post.path,\n                date: new Date(post.date).toLocaleDateString(),\n                tags: post.tags.map(function(tag) {\n                    return '<span>' + tag.name + '</span>';\n                }).join('')\n            });\n        }).join('');\n    } \n}\n```\n#### 3.3 查询匹配\n``` javascript\nfunction search(key) {\n    // 关键字 => 正则，空格隔开的看作多个关键字\n    // a b c => /a|b|c/gmi\n    var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi');\n    loadData(function(data) {\n        var result = data.filter(function(post) {\n            return matcher(post, regExp);\n        });\n        render(result);\n    });\n}\n```","source":"_posts/自定义HEXO站内搜索Javascript-json.md","raw":"---\ntitle: 自定义HEXO站内搜索Javascript+json\ndate: 2016-11-09 09:24:56\ntags: [javascript,hexo]\ncategories: hexo博客折腾\n---\n\n### 开始之前\n\n目前很多[Hexo](https://hexo.io/)博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：\n    [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)生成`xml`格式的数据文件。\n    [hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content) 生成`json`格式的数据文件。 \n今天的主角是[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。\n<!-- more -->\n### 1.安装 \n\n``` bash \n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后执行`hexo generate`时会自动生成`content.json`文件，若使用默认设置，生成的数据结构如下 \n``` json\nmeta: {\n    title: hexo.config.title,\n    subtitle: hexo.config.subtitle,\n    description: hexo.config.description,\n    author: hexo.config.author,\n    url: hexo.config.url\n},\npages: [{ //-> all pages\n    title: page.title,\n    slug: page.slug,\n    date: page.date,\n    updated: page.updated,\n    comments: page.comments,\n    permalink: page.permalink,\n    path: page.path,\n    excerpt: page.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: page.content, //-> only text minified ;)\n    raw: page.raw, //-> original MD content\n    content: page.content //-> final HTML content\n}],\nposts: [{ //-> only published posts\n    title: post.title,\n    slug: post.slug,\n    date: post.date,\n    updated: post.updated,\n    comments: post.comments,\n    permalink: post.permalink,\n    path: post.path,\n    excerpt: post.excerpt, //-> only text ;)\n    keywords: null //-> it needs settings\n    text: post.content, //-> only text minified ;)\n    raw: post.raw, //-> original MD content\n    content: post.content, //-> final HTML content\n    categories: [{\n        name: category.name,\n        slug: category.slug,\n        permalink: category.permalink\n    }],\n    tags: [{\n        name: tag.name,\n        slug: tag.slug,\n        permalink: tag.permalink\n    }]\n}]\n```\n### 2.配置 \n\nhexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：\n``` yml\njsonContent:\n  meta: true\n  keywords: false # (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)\n  pages:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n  posts:\n    title: true\n    slug: true\n    date: true\n    updated: true\n    comments: true\n    path: true\n    link: true\n    permalink: true\n    excerpt: true\n    keywords: true # but only if root keywords option language was set\n    text: true\n    raw: false\n    content: false\n    categories: true\n    tags: true\n```\n因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在`hexo/_config.yml`中加入：\n``` yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true #文章标题\n    date: true #发表日期\n    path: true #路径\n    text: true #文本字段\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true #标签\n```\n这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。\n例如：\n``` json\n{\n  \"title\": \"自定义HEXO站内搜索Javascript+json\",\n  \"date\": \"2016-11-09T01:24:56.000Z\",\n  \"path\": \"2016/11/09/自定义HEXO站内搜索Javascript-json.html\",\n  \"text\": \"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\",\n  \"tags\": [{\n    \"name\": \"javascript,hexo\",\n    \"slug\": \"javascript-hexo\",\n    \"permalink\": \"http://chaoo.oschina.io/tags/javascript-hexo/\"\n  }]\n}\n```\n### 3.JavaScript实现代码\n\n接下来就是用JS实现查询方法并把结果渲染到页面。\n#### 3.1 xhr加载数据\n``` javascript\nvar searchData;\nfunction loadData(success) {\n    if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', '/content.json', true);\n        xhr.onload = function() {\n            if (this.status >= 200 && this.status < 300) {\n                var res = JSON.parse(this.response || this.responseText);\n                searchData = res instanceof Array ? res : res.posts;\n                success(searchData);\n            } else {\n                console.error(this.statusText);\n            }\n        };\n        xhr.onerror = function() {\n            console.error(this.statusText);\n        };\n        xhr.send();\n    } else {\n        success(searchData);\n    }\n}\n```\n#### 3.2 匹配文章内容返回结果\n``` javascript\nfunction matcher(post, regExp) {\n    // 匹配优先级：title > tags > text\n    return regtest(post.title, regExp) || post.tags.some(function(tag) {\n        return regtest(tag.name, regExp);\n    }) || regtest(post.text, regExp);\n}\nfunction regtest(raw, regExp) {\n    regExp.lastIndex = 0;\n    return regExp.test(raw);\n}\n```\n#### 3.3 结果渲染到页面\n``` javascript\nfunction render(data) {\n    var html = '';\n    if (data.length) {\n        html = data.map(function(post) {\n            return tpl(searchTpl, {\n                title: post.title,\n                path: post.path,\n                date: new Date(post.date).toLocaleDateString(),\n                tags: post.tags.map(function(tag) {\n                    return '<span>' + tag.name + '</span>';\n                }).join('')\n            });\n        }).join('');\n    } \n}\n```\n#### 3.3 查询匹配\n``` javascript\nfunction search(key) {\n    // 关键字 => 正则，空格隔开的看作多个关键字\n    // a b c => /a|b|c/gmi\n    var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi');\n    loadData(function(data) {\n        var result = data.filter(function(post) {\n            return matcher(post, regExp);\n        });\n        render(result);\n    });\n}\n```","slug":"自定义HEXO站内搜索Javascript-json","published":1,"updated":"2019-07-07T03:06:11.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrrq000bxwt3oydn76sr","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>目前很多<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href=\"https://github.com/PaicHyperionDev/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p>\n<a id=\"more\"></a>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta: &#123;</span><br><span class=\"line\">    title: hexo.config.title,</span><br><span class=\"line\">    subtitle: hexo.config.subtitle,</span><br><span class=\"line\">    description: hexo.config.description,</span><br><span class=\"line\">    author: hexo.config.author,</span><br><span class=\"line\">    url: hexo.config.url</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">pages: [&#123; //-&gt; all pages</span><br><span class=\"line\">    title: page.title,</span><br><span class=\"line\">    slug: page.slug,</span><br><span class=\"line\">    date: page.date,</span><br><span class=\"line\">    updated: page.updated,</span><br><span class=\"line\">    comments: page.comments,</span><br><span class=\"line\">    permalink: page.permalink,</span><br><span class=\"line\">    path: page.path,</span><br><span class=\"line\">    excerpt: page.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: page.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: page.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: page.content //-&gt; final HTML content</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\">posts: [&#123; //-&gt; only published posts</span><br><span class=\"line\">    title: post.title,</span><br><span class=\"line\">    slug: post.slug,</span><br><span class=\"line\">    date: post.date,</span><br><span class=\"line\">    updated: post.updated,</span><br><span class=\"line\">    comments: post.comments,</span><br><span class=\"line\">    permalink: post.permalink,</span><br><span class=\"line\">    path: post.path,</span><br><span class=\"line\">    excerpt: post.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: post.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: post.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: post.content, //-&gt; final HTML content</span><br><span class=\"line\">    categories: [&#123;</span><br><span class=\"line\">        name: category.name,</span><br><span class=\"line\">        slug: category.slug,</span><br><span class=\"line\">        permalink: category.permalink</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tags: [&#123;</span><br><span class=\"line\">        name: tag.name,</span><br><span class=\"line\">        slug: tag.slug,</span><br><span class=\"line\">        permalink: tag.permalink</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2.配置\"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  keywords:</span> <span class=\"literal\">false</span> <span class=\"comment\"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文章标题</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span> <span class=\"comment\">#发表日期</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span> <span class=\"comment\">#路径</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文本字段</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span> <span class=\"comment\">#标签</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"自定义HEXO站内搜索Javascript+json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"date\"</span>: <span class=\"string\">\"2016-11-09T01:24:56.000Z\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"2016/11/09/自定义HEXO站内搜索Javascript-json.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"tags\"</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"javascript,hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"slug\"</span>: <span class=\"string\">\"javascript-hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"permalink\"</span>: <span class=\"string\">\"http://chaoo.oschina.io/tags/javascript-hexo/\"</span></span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-JavaScript实现代码\"><a href=\"#3-JavaScript实现代码\" class=\"headerlink\" title=\"3.JavaScript实现代码\"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p>\n<h4 id=\"3-1-xhr加载数据\"><a href=\"#3-1-xhr加载数据\" class=\"headerlink\" title=\"3.1 xhr加载数据\"></a>3.1 xhr加载数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchData;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span>(<span class=\"params\">success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!searchData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'/content.json'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(<span class=\"keyword\">this</span>.response || <span class=\"keyword\">this</span>.responseText);</span><br><span class=\"line\">                searchData = res <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? res : res.posts;</span><br><span class=\"line\">                success(searchData);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.send();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        success(searchData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-匹配文章内容返回结果\"><a href=\"#3-2-匹配文章内容返回结果\" class=\"headerlink\" title=\"3.2 匹配文章内容返回结果\"></a>3.2 匹配文章内容返回结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matcher</span>(<span class=\"params\">post, regExp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regtest(post.title, regExp) || post.tags.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regtest(tag.name, regExp);</span><br><span class=\"line\">    &#125;) || regtest(post.text, regExp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">regtest</span>(<span class=\"params\">raw, regExp</span>) </span>&#123;</span><br><span class=\"line\">    regExp.lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.test(raw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-结果渲染到页面\"><a href=\"#3-3-结果渲染到页面\" class=\"headerlink\" title=\"3.3 结果渲染到页面\"></a>3.3 结果渲染到页面</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> html = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length) &#123;</span><br><span class=\"line\">        html = data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tpl(searchTpl, &#123;</span><br><span class=\"line\">                title: post.title,</span><br><span class=\"line\">                path: post.path,</span><br><span class=\"line\">                date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(post.date).toLocaleDateString(),</span><br><span class=\"line\">                tags: post.tags.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span&gt;'</span> + tag.name + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">                &#125;).join(<span class=\"string\">''</span>)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-查询匹配\"><a href=\"#3-3-查询匹配\" class=\"headerlink\" title=\"3.3 查询匹配\"></a>3.3 查询匹配</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">search</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class=\"line\">    <span class=\"comment\">// a b c =&gt; /a|b|c/gmi</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> regExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(key.replace(<span class=\"regexp\">/[ ]/g</span>, <span class=\"string\">'|'</span>), <span class=\"string\">'gmi'</span>);</span><br><span class=\"line\">    loadData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> matcher(post, regExp);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        render(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p>目前很多<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href=\"https://github.com/PaicHyperionDev/hexo-generator-search\" target=\"_blank\" rel=\"noopener\">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p>","more":"<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1.安装\"></a>1.安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meta: &#123;</span><br><span class=\"line\">    title: hexo.config.title,</span><br><span class=\"line\">    subtitle: hexo.config.subtitle,</span><br><span class=\"line\">    description: hexo.config.description,</span><br><span class=\"line\">    author: hexo.config.author,</span><br><span class=\"line\">    url: hexo.config.url</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">pages: [&#123; //-&gt; all pages</span><br><span class=\"line\">    title: page.title,</span><br><span class=\"line\">    slug: page.slug,</span><br><span class=\"line\">    date: page.date,</span><br><span class=\"line\">    updated: page.updated,</span><br><span class=\"line\">    comments: page.comments,</span><br><span class=\"line\">    permalink: page.permalink,</span><br><span class=\"line\">    path: page.path,</span><br><span class=\"line\">    excerpt: page.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: page.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: page.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: page.content //-&gt; final HTML content</span><br><span class=\"line\">&#125;],</span><br><span class=\"line\">posts: [&#123; //-&gt; only published posts</span><br><span class=\"line\">    title: post.title,</span><br><span class=\"line\">    slug: post.slug,</span><br><span class=\"line\">    date: post.date,</span><br><span class=\"line\">    updated: post.updated,</span><br><span class=\"line\">    comments: post.comments,</span><br><span class=\"line\">    permalink: post.permalink,</span><br><span class=\"line\">    path: post.path,</span><br><span class=\"line\">    excerpt: post.excerpt, //-&gt; only text ;)</span><br><span class=\"line\">    keywords: null //-&gt; it needs settings</span><br><span class=\"line\">    text: post.content, //-&gt; only text minified ;)</span><br><span class=\"line\">    raw: post.raw, //-&gt; original MD content</span><br><span class=\"line\">    content: post.content, //-&gt; final HTML content</span><br><span class=\"line\">    categories: [&#123;</span><br><span class=\"line\">        name: category.name,</span><br><span class=\"line\">        slug: category.slug,</span><br><span class=\"line\">        permalink: category.permalink</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    tags: [&#123;</span><br><span class=\"line\">        name: tag.name,</span><br><span class=\"line\">        slug: tag.slug,</span><br><span class=\"line\">        permalink: tag.permalink</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2.配置\"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  keywords:</span> <span class=\"literal\">false</span> <span class=\"comment\"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    keywords:</span> <span class=\"literal\">true</span> <span class=\"comment\"># but only if root keywords option language was set</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文章标题</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span> <span class=\"comment\">#发表日期</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span> <span class=\"comment\">#路径</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span> <span class=\"comment\">#文本字段</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span> <span class=\"comment\">#标签</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"title\"</span>: <span class=\"string\">\"自定义HEXO站内搜索Javascript+json\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"date\"</span>: <span class=\"string\">\"2016-11-09T01:24:56.000Z\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"path\"</span>: <span class=\"string\">\"2016/11/09/自定义HEXO站内搜索Javascript-json.html\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"text\"</span>: <span class=\"string\">\"目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"tags\"</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"javascript,hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"slug\"</span>: <span class=\"string\">\"javascript-hexo\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"permalink\"</span>: <span class=\"string\">\"http://chaoo.oschina.io/tags/javascript-hexo/\"</span></span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-JavaScript实现代码\"><a href=\"#3-JavaScript实现代码\" class=\"headerlink\" title=\"3.JavaScript实现代码\"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p>\n<h4 id=\"3-1-xhr加载数据\"><a href=\"#3-1-xhr加载数据\" class=\"headerlink\" title=\"3.1 xhr加载数据\"></a>3.1 xhr加载数据</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> searchData;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadData</span>(<span class=\"params\">success</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!searchData) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'/content.json'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> res = <span class=\"built_in\">JSON</span>.parse(<span class=\"keyword\">this</span>.response || <span class=\"keyword\">this</span>.responseText);</span><br><span class=\"line\">                searchData = res <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span> ? res : res.posts;</span><br><span class=\"line\">                success(searchData);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.error(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        xhr.send();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        success(searchData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-匹配文章内容返回结果\"><a href=\"#3-2-匹配文章内容返回结果\" class=\"headerlink\" title=\"3.2 匹配文章内容返回结果\"></a>3.2 匹配文章内容返回结果</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">matcher</span>(<span class=\"params\">post, regExp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regtest(post.title, regExp) || post.tags.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> regtest(tag.name, regExp);</span><br><span class=\"line\">    &#125;) || regtest(post.text, regExp);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">regtest</span>(<span class=\"params\">raw, regExp</span>) </span>&#123;</span><br><span class=\"line\">    regExp.lastIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.test(raw);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-结果渲染到页面\"><a href=\"#3-3-结果渲染到页面\" class=\"headerlink\" title=\"3.3 结果渲染到页面\"></a>3.3 结果渲染到页面</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> html = <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.length) &#123;</span><br><span class=\"line\">        html = data.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tpl(searchTpl, &#123;</span><br><span class=\"line\">                title: post.title,</span><br><span class=\"line\">                path: post.path,</span><br><span class=\"line\">                date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(post.date).toLocaleDateString(),</span><br><span class=\"line\">                tags: post.tags.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tag</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span&gt;'</span> + tag.name + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">                &#125;).join(<span class=\"string\">''</span>)</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-查询匹配\"><a href=\"#3-3-查询匹配\" class=\"headerlink\" title=\"3.3 查询匹配\"></a>3.3 查询匹配</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">search</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class=\"line\">    <span class=\"comment\">// a b c =&gt; /a|b|c/gmi</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> regExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(key.replace(<span class=\"regexp\">/[ ]/g</span>, <span class=\"string\">'|'</span>), <span class=\"string\">'gmi'</span>);</span><br><span class=\"line\">    loadData(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = data.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> matcher(post, regExp);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        render(result);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"谈谈开源","date":"2019-07-11T12:13:15.000Z","top":1,"_content":"\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","source":"_posts/谈谈开源.md","raw":"---\ntitle: 谈谈开源\ndate: 2019-07-11 20:13:15\ntags: 开源\ncategories: 杂谈\ntop: 1\n---\n\n### 什么是开源\n所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。\n\n在IT领域来说的话，字面意思就是**开放源代码**，开源软件的源代码任何人都可以审查、修改和增强。\n<!-- more -->\n虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。\n\n\n### 开源是否等于免费\n开源等于免费是对开源的最大误解。\n\n商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于**License**（许可协议）。\n\n商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。\n\n开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的**约束和保护**。\n\n目前使用最广泛的一种开源协议便是**MIT License**，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。\n\n### 为什么要选择开源软件\n开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！\n\n对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步**相互切磋与学习**。\n\n开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。\n\n### 最后\n\n最后还要说一点：不要把开源软件与盗版混为一谈。\n\n如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。\n\n开源的观念并不只限于软件的开发与使用，而是希望能够抱着**开放的心态**，**分享与合作的精神**，**相互切磋与学习**，**当你的代码被分享时它会变得更好**。\n\n> 参考连接：\n> - https://blog.csdn.net/happmaoo/article/details/83201544\n> - https://www.oschina.net/news/58921/what-is-open-source","slug":"谈谈开源","published":1,"updated":"2019-07-20T14:11:57.528Z","_id":"cjyblnrrv000fxwt3w6psk7id","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>\n<a id=\"more\"></a>\n<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是开源\"><a href=\"#什么是开源\" class=\"headerlink\" title=\"什么是开源\"></a>什么是开源</h3><p>所谓的「开源」，原本指的是开放其设计让所有使用者自由修改的一项机制。</p>\n<p>在IT领域来说的话，字面意思就是<strong>开放源代码</strong>，开源软件的源代码任何人都可以审查、修改和增强。</p>","more":"<p>虽然大多被用于软件开发过程中，但这项机制已逐渐演变为泛指在产品、计划与专案方面，透过开放大众的参与、讨论与修改，进而加速其发展、增加透明度及大众福利的方式。</p>\n<h3 id=\"开源是否等于免费\"><a href=\"#开源是否等于免费\" class=\"headerlink\" title=\"开源是否等于免费\"></a>开源是否等于免费</h3><p>开源等于免费是对开源的最大误解。</p>\n<p>商业软件（Business Software）、自由软件（Free Software）和开源软件（Open Source Software，此处为狭义的开源）。它们之间的根本区别并不是在是否收费上，而是在于<strong>License</strong>（许可协议）。</p>\n<p>商业软件用的是商业License，以保障软件商的利益为第一位，基本没有考虑用户的利益。</p>\n<p>开源软件既然源码都是开放的，所以直接拿来免费使用基本都是没有问题的，但是这并不意味着使用开源软件是完全没限制的。每个开源软件都受License(开源协议)的<strong>约束和保护</strong>。</p>\n<p>目前使用最广泛的一种开源协议便是<strong>MIT License</strong>，MIT允许别人用作者的代码做任何事情，但必须保证作者的所有权，并且作者无须承担代码使用产生的风险。比如Vue.js、React、Element、Bootstrap都是用的MIT协议。</p>\n<h3 id=\"为什么要选择开源软件\"><a href=\"#为什么要选择开源软件\" class=\"headerlink\" title=\"为什么要选择开源软件\"></a>为什么要选择开源软件</h3><p>开源软件的出现给了用户更多更好的选择，商业软件要想在这样的竞争环境下生存下去，唯一的办法就是把你的东西做得比开源软件更好！</p>\n<p>对于程序员来说，我们不但可以以开源软件为基础，根据自己的需要进行开发；也可以通过分享、观摩他人的源代码，进一步<strong>相互切磋与学习</strong>。</p>\n<p>开源这件事情，不论对用户还是开发者来说，都只是一种选择。商业是商业，开源是开源，没有谁比谁了不起。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>最后还要说一点：不要把开源软件与盗版混为一谈。</p>\n<p>如前面所说，开源也是有License的，违反License的行为就是对开源的盗版。在反盗版问题上，所有类型软件的立场应该是一致的。</p>\n<p>开源的观念并不只限于软件的开发与使用，而是希望能够抱着<strong>开放的心态</strong>，<strong>分享与合作的精神</strong>，<strong>相互切磋与学习</strong>，<strong>当你的代码被分享时它会变得更好</strong>。</p>\n<blockquote>\n<p>参考连接：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/happmaoo/article/details/83201544\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/happmaoo/article/details/83201544</a></li>\n<li><a href=\"https://www.oschina.net/news/58921/what-is-open-source\" target=\"_blank\" rel=\"noopener\">https://www.oschina.net/news/58921/what-is-open-source</a></li>\n</ul>\n</blockquote>"},{"title":"八、JavaSE反射机制","date":"2019-07-10T07:47:15.000Z","_content":"\n反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [Class类](#id2)\n3. [Constructor类](#id3)\n4. [Field类](#id4)\n5. [Method类](#id5)\n6. [原始方式与反射方式构造对象实例](#id6)\n7. [注解(Annotation)](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 基本概念\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；\n类是用来描述一组对象，反射机制可以理解为是用来描述一组类\n\n通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。\n\n#### 1.1 相关类及描述\n- Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n- Package：用来描述类所属的包\n- Field：用来描述类中的属性\n- Method：用来描述类中的方法\n- Constructor：用来描述类中的构造方法\n- Annotation：用来描述类中的注解\n\n\n<span id=\"id2\"><span>\n### 2. Class类\njava.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n\n#### 2.1 获取Class类型对象的三种方式\n``` java\nClass clazz = Class.forName(\"包名.类名\");//用的最多，但可能抛出ClassNotFoundException异常\nClass clazz = 类名.class;//任何类都有一个隐含的静态成员变量class\nClass clazz = 对象.getClass();//Object类中的方法\nClass clazz = 包装类.TYPE;//获取对应基本数据类型的class对象\n```\n\n#### 2.2 常用方法\n- static Class<?> forName(String className)\n    * 用于获取参数指定对应的Class对象并返回\n- T newInstance()\n    * 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n- Constructor<T> getConstructor(Class<?>... parameterTypes)\n    * 用于获取此Class对象所表示类型中参数指定的公共构造方法。\n- Constructor<?>[] getConstructors()\n    * 用于获取此Class对象所表示类型中所有的公共构造方法\n- Field getDeclaredField(String name)\n    * 用于获取此Class对象所表示类中参数指定的单个成员变量信息\n- Field[] fs = getDeclaredFields()\n    * 用于获取此Class对象所表示类中所有成员变量信息\n- Method getMethod(String name, Class<?>... parameterTypes)\n    * 用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法\n- Method[] getMethods()\n    * 用于获取该Class对象表示类中所有公共成员方法。\n- 获取私有相关方法\n    * getDeclaredConstructor(Class<?>... parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)\n    * getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)\n    * getDeclaredMethod(String name, Class<?>... parameterTypes) 获取一个方法(自己类 公有 私有)\n    * getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)\n\n\n#### 2.3 其他方法\n1. int result = getModifiers(); 获取类的修饰符(权限+特征)\n    * 每一个修饰符 用一个整数来进行表示：0--默认不写，1--public，2--private，4--protected，-static， 16--final，32--synchronized，64volatile，128--transient，256--native，512--interface，1024--abstract\n2. String name = getName(); 获取类的全名(包名.类名)\n3. String name = getSimpleName(); 获取类简单名(只有类名 缺少包)\n4. Package p = getPackage(); 获取当前类所属的包\n    * p.getName(); 获取包名(Package类中的方法)\n5. Class sclazz = getSuperClass(); 获取超类(父类)对应Class\n6. Class[] classes = getInterface(); 获取当前类父亲接口\n7. Class[] classes = getClasses(); 获取类中的内部类\n8. Object obj = **newInstance()**; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n9. Field f = getField(\"属性名\"); 获取类中的属性(公有的 自己类+父类)\n10. Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)\n11. getDeclaredField(\"属性\"); 获取当前类中的属性(公有+私有 自己类)\n12. Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)\n\n\n<span id=\"id3\"><span>\n### 3. Constructor类\njava.lang.reflect.Constructor类主要用于描述获取到的构造方法信息\n\n#### 3.1 Constructor类中的常用方法\n- T newInstance(Object... initargs)\n    * 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。\n\n#### 3.2 其他方法\n- con.getModifiers();\n- con.getName();\n- con.getParameterTypes();\n- con.getExceptionTypes();\n- 如何操作构造方法\n    * 执行一次,创建对象\n    * Object = newInstance(执行构造方法时的所有参数);\n    * con.setAccessible(true);\n\n\n<span id=\"id4\"><span>\n### 4. Field类\njava.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。\n\n#### 4.1 Field类中的常用方法\n- Object get(Object obj)\n    * 调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。\n- Object set(Object obj, Object value)\n    * 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。\n- void setAccessible(boolean flag)\n    * 当实参传递true时，则反射的对象在使用时应该取消java语言访问检查\n\n\n#### 4.2 其他方法\n1. int = getModifiers(); 获取属性修饰符(权限+特征)\n2. Class = getType(); 获取属性的类型对应的那个class\n3. String = getName(); 获取属性的名字\n4. 操作属性: set(对象,值); Object = get(对象);\n    * 如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入\n\n\n<span id=\"id5\"><span>\n### 5. Method类\njava.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。\n\n#### 5.1 Method类中的常用方法\n- Object invoke(Object obj, Object... args)\n    * 使用对象obj来调用此Method对象所表示的成员方法，实参传递args。\n\n#### 5.2 其他方法\n- int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)\n- Class mrt = m.getReturnType(); 获取返回值数据类型\n- String mn = m.getName(); 获取方法的名字\n- Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型\n- Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型\n- 如何操作方法\n- 调用方法   让他执行一次\n- Object result = invoke(对象,执行方法需要传递的所有参数...);\n- 若方法是私有的方法  不允许操作\n- 可以设置setAccessable(true)   设置方法使用权  准入\n\n\n<span id=\"id6\"><span>\n### 6. 原始方式与反射方式构造对象实例\n1. 使用原始方式来构造对象\n\n``` java\n  //1.采用无参的方式构造Person对象并打印\nPerson p = new Person();\nSystem.out.println(p); //null 0\n  //2.使用有参方式来构造Person对象\nPerson p2 = new Person(\"zhangfei\", 30);\nSystem.out.println(p2); //zhangfei 30\n  //3.修改与获取属性(成员变量)，调用get,set方法\np2.setName(\"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + p2.getName()); //guanyu\n```\n\n2. 使用反射机制来构造对象\n\n``` java\n    //1.使用获取到的Class对象来构造Person对象并打印\nClass c1 = Class.forName(\"myproject.Person\");//不可省略包名\nSystem.out.println(c1.newInstance());//null 0\n    //2.使用有参方式来构造对象\nClass c2 = Class.forName(\"myproject.Person\");\nConstructor ct2 = c2.getConstructor(String.class, int.class);\nObject obj = ct2.newInstance(\"zhangfei\", 30);\nSystem.out.println(obj);//zhangfei 30\n    //3.修改与获取属性(成员变量)\nField f2 = c2.getDeclaredField(\"name\");\nf2.setAccessible(true);//暴力反射，设置使用权\nf2.set(obj, \"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + f2.get(obj)); //guanyu\n    //4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来\nMethod m1 = c2.getMethod(\"getName\");\nSystem.out.println(\"获取到的姓名是：\" + m1.invoke(obj)); //zhangfei\n    //5.成员方法setName，调用getMethod方法来修改姓名并打印出来\nMethod m2 = c2.getMethod(\"setName\", String.class);\nObject res = m2.invoke(obj, \"guanyu\");\nSystem.out.println(\"方法调用的返回值是：\" + res); //null\nSystem.out.println(\"修改后的姓名是：\" + m1.invoke(obj)); //guanyu\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 注解(Annotation)\n#### 7.1 注解相关概念\n- 注释\n    * 单行注释：`//`\n    * 多行注释：`/*   */`\n    * 文档注释：`/**   */`\n- 注解的写法\n    * `@XXX [(一些信息)]`\n- 注解位置\n    * 类的上面，属性上面，方法上面，构造方法上面，参数前面\n- 注解的作用\n    1. 用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated\n    2. 用来做代码的检测(验证)，@Override\n    3. *可以携带一些信息(内容)，文件.properties/.xml，注解\n- 常用的注解\n    * @Deprecated：用来说明方法是废弃的\n    * @Override：用来做代码检测   检测此方法是否是一个重写\n    * @SuppressWarnings(String[])：{\"\"}，如果数组内的元素只有一个长度，可以省略{}\n        + unused：变量定义后未被使用\n        + serial：类实现了序列化接口  不添加序列化ID号\n        + rawtypes：集合没有定义泛型\n        + deprecation：方法以废弃    \n        + *unchecked：出现了泛型的问题  可以不检测\n        + all：包含了以上所有(不推荐)\n- 注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：\n    1. 基本数据类型\n    2. String类型\n    3. 枚举类型enum\n    4. 注解类型@\n    5. 数组类型[]，数组的内部需要是如上的四种类型\n- 注解的分类\n    1. 按运行机制分：源码注解，编译时注解，运行时注解\n    2. 按照来源分：来自JDK的注解，来自第三方的注解，自定义注解\n    \n\n#### 7.2 自定义注解类型的语法要求：\n1. 使用@interface关键字定义注解\n2. 成员以**无参无异常**方式声明\n3. 可以用default为成员指定一个默认值\n4. 成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration\n5. 如果注解只有一个成员，则成员名必须取名**value()**,在使用时可以忽略成员名和赋值号(=)\n6. 注解类可以没有成员，没有成员的注解称为标识注解\n7. 需要元注解来描述说明\n    + @Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)\n    + @Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)--->编译--->字节码文件(CLASS)--->加载--->内存执行(RUNTIME)\n    + @Inherited：允许子类继承\n    + @Document：当前注解是否能被文档(javadoc)所记录\n\n``` java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 18;\n}\n```\n\n#### 7.3 使用自定义注解：\n* @<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n\n``` java\n@Description(desc=\"I am eyeColor\", author=\"Chao\", age=18)\npublic String eyeColor(){\n    return \"red\";\n}\n```\n\n> 如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字\n\n``` java\n@Description(\"I am class annotation\")\npublic class Child implements Person{\n    @Override\n    @Description(\"I am method annotation\")\n    public String name(){\n        return null;\n    }\n    @Override\n    public int age(){\n        return 0;\n    }\n    @Override\n    public void sing(){ }\n}\n```\n\n#### 7.4 解析注解\n通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。\n\n1. 使用类加载器加载类\n    * `Class c=Class.forName（\"com.ann.test.Child\")`\n2. 找到类上面的注解\n    * `isAnnotationPresent（类类型）`：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。\n3. 拿到注解实例，需要强制类型转换。\n    * `Description d=（Description）c.getAnnotation(Description.class);`\n4. 找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。\n\n``` java\npublic class ParseAnn{\n  public static void main(String[]){\n    try{//1. 使用类加载器加载类\n      Class c=Class.forName（\"com.ann.test.Child\")\n      //2. 找到类上面的注解\n      boolean isExist = c.isAnnotationPresent(Description.class);\n      if(isExist){\n        //3. 拿到注解实例\n        Description d=（Description）c.getAnnotation(Description.class);\n        System.out.println(d.value());\n      }\n      //4.找到方法上的注解\n      Method[] ms = c.getMethods();\n      for(Method m:ms){\n        boolean isMExist = m.isAnnotationPresent(Description.class);\n        if(isMExist){\n          Description md=（Description）c.getAnnotation(Description.class);\n          System.out.println(md.value());\n        }\n      }\n    }catch(ClassNotFoundException e){\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n* 另一种解析方法上的注解:\n    + 获取这个方法的所有注解，`Annotation [] as=m.getAnnotations();`然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。\n\n``` java\nfor(Method m:ms){\n  Annotation [] as=m.getAnnotations();\n  for(Annotation a:as){\n    if(a instanceof Description){\n      Description md = (Description)a;\n      System.out.println(md.value());\n    }\n  }\n}\n```\n\n> @Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 \n\n","source":"_posts/08_JavaSE反射机制.md","raw":"---\ntitle: 八、JavaSE反射机制\ndate: 2019-07-10 15:47:15\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。\n多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [Class类](#id2)\n3. [Constructor类](#id3)\n4. [Field类](#id4)\n5. [Method类](#id5)\n6. [原始方式与反射方式构造对象实例](#id6)\n7. [注解(Annotation)](#id7)\n\n\n<span id=\"id1\"><span>\n### 1. 基本概念\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。\n\n反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；\n类是用来描述一组对象，反射机制可以理解为是用来描述一组类\n\n通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。\n\n#### 1.1 相关类及描述\n- Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n- Package：用来描述类所属的包\n- Field：用来描述类中的属性\n- Method：用来描述类中的方法\n- Constructor：用来描述类中的构造方法\n- Annotation：用来描述类中的注解\n\n\n<span id=\"id2\"><span>\n### 2. Class类\njava.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成\n\n#### 2.1 获取Class类型对象的三种方式\n``` java\nClass clazz = Class.forName(\"包名.类名\");//用的最多，但可能抛出ClassNotFoundException异常\nClass clazz = 类名.class;//任何类都有一个隐含的静态成员变量class\nClass clazz = 对象.getClass();//Object类中的方法\nClass clazz = 包装类.TYPE;//获取对应基本数据类型的class对象\n```\n\n#### 2.2 常用方法\n- static Class<?> forName(String className)\n    * 用于获取参数指定对应的Class对象并返回\n- T newInstance()\n    * 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n- Constructor<T> getConstructor(Class<?>... parameterTypes)\n    * 用于获取此Class对象所表示类型中参数指定的公共构造方法。\n- Constructor<?>[] getConstructors()\n    * 用于获取此Class对象所表示类型中所有的公共构造方法\n- Field getDeclaredField(String name)\n    * 用于获取此Class对象所表示类中参数指定的单个成员变量信息\n- Field[] fs = getDeclaredFields()\n    * 用于获取此Class对象所表示类中所有成员变量信息\n- Method getMethod(String name, Class<?>... parameterTypes)\n    * 用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法\n- Method[] getMethods()\n    * 用于获取该Class对象表示类中所有公共成员方法。\n- 获取私有相关方法\n    * getDeclaredConstructor(Class<?>... parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)\n    * getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)\n    * getDeclaredMethod(String name, Class<?>... parameterTypes) 获取一个方法(自己类 公有 私有)\n    * getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)\n\n\n#### 2.3 其他方法\n1. int result = getModifiers(); 获取类的修饰符(权限+特征)\n    * 每一个修饰符 用一个整数来进行表示：0--默认不写，1--public，2--private，4--protected，-static， 16--final，32--synchronized，64volatile，128--transient，256--native，512--interface，1024--abstract\n2. String name = getName(); 获取类的全名(包名.类名)\n3. String name = getSimpleName(); 获取类简单名(只有类名 缺少包)\n4. Package p = getPackage(); 获取当前类所属的包\n    * p.getName(); 获取包名(Package类中的方法)\n5. Class sclazz = getSuperClass(); 获取超类(父类)对应Class\n6. Class[] classes = getInterface(); 获取当前类父亲接口\n7. Class[] classes = getClasses(); 获取类中的内部类\n8. Object obj = **newInstance()**; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException\n9. Field f = getField(\"属性名\"); 获取类中的属性(公有的 自己类+父类)\n10. Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)\n11. getDeclaredField(\"属性\"); 获取当前类中的属性(公有+私有 自己类)\n12. Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)\n\n\n<span id=\"id3\"><span>\n### 3. Constructor类\njava.lang.reflect.Constructor类主要用于描述获取到的构造方法信息\n\n#### 3.1 Constructor类中的常用方法\n- T newInstance(Object... initargs)\n    * 使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。\n\n#### 3.2 其他方法\n- con.getModifiers();\n- con.getName();\n- con.getParameterTypes();\n- con.getExceptionTypes();\n- 如何操作构造方法\n    * 执行一次,创建对象\n    * Object = newInstance(执行构造方法时的所有参数);\n    * con.setAccessible(true);\n\n\n<span id=\"id4\"><span>\n### 4. Field类\njava.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。\n\n#### 4.1 Field类中的常用方法\n- Object get(Object obj)\n    * 调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。\n- Object set(Object obj, Object value)\n    * 将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。\n- void setAccessible(boolean flag)\n    * 当实参传递true时，则反射的对象在使用时应该取消java语言访问检查\n\n\n#### 4.2 其他方法\n1. int = getModifiers(); 获取属性修饰符(权限+特征)\n2. Class = getType(); 获取属性的类型对应的那个class\n3. String = getName(); 获取属性的名字\n4. 操作属性: set(对象,值); Object = get(对象);\n    * 如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入\n\n\n<span id=\"id5\"><span>\n### 5. Method类\njava.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。\n\n#### 5.1 Method类中的常用方法\n- Object invoke(Object obj, Object... args)\n    * 使用对象obj来调用此Method对象所表示的成员方法，实参传递args。\n\n#### 5.2 其他方法\n- int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)\n- Class mrt = m.getReturnType(); 获取返回值数据类型\n- String mn = m.getName(); 获取方法的名字\n- Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型\n- Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型\n- 如何操作方法\n- 调用方法   让他执行一次\n- Object result = invoke(对象,执行方法需要传递的所有参数...);\n- 若方法是私有的方法  不允许操作\n- 可以设置setAccessable(true)   设置方法使用权  准入\n\n\n<span id=\"id6\"><span>\n### 6. 原始方式与反射方式构造对象实例\n1. 使用原始方式来构造对象\n\n``` java\n  //1.采用无参的方式构造Person对象并打印\nPerson p = new Person();\nSystem.out.println(p); //null 0\n  //2.使用有参方式来构造Person对象\nPerson p2 = new Person(\"zhangfei\", 30);\nSystem.out.println(p2); //zhangfei 30\n  //3.修改与获取属性(成员变量)，调用get,set方法\np2.setName(\"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + p2.getName()); //guanyu\n```\n\n2. 使用反射机制来构造对象\n\n``` java\n    //1.使用获取到的Class对象来构造Person对象并打印\nClass c1 = Class.forName(\"myproject.Person\");//不可省略包名\nSystem.out.println(c1.newInstance());//null 0\n    //2.使用有参方式来构造对象\nClass c2 = Class.forName(\"myproject.Person\");\nConstructor ct2 = c2.getConstructor(String.class, int.class);\nObject obj = ct2.newInstance(\"zhangfei\", 30);\nSystem.out.println(obj);//zhangfei 30\n    //3.修改与获取属性(成员变量)\nField f2 = c2.getDeclaredField(\"name\");\nf2.setAccessible(true);//暴力反射，设置使用权\nf2.set(obj, \"guanyu\");\nSystem.out.println(\"修改后的姓名是：\" + f2.get(obj)); //guanyu\n    //4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来\nMethod m1 = c2.getMethod(\"getName\");\nSystem.out.println(\"获取到的姓名是：\" + m1.invoke(obj)); //zhangfei\n    //5.成员方法setName，调用getMethod方法来修改姓名并打印出来\nMethod m2 = c2.getMethod(\"setName\", String.class);\nObject res = m2.invoke(obj, \"guanyu\");\nSystem.out.println(\"方法调用的返回值是：\" + res); //null\nSystem.out.println(\"修改后的姓名是：\" + m1.invoke(obj)); //guanyu\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 注解(Annotation)\n#### 7.1 注解相关概念\n- 注释\n    * 单行注释：`//`\n    * 多行注释：`/*   */`\n    * 文档注释：`/**   */`\n- 注解的写法\n    * `@XXX [(一些信息)]`\n- 注解位置\n    * 类的上面，属性上面，方法上面，构造方法上面，参数前面\n- 注解的作用\n    1. 用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated\n    2. 用来做代码的检测(验证)，@Override\n    3. *可以携带一些信息(内容)，文件.properties/.xml，注解\n- 常用的注解\n    * @Deprecated：用来说明方法是废弃的\n    * @Override：用来做代码检测   检测此方法是否是一个重写\n    * @SuppressWarnings(String[])：{\"\"}，如果数组内的元素只有一个长度，可以省略{}\n        + unused：变量定义后未被使用\n        + serial：类实现了序列化接口  不添加序列化ID号\n        + rawtypes：集合没有定义泛型\n        + deprecation：方法以废弃    \n        + *unchecked：出现了泛型的问题  可以不检测\n        + all：包含了以上所有(不推荐)\n- 注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：\n    1. 基本数据类型\n    2. String类型\n    3. 枚举类型enum\n    4. 注解类型@\n    5. 数组类型[]，数组的内部需要是如上的四种类型\n- 注解的分类\n    1. 按运行机制分：源码注解，编译时注解，运行时注解\n    2. 按照来源分：来自JDK的注解，来自第三方的注解，自定义注解\n    \n\n#### 7.2 自定义注解类型的语法要求：\n1. 使用@interface关键字定义注解\n2. 成员以**无参无异常**方式声明\n3. 可以用default为成员指定一个默认值\n4. 成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration\n5. 如果注解只有一个成员，则成员名必须取名**value()**,在使用时可以忽略成员名和赋值号(=)\n6. 注解类可以没有成员，没有成员的注解称为标识注解\n7. 需要元注解来描述说明\n    + @Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)\n    + @Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)--->编译--->字节码文件(CLASS)--->加载--->内存执行(RUNTIME)\n    + @Inherited：允许子类继承\n    + @Document：当前注解是否能被文档(javadoc)所记录\n\n``` java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Description{\n    String desc();\n    String author();\n    int age() default 18;\n}\n```\n\n#### 7.3 使用自定义注解：\n* @<注解名>(<成员名1>=<成员值1>,<成员名2>=<成员值2>,...)\n\n``` java\n@Description(desc=\"I am eyeColor\", author=\"Chao\", age=18)\npublic String eyeColor(){\n    return \"red\";\n}\n```\n\n> 如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字\n\n``` java\n@Description(\"I am class annotation\")\npublic class Child implements Person{\n    @Override\n    @Description(\"I am method annotation\")\n    public String name(){\n        return null;\n    }\n    @Override\n    public int age(){\n        return 0;\n    }\n    @Override\n    public void sing(){ }\n}\n```\n\n#### 7.4 解析注解\n通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。\n\n1. 使用类加载器加载类\n    * `Class c=Class.forName（\"com.ann.test.Child\")`\n2. 找到类上面的注解\n    * `isAnnotationPresent（类类型）`：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。\n3. 拿到注解实例，需要强制类型转换。\n    * `Description d=（Description）c.getAnnotation(Description.class);`\n4. 找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。\n\n``` java\npublic class ParseAnn{\n  public static void main(String[]){\n    try{//1. 使用类加载器加载类\n      Class c=Class.forName（\"com.ann.test.Child\")\n      //2. 找到类上面的注解\n      boolean isExist = c.isAnnotationPresent(Description.class);\n      if(isExist){\n        //3. 拿到注解实例\n        Description d=（Description）c.getAnnotation(Description.class);\n        System.out.println(d.value());\n      }\n      //4.找到方法上的注解\n      Method[] ms = c.getMethods();\n      for(Method m:ms){\n        boolean isMExist = m.isAnnotationPresent(Description.class);\n        if(isMExist){\n          Description md=（Description）c.getAnnotation(Description.class);\n          System.out.println(md.value());\n        }\n      }\n    }catch(ClassNotFoundException e){\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n* 另一种解析方法上的注解:\n    + 获取这个方法的所有注解，`Annotation [] as=m.getAnnotations();`然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。\n\n``` java\nfor(Method m:ms){\n  Annotation [] as=m.getAnnotations();\n  for(Annotation a:as){\n    if(a instanceof Description){\n      Description md = (Description)a;\n      System.out.println(md.value());\n    }\n  }\n}\n```\n\n> @Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 \n\n","slug":"08_JavaSE反射机制","published":1,"updated":"2019-07-20T14:56:40.906Z","_id":"cjyblnrsk001bxwt3kcg8nvj5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">Class类</a></li>\n<li><a href=\"#id3\">Constructor类</a></li>\n<li><a href=\"#id4\">Field类</a></li>\n<li><a href=\"#id5\">Method类</a></li>\n<li><a href=\"#id6\">原始方式与反射方式构造对象实例</a></li>\n<li><a href=\"#id7\">注解(Annotation)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>\n<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>\n<h4 id=\"1-1-相关类及描述\"><a href=\"#1-1-相关类及描述\" class=\"headerlink\" title=\"1.1 相关类及描述\"></a>1.1 相关类及描述</h4><ul>\n<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>\n<li>Package：用来描述类所属的包</li>\n<li>Field：用来描述类中的属性</li>\n<li>Method：用来描述类中的方法</li>\n<li>Constructor：用来描述类中的构造方法</li>\n<li>Annotation：用来描述类中的注解</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Class类\"><a href=\"#2-Class类\" class=\"headerlink\" title=\"2. Class类\"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>\n<h4 id=\"2-1-获取Class类型对象的三种方式\"><a href=\"#2-1-获取Class类型对象的三种方式\" class=\"headerlink\" title=\"2.1 获取Class类型对象的三种方式\"></a>2.1 获取Class类型对象的三种方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"包名.类名\"</span>);<span class=\"comment\">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class=\"line\">Class clazz = 类名.class;<span class=\"comment\">//任何类都有一个隐含的静态成员变量class</span></span><br><span class=\"line\">Class clazz = 对象.getClass();<span class=\"comment\">//Object类中的方法</span></span><br><span class=\"line\">Class clazz = 包装类.TYPE;<span class=\"comment\">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-常用方法\"><a href=\"#2-2-常用方法\" class=\"headerlink\" title=\"2.2 常用方法\"></a>2.2 常用方法</h4><ul>\n<li>static Class&lt;?&gt; forName(String className)<ul>\n<li>用于获取参数指定对应的Class对象并返回</li>\n</ul>\n</li>\n<li>T newInstance()<ul>\n<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n</ul>\n</li>\n<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>\n</ul>\n</t></li>\n<li>Constructor&lt;?&gt;[] getConstructors()<ul>\n<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>\n</ul>\n</li>\n<li>Field getDeclaredField(String name)<ul>\n<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>\n</ul>\n</li>\n<li>Field[] fs = getDeclaredFields()<ul>\n<li>用于获取此Class对象所表示类中所有成员变量信息</li>\n</ul>\n</li>\n<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>\n</ul>\n</li>\n<li>Method[] getMethods()<ul>\n<li>用于获取该Class对象表示类中所有公共成员方法。</li>\n</ul>\n</li>\n<li>获取私有相关方法<ul>\n<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>\n<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>\n<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>\n<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-其他方法\"><a href=\"#2-3-其他方法\" class=\"headerlink\" title=\"2.3 其他方法\"></a>2.3 其他方法</h4><ol>\n<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>\n<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>\n</ul>\n</li>\n<li>String name = getName(); 获取类的全名(包名.类名)</li>\n<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>\n<li>Package p = getPackage(); 获取当前类所属的包<ul>\n<li>p.getName(); 获取包名(Package类中的方法)</li>\n</ul>\n</li>\n<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>\n<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>\n<li>Class[] classes = getClasses(); 获取类中的内部类</li>\n<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>\n<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>\n<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>\n<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Constructor类\"><a href=\"#3-Constructor类\" class=\"headerlink\" title=\"3. Constructor类\"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>\n<h4 id=\"3-1-Constructor类中的常用方法\"><a href=\"#3-1-Constructor类中的常用方法\" class=\"headerlink\" title=\"3.1 Constructor类中的常用方法\"></a>3.1 Constructor类中的常用方法</h4><ul>\n<li>T newInstance(Object… initargs)<ul>\n<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-其他方法\"><a href=\"#3-2-其他方法\" class=\"headerlink\" title=\"3.2 其他方法\"></a>3.2 其他方法</h4><ul>\n<li>con.getModifiers();</li>\n<li>con.getName();</li>\n<li>con.getParameterTypes();</li>\n<li>con.getExceptionTypes();</li>\n<li>如何操作构造方法<ul>\n<li>执行一次,创建对象</li>\n<li>Object = newInstance(执行构造方法时的所有参数);</li>\n<li>con.setAccessible(true);</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Field类\"><a href=\"#4-Field类\" class=\"headerlink\" title=\"4. Field类\"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>\n<h4 id=\"4-1-Field类中的常用方法\"><a href=\"#4-1-Field类中的常用方法\" class=\"headerlink\" title=\"4.1 Field类中的常用方法\"></a>4.1 Field类中的常用方法</h4><ul>\n<li>Object get(Object obj)<ul>\n<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>\n</ul>\n</li>\n<li>Object set(Object obj, Object value)<ul>\n<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>\n</ul>\n</li>\n<li>void setAccessible(boolean flag)<ul>\n<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-其他方法\"><a href=\"#4-2-其他方法\" class=\"headerlink\" title=\"4.2 其他方法\"></a>4.2 其他方法</h4><ol>\n<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>\n<li>Class = getType(); 获取属性的类型对应的那个class</li>\n<li>String = getName(); 获取属性的名字</li>\n<li>操作属性: set(对象,值); Object = get(对象);<ul>\n<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-Method类\"><a href=\"#5-Method类\" class=\"headerlink\" title=\"5. Method类\"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>\n<h4 id=\"5-1-Method类中的常用方法\"><a href=\"#5-1-Method类中的常用方法\" class=\"headerlink\" title=\"5.1 Method类中的常用方法\"></a>5.1 Method类中的常用方法</h4><ul>\n<li>Object invoke(Object obj, Object… args)<ul>\n<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-其他方法\"><a href=\"#5-2-其他方法\" class=\"headerlink\" title=\"5.2 其他方法\"></a>5.2 其他方法</h4><ul>\n<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>\n<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>\n<li>String mn = m.getName(); 获取方法的名字</li>\n<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>\n<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>\n<li>如何操作方法</li>\n<li>调用方法   让他执行一次</li>\n<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>\n<li>若方法是私有的方法  不允许操作</li>\n<li>可以设置setAccessable(true)   设置方法使用权  准入</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-原始方式与反射方式构造对象实例\"><a href=\"#6-原始方式与反射方式构造对象实例\" class=\"headerlink\" title=\"6. 原始方式与反射方式构造对象实例\"></a>6. 原始方式与反射方式构造对象实例</h3><ol>\n<li>使用原始方式来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//1.采用无参的方式构造Person对象并打印</span></span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p); <span class=\"comment\">//null 0</span></span><br><span class=\"line\">  <span class=\"comment\">//2.使用有参方式来构造Person对象</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(p2); <span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">  <span class=\"comment\">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class=\"line\">p2.setName(<span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + p2.getName()); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用反射机制来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class=\"line\">Class c1 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);<span class=\"comment\">//不可省略包名</span></span><br><span class=\"line\">System.out.println(c1.newInstance());<span class=\"comment\">//null 0</span></span><br><span class=\"line\">    <span class=\"comment\">//2.使用有参方式来构造对象</span></span><br><span class=\"line\">Class c2 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);</span><br><span class=\"line\">Constructor ct2 = c2.getConstructor(String.class, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Object obj = ct2.newInstance(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(obj);<span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">    <span class=\"comment\">//3.修改与获取属性(成员变量)</span></span><br><span class=\"line\">Field f2 = c2.getDeclaredField(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">f2.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//暴力反射，设置使用权</span></span><br><span class=\"line\">f2.set(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + f2.get(obj)); <span class=\"comment\">//guanyu</span></span><br><span class=\"line\">    <span class=\"comment\">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class=\"line\">Method m1 = c2.getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"获取到的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//zhangfei</span></span><br><span class=\"line\">    <span class=\"comment\">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class=\"line\">Method m2 = c2.getMethod(<span class=\"string\">\"setName\"</span>, String.class);</span><br><span class=\"line\">Object res = m2.invoke(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"方法调用的返回值是：\"</span> + res); <span class=\"comment\">//null</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-注解-Annotation\"><a href=\"#7-注解-Annotation\" class=\"headerlink\" title=\"7. 注解(Annotation)\"></a>7. 注解(Annotation)</h3><h4 id=\"7-1-注解相关概念\"><a href=\"#7-1-注解相关概念\" class=\"headerlink\" title=\"7.1 注解相关概念\"></a>7.1 注解相关概念</h4><ul>\n<li>注释<ul>\n<li>单行注释：<code>//</code></li>\n<li>多行注释：<code>/*   */</code></li>\n<li>文档注释：<code>/**   */</code></li>\n</ul>\n</li>\n<li>注解的写法<ul>\n<li><code>@XXX [(一些信息)]</code></li>\n</ul>\n</li>\n<li>注解位置<ul>\n<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>\n</ul>\n</li>\n<li>注解的作用<ol>\n<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>\n<li>用来做代码的检测(验证)，@Override</li>\n<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>\n</ol>\n</li>\n<li>常用的注解<ul>\n<li>@Deprecated：用来说明方法是废弃的</li>\n<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>\n<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>\n<li>unused：变量定义后未被使用</li>\n<li>serial：类实现了序列化接口  不添加序列化ID号</li>\n<li>rawtypes：集合没有定义泛型</li>\n<li>deprecation：方法以废弃    </li>\n<li>*unchecked：出现了泛型的问题  可以不检测</li>\n<li>all：包含了以上所有(不推荐)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>\n<li>基本数据类型</li>\n<li>String类型</li>\n<li>枚举类型enum</li>\n<li>注解类型@</li>\n<li>数组类型[]，数组的内部需要是如上的四种类型</li>\n</ol>\n</li>\n<li>注解的分类<ol>\n<li>按运行机制分：源码注解，编译时注解，运行时注解</li>\n<li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-2-自定义注解类型的语法要求：\"><a href=\"#7-2-自定义注解类型的语法要求：\" class=\"headerlink\" title=\"7.2 自定义注解类型的语法要求：\"></a>7.2 自定义注解类型的语法要求：</h4><ol>\n<li>使用@interface关键字定义注解</li>\n<li>成员以<strong>无参无异常</strong>方式声明</li>\n<li>可以用default为成员指定一个默认值</li>\n<li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li>\n<li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li>\n<li>注解类可以没有成员，没有成员的注解称为标识注解</li>\n<li>需要元注解来描述说明<ul>\n<li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li>\n<li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>\n<li>@Inherited：允许子类继承</li>\n<li>@Document：当前注解是否能被文档(javadoc)所记录</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-使用自定义注解：\"><a href=\"#7-3-使用自定义注解：\" class=\"headerlink\" title=\"7.3 使用自定义注解：\"></a>7.3 使用自定义注解：</h4><ul>\n<li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(desc=<span class=\"string\">\"I am eyeColor\"</span>, author=<span class=\"string\">\"Chao\"</span>, age=<span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">eyeColor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(<span class=\"string\">\"I am class annotation\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Description</span>(<span class=\"string\">\"I am method annotation\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-解析注解\"><a href=\"#7-4-解析注解\" class=\"headerlink\" title=\"7.4 解析注解\"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p>\n<ol>\n<li>使用类加载器加载类<ul>\n<li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li>\n</ul>\n</li>\n<li>找到类上面的注解<ul>\n<li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li>\n</ul>\n</li>\n<li>拿到注解实例，需要强制类型转换。<ul>\n<li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li>\n</ul>\n</li>\n<li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseAnn</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;<span class=\"comment\">//1. 使用类加载器加载类</span></span><br><span class=\"line\">      Class c=Class.forName（<span class=\"string\">\"com.ann.test.Child\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//2. 找到类上面的注解</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isExist)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3. 拿到注解实例</span></span><br><span class=\"line\">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">        System.out.println(d.value());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//4.找到方法上的注解</span></span><br><span class=\"line\">      Method[] ms = c.getMethods();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isMExist)&#123;</span><br><span class=\"line\">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">          System.out.println(md.value());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种解析方法上的注解:<ul>\n<li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">  Annotation [] as=m.getAnnotations();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">      Description md = (Description)a;</span><br><span class=\"line\">      System.out.println(md.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">Class类</a></li>\n<li><a href=\"#id3\">Constructor类</a></li>\n<li><a href=\"#id4\">Field类</a></li>\n<li><a href=\"#id5\">Method类</a></li>\n<li><a href=\"#id6\">原始方式与反射方式构造对象实例</a></li>\n<li><a href=\"#id7\">注解(Annotation)</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>\n<p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p>\n<p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p>\n<h4 id=\"1-1-相关类及描述\"><a href=\"#1-1-相关类及描述\" class=\"headerlink\" title=\"1.1 相关类及描述\"></a>1.1 相关类及描述</h4><ul>\n<li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li>\n<li>Package：用来描述类所属的包</li>\n<li>Field：用来描述类中的属性</li>\n<li>Method：用来描述类中的方法</li>\n<li>Constructor：用来描述类中的构造方法</li>\n<li>Annotation：用来描述类中的注解</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Class类\"><a href=\"#2-Class类\" class=\"headerlink\" title=\"2. Class类\"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p>\n<h4 id=\"2-1-获取Class类型对象的三种方式\"><a href=\"#2-1-获取Class类型对象的三种方式\" class=\"headerlink\" title=\"2.1 获取Class类型对象的三种方式\"></a>2.1 获取Class类型对象的三种方式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class clazz = Class.forName(<span class=\"string\">\"包名.类名\"</span>);<span class=\"comment\">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class=\"line\">Class clazz = 类名.class;<span class=\"comment\">//任何类都有一个隐含的静态成员变量class</span></span><br><span class=\"line\">Class clazz = 对象.getClass();<span class=\"comment\">//Object类中的方法</span></span><br><span class=\"line\">Class clazz = 包装类.TYPE;<span class=\"comment\">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-常用方法\"><a href=\"#2-2-常用方法\" class=\"headerlink\" title=\"2.2 常用方法\"></a>2.2 常用方法</h4><ul>\n<li>static Class&lt;?&gt; forName(String className)<ul>\n<li>用于获取参数指定对应的Class对象并返回</li>\n</ul>\n</li>\n<li>T newInstance()<ul>\n<li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n</ul>\n</li>\n<li>Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li>\n</ul>\n</t></li>\n<li>Constructor&lt;?&gt;[] getConstructors()<ul>\n<li>用于获取此Class对象所表示类型中所有的公共构造方法</li>\n</ul>\n</li>\n<li>Field getDeclaredField(String name)<ul>\n<li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li>\n</ul>\n</li>\n<li>Field[] fs = getDeclaredFields()<ul>\n<li>用于获取此Class对象所表示类中所有成员变量信息</li>\n</ul>\n</li>\n<li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul>\n<li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li>\n</ul>\n</li>\n<li>Method[] getMethods()<ul>\n<li>用于获取该Class对象表示类中所有公共成员方法。</li>\n</ul>\n</li>\n<li>获取私有相关方法<ul>\n<li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li>\n<li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li>\n<li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li>\n<li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-3-其他方法\"><a href=\"#2-3-其他方法\" class=\"headerlink\" title=\"2.3 其他方法\"></a>2.3 其他方法</h4><ol>\n<li>int result = getModifiers(); 获取类的修饰符(权限+特征)<ul>\n<li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li>\n</ul>\n</li>\n<li>String name = getName(); 获取类的全名(包名.类名)</li>\n<li>String name = getSimpleName(); 获取类简单名(只有类名 缺少包)</li>\n<li>Package p = getPackage(); 获取当前类所属的包<ul>\n<li>p.getName(); 获取包名(Package类中的方法)</li>\n</ul>\n</li>\n<li>Class sclazz = getSuperClass(); 获取超类(父类)对应Class</li>\n<li>Class[] classes = getInterface(); 获取当前类父亲接口</li>\n<li>Class[] classes = getClasses(); 获取类中的内部类</li>\n<li>Object obj = <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li>\n<li>Field f = getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li>\n<li>Field[] fs = getFields(); 获取类中的全部属性(公有的 自己类+父类)</li>\n<li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li>\n<li>Field[] fs = getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-Constructor类\"><a href=\"#3-Constructor类\" class=\"headerlink\" title=\"3. Constructor类\"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p>\n<h4 id=\"3-1-Constructor类中的常用方法\"><a href=\"#3-1-Constructor类中的常用方法\" class=\"headerlink\" title=\"3.1 Constructor类中的常用方法\"></a>3.1 Constructor类中的常用方法</h4><ul>\n<li>T newInstance(Object… initargs)<ul>\n<li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-2-其他方法\"><a href=\"#3-2-其他方法\" class=\"headerlink\" title=\"3.2 其他方法\"></a>3.2 其他方法</h4><ul>\n<li>con.getModifiers();</li>\n<li>con.getName();</li>\n<li>con.getParameterTypes();</li>\n<li>con.getExceptionTypes();</li>\n<li>如何操作构造方法<ul>\n<li>执行一次,创建对象</li>\n<li>Object = newInstance(执行构造方法时的所有参数);</li>\n<li>con.setAccessible(true);</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Field类\"><a href=\"#4-Field类\" class=\"headerlink\" title=\"4. Field类\"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p>\n<h4 id=\"4-1-Field类中的常用方法\"><a href=\"#4-1-Field类中的常用方法\" class=\"headerlink\" title=\"4.1 Field类中的常用方法\"></a>4.1 Field类中的常用方法</h4><ul>\n<li>Object get(Object obj)<ul>\n<li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li>\n</ul>\n</li>\n<li>Object set(Object obj, Object value)<ul>\n<li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li>\n</ul>\n</li>\n<li>void setAccessible(boolean flag)<ul>\n<li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-其他方法\"><a href=\"#4-2-其他方法\" class=\"headerlink\" title=\"4.2 其他方法\"></a>4.2 其他方法</h4><ol>\n<li>int = getModifiers(); 获取属性修饰符(权限+特征)</li>\n<li>Class = getType(); 获取属性的类型对应的那个class</li>\n<li>String = getName(); 获取属性的名字</li>\n<li>操作属性: set(对象,值); Object = get(对象);<ul>\n<li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-Method类\"><a href=\"#5-Method类\" class=\"headerlink\" title=\"5. Method类\"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p>\n<h4 id=\"5-1-Method类中的常用方法\"><a href=\"#5-1-Method类中的常用方法\" class=\"headerlink\" title=\"5.1 Method类中的常用方法\"></a>5.1 Method类中的常用方法</h4><ul>\n<li>Object invoke(Object obj, Object… args)<ul>\n<li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-其他方法\"><a href=\"#5-2-其他方法\" class=\"headerlink\" title=\"5.2 其他方法\"></a>5.2 其他方法</h4><ul>\n<li>int mm = m.getModifiers(); 获取方法的修饰符(权限+特征)</li>\n<li>Class mrt = m.getReturnType(); 获取返回值数据类型</li>\n<li>String mn = m.getName(); 获取方法的名字</li>\n<li>Class[] mpts = m.getParameterTypes(); 获取方法参数列表的类型</li>\n<li>Class[] mets = m.getExceptionTypes(); 获取方法抛出异常的类型</li>\n<li>如何操作方法</li>\n<li>调用方法   让他执行一次</li>\n<li>Object result = invoke(对象,执行方法需要传递的所有参数…);</li>\n<li>若方法是私有的方法  不允许操作</li>\n<li>可以设置setAccessable(true)   设置方法使用权  准入</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-原始方式与反射方式构造对象实例\"><a href=\"#6-原始方式与反射方式构造对象实例\" class=\"headerlink\" title=\"6. 原始方式与反射方式构造对象实例\"></a>6. 原始方式与反射方式构造对象实例</h3><ol>\n<li>使用原始方式来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//1.采用无参的方式构造Person对象并打印</span></span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">System.out.println(p); <span class=\"comment\">//null 0</span></span><br><span class=\"line\">  <span class=\"comment\">//2.使用有参方式来构造Person对象</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(p2); <span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">  <span class=\"comment\">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class=\"line\">p2.setName(<span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + p2.getName()); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用反射机制来构造对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class=\"line\">Class c1 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);<span class=\"comment\">//不可省略包名</span></span><br><span class=\"line\">System.out.println(c1.newInstance());<span class=\"comment\">//null 0</span></span><br><span class=\"line\">    <span class=\"comment\">//2.使用有参方式来构造对象</span></span><br><span class=\"line\">Class c2 = Class.forName(<span class=\"string\">\"myproject.Person\"</span>);</span><br><span class=\"line\">Constructor ct2 = c2.getConstructor(String.class, <span class=\"keyword\">int</span>.class);</span><br><span class=\"line\">Object obj = ct2.newInstance(<span class=\"string\">\"zhangfei\"</span>, <span class=\"number\">30</span>);</span><br><span class=\"line\">System.out.println(obj);<span class=\"comment\">//zhangfei 30</span></span><br><span class=\"line\">    <span class=\"comment\">//3.修改与获取属性(成员变量)</span></span><br><span class=\"line\">Field f2 = c2.getDeclaredField(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">f2.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//暴力反射，设置使用权</span></span><br><span class=\"line\">f2.set(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + f2.get(obj)); <span class=\"comment\">//guanyu</span></span><br><span class=\"line\">    <span class=\"comment\">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class=\"line\">Method m1 = c2.getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"获取到的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//zhangfei</span></span><br><span class=\"line\">    <span class=\"comment\">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class=\"line\">Method m2 = c2.getMethod(<span class=\"string\">\"setName\"</span>, String.class);</span><br><span class=\"line\">Object res = m2.invoke(obj, <span class=\"string\">\"guanyu\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"方法调用的返回值是：\"</span> + res); <span class=\"comment\">//null</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"修改后的姓名是：\"</span> + m1.invoke(obj)); <span class=\"comment\">//guanyu</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-注解-Annotation\"><a href=\"#7-注解-Annotation\" class=\"headerlink\" title=\"7. 注解(Annotation)\"></a>7. 注解(Annotation)</h3><h4 id=\"7-1-注解相关概念\"><a href=\"#7-1-注解相关概念\" class=\"headerlink\" title=\"7.1 注解相关概念\"></a>7.1 注解相关概念</h4><ul>\n<li>注释<ul>\n<li>单行注释：<code>//</code></li>\n<li>多行注释：<code>/*   */</code></li>\n<li>文档注释：<code>/**   */</code></li>\n</ul>\n</li>\n<li>注解的写法<ul>\n<li><code>@XXX [(一些信息)]</code></li>\n</ul>\n</li>\n<li>注解位置<ul>\n<li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li>\n</ul>\n</li>\n<li>注解的作用<ol>\n<li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li>\n<li>用来做代码的检测(验证)，@Override</li>\n<li>*可以携带一些信息(内容)，文件.properties/.xml，注解</li>\n</ol>\n</li>\n<li>常用的注解<ul>\n<li>@Deprecated：用来说明方法是废弃的</li>\n<li>@Override：用来做代码检测   检测此方法是否是一个重写</li>\n<li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul>\n<li>unused：变量定义后未被使用</li>\n<li>serial：类实现了序列化接口  不添加序列化ID号</li>\n<li>rawtypes：集合没有定义泛型</li>\n<li>deprecation：方法以废弃    </li>\n<li>*unchecked：出现了泛型的问题  可以不检测</li>\n<li>all：包含了以上所有(不推荐)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol>\n<li>基本数据类型</li>\n<li>String类型</li>\n<li>枚举类型enum</li>\n<li>注解类型@</li>\n<li>数组类型[]，数组的内部需要是如上的四种类型</li>\n</ol>\n</li>\n<li>注解的分类<ol>\n<li>按运行机制分：源码注解，编译时注解，运行时注解</li>\n<li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"7-2-自定义注解类型的语法要求：\"><a href=\"#7-2-自定义注解类型的语法要求：\" class=\"headerlink\" title=\"7.2 自定义注解类型的语法要求：\"></a>7.2 自定义注解类型的语法要求：</h4><ol>\n<li>使用@interface关键字定义注解</li>\n<li>成员以<strong>无参无异常</strong>方式声明</li>\n<li>可以用default为成员指定一个默认值</li>\n<li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li>\n<li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(=)</li>\n<li>注解类可以没有成员，没有成员的注解称为标识注解</li>\n<li>需要元注解来描述说明<ul>\n<li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li>\n<li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li>\n<li>@Inherited：允许子类继承</li>\n<li>@Document：当前注解是否能被文档(javadoc)所记录</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Description&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">desc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">author</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 18</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-使用自定义注解：\"><a href=\"#7-3-使用自定义注解：\" class=\"headerlink\" title=\"7.3 使用自定义注解：\"></a>7.3 使用自定义注解：</h4><ul>\n<li>@&lt;注解名&gt;(&lt;成员名1&gt;=&lt;成员值1&gt;,&lt;成员名2&gt;=&lt;成员值2&gt;,…)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(desc=<span class=\"string\">\"I am eyeColor\"</span>, author=<span class=\"string\">\"Chao\"</span>, age=<span class=\"number\">18</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">eyeColor</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"red\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Description</span>(<span class=\"string\">\"I am class annotation\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"meta\">@Description</span>(<span class=\"string\">\"I am method annotation\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">name</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">age</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sing</span><span class=\"params\">()</span></span>&#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-解析注解\"><a href=\"#7-4-解析注解\" class=\"headerlink\" title=\"7.4 解析注解\"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p>\n<ol>\n<li>使用类加载器加载类<ul>\n<li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li>\n</ul>\n</li>\n<li>找到类上面的注解<ul>\n<li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li>\n</ul>\n</li>\n<li>拿到注解实例，需要强制类型转换。<ul>\n<li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li>\n</ul>\n</li>\n<li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseAnn</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;<span class=\"comment\">//1. 使用类加载器加载类</span></span><br><span class=\"line\">      Class c=Class.forName（<span class=\"string\">\"com.ann.test.Child\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//2. 找到类上面的注解</span></span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> isExist = c.isAnnotationPresent(Description.class);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(isExist)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//3. 拿到注解实例</span></span><br><span class=\"line\">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">        System.out.println(d.value());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//4.找到方法上的注解</span></span><br><span class=\"line\">      Method[] ms = c.getMethods();</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> isMExist = m.isAnnotationPresent(Description.class);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isMExist)&#123;</span><br><span class=\"line\">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class=\"line\">          System.out.println(md.value());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种解析方法上的注解:<ul>\n<li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Method m:ms)&#123;</span><br><span class=\"line\">  Annotation [] as=m.getAnnotations();</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(Annotation a:as)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a <span class=\"keyword\">instanceof</span> Description)&#123;</span><br><span class=\"line\">      Description md = (Description)a;</span><br><span class=\"line\">      System.out.println(md.value());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p>\n</blockquote>"},{"title":"九、JavaSE网络编程","date":"2019-07-12T03:59:46.000Z","_content":"\n\n网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\njava.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n<!-- more -->\n\n1. [网络编程常识](#id1)\n2. [基于tcp协议的编程模型](#id2)\n3. [基于udp协议的编程模型](#id3)\n\n\n<span id=\"id1\"><span>\n### 1. 网络编程常识\n#### 1.1 七层网络模型\n为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：\n<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n- 当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；\n- 当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；\n\n#### 1.2 IP地址 \n- IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。\n- 日常生活中采用**点分十进制**表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1\n\n#### 1.3 端口号\n- 根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。\n- 网络编程需要提供：IP地址 和 端口号\n- 端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。\n\n#### 1.4 tcp协议与udp协议\n- TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。\n- UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。\n- tcp协议与udp协议比较：\n\n|tcp协议                         | udp协议|\n|--------|-------|\n|传输控制协议，面向连接           |用户数据报协议，非面向连接|\n|通信过程全程保持连接             |通信过程不需要全程连接|\n|保证了数据传输的可靠性和有序性    |不保证数据传输的可靠性和有序性|\n|全双工的字节流的通信方式         |全双工的数据报的通信方式|\n|服务器的资源消耗多，压力大，效率低|服务器资源消耗少，压力小，效率高|\n\n\n<span id=\"id2\"><span>\n### 2. 基于tcp协议的编程模型\n#### 2.1 编程模型\n```\n服务器端                         客户端\n\n创建监听服务\n等待连接    <----建立连接------  连接服务器           \n进行通讯    <----进行通讯----->  进行通讯\n关闭连接                        关闭连接\n\n```\n- 服务器：\n    1. 创建ServerSocket类型的对象并提供端口号；\n    2. 等待客户端的连接请求，调用accept方法；\n    3. 使用输入输出流进行通信；\n    4. 关闭Socket；\n- 客户端：\n    1. 创建Socket类型的对象并提供服务器的通信地址和端口号；\n    2. 使用输入输出流进行通信；\n    3. 关闭Socket；\n\n#### 2.2 ServerSocket类和Socket类\n- java.net.ServerSocket类主要用于描述服务器套接字信息。\n\n|常用方法||\n|----|----|\n|ServerSocket(int port)|根据参数指定的端口号来构造对象|\n|Socket accept()|监听并接收到此套接字的连接请求|\n|void close()|用于关闭套接字|\n\n- java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。\n\n|常用方法||\n|----|----|\n|Socket(String host, int port)|根据指定主机名和端口号来构造对象|\n|InputStream getInputStream()|用于获取当前套接字的输入流|\n|OutputStream getOutputStream()|用于获取当前套接字的输出流|\n|void close()|用于关闭套接字|\n\n\n\n<span id=\"id3\"><span>\n### 3.客户端与服务端通信演示：\n\n``` java\n//服务端线程\npublic class ServerThread extends Thread {\n  private Socket s;\n  public ServerThread(Socket s) {\n    this.s = s;\n  }\n  @Override\n  public void run() {\n    try {\n      // 3.使用输入输出流进行通信\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      while(true) {\n        // 实现服务器接收到字符串内容后打印出来\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        //System.out.println(\"服务器接收到的数据是：\" + str);\n        // 当服务器接收到\"bye\"后，则聊天结束\n        if(\"bye\".equalsIgnoreCase(str)) {\n          System.out.println(\"客户端\" + s.getInetAddress() + \"已下线！\");\n          break;\n        }\n        System.out.println(\"客户端\" + s.getInetAddress() \n          + \"发来的消息是：\" + str);  \n        // 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"\n        ps.println(\"I received!\");\n        //System.out.println(\"服务器发送数据成功！\");\n      } \n      // 4.关闭Socket\n      ps.close();\n      br.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//服务端测试\npublic class ServerStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建ServerSocket类型的对象并提供端口号\n      ServerSocket ss = new ServerSocket(8888);\n      // 2.等待客户端的连接请求，调用accept方法\n      while(true) {\n        System.out.println(\"等待客户端的连接请求...\");\n        // 当没有客户端连接时，阻塞在accept方法的调用这里\n        Socket s = ss.accept();\n        // 获取连接成功的客户端通信地址\n        System.out.println(\"客户端\" + s.getInetAddress() + \"连接成功！\");\n        // 当有客户端连接成功后，则启动一个新的线程为之服务\n        new ServerThread(s).start();\n      }\n      //ss.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//客户端测试\npublic class ClientStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建Socket类型的对象并提供服务器的通信地址和端口号\n      Socket s = new Socket(\"XDL-20170621QCO\", 8888);\n      System.out.println(\"连接服务器成功！\");\n      // 2.使用输入输出流进行通信\n      Scanner sc = new Scanner(System.in);\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      while(true) {\n        // 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞\n        //Thread.sleep(10000);\n        // 练习：实现客户端向服务器发送的内容由用户从键盘输入\n        System.out.println(\"请输入要发送的内容：\");\n        //String msg = sc.next(); // 读取字符串内容时，遇到空格停止\n        String msg = sc.nextLine();\n        // 实现客户端向服务器发送字符串内容\"hello\"\n        //ps.println(\"hello\");\n        ps.println(msg);\n        System.out.println(\"客户端发送数据成功！\");\n        // 判断客户端发送的内容是否为\"bye\"，若是则聊天结束\n        if(\"bye\".equalsIgnoreCase(msg)) {\n          System.out.println(\"聊天结束！\");\n          break;\n        }\n        // 实现服务器回发消息的接收\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        System.out.println(\"客户端接收到的数据是：\" + str);\n      }\n      // 3.关闭Socket\n      br.close();\n      sc.close();\n      ps.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 基于udp协议的编程模型\n#### 4.1 编程模型\n- 主机A(接收方):\n    1. 创建DatagramSocket类型的对象，并提供端口号；\n    2. 创建DatagramPacket类型的对象，用于接收发来的数据；\n    3. 从Socket中接收数据，调用**receive()**方法；\n    4. 关闭Socket并释放有关的资源；\n- 主机B(发送方)\n    1. 创建DatagramSocket类型的对象；\n    2. 创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；\n    3. 通过Socket发送数据，调用**send()**方法；\n    4. 关闭Socket并释放有关的资源；\n\n#### 4.2 DatagramSocket类\n- java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);\n\n|常用方法||\n|----|----|\n|DatagramSocket()              |无参的方式构造对象。|\n|DatagramSocket(int port)      |根据参数指定的端口号来构造对象。|\n|void receive(DatagramPacket p)|用于接收数据并存放到参数指定的变量中。|\n|void send(DatagramPacket p)   |用于将参数指定的数据发送出去。|\n|void close()                  | |\n\n\n#### 4.3 DatagramPacket类\n- java.net.DatagramPacket类用于描述数据报信息(信件)；\n\n|常用方法||\n|----|----|\n|DatagramPacket(byte[] buf, int length) |用于接收数据包并记录到参数变量中； |\n|DatagramPacket(byte[] buf, int length, InetAddress address, int port) |用于将参数指定的数据发送到参数指定的位置|\n|InetAddress getAddress()               |用于获取发送方或接收方的通信地址信息。|\n|int getPort()                          |用于获取发送方或接收方的端口信息。|\n|int getLength()                        |用于获取发送或接收数据的长度。|\n\n#### 4.4 InetAddress类\n- java.net.InetAddress类用于描述互联网协议地址。\n\n|常用方法||\n|----|----|\n|static InetAddress getLocalHost()         |用于获取本地主机的通信地址信息。|\n|static InetAddress getByName(String host) |根据参数指定的主机名来获取通信地址。|\n|String getHostName()                      |用于获取通信地址中的主机名信息。|\n|String getHostAddress()                   |用于获取通信地址中的IP地址信息。|\n\n","source":"_posts/09_JavaSE网络编程.md","raw":"---\ntitle: 九、JavaSE网络编程\ndate: 2019-07-12 11:59:46\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\njava.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n<!-- more -->\n\n1. [网络编程常识](#id1)\n2. [基于tcp协议的编程模型](#id2)\n3. [基于udp协议的编程模型](#id3)\n\n\n<span id=\"id1\"><span>\n### 1. 网络编程常识\n#### 1.1 七层网络模型\n为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：\n<br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层\n- 当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；\n- 当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；\n\n#### 1.2 IP地址 \n- IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。\n- 日常生活中采用**点分十进制**表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1\n\n#### 1.3 端口号\n- 根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。\n- 网络编程需要提供：IP地址 和 端口号\n- 端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。\n\n#### 1.4 tcp协议与udp协议\n- TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。\n- UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。\n- tcp协议与udp协议比较：\n\n|tcp协议                         | udp协议|\n|--------|-------|\n|传输控制协议，面向连接           |用户数据报协议，非面向连接|\n|通信过程全程保持连接             |通信过程不需要全程连接|\n|保证了数据传输的可靠性和有序性    |不保证数据传输的可靠性和有序性|\n|全双工的字节流的通信方式         |全双工的数据报的通信方式|\n|服务器的资源消耗多，压力大，效率低|服务器资源消耗少，压力小，效率高|\n\n\n<span id=\"id2\"><span>\n### 2. 基于tcp协议的编程模型\n#### 2.1 编程模型\n```\n服务器端                         客户端\n\n创建监听服务\n等待连接    <----建立连接------  连接服务器           \n进行通讯    <----进行通讯----->  进行通讯\n关闭连接                        关闭连接\n\n```\n- 服务器：\n    1. 创建ServerSocket类型的对象并提供端口号；\n    2. 等待客户端的连接请求，调用accept方法；\n    3. 使用输入输出流进行通信；\n    4. 关闭Socket；\n- 客户端：\n    1. 创建Socket类型的对象并提供服务器的通信地址和端口号；\n    2. 使用输入输出流进行通信；\n    3. 关闭Socket；\n\n#### 2.2 ServerSocket类和Socket类\n- java.net.ServerSocket类主要用于描述服务器套接字信息。\n\n|常用方法||\n|----|----|\n|ServerSocket(int port)|根据参数指定的端口号来构造对象|\n|Socket accept()|监听并接收到此套接字的连接请求|\n|void close()|用于关闭套接字|\n\n- java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。\n\n|常用方法||\n|----|----|\n|Socket(String host, int port)|根据指定主机名和端口号来构造对象|\n|InputStream getInputStream()|用于获取当前套接字的输入流|\n|OutputStream getOutputStream()|用于获取当前套接字的输出流|\n|void close()|用于关闭套接字|\n\n\n\n<span id=\"id3\"><span>\n### 3.客户端与服务端通信演示：\n\n``` java\n//服务端线程\npublic class ServerThread extends Thread {\n  private Socket s;\n  public ServerThread(Socket s) {\n    this.s = s;\n  }\n  @Override\n  public void run() {\n    try {\n      // 3.使用输入输出流进行通信\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      while(true) {\n        // 实现服务器接收到字符串内容后打印出来\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        //System.out.println(\"服务器接收到的数据是：\" + str);\n        // 当服务器接收到\"bye\"后，则聊天结束\n        if(\"bye\".equalsIgnoreCase(str)) {\n          System.out.println(\"客户端\" + s.getInetAddress() + \"已下线！\");\n          break;\n        }\n        System.out.println(\"客户端\" + s.getInetAddress() \n          + \"发来的消息是：\" + str);  \n        // 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"\n        ps.println(\"I received!\");\n        //System.out.println(\"服务器发送数据成功！\");\n      } \n      // 4.关闭Socket\n      ps.close();\n      br.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//服务端测试\npublic class ServerStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建ServerSocket类型的对象并提供端口号\n      ServerSocket ss = new ServerSocket(8888);\n      // 2.等待客户端的连接请求，调用accept方法\n      while(true) {\n        System.out.println(\"等待客户端的连接请求...\");\n        // 当没有客户端连接时，阻塞在accept方法的调用这里\n        Socket s = ss.accept();\n        // 获取连接成功的客户端通信地址\n        System.out.println(\"客户端\" + s.getInetAddress() + \"连接成功！\");\n        // 当有客户端连接成功后，则启动一个新的线程为之服务\n        new ServerThread(s).start();\n      }\n      //ss.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n//客户端测试\npublic class ClientStringTest {\n  public static void main(String[] args) {\n    try {\n      // 1.创建Socket类型的对象并提供服务器的通信地址和端口号\n      Socket s = new Socket(\"XDL-20170621QCO\", 8888);\n      System.out.println(\"连接服务器成功！\");\n      // 2.使用输入输出流进行通信\n      Scanner sc = new Scanner(System.in);\n      PrintStream ps = new PrintStream(s.getOutputStream());\n      BufferedReader br = new BufferedReader(\n          new InputStreamReader(s.getInputStream()));\n      while(true) {\n        // 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞\n        //Thread.sleep(10000);\n        // 练习：实现客户端向服务器发送的内容由用户从键盘输入\n        System.out.println(\"请输入要发送的内容：\");\n        //String msg = sc.next(); // 读取字符串内容时，遇到空格停止\n        String msg = sc.nextLine();\n        // 实现客户端向服务器发送字符串内容\"hello\"\n        //ps.println(\"hello\");\n        ps.println(msg);\n        System.out.println(\"客户端发送数据成功！\");\n        // 判断客户端发送的内容是否为\"bye\"，若是则聊天结束\n        if(\"bye\".equalsIgnoreCase(msg)) {\n          System.out.println(\"聊天结束！\");\n          break;\n        }\n        // 实现服务器回发消息的接收\n        // 当客户端没有发送数据时，服务器会在这里阻塞\n        String str = br.readLine();\n        System.out.println(\"客户端接收到的数据是：\" + str);\n      }\n      // 3.关闭Socket\n      br.close();\n      sc.close();\n      ps.close();\n      s.close();\n    } catch(Exception e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n\n\n<span id=\"id4\"><span>\n### 4. 基于udp协议的编程模型\n#### 4.1 编程模型\n- 主机A(接收方):\n    1. 创建DatagramSocket类型的对象，并提供端口号；\n    2. 创建DatagramPacket类型的对象，用于接收发来的数据；\n    3. 从Socket中接收数据，调用**receive()**方法；\n    4. 关闭Socket并释放有关的资源；\n- 主机B(发送方)\n    1. 创建DatagramSocket类型的对象；\n    2. 创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；\n    3. 通过Socket发送数据，调用**send()**方法；\n    4. 关闭Socket并释放有关的资源；\n\n#### 4.2 DatagramSocket类\n- java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);\n\n|常用方法||\n|----|----|\n|DatagramSocket()              |无参的方式构造对象。|\n|DatagramSocket(int port)      |根据参数指定的端口号来构造对象。|\n|void receive(DatagramPacket p)|用于接收数据并存放到参数指定的变量中。|\n|void send(DatagramPacket p)   |用于将参数指定的数据发送出去。|\n|void close()                  | |\n\n\n#### 4.3 DatagramPacket类\n- java.net.DatagramPacket类用于描述数据报信息(信件)；\n\n|常用方法||\n|----|----|\n|DatagramPacket(byte[] buf, int length) |用于接收数据包并记录到参数变量中； |\n|DatagramPacket(byte[] buf, int length, InetAddress address, int port) |用于将参数指定的数据发送到参数指定的位置|\n|InetAddress getAddress()               |用于获取发送方或接收方的通信地址信息。|\n|int getPort()                          |用于获取发送方或接收方的端口信息。|\n|int getLength()                        |用于获取发送或接收数据的长度。|\n\n#### 4.4 InetAddress类\n- java.net.InetAddress类用于描述互联网协议地址。\n\n|常用方法||\n|----|----|\n|static InetAddress getLocalHost()         |用于获取本地主机的通信地址信息。|\n|static InetAddress getByName(String host) |根据参数指定的主机名来获取通信地址。|\n|String getHostName()                      |用于获取通信地址中的主机名信息。|\n|String getHostAddress()                   |用于获取通信地址中的IP地址信息。|\n\n","slug":"09_JavaSE网络编程","published":1,"updated":"2019-07-20T15:01:52.870Z","_id":"cjyblnrsl001cxwt30sj3188v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">网络编程常识</a></li>\n<li><a href=\"#id2\">基于tcp协议的编程模型</a></li>\n<li><a href=\"#id3\">基于udp协议的编程模型</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-网络编程常识\"><a href=\"#1-网络编程常识\" class=\"headerlink\" title=\"1. 网络编程常识\"></a>1. 网络编程常识</h3><h4 id=\"1-1-七层网络模型\"><a href=\"#1-1-七层网络模型\" class=\"headerlink\" title=\"1.1 七层网络模型\"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>\n<ul>\n<li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li>\n<li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li>\n</ul>\n<h4 id=\"1-2-IP地址\"><a href=\"#1-2-IP地址\" class=\"headerlink\" title=\"1.2 IP地址\"></a>1.2 IP地址</h4><ul>\n<li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li>\n<li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li>\n</ul>\n<h4 id=\"1-3-端口号\"><a href=\"#1-3-端口号\" class=\"headerlink\" title=\"1.3 端口号\"></a>1.3 端口号</h4><ul>\n<li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li>\n<li>网络编程需要提供：IP地址 和 端口号</li>\n<li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li>\n</ul>\n<h4 id=\"1-4-tcp协议与udp协议\"><a href=\"#1-4-tcp协议与udp协议\" class=\"headerlink\" title=\"1.4 tcp协议与udp协议\"></a>1.4 tcp协议与udp协议</h4><ul>\n<li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li>\n<li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>\n<li>tcp协议与udp协议比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>tcp协议</th>\n<th>udp协议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输控制协议，面向连接</td>\n<td>用户数据报协议，非面向连接</td>\n</tr>\n<tr>\n<td>通信过程全程保持连接</td>\n<td>通信过程不需要全程连接</td>\n</tr>\n<tr>\n<td>保证了数据传输的可靠性和有序性</td>\n<td>不保证数据传输的可靠性和有序性</td>\n</tr>\n<tr>\n<td>全双工的字节流的通信方式</td>\n<td>全双工的数据报的通信方式</td>\n</tr>\n<tr>\n<td>服务器的资源消耗多，压力大，效率低</td>\n<td>服务器资源消耗少，压力小，效率高</td>\n</tr>\n</tbody></table>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-基于tcp协议的编程模型\"><a href=\"#2-基于tcp协议的编程模型\" class=\"headerlink\" title=\"2. 基于tcp协议的编程模型\"></a>2. 基于tcp协议的编程模型</h3><h4 id=\"2-1-编程模型\"><a href=\"#2-1-编程模型\" class=\"headerlink\" title=\"2.1 编程模型\"></a>2.1 编程模型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器端                         客户端</span><br><span class=\"line\"></span><br><span class=\"line\">创建监听服务</span><br><span class=\"line\">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class=\"line\">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class=\"line\">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>服务器：<ol>\n<li>创建ServerSocket类型的对象并提供端口号；</li>\n<li>等待客户端的连接请求，调用accept方法；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n<li>客户端：<ol>\n<li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-2-ServerSocket类和Socket类\"><a href=\"#2-2-ServerSocket类和Socket类\" class=\"headerlink\" title=\"2.2 ServerSocket类和Socket类\"></a>2.2 ServerSocket类和Socket类</h4><ul>\n<li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ServerSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象</td>\n</tr>\n<tr>\n<td>Socket accept()</td>\n<td>监听并接收到此套接字的连接请求</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<ul>\n<li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket(String host, int port)</td>\n<td>根据指定主机名和端口号来构造对象</td>\n</tr>\n<tr>\n<td>InputStream getInputStream()</td>\n<td>用于获取当前套接字的输入流</td>\n</tr>\n<tr>\n<td>OutputStream getOutputStream()</td>\n<td>用于获取当前套接字的输出流</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-客户端与服务端通信演示：\"><a href=\"#3-客户端与服务端通信演示：\" class=\"headerlink\" title=\"3.客户端与服务端通信演示：\"></a>3.客户端与服务端通信演示：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Socket s;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3.使用输入输出流进行通信</span></span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器接收到的数据是：\" + str);</span></span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到\"bye\"后，则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"已下线！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() </span><br><span class=\"line\">          + <span class=\"string\">\"发来的消息是：\"</span> + str);  </span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"</span></span><br><span class=\"line\">        ps.println(<span class=\"string\">\"I received!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器发送数据成功！\");</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"comment\">// 4.关闭Socket</span></span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//服务端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class=\"line\">      ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"等待客户端的连接请求...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class=\"line\">        Socket s = ss.accept();</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接成功的客户端通信地址</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"连接成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ServerThread(s).start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//ss.close();</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//客户端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class=\"line\">      Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"XDL-20170621QCO\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"连接服务器成功！\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.使用输入输出流进行通信</span></span><br><span class=\"line\">      Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class=\"line\">        <span class=\"comment\">//Thread.sleep(10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入要发送的内容：\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class=\"line\">        String msg = sc.nextLine();</span><br><span class=\"line\">        <span class=\"comment\">// 实现客户端向服务器发送字符串内容\"hello\"</span></span><br><span class=\"line\">        <span class=\"comment\">//ps.println(\"hello\");</span></span><br><span class=\"line\">        ps.println(msg);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送数据成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 判断客户端发送的内容是否为\"bye\"，若是则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"聊天结束！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器回发消息的接收</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端接收到的数据是：\"</span> + str);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 3.关闭Socket</span></span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      sc.close();</span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-基于udp协议的编程模型\"><a href=\"#4-基于udp协议的编程模型\" class=\"headerlink\" title=\"4. 基于udp协议的编程模型\"></a>4. 基于udp协议的编程模型</h3><h4 id=\"4-1-编程模型\"><a href=\"#4-1-编程模型\" class=\"headerlink\" title=\"4.1 编程模型\"></a>4.1 编程模型</h4><ul>\n<li>主机A(接收方):<ol>\n<li>创建DatagramSocket类型的对象，并提供端口号；</li>\n<li>创建DatagramPacket类型的对象，用于接收发来的数据；</li>\n<li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n<li>主机B(发送方)<ol>\n<li>创建DatagramSocket类型的对象；</li>\n<li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li>\n<li>通过Socket发送数据，调用<strong>send()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-2-DatagramSocket类\"><a href=\"#4-2-DatagramSocket类\" class=\"headerlink\" title=\"4.2 DatagramSocket类\"></a>4.2 DatagramSocket类</h4><ul>\n<li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramSocket()</td>\n<td>无参的方式构造对象。</td>\n</tr>\n<tr>\n<td>DatagramSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象。</td>\n</tr>\n<tr>\n<td>void receive(DatagramPacket p)</td>\n<td>用于接收数据并存放到参数指定的变量中。</td>\n</tr>\n<tr>\n<td>void send(DatagramPacket p)</td>\n<td>用于将参数指定的数据发送出去。</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"4-3-DatagramPacket类\"><a href=\"#4-3-DatagramPacket类\" class=\"headerlink\" title=\"4.3 DatagramPacket类\"></a>4.3 DatagramPacket类</h4><ul>\n<li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramPacket(byte[] buf, int length)</td>\n<td>用于接收数据包并记录到参数变量中；</td>\n</tr>\n<tr>\n<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>\n<td>用于将参数指定的数据发送到参数指定的位置</td>\n</tr>\n<tr>\n<td>InetAddress getAddress()</td>\n<td>用于获取发送方或接收方的通信地址信息。</td>\n</tr>\n<tr>\n<td>int getPort()</td>\n<td>用于获取发送方或接收方的端口信息。</td>\n</tr>\n<tr>\n<td>int getLength()</td>\n<td>用于获取发送或接收数据的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-4-InetAddress类\"><a href=\"#4-4-InetAddress类\" class=\"headerlink\" title=\"4.4 InetAddress类\"></a>4.4 InetAddress类</h4><ul>\n<li>java.net.InetAddress类用于描述互联网协议地址。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static InetAddress getLocalHost()</td>\n<td>用于获取本地主机的通信地址信息。</td>\n</tr>\n<tr>\n<td>static InetAddress getByName(String host)</td>\n<td>根据参数指定的主机名来获取通信地址。</td>\n</tr>\n<tr>\n<td>String getHostName()</td>\n<td>用于获取通信地址中的主机名信息。</td>\n</tr>\n<tr>\n<td>String getHostAddress()</td>\n<td>用于获取通信地址中的IP地址信息。</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>","more":"<ol>\n<li><a href=\"#id1\">网络编程常识</a></li>\n<li><a href=\"#id2\">基于tcp协议的编程模型</a></li>\n<li><a href=\"#id3\">基于udp协议的编程模型</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-网络编程常识\"><a href=\"#1-网络编程常识\" class=\"headerlink\" title=\"1. 网络编程常识\"></a>1. 网络编程常识</h3><h4 id=\"1-1-七层网络模型\"><a href=\"#1-1-七层网络模型\" class=\"headerlink\" title=\"1.1 七层网络模型\"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>\n<ul>\n<li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li>\n<li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li>\n</ul>\n<h4 id=\"1-2-IP地址\"><a href=\"#1-2-IP地址\" class=\"headerlink\" title=\"1.2 IP地址\"></a>1.2 IP地址</h4><ul>\n<li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li>\n<li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li>\n</ul>\n<h4 id=\"1-3-端口号\"><a href=\"#1-3-端口号\" class=\"headerlink\" title=\"1.3 端口号\"></a>1.3 端口号</h4><ul>\n<li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li>\n<li>网络编程需要提供：IP地址 和 端口号</li>\n<li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li>\n</ul>\n<h4 id=\"1-4-tcp协议与udp协议\"><a href=\"#1-4-tcp协议与udp协议\" class=\"headerlink\" title=\"1.4 tcp协议与udp协议\"></a>1.4 tcp协议与udp协议</h4><ul>\n<li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li>\n<li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li>\n<li>tcp协议与udp协议比较：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>tcp协议</th>\n<th>udp协议</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>传输控制协议，面向连接</td>\n<td>用户数据报协议，非面向连接</td>\n</tr>\n<tr>\n<td>通信过程全程保持连接</td>\n<td>通信过程不需要全程连接</td>\n</tr>\n<tr>\n<td>保证了数据传输的可靠性和有序性</td>\n<td>不保证数据传输的可靠性和有序性</td>\n</tr>\n<tr>\n<td>全双工的字节流的通信方式</td>\n<td>全双工的数据报的通信方式</td>\n</tr>\n<tr>\n<td>服务器的资源消耗多，压力大，效率低</td>\n<td>服务器资源消耗少，压力小，效率高</td>\n</tr>\n</tbody></table>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-基于tcp协议的编程模型\"><a href=\"#2-基于tcp协议的编程模型\" class=\"headerlink\" title=\"2. 基于tcp协议的编程模型\"></a>2. 基于tcp协议的编程模型</h3><h4 id=\"2-1-编程模型\"><a href=\"#2-1-编程模型\" class=\"headerlink\" title=\"2.1 编程模型\"></a>2.1 编程模型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">服务器端                         客户端</span><br><span class=\"line\"></span><br><span class=\"line\">创建监听服务</span><br><span class=\"line\">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class=\"line\">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class=\"line\">关闭连接                        关闭连接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>服务器：<ol>\n<li>创建ServerSocket类型的对象并提供端口号；</li>\n<li>等待客户端的连接请求，调用accept方法；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n<li>客户端：<ol>\n<li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li>\n<li>使用输入输出流进行通信；</li>\n<li>关闭Socket；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-2-ServerSocket类和Socket类\"><a href=\"#2-2-ServerSocket类和Socket类\" class=\"headerlink\" title=\"2.2 ServerSocket类和Socket类\"></a>2.2 ServerSocket类和Socket类</h4><ul>\n<li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ServerSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象</td>\n</tr>\n<tr>\n<td>Socket accept()</td>\n<td>监听并接收到此套接字的连接请求</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<ul>\n<li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Socket(String host, int port)</td>\n<td>根据指定主机名和端口号来构造对象</td>\n</tr>\n<tr>\n<td>InputStream getInputStream()</td>\n<td>用于获取当前套接字的输入流</td>\n</tr>\n<tr>\n<td>OutputStream getOutputStream()</td>\n<td>用于获取当前套接字的输出流</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td>用于关闭套接字</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-客户端与服务端通信演示：\"><a href=\"#3-客户端与服务端通信演示：\" class=\"headerlink\" title=\"3.客户端与服务端通信演示：\"></a>3.客户端与服务端通信演示：</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务端线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Socket s;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ServerThread</span><span class=\"params\">(Socket s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.s = s;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 3.使用输入输出流进行通信</span></span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器接收到的数据是：\" + str);</span></span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到\"bye\"后，则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(str)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"已下线！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() </span><br><span class=\"line\">          + <span class=\"string\">\"发来的消息是：\"</span> + str);  </span><br><span class=\"line\">        <span class=\"comment\">// 当服务器接收到客户端发来的消息后，向客户端回发消息\"I received!\"</span></span><br><span class=\"line\">        ps.println(<span class=\"string\">\"I received!\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//System.out.println(\"服务器发送数据成功！\");</span></span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">      <span class=\"comment\">// 4.关闭Socket</span></span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//服务端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class=\"line\">      ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8888</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"等待客户端的连接请求...\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class=\"line\">        Socket s = ss.accept();</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接成功的客户端通信地址</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端\"</span> + s.getInetAddress() + <span class=\"string\">\"连接成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ServerThread(s).start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//ss.close();</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//客户端测试</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientStringTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class=\"line\">      Socket s = <span class=\"keyword\">new</span> Socket(<span class=\"string\">\"XDL-20170621QCO\"</span>, <span class=\"number\">8888</span>);</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"连接服务器成功！\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 2.使用输入输出流进行通信</span></span><br><span class=\"line\">      Scanner sc = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">      PrintStream ps = <span class=\"keyword\">new</span> PrintStream(s.getOutputStream());</span><br><span class=\"line\">      BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">          <span class=\"keyword\">new</span> InputStreamReader(s.getInputStream()));</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class=\"line\">        <span class=\"comment\">//Thread.sleep(10000);</span></span><br><span class=\"line\">        <span class=\"comment\">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"请输入要发送的内容：\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class=\"line\">        String msg = sc.nextLine();</span><br><span class=\"line\">        <span class=\"comment\">// 实现客户端向服务器发送字符串内容\"hello\"</span></span><br><span class=\"line\">        <span class=\"comment\">//ps.println(\"hello\");</span></span><br><span class=\"line\">        ps.println(msg);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端发送数据成功！\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 判断客户端发送的内容是否为\"bye\"，若是则聊天结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">\"bye\"</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class=\"line\">          System.out.println(<span class=\"string\">\"聊天结束！\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 实现服务器回发消息的接收</span></span><br><span class=\"line\">        <span class=\"comment\">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class=\"line\">        String str = br.readLine();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"客户端接收到的数据是：\"</span> + str);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 3.关闭Socket</span></span><br><span class=\"line\">      br.close();</span><br><span class=\"line\">      sc.close();</span><br><span class=\"line\">      ps.close();</span><br><span class=\"line\">      s.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-基于udp协议的编程模型\"><a href=\"#4-基于udp协议的编程模型\" class=\"headerlink\" title=\"4. 基于udp协议的编程模型\"></a>4. 基于udp协议的编程模型</h3><h4 id=\"4-1-编程模型\"><a href=\"#4-1-编程模型\" class=\"headerlink\" title=\"4.1 编程模型\"></a>4.1 编程模型</h4><ul>\n<li>主机A(接收方):<ol>\n<li>创建DatagramSocket类型的对象，并提供端口号；</li>\n<li>创建DatagramPacket类型的对象，用于接收发来的数据；</li>\n<li>从Socket中接收数据，调用<strong>receive()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n<li>主机B(发送方)<ol>\n<li>创建DatagramSocket类型的对象；</li>\n<li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li>\n<li>通过Socket发送数据，调用<strong>send()</strong>方法；</li>\n<li>关闭Socket并释放有关的资源；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"4-2-DatagramSocket类\"><a href=\"#4-2-DatagramSocket类\" class=\"headerlink\" title=\"4.2 DatagramSocket类\"></a>4.2 DatagramSocket类</h4><ul>\n<li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramSocket()</td>\n<td>无参的方式构造对象。</td>\n</tr>\n<tr>\n<td>DatagramSocket(int port)</td>\n<td>根据参数指定的端口号来构造对象。</td>\n</tr>\n<tr>\n<td>void receive(DatagramPacket p)</td>\n<td>用于接收数据并存放到参数指定的变量中。</td>\n</tr>\n<tr>\n<td>void send(DatagramPacket p)</td>\n<td>用于将参数指定的数据发送出去。</td>\n</tr>\n<tr>\n<td>void close()</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"4-3-DatagramPacket类\"><a href=\"#4-3-DatagramPacket类\" class=\"headerlink\" title=\"4.3 DatagramPacket类\"></a>4.3 DatagramPacket类</h4><ul>\n<li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DatagramPacket(byte[] buf, int length)</td>\n<td>用于接收数据包并记录到参数变量中；</td>\n</tr>\n<tr>\n<td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td>\n<td>用于将参数指定的数据发送到参数指定的位置</td>\n</tr>\n<tr>\n<td>InetAddress getAddress()</td>\n<td>用于获取发送方或接收方的通信地址信息。</td>\n</tr>\n<tr>\n<td>int getPort()</td>\n<td>用于获取发送方或接收方的端口信息。</td>\n</tr>\n<tr>\n<td>int getLength()</td>\n<td>用于获取发送或接收数据的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"4-4-InetAddress类\"><a href=\"#4-4-InetAddress类\" class=\"headerlink\" title=\"4.4 InetAddress类\"></a>4.4 InetAddress类</h4><ul>\n<li>java.net.InetAddress类用于描述互联网协议地址。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>static InetAddress getLocalHost()</td>\n<td>用于获取本地主机的通信地址信息。</td>\n</tr>\n<tr>\n<td>static InetAddress getByName(String host)</td>\n<td>根据参数指定的主机名来获取通信地址。</td>\n</tr>\n<tr>\n<td>String getHostName()</td>\n<td>用于获取通信地址中的主机名信息。</td>\n</tr>\n<tr>\n<td>String getHostAddress()</td>\n<td>用于获取通信地址中的IP地址信息。</td>\n</tr>\n</tbody></table>"},{"title":"十、JavaSE常用设计模式","date":"2019-07-15T00:34:55.000Z","_content":"\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\n<!-- more -->\n\n1. [常用的设计原则](#id1)\n2. [设计模式分类](#id2)\n3. [单例模式](#id3)\n4. [模板模式](#id4)\n5. [工厂模式](#id5)\n6. [适配器模式](#id6)\n\n\n<span id=\"id1\"><span>\n### 1.常用的设计原则\n- **开闭原则**：对扩展开发，对修改方便\n- **里氏代换原则**：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）\n- **依赖倒转原则**：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性\n- **接口隔离原则**：尽量多依赖小接口而不是大接口\n- **迪米特法则**（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。\n- **合成复用原则**：尽量多使用合成/聚合的方式，而不是继承的方式。\n\n\n<span id=\"id2\"><span>\n### 2.设计模式分类\n#### 2.1 基本概念\n- 设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。\n- 设计模式用来解决某些特定场景下的某一类问题-->通用的解决方案。\n- 设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性\n\n#### 2.2 具体分类\n1. **创建型模式**：*用于对象创建的过程*\n  - **单例模式**、**工厂方法模式**、抽象工厂模式、建造者模式(生成器模式)、原型模式\n2. **结构型模式**：*用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构*\n  - 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)\n3. **行为型模式**：*用于解决类或对象之间的交互，更合理的优化类或对象之间的关系*\n  - 责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、**模板模式**、访问者模式、备忘录模式、\n4. JEE 设计模式\n  - 数据访问对象模式 \n\n\n<span id=\"id3\"><span>\n### 3.单例模式（Singleton）\n#### 3.1 实现流程：\n1. 私有的构造方法\n2. 私有的静态的当前类的对象作为属性\n3. 共有的静态方法返回当前对象\n#### 3.1 实现方式：\n1. 饿汉式：立即加载，对象启动时就加载\n2. 懒汉式：延迟加载，对象什么时候用到时才会加载\n3. 生命周期托管：单例对象交给别人处理\n\n\n<span id=\"id4\"><span>\n### 4.模板模式\n在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。\n\n- eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。\n\n``` java\n  // 抽象类\nabstract class Software {\n   abstract void initialize();\n   abstract void start();\n   abstract void end();\n   public final void play(){\n      initialize();\n      start();\n      end();\n   }\n}\n  // 不同子类以不同方法实现抽象类的的方法\nclass Browser extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Browser Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Browser Initialized!.\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Browser Started.\");\n   }\n}\nclass Editor extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Editor Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Editor Initialized!\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Editor Started!\");\n   }\n}\n// 使用\npublic class Main {\n   public static void main(String[] args) {\n      Software s1 = new Browser();\n      s1.play();\n      s1 = new Editor();\n      s1.play();    \n   }\n}\n```\n\n#### 4.1 模式模式优缺点：\n1. 优点\n  - 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。\n2. 缺点\n  - 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。\n3. 适用场景\n  - 在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。\n\n\n<span id=\"id5\"><span>\n### 5. 工厂模式\n1. 简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；\n2. 工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；\n3. 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。\n\n#### 5.1 简单工厂模式的实现：\n``` java\n  // 产品接口\npublic interface Fruit { void whatIm(); }\n  // 具体类\npublic class Apple implements Fruit {\n  @Override\n  public void whatIm() { /*苹果*/}\n}\npublic class Pear implements Fruit {\n    @Override\n    public void whatIm() { /* 梨 */ }\n}\n  // 工厂\npublic class FruitFactory {\n    public Fruit createFruit(String type) {\n        if (type.equals(\"apple\")) {//生产苹果\n            return new Apple();\n        } else if (type.equals(\"pear\")) {//生产梨\n            return new Pear();\n        }\n        return null;\n    }\n}\n  // 使用\nFruitFactory mFactory = new FruitFactory();\nApple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果\nPear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨\n```\n> 简单工厂只适合于产品对象较少，且产品固定的需求\n\n\n#### 5.2 工厂方法模式实现：\n``` java\n  // 工厂接口\npublic interface FruitFactory {\n    Fruit createFruit();//生产水果\n}\n  // 具体工厂\npublic class AppleFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Apple();\n    }\n}\npublic class PearFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Pear();\n    }\n}\n  // 使用\nAppleFactory appleFactory = new AppleFactory();\nPearFactory pearFactory = new PearFactory();\nApple apple = (Apple) appleFactory.createFruit();//获得苹果\nPear pear = (Pear) pearFactory.createFruit();//获得梨\n```\n> 工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂\n\n#### 5.3 抽象工厂模式实现：\n  - 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；\n  - eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：\n\n``` java\n // cpu接口和实现类\npublic interface Cpu {\n    void run();\n    class Cpu650 implements Cpu {\n        @Override\n        public void run() {/* 625 也厉害 */ }\n    }\n    class Cpu825 implements Cpu {\n        @Override\n        public void run() { /* 825 处理更强劲 */ }\n    }\n}\n  // 屏幕接口和实现类\npublic interface Screen {\n    void size();\n    class Screen5 implements Screen {\n        @Override\n        public void size() {/* 5寸 */}\n    }\n    class Screen6 implements Screen {\n        @Override\n        public void size() { /* 6寸 */ }\n    }\n}\n  // 工厂接口\npublic interface PhoneFactory {\n    Cpu getCpu();//使用的cpu\n    Screen getScreen();//使用的屏幕\n}\n  // 具体工厂实现类\npublic class XiaoMiFactory implements PhoneFactory {\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu825();//高性能处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen6();//6寸大屏\n    }\n}\npublic class HongMiFactory implements PhoneFactory {\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu650();//高效处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen5();//小屏手机\n    }\n}\n```\n> 对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；\n\n#### 5.4 三种工厂方式总结：\n1. 对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；\n2. 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；\n\n\n<span id=\"id6\"><span>\n### 6.适配器模式（Adapter）\n- 适配器模式Adapter是结构型模式的一种，分为**类适配器模式**，**对象适配器模式**，**缺省适配器模式**。\n  * 类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；\n  * 对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。\n\n> 适配器模式的缺点\n<br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。\n\n#### 6.1 缺省适配器模式\n- 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。\n- 缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)\n- 适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。\n\n","source":"_posts/10_JavaSE常用设计模式.md","raw":"---\ntitle: 十、JavaSE常用设计模式\ndate: 2019-07-15 08:34:55\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。\n<!-- more -->\n\n1. [常用的设计原则](#id1)\n2. [设计模式分类](#id2)\n3. [单例模式](#id3)\n4. [模板模式](#id4)\n5. [工厂模式](#id5)\n6. [适配器模式](#id6)\n\n\n<span id=\"id1\"><span>\n### 1.常用的设计原则\n- **开闭原则**：对扩展开发，对修改方便\n- **里氏代换原则**：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）\n- **依赖倒转原则**：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性\n- **接口隔离原则**：尽量多依赖小接口而不是大接口\n- **迪米特法则**（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。\n- **合成复用原则**：尽量多使用合成/聚合的方式，而不是继承的方式。\n\n\n<span id=\"id2\"><span>\n### 2.设计模式分类\n#### 2.1 基本概念\n- 设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。\n- 设计模式用来解决某些特定场景下的某一类问题-->通用的解决方案。\n- 设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性\n\n#### 2.2 具体分类\n1. **创建型模式**：*用于对象创建的过程*\n  - **单例模式**、**工厂方法模式**、抽象工厂模式、建造者模式(生成器模式)、原型模式\n2. **结构型模式**：*用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构*\n  - 适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)\n3. **行为型模式**：*用于解决类或对象之间的交互，更合理的优化类或对象之间的关系*\n  - 责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、**模板模式**、访问者模式、备忘录模式、\n4. JEE 设计模式\n  - 数据访问对象模式 \n\n\n<span id=\"id3\"><span>\n### 3.单例模式（Singleton）\n#### 3.1 实现流程：\n1. 私有的构造方法\n2. 私有的静态的当前类的对象作为属性\n3. 共有的静态方法返回当前对象\n#### 3.1 实现方式：\n1. 饿汉式：立即加载，对象启动时就加载\n2. 懒汉式：延迟加载，对象什么时候用到时才会加载\n3. 生命周期托管：单例对象交给别人处理\n\n\n<span id=\"id4\"><span>\n### 4.模板模式\n在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。\n\n- eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。\n\n``` java\n  // 抽象类\nabstract class Software {\n   abstract void initialize();\n   abstract void start();\n   abstract void end();\n   public final void play(){\n      initialize();\n      start();\n      end();\n   }\n}\n  // 不同子类以不同方法实现抽象类的的方法\nclass Browser extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Browser Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Browser Initialized!.\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Browser Started.\");\n   }\n}\nclass Editor extends Software {\n   @Override\n   void end() {\n      System.out.println(\"Editor Finished!\");\n   }\n   @Override\n   void initialize() {\n      System.out.println(\"Editor Initialized!\");\n   }\n   @Override\n   void start() {\n      System.out.println(\"Editor Started!\");\n   }\n}\n// 使用\npublic class Main {\n   public static void main(String[] args) {\n      Software s1 = new Browser();\n      s1.play();\n      s1 = new Editor();\n      s1.play();    \n   }\n}\n```\n\n#### 4.1 模式模式优缺点：\n1. 优点\n  - 模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。\n2. 缺点\n  - 每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。\n3. 适用场景\n  - 在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。\n\n\n<span id=\"id5\"><span>\n### 5. 工厂模式\n1. 简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；\n2. 工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；\n3. 抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。\n\n#### 5.1 简单工厂模式的实现：\n``` java\n  // 产品接口\npublic interface Fruit { void whatIm(); }\n  // 具体类\npublic class Apple implements Fruit {\n  @Override\n  public void whatIm() { /*苹果*/}\n}\npublic class Pear implements Fruit {\n    @Override\n    public void whatIm() { /* 梨 */ }\n}\n  // 工厂\npublic class FruitFactory {\n    public Fruit createFruit(String type) {\n        if (type.equals(\"apple\")) {//生产苹果\n            return new Apple();\n        } else if (type.equals(\"pear\")) {//生产梨\n            return new Pear();\n        }\n        return null;\n    }\n}\n  // 使用\nFruitFactory mFactory = new FruitFactory();\nApple apple = (Apple) mFactory.createFruit(\"apple\");//获得苹果\nPear pear = (Pear) mFactory.createFruit(\"pear\");//获得梨\n```\n> 简单工厂只适合于产品对象较少，且产品固定的需求\n\n\n#### 5.2 工厂方法模式实现：\n``` java\n  // 工厂接口\npublic interface FruitFactory {\n    Fruit createFruit();//生产水果\n}\n  // 具体工厂\npublic class AppleFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Apple();\n    }\n}\npublic class PearFactory implements FruitFactory {\n    @Override\n    public Fruit createFruit() {\n        return new Pear();\n    }\n}\n  // 使用\nAppleFactory appleFactory = new AppleFactory();\nPearFactory pearFactory = new PearFactory();\nApple apple = (Apple) appleFactory.createFruit();//获得苹果\nPear pear = (Pear) pearFactory.createFruit();//获得梨\n```\n> 工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂\n\n#### 5.3 抽象工厂模式实现：\n  - 抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；\n  - eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：\n\n``` java\n // cpu接口和实现类\npublic interface Cpu {\n    void run();\n    class Cpu650 implements Cpu {\n        @Override\n        public void run() {/* 625 也厉害 */ }\n    }\n    class Cpu825 implements Cpu {\n        @Override\n        public void run() { /* 825 处理更强劲 */ }\n    }\n}\n  // 屏幕接口和实现类\npublic interface Screen {\n    void size();\n    class Screen5 implements Screen {\n        @Override\n        public void size() {/* 5寸 */}\n    }\n    class Screen6 implements Screen {\n        @Override\n        public void size() { /* 6寸 */ }\n    }\n}\n  // 工厂接口\npublic interface PhoneFactory {\n    Cpu getCpu();//使用的cpu\n    Screen getScreen();//使用的屏幕\n}\n  // 具体工厂实现类\npublic class XiaoMiFactory implements PhoneFactory {\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu825();//高性能处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen6();//6寸大屏\n    }\n}\npublic class HongMiFactory implements PhoneFactory {\n\n    @Override\n    public Cpu getCpu() {\n        return new Cpu.Cpu650();//高效处理器\n    }\n    @Override\n    public Screen getScreen() {\n        return new Screen.Screen5();//小屏手机\n    }\n}\n```\n> 对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；\n\n#### 5.4 三种工厂方式总结：\n1. 对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；\n2. 抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；\n\n\n<span id=\"id6\"><span>\n### 6.适配器模式（Adapter）\n- 适配器模式Adapter是结构型模式的一种，分为**类适配器模式**，**对象适配器模式**，**缺省适配器模式**。\n  * 类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；\n  * 对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。\n\n> 适配器模式的缺点\n<br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。\n\n#### 6.1 缺省适配器模式\n- 缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。\n- 缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)\n- 适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。\n\n","slug":"10_JavaSE常用设计模式","published":1,"updated":"2019-07-20T15:03:36.395Z","_id":"cjyblnrso001exwt3hfmb6xp6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">常用的设计原则</a></li>\n<li><a href=\"#id2\">设计模式分类</a></li>\n<li><a href=\"#id3\">单例模式</a></li>\n<li><a href=\"#id4\">模板模式</a></li>\n<li><a href=\"#id5\">工厂模式</a></li>\n<li><a href=\"#id6\">适配器模式</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-常用的设计原则\"><a href=\"#1-常用的设计原则\" class=\"headerlink\" title=\"1.常用的设计原则\"></a>1.常用的设计原则</h3><ul>\n<li><strong>开闭原则</strong>：对扩展开发，对修改方便</li>\n<li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li>\n<li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>\n<li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li>\n<li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li>\n<li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-设计模式分类\"><a href=\"#2-设计模式分类\" class=\"headerlink\" title=\"2.设计模式分类\"></a>2.设计模式分类</h3><h4 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h4><ul>\n<li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li>\n<li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li>\n<li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li>\n</ul>\n<h4 id=\"2-2-具体分类\"><a href=\"#2-2-具体分类\" class=\"headerlink\" title=\"2.2 具体分类\"></a>2.2 具体分类</h4><ol>\n<li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul>\n<li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li>\n</ul>\n</li>\n<li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul>\n<li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li>\n</ul>\n</li>\n<li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul>\n<li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li>\n</ul>\n</li>\n<li>JEE 设计模式<ul>\n<li>数据访问对象模式 </li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-单例模式（Singleton）\"><a href=\"#3-单例模式（Singleton）\" class=\"headerlink\" title=\"3.单例模式（Singleton）\"></a>3.单例模式（Singleton）</h3><h4 id=\"3-1-实现流程：\"><a href=\"#3-1-实现流程：\" class=\"headerlink\" title=\"3.1 实现流程：\"></a>3.1 实现流程：</h4><ol>\n<li>私有的构造方法</li>\n<li>私有的静态的当前类的对象作为属性</li>\n<li>共有的静态方法返回当前对象<h4 id=\"3-1-实现方式：\"><a href=\"#3-1-实现方式：\" class=\"headerlink\" title=\"3.1 实现方式：\"></a>3.1 实现方式：</h4></li>\n<li>饿汉式：立即加载，对象启动时就加载</li>\n<li>懒汉式：延迟加载，对象什么时候用到时才会加载</li>\n<li>生命周期托管：单例对象交给别人处理</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-模板模式\"><a href=\"#4-模板模式\" class=\"headerlink\" title=\"4.模板模式\"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p>\n<ul>\n<li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      initialize();</span><br><span class=\"line\">      start();</span><br><span class=\"line\">      end();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Browser</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Initialized!.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Started.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Initialized!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Started!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      Software s1 = <span class=\"keyword\">new</span> Browser();</span><br><span class=\"line\">      s1.play();</span><br><span class=\"line\">      s1 = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\">      s1.play();    </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-模式模式优缺点：\"><a href=\"#4-1-模式模式优缺点：\" class=\"headerlink\" title=\"4.1 模式模式优缺点：\"></a>4.1 模式模式优缺点：</h4><ol>\n<li>优点<ul>\n<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>\n</ul>\n</li>\n<li>适用场景<ul>\n<li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-工厂模式\"><a href=\"#5-工厂模式\" class=\"headerlink\" title=\"5. 工厂模式\"></a>5. 工厂模式</h3><ol>\n<li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li>\n<li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li>\n<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li>\n</ol>\n<h4 id=\"5-1-简单工厂模式的实现：\"><a href=\"#5-1-简单工厂模式的实现：\" class=\"headerlink\" title=\"5.1 简单工厂模式的实现：\"></a>5.1 简单工厂模式的实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 产品接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fruit</span> </span>&#123; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span></span>; &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*苹果*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pear</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 梨 */</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"apple\"</span>)) &#123;<span class=\"comment\">//生产苹果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"pear\"</span>)) &#123;<span class=\"comment\">//生产梨</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">FruitFactory mFactory = <span class=\"keyword\">new</span> FruitFactory();</span><br><span class=\"line\">Apple apple = (Apple) mFactory.createFruit(<span class=\"string\">\"apple\"</span>);<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) mFactory.createFruit(<span class=\"string\">\"pear\"</span>);<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>简单工厂只适合于产品对象较少，且产品固定的需求</p>\n</blockquote>\n<h4 id=\"5-2-工厂方法模式实现：\"><a href=\"#5-2-工厂方法模式实现：\" class=\"headerlink\" title=\"5.2 工厂方法模式实现：\"></a>5.2 工厂方法模式实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span></span>;<span class=\"comment\">//生产水果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppleFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PearFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">AppleFactory appleFactory = <span class=\"keyword\">new</span> AppleFactory();</span><br><span class=\"line\">PearFactory pearFactory = <span class=\"keyword\">new</span> PearFactory();</span><br><span class=\"line\">Apple apple = (Apple) appleFactory.createFruit();<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) pearFactory.createFruit();<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p>\n</blockquote>\n<h4 id=\"5-3-抽象工厂模式实现：\"><a href=\"#5-3-抽象工厂模式实现：\" class=\"headerlink\" title=\"5.3 抽象工厂模式实现：\"></a>5.3 抽象工厂模式实现：</h4><ul>\n<li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li>\n<li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// cpu接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu650</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 625 也厉害 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu825</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 825 处理更强劲 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏幕接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen5</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 5寸 */</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen6</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 6寸 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的cpu</span></span><br><span class=\"line\">    <span class=\"function\">Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的屏幕</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu825();<span class=\"comment\">//高性能处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen6();<span class=\"comment\">//6寸大屏</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HongMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu650();<span class=\"comment\">//高效处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen5();<span class=\"comment\">//小屏手机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p>\n</blockquote>\n<h4 id=\"5-4-三种工厂方式总结：\"><a href=\"#5-4-三种工厂方式总结：\" class=\"headerlink\" title=\"5.4 三种工厂方式总结：\"></a>5.4 三种工厂方式总结：</h4><ol>\n<li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li>\n<li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-适配器模式（Adapter）\"><a href=\"#6-适配器模式（Adapter）\" class=\"headerlink\" title=\"6.适配器模式（Adapter）\"></a>6.适配器模式（Adapter）</h3><ul>\n<li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul>\n<li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li>\n<li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>\n</blockquote>\n<h4 id=\"6-1-缺省适配器模式\"><a href=\"#6-1-缺省适配器模式\" class=\"headerlink\" title=\"6.1 缺省适配器模式\"></a>6.1 缺省适配器模式</h4><ul>\n<li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li>\n<li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li>\n<li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>","more":"<ol>\n<li><a href=\"#id1\">常用的设计原则</a></li>\n<li><a href=\"#id2\">设计模式分类</a></li>\n<li><a href=\"#id3\">单例模式</a></li>\n<li><a href=\"#id4\">模板模式</a></li>\n<li><a href=\"#id5\">工厂模式</a></li>\n<li><a href=\"#id6\">适配器模式</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-常用的设计原则\"><a href=\"#1-常用的设计原则\" class=\"headerlink\" title=\"1.常用的设计原则\"></a>1.常用的设计原则</h3><ul>\n<li><strong>开闭原则</strong>：对扩展开发，对修改方便</li>\n<li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li>\n<li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li>\n<li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li>\n<li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li>\n<li><strong>合成复用原则</strong>：尽量多使用合成/聚合的方式，而不是继承的方式。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-设计模式分类\"><a href=\"#2-设计模式分类\" class=\"headerlink\" title=\"2.设计模式分类\"></a>2.设计模式分类</h3><h4 id=\"2-1-基本概念\"><a href=\"#2-1-基本概念\" class=\"headerlink\" title=\"2.1 基本概念\"></a>2.1 基本概念</h4><ul>\n<li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li>\n<li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li>\n<li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li>\n</ul>\n<h4 id=\"2-2-具体分类\"><a href=\"#2-2-具体分类\" class=\"headerlink\" title=\"2.2 具体分类\"></a>2.2 具体分类</h4><ol>\n<li><strong>创建型模式</strong>：<em>用于对象创建的过程</em><ul>\n<li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li>\n</ul>\n</li>\n<li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em><ul>\n<li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器/标准模式)</li>\n</ul>\n</li>\n<li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em><ul>\n<li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li>\n</ul>\n</li>\n<li>JEE 设计模式<ul>\n<li>数据访问对象模式 </li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-单例模式（Singleton）\"><a href=\"#3-单例模式（Singleton）\" class=\"headerlink\" title=\"3.单例模式（Singleton）\"></a>3.单例模式（Singleton）</h3><h4 id=\"3-1-实现流程：\"><a href=\"#3-1-实现流程：\" class=\"headerlink\" title=\"3.1 实现流程：\"></a>3.1 实现流程：</h4><ol>\n<li>私有的构造方法</li>\n<li>私有的静态的当前类的对象作为属性</li>\n<li>共有的静态方法返回当前对象<h4 id=\"3-1-实现方式：\"><a href=\"#3-1-实现方式：\" class=\"headerlink\" title=\"3.1 实现方式：\"></a>3.1 实现方式：</h4></li>\n<li>饿汉式：立即加载，对象启动时就加载</li>\n<li>懒汉式：延迟加载，对象什么时候用到时才会加载</li>\n<li>生命周期托管：单例对象交给别人处理</li>\n</ol>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-模板模式\"><a href=\"#4-模板模式\" class=\"headerlink\" title=\"4.模板模式\"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p>\n<ul>\n<li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">play</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      initialize();</span><br><span class=\"line\">      start();</span><br><span class=\"line\">      end();</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Browser</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Initialized!.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Browser Started.\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> <span class=\"keyword\">extends</span> <span class=\"title\">Software</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">end</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Finished!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Initialized!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Editor Started!\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">      Software s1 = <span class=\"keyword\">new</span> Browser();</span><br><span class=\"line\">      s1.play();</span><br><span class=\"line\">      s1 = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\">      s1.play();    </span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1-模式模式优缺点：\"><a href=\"#4-1-模式模式优缺点：\" class=\"headerlink\" title=\"4.1 模式模式优缺点：\"></a>4.1 模式模式优缺点：</h4><ol>\n<li>优点<ul>\n<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>\n</ul>\n</li>\n<li>适用场景<ul>\n<li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-工厂模式\"><a href=\"#5-工厂模式\" class=\"headerlink\" title=\"5. 工厂模式\"></a>5. 工厂模式</h3><ol>\n<li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li>\n<li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li>\n<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li>\n</ol>\n<h4 id=\"5-1-简单工厂模式的实现：\"><a href=\"#5-1-简单工厂模式的实现：\" class=\"headerlink\" title=\"5.1 简单工厂模式的实现：\"></a>5.1 简单工厂模式的实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 产品接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Fruit</span> </span>&#123; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span></span>; &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apple</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/*苹果*/</span>&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pear</span> <span class=\"keyword\">implements</span> <span class=\"title\">Fruit</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">whatIm</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 梨 */</span> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"apple\"</span>)) &#123;<span class=\"comment\">//生产苹果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (type.equals(<span class=\"string\">\"pear\"</span>)) &#123;<span class=\"comment\">//生产梨</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">FruitFactory mFactory = <span class=\"keyword\">new</span> FruitFactory();</span><br><span class=\"line\">Apple apple = (Apple) mFactory.createFruit(<span class=\"string\">\"apple\"</span>);<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) mFactory.createFruit(<span class=\"string\">\"pear\"</span>);<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>简单工厂只适合于产品对象较少，且产品固定的需求</p>\n</blockquote>\n<h4 id=\"5-2-工厂方法模式实现：\"><a href=\"#5-2-工厂方法模式实现：\" class=\"headerlink\" title=\"5.2 工厂方法模式实现：\"></a>5.2 工厂方法模式实现：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span></span>;<span class=\"comment\">//生产水果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppleFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PearFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">createFruit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 使用</span></span><br><span class=\"line\">AppleFactory appleFactory = <span class=\"keyword\">new</span> AppleFactory();</span><br><span class=\"line\">PearFactory pearFactory = <span class=\"keyword\">new</span> PearFactory();</span><br><span class=\"line\">Apple apple = (Apple) appleFactory.createFruit();<span class=\"comment\">//获得苹果</span></span><br><span class=\"line\">Pear pear = (Pear) pearFactory.createFruit();<span class=\"comment\">//获得梨</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p>\n</blockquote>\n<h4 id=\"5-3-抽象工厂模式实现：\"><a href=\"#5-3-抽象工厂模式实现：\" class=\"headerlink\" title=\"5.3 抽象工厂模式实现：\"></a>5.3 抽象工厂模式实现：</h4><ul>\n<li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li>\n<li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// cpu接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu650</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 625 也厉害 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cpu825</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cpu</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 825 处理更强劲 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏幕接口和实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen5</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/* 5寸 */</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Screen6</span> <span class=\"keyword\">implements</span> <span class=\"title\">Screen</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">/* 6寸 */</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的cpu</span></span><br><span class=\"line\">    <span class=\"function\">Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span></span>;<span class=\"comment\">//使用的屏幕</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 具体工厂实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">XiaoMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu825();<span class=\"comment\">//高性能处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen6();<span class=\"comment\">//6寸大屏</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HongMiFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">PhoneFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Cpu <span class=\"title\">getCpu</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Cpu.Cpu650();<span class=\"comment\">//高效处理器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Screen <span class=\"title\">getScreen</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Screen.Screen5();<span class=\"comment\">//小屏手机</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p>\n</blockquote>\n<h4 id=\"5-4-三种工厂方式总结：\"><a href=\"#5-4-三种工厂方式总结：\" class=\"headerlink\" title=\"5.4 三种工厂方式总结：\"></a>5.4 三种工厂方式总结：</h4><ol>\n<li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li>\n<li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-适配器模式（Adapter）\"><a href=\"#6-适配器模式（Adapter）\" class=\"headerlink\" title=\"6.适配器模式（Adapter）\"></a>6.适配器模式（Adapter）</h3><ul>\n<li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul>\n<li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li>\n<li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>\n</blockquote>\n<h4 id=\"6-1-缺省适配器模式\"><a href=\"#6-1-缺省适配器模式\" class=\"headerlink\" title=\"6.1 缺省适配器模式\"></a>6.1 缺省适配器模式</h4><ul>\n<li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li>\n<li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li>\n<li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li>\n</ul>"},{"title":"十一、JavaSE数据结构与算法入门","date":"2019-07-15T10:12:38.000Z","_content":"\n数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。\n<!-- more -->\n\n1. [Java数据结构](#id1)\n2. [时间复杂度与空间复杂度](#id2)\n3. [算法的基本概念](#id3)\n\n\n<span id=\"id1\"><span>\n### 1.Java数据结构(Data Structure)\n#### 1.1 数据结构\n1. 数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n2. 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。\n3. 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。\n\n#### 1.2 Java数据结构\n- 数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。\n  1. 线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。\n  2. 非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。\n- 按数据的存储结构分为：顺序存储结构和链式存储结构\n  1. 顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 \n  2. 链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。\n\n#### 1.2.1 线性数据结构\n常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。\n\n1. 一维数组\n  - 在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。\n  - ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。\n  - 数组的插入/更新/删除效率比较低，而**查询效率非常高**,查询效率时间复杂度是1。\n2. 线性表\n  - 线性表是有序的储存结构、链式的储存结构。\n  - 链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。\n  - 常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。\n  - 线性表**插入效率比较高**，而查询效率就比较低（add(),get()）。\n3. 栈Stack\n  - 栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。\n4. 队列\n  - 队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。\n  - Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。\n  - 使用场景也非常多，如线程池，mq，连接池等。\n5. 串\n  - 串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）\n\n#### 1.2.2 非线性数据结构\n常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。\n\n1. 多维数组\n  - Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。\n2. 集合\n  - 由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。\n3. 树\n  - 在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。\n  - 除了根节点，其他结点有且只有一个直接父节点\n  - 每个结点可以有任意多个直接子节点。\n  - 树的数据结构又分为：\n    1. 自由树/普通树：对子节点没有任何约束。\n    2. 二叉树：每个节点最多含有两个子节点的树称为二叉树。\n    3. 二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）\n    4. B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。\n    5. B+tree：又称B+。是B-树的变体，也是一种多路搜索树。\n4. Hash\n  - Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）\n  - 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\n  - Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。\n  - Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。\n  - 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。\n5. 图\n  - 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\n\n\n### 2. 时间复杂度与空间复杂度\n#### 2.1 时间复杂度\n一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为**语句频度或时间频度**。记为**T(n)**\n\n在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。\n\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称**时间复杂度**。\n\n有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。\n\n常见的算法的时间 复杂度之间的关系为：`O(1)<O(logn)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)`\n\n\n#### 2.2 空间复杂度\n空间复杂度：算法所需存储空间的度量，记作：`S(n)=O( f(n) )`，其中 n 为问题的规模。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。\n\n算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。\n\n> - 空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。\n> - 时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。\n> - 稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。\n\n### 3.算法的基本概念\n- 算法: 简单来说就是解决问题的步骤。\n- 算法的五个特征:有穷性，确定性，可行性，有输入，有输出\n  1. 有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。\n  2. 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。\n  3. 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。\n  4. 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。\n  5. 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。\n- 算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求\n  * 描述算法的速度必须要和数据项的个数联系起来。\n  * 算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；\n  * 一个算法的效率越高越好，而存储量是越低越好。\n\n\n### 4. 常用的查找算法\n#### 4.1 线性（顺序）查找算法\n1. 使用目标元素与样本数列中第一个元素起依次进行比较\n2. 若目标元素等于样本元素，则表示查找成功\n3. 若目标元素与样本元素比较完毕也不相等，则表示查找失败\n\n#### 4.2 二分查找算法\n二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。\n\n- 普通循环实现二分查找算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 28));\n}\n/**\n * 二分查找普通循环实现\n *\n * @param srcArray 有序数组\n * @param key 查找元素\n * @return\n */\npublic static int binSearch(int srcArray[], int key) {\n    int mid = srcArray.length / 2;\n    if (key == srcArray[mid]) return mid;\n    int start = 0;\n    int end = srcArray.length - 1;\n    while (start <= end) {\n        mid = (end - start) / 2 + start;\n        if (key < srcArray[mid]) {\n            end = mid - 1;\n        } else if (key > srcArray[mid]) {\n            start = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n> 二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。\n\n\n- 递归实现二分查找递归实现算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 0,15,28));\n}\n/**\n * 二分查找递归实现\n *\n * @param srcArray  有序数组\n * @param start 数组低地址下标\n * @param end   数组高地址下标\n * @param key  查找元素\n * @return 查找元素不存在返回-1\n */\npublic static int binSearch(int srcArray[], int start, int end, int key) {\n    int mid = (end - start) / 2 + start;\n    if (srcArray[mid] == key) {\n        return mid;\n    }\n    if (start >= end) {\n        return -1;\n    } else if (key > srcArray[mid]) {\n        return binSearch(srcArray, mid + 1, end, key);\n    } else if (key < srcArray[mid]) {\n        return binSearch(srcArray, start, mid - 1, key);\n    }\n    return -1;\n}\n```\n> 递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。\n\n\n### 4. 常用的排序算法\n- 八大排序算法\n  * 一、直接插入排序（Insertion Sort）\n  * 二、希尔排序（Shell Sort）\n  * 三、选择排序（Selection Sort）\n  * 四、堆排序（Heap Sort）\n  * 五、冒泡排序（Bubble Sort）\n  * 六、快速排序（Quick Sort）\n  * 七、归并排序（Merging Sort）\n  * 八、基数排序（Radix Sort）\n\n#### 4.1 冒泡排序算法\n冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n- 算法描述：\n  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n  3. 针对所有的元素重复以上的步骤，除了最后一个。\n  4. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。\n\n- 代码实现：\n``` java\npublic static void bubbleSort(int[] arr){\n    for (int i=1; i<arr.length; i++){\n      boolean flag = true;//声明标志位\n      for(int j=0; j<arr.length-i; j++){\n        if(arr[j] > arr[j+1]){\n          int temp = arr[j+1];\n          arr[j] = arr[j+1];\n          arr[j++1] = temp;\n          flag = false;\n        }\n      }\n      //若此轮结束flag还是为true,则证明已经有序\n      if(flag) break;\n    }\n}\n```\n\n- 冒泡排序算法复杂度:\n  * 平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)\n  * 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).\n\n> Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。\n\n\n\n","source":"_posts/11_JavaSE数据结构与算法入门.md","raw":"---\ntitle: 十一、JavaSE数据结构与算法入门\ndate: 2019-07-15 18:12:38\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。\n<!-- more -->\n\n1. [Java数据结构](#id1)\n2. [时间复杂度与空间复杂度](#id2)\n3. [算法的基本概念](#id3)\n\n\n<span id=\"id1\"><span>\n### 1.Java数据结构(Data Structure)\n#### 1.1 数据结构\n1. 数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。\n2. 而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。\n3. 而一个数据结构的设计过程分成抽象层、数据结构层和实现层。\n\n#### 1.2 Java数据结构\n- 数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。\n  1. 线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。\n  2. 非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。\n- 按数据的存储结构分为：顺序存储结构和链式存储结构\n  1. 顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 \n  2. 链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。\n\n#### 1.2.1 线性数据结构\n常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。\n\n1. 一维数组\n  - 在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。\n  - ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。\n  - 数组的插入/更新/删除效率比较低，而**查询效率非常高**,查询效率时间复杂度是1。\n2. 线性表\n  - 线性表是有序的储存结构、链式的储存结构。\n  - 链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。\n  - 常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。\n  - 线性表**插入效率比较高**，而查询效率就比较低（add(),get()）。\n3. 栈Stack\n  - 栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。\n4. 队列\n  - 队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。\n  - Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。\n  - 使用场景也非常多，如线程池，mq，连接池等。\n5. 串\n  - 串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）\n\n#### 1.2.2 非线性数据结构\n常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。\n\n1. 多维数组\n  - Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。\n2. 集合\n  - 由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。\n3. 树\n  - 在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。\n  - 除了根节点，其他结点有且只有一个直接父节点\n  - 每个结点可以有任意多个直接子节点。\n  - 树的数据结构又分为：\n    1. 自由树/普通树：对子节点没有任何约束。\n    2. 二叉树：每个节点最多含有两个子节点的树称为二叉树。\n    3. 二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）\n    4. B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。\n    5. B+tree：又称B+。是B-树的变体，也是一种多路搜索树。\n4. Hash\n  - Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）\n  - 简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。\n  - Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。\n  - Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。\n  - 需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。\n5. 图\n  - 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\n\n\n### 2. 时间复杂度与空间复杂度\n#### 2.1 时间复杂度\n一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为**语句频度或时间频度**。记为**T(n)**\n\n在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。\n\n一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称**时间复杂度**。\n\n有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。\n\n常见的算法的时间 复杂度之间的关系为：`O(1)<O(logn)<O(n)<O(nlog n)<O(n2)<O(2n)<O(n!)<O(nn)`\n\n\n#### 2.2 空间复杂度\n空间复杂度：算法所需存储空间的度量，记作：`S(n)=O( f(n) )`，其中 n 为问题的规模。\n\n一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。\n\n算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。\n\n> - 空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。\n> - 时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。\n> - 稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。\n\n### 3.算法的基本概念\n- 算法: 简单来说就是解决问题的步骤。\n- 算法的五个特征:有穷性，确定性，可行性，有输入，有输出\n  1. 有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。\n  2. 确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。\n  3. 可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。\n  4. 有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。\n  5. 有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。\n- 算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求\n  * 描述算法的速度必须要和数据项的个数联系起来。\n  * 算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；\n  * 一个算法的效率越高越好，而存储量是越低越好。\n\n\n### 4. 常用的查找算法\n#### 4.1 线性（顺序）查找算法\n1. 使用目标元素与样本数列中第一个元素起依次进行比较\n2. 若目标元素等于样本元素，则表示查找成功\n3. 若目标元素与样本元素比较完毕也不相等，则表示查找失败\n\n#### 4.2 二分查找算法\n二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。\n\n- 普通循环实现二分查找算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 28));\n}\n/**\n * 二分查找普通循环实现\n *\n * @param srcArray 有序数组\n * @param key 查找元素\n * @return\n */\npublic static int binSearch(int srcArray[], int key) {\n    int mid = srcArray.length / 2;\n    if (key == srcArray[mid]) return mid;\n    int start = 0;\n    int end = srcArray.length - 1;\n    while (start <= end) {\n        mid = (end - start) / 2 + start;\n        if (key < srcArray[mid]) {\n            end = mid - 1;\n        } else if (key > srcArray[mid]) {\n            start = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n```\n> 二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。\n\n\n- 递归实现二分查找递归实现算法\n\n``` java\npublic static void main(String[] args) {\n    int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};\n    System.out.println(binSearch(srcArray, 0,15,28));\n}\n/**\n * 二分查找递归实现\n *\n * @param srcArray  有序数组\n * @param start 数组低地址下标\n * @param end   数组高地址下标\n * @param key  查找元素\n * @return 查找元素不存在返回-1\n */\npublic static int binSearch(int srcArray[], int start, int end, int key) {\n    int mid = (end - start) / 2 + start;\n    if (srcArray[mid] == key) {\n        return mid;\n    }\n    if (start >= end) {\n        return -1;\n    } else if (key > srcArray[mid]) {\n        return binSearch(srcArray, mid + 1, end, key);\n    } else if (key < srcArray[mid]) {\n        return binSearch(srcArray, start, mid - 1, key);\n    }\n    return -1;\n}\n```\n> 递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。\n\n\n### 4. 常用的排序算法\n- 八大排序算法\n  * 一、直接插入排序（Insertion Sort）\n  * 二、希尔排序（Shell Sort）\n  * 三、选择排序（Selection Sort）\n  * 四、堆排序（Heap Sort）\n  * 五、冒泡排序（Bubble Sort）\n  * 六、快速排序（Quick Sort）\n  * 七、归并排序（Merging Sort）\n  * 八、基数排序（Radix Sort）\n\n#### 4.1 冒泡排序算法\n冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n- 算法描述：\n  1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n  3. 针对所有的元素重复以上的步骤，除了最后一个。\n  4. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。\n\n- 代码实现：\n``` java\npublic static void bubbleSort(int[] arr){\n    for (int i=1; i<arr.length; i++){\n      boolean flag = true;//声明标志位\n      for(int j=0; j<arr.length-i; j++){\n        if(arr[j] > arr[j+1]){\n          int temp = arr[j+1];\n          arr[j] = arr[j+1];\n          arr[j++1] = temp;\n          flag = false;\n        }\n      }\n      //若此轮结束flag还是为true,则证明已经有序\n      if(flag) break;\n    }\n}\n```\n\n- 冒泡排序算法复杂度:\n  * 平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)\n  * 冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).\n\n> Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。\n\n\n\n","slug":"11_JavaSE数据结构与算法入门","published":1,"updated":"2019-07-20T15:08:05.419Z","_id":"cjyblnrsr001gxwt3ey6qnm3p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Java数据结构</a></li>\n<li><a href=\"#id2\">时间复杂度与空间复杂度</a></li>\n<li><a href=\"#id3\">算法的基本概念</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Java数据结构-Data-Structure\"><a href=\"#1-Java数据结构-Data-Structure\" class=\"headerlink\" title=\"1.Java数据结构(Data Structure)\"></a>1.Java数据结构(Data Structure)</h3><h4 id=\"1-1-数据结构\"><a href=\"#1-1-数据结构\" class=\"headerlink\" title=\"1.1 数据结构\"></a>1.1 数据结构</h4><ol>\n<li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li>\n<li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li>\n<li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li>\n</ol>\n<h4 id=\"1-2-Java数据结构\"><a href=\"#1-2-Java数据结构\" class=\"headerlink\" title=\"1.2 Java数据结构\"></a>1.2 Java数据结构</h4><ul>\n<li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol>\n<li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li>\n<li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li>\n</ol>\n</li>\n<li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol>\n<li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li>\n<li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-1-线性数据结构\"><a href=\"#1-2-1-线性数据结构\" class=\"headerlink\" title=\"1.2.1 线性数据结构\"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p>\n<ol>\n<li>一维数组<ul>\n<li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li>\n<li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li>\n<li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li>\n</ul>\n</li>\n<li>线性表<ul>\n<li>线性表是有序的储存结构、链式的储存结构。</li>\n<li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li>\n<li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li>\n<li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li>\n</ul>\n</li>\n<li>栈Stack<ul>\n<li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li>\n<li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li>\n<li>使用场景也非常多，如线程池，mq，连接池等。</li>\n</ul>\n</li>\n<li>串<ul>\n<li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-2-非线性数据结构\"><a href=\"#1-2-2-非线性数据结构\" class=\"headerlink\" title=\"1.2.2 非线性数据结构\"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p>\n<ol>\n<li>多维数组<ul>\n<li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li>\n</ul>\n</li>\n<li>集合<ul>\n<li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li>\n</ul>\n</li>\n<li>树<ul>\n<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>\n<li>除了根节点，其他结点有且只有一个直接父节点</li>\n<li>每个结点可以有任意多个直接子节点。</li>\n<li>树的数据结构又分为：<ol>\n<li>自由树/普通树：对子节点没有任何约束。</li>\n<li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li>\n<li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li>\n<li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li>\n<li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Hash<ul>\n<li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li>\n<li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>\n<li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li>\n<li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li>\n<li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-时间复杂度与空间复杂度\"><a href=\"#2-时间复杂度与空间复杂度\" class=\"headerlink\" title=\"2. 时间复杂度与空间复杂度\"></a>2. 时间复杂度与空间复杂度</h3><h4 id=\"2-1-时间复杂度\"><a href=\"#2-1-时间复杂度\" class=\"headerlink\" title=\"2.1 时间复杂度\"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p>\n<p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p>\n<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p>\n<p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p>\n<p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p>\n<h4 id=\"2-2-空间复杂度\"><a href=\"#2-2-空间复杂度\" class=\"headerlink\" title=\"2.2 空间复杂度\"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p>\n<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>\n<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>\n<blockquote>\n<ul>\n<li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li>\n<li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li>\n<li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-算法的基本概念\"><a href=\"#3-算法的基本概念\" class=\"headerlink\" title=\"3.算法的基本概念\"></a>3.算法的基本概念</h3><ul>\n<li>算法: 简单来说就是解决问题的步骤。</li>\n<li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol>\n<li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li>\n<li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li>\n<li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li>\n<li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li>\n<li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li>\n</ol>\n</li>\n<li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul>\n<li>描述算法的速度必须要和数据项的个数联系起来。</li>\n<li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li>\n<li>一个算法的效率越高越好，而存储量是越低越好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-常用的查找算法\"><a href=\"#4-常用的查找算法\" class=\"headerlink\" title=\"4. 常用的查找算法\"></a>4. 常用的查找算法</h3><h4 id=\"4-1-线性（顺序）查找算法\"><a href=\"#4-1-线性（顺序）查找算法\" class=\"headerlink\" title=\"4.1 线性（顺序）查找算法\"></a>4.1 线性（顺序）查找算法</h4><ol>\n<li>使用目标元素与样本数列中第一个元素起依次进行比较</li>\n<li>若目标元素等于样本元素，则表示查找成功</li>\n<li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li>\n</ol>\n<h4 id=\"4-2-二分查找算法\"><a href=\"#4-2-二分查找算法\" class=\"headerlink\" title=\"4.2 二分查找算法\"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p>\n<ul>\n<li>普通循环实现二分查找算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找普通循环实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray 有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key 查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = srcArray.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == srcArray[mid]) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">        mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>\n</blockquote>\n<ul>\n<li>递归实现二分查找递归实现算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">0</span>,<span class=\"number\">15</span>,<span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray  有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 数组低地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end   数组高地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key  查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 查找元素不存在返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcArray[mid] == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, mid + <span class=\"number\">1</span>, end, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, start, mid - <span class=\"number\">1</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>\n</blockquote>\n<h3 id=\"4-常用的排序算法\"><a href=\"#4-常用的排序算法\" class=\"headerlink\" title=\"4. 常用的排序算法\"></a>4. 常用的排序算法</h3><ul>\n<li>八大排序算法<ul>\n<li>一、直接插入排序（Insertion Sort）</li>\n<li>二、希尔排序（Shell Sort）</li>\n<li>三、选择排序（Selection Sort）</li>\n<li>四、堆排序（Heap Sort）</li>\n<li>五、冒泡排序（Bubble Sort）</li>\n<li>六、快速排序（Quick Sort）</li>\n<li>七、归并排序（Merging Sort）</li>\n<li>八、基数排序（Radix Sort）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-冒泡排序算法\"><a href=\"#4-1-冒泡排序算法\" class=\"headerlink\" title=\"4.1 冒泡排序算法\"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<ul>\n<li><p>算法描述：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li>\n</ol>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;<span class=\"comment\">//声明标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> temp = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j++<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">          flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>冒泡排序算法复杂度:</p>\n<ul>\n<li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li>\n<li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p>","more":"<ol>\n<li><a href=\"#id1\">Java数据结构</a></li>\n<li><a href=\"#id2\">时间复杂度与空间复杂度</a></li>\n<li><a href=\"#id3\">算法的基本概念</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Java数据结构-Data-Structure\"><a href=\"#1-Java数据结构-Data-Structure\" class=\"headerlink\" title=\"1.Java数据结构(Data Structure)\"></a>1.Java数据结构(Data Structure)</h3><h4 id=\"1-1-数据结构\"><a href=\"#1-1-数据结构\" class=\"headerlink\" title=\"1.1 数据结构\"></a>1.1 数据结构</h4><ol>\n<li>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。</li>\n<li>而各数据元素之间的相互关系，又包括三个组成成分，数据的逻辑结构，数据的存储结构和数据运算结构。</li>\n<li>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</li>\n</ol>\n<h4 id=\"1-2-Java数据结构\"><a href=\"#1-2-Java数据结构\" class=\"headerlink\" title=\"1.2 Java数据结构\"></a>1.2 Java数据结构</h4><ul>\n<li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol>\n<li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li>\n<li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li>\n</ol>\n</li>\n<li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol>\n<li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li>\n<li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"1-2-1-线性数据结构\"><a href=\"#1-2-1-线性数据结构\" class=\"headerlink\" title=\"1.2.1 线性数据结构\"></a>1.2.1 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p>\n<ol>\n<li>一维数组<ul>\n<li>在Java里面常用的util有：String [],int [],ArrayList,Vector,CopyOnWriteArrayList等。</li>\n<li>ArrayList和Vector的区别是:Vector是线程安全的，方法同步。CopyOnWriteArrayList也是线程安全的但效率要比Vector高很多。</li>\n<li>数组的插入/更新/删除效率比较低，而<strong>查询效率非常高</strong>,查询效率时间复杂度是1。</li>\n</ul>\n</li>\n<li>线性表<ul>\n<li>线性表是有序的储存结构、链式的储存结构。</li>\n<li>链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。</li>\n<li>常见的有顺序链表(LinkedList、Linked***)，单项链表（里面只有Node类），双向链表(两个Node类)，循环链表(多个Node类)等。</li>\n<li>线性表<strong>插入效率比较高</strong>，而查询效率就比较低（add(),get()）。</li>\n</ul>\n</li>\n<li>栈Stack<ul>\n<li>栈，最主要的是要实现先进后出，后进先出的逻辑结构（push(),pop()）。</li>\n</ul>\n</li>\n<li>队列<ul>\n<li>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。队列又有单项有序队列，双向队列，阻塞队列等。</li>\n<li>Queue这种数据结构注定了基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</li>\n<li>使用场景也非常多，如线程池，mq，连接池等。</li>\n</ul>\n</li>\n<li>串<ul>\n<li>串：也称字符串，是由N个字符组成的优先序列。在Java里面就是指String,而String里面是由chat[]来进行储存。（KMP算法）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"1-2-2-非线性数据结构\"><a href=\"#1-2-2-非线性数据结构\" class=\"headerlink\" title=\"1.2.2 非线性数据结构\"></a>1.2.2 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p>\n<ol>\n<li>多维数组<ul>\n<li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li>\n</ul>\n</li>\n<li>集合<ul>\n<li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li>\n</ul>\n</li>\n<li>树<ul>\n<li>在一个树结构中，有且仅有一个结点没有直接父节点，它就是根节点。</li>\n<li>除了根节点，其他结点有且只有一个直接父节点</li>\n<li>每个结点可以有任意多个直接子节点。</li>\n<li>树的数据结构又分为：<ol>\n<li>自由树/普通树：对子节点没有任何约束。</li>\n<li>二叉树：每个节点最多含有两个子节点的树称为二叉树。</li>\n<li>二叉搜索树/BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。（二叉平衡树，AVL树，红黑树）</li>\n<li>B-tree：又称B树、B-树。又叫平衡(balance)多路查找树。</li>\n<li>B+tree：又称B+。是B-树的变体，也是一种多路搜索树。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Hash<ul>\n<li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li>\n<li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>\n<li>Java中的hashCode：默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li>\n<li>Hash表：Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li>\n<li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li>\n</ul>\n</li>\n<li>图<ul>\n<li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-时间复杂度与空间复杂度\"><a href=\"#2-时间复杂度与空间复杂度\" class=\"headerlink\" title=\"2. 时间复杂度与空间复杂度\"></a>2. 时间复杂度与空间复杂度</h3><h4 id=\"2-1-时间复杂度\"><a href=\"#2-1-时间复杂度\" class=\"headerlink\" title=\"2.1 时间复杂度\"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p>\n<p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p>\n<p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p>\n<p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p>\n<p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p>\n<h4 id=\"2-2-空间复杂度\"><a href=\"#2-2-空间复杂度\" class=\"headerlink\" title=\"2.2 空间复杂度\"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p>\n<p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p>\n<p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p>\n<blockquote>\n<ul>\n<li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li>\n<li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li>\n<li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li>\n</ul>\n</blockquote>\n<h3 id=\"3-算法的基本概念\"><a href=\"#3-算法的基本概念\" class=\"headerlink\" title=\"3.算法的基本概念\"></a>3.算法的基本概念</h3><ul>\n<li>算法: 简单来说就是解决问题的步骤。</li>\n<li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol>\n<li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li>\n<li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li>\n<li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li>\n<li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li>\n<li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li>\n</ol>\n</li>\n<li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul>\n<li>描述算法的速度必须要和数据项的个数联系起来。</li>\n<li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li>\n<li>一个算法的效率越高越好，而存储量是越低越好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-常用的查找算法\"><a href=\"#4-常用的查找算法\" class=\"headerlink\" title=\"4. 常用的查找算法\"></a>4. 常用的查找算法</h3><h4 id=\"4-1-线性（顺序）查找算法\"><a href=\"#4-1-线性（顺序）查找算法\" class=\"headerlink\" title=\"4.1 线性（顺序）查找算法\"></a>4.1 线性（顺序）查找算法</h4><ol>\n<li>使用目标元素与样本数列中第一个元素起依次进行比较</li>\n<li>若目标元素等于样本元素，则表示查找成功</li>\n<li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li>\n</ol>\n<h4 id=\"4-2-二分查找算法\"><a href=\"#4-2-二分查找算法\" class=\"headerlink\" title=\"4.2 二分查找算法\"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p>\n<ul>\n<li>普通循环实现二分查找算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找普通循环实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray 有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key 查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = srcArray.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == srcArray[mid]) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> end = srcArray.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">        mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">            end = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">            start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p>\n</blockquote>\n<ul>\n<li>递归实现二分查找递归实现算法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> srcArray[] = &#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">11</span>,<span class=\"number\">17</span>,<span class=\"number\">21</span>,<span class=\"number\">23</span>,<span class=\"number\">28</span>,<span class=\"number\">30</span>,<span class=\"number\">32</span>,<span class=\"number\">50</span>,<span class=\"number\">64</span>,<span class=\"number\">78</span>,<span class=\"number\">81</span>,<span class=\"number\">95</span>,<span class=\"number\">101</span>&#125;;</span><br><span class=\"line\">    System.out.println(binSearch(srcArray, <span class=\"number\">0</span>,<span class=\"number\">15</span>,<span class=\"number\">28</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 二分查找递归实现</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> srcArray  有序数组</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> start 数组低地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> end   数组高地址下标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> key  查找元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 查找元素不存在返回-1</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">binSearch</span><span class=\"params\">(<span class=\"keyword\">int</span> srcArray[], <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end, <span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (end - start) / <span class=\"number\">2</span> + start;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (srcArray[mid] == key) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, mid + <span class=\"number\">1</span>, end, key);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binSearch(srcArray, start, mid - <span class=\"number\">1</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p>\n</blockquote>\n<h3 id=\"4-常用的排序算法\"><a href=\"#4-常用的排序算法\" class=\"headerlink\" title=\"4. 常用的排序算法\"></a>4. 常用的排序算法</h3><ul>\n<li>八大排序算法<ul>\n<li>一、直接插入排序（Insertion Sort）</li>\n<li>二、希尔排序（Shell Sort）</li>\n<li>三、选择排序（Selection Sort）</li>\n<li>四、堆排序（Heap Sort）</li>\n<li>五、冒泡排序（Bubble Sort）</li>\n<li>六、快速排序（Quick Sort）</li>\n<li>七、归并排序（Merging Sort）</li>\n<li>八、基数排序（Radix Sort）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-1-冒泡排序算法\"><a href=\"#4-1-冒泡排序算法\" class=\"headerlink\" title=\"4.1 冒泡排序算法\"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<ul>\n<li><p>算法描述：</p>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li>\n</ol>\n</li>\n<li><p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> flag = <span class=\"keyword\">true</span>;<span class=\"comment\">//声明标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[j] &gt; arr[j+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> temp = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">          arr[j++<span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">          flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(flag) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>冒泡排序算法复杂度:</p>\n<ul>\n<li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li>\n<li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p>\n</blockquote>"},{"title":"BlueLake博客主题的详细配置","date":"2016-12-29T03:25:33.000Z","top":9,"_content":"### 开始之前\n\n[BlueLake主题](https://github.com/chaooo/hexo-theme-BlueLake)写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。\n<!-- more -->\n在阅读本文之前，假定您已经成功安装了[Hexo](https://hexo.io/zh-cn/)，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n> 需要特别注意的是Hexo有两个`_config.yml`配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为**`根_config.yml`**；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为**`主题_config.yml`**。\n\n### 1. 安装\n\n您可以直接到[BlueLake发布页](https://github.com/chaooo/hexo-theme-BlueLake)下载，然后解压拷贝到`themes`目录下，修改配置即可。\n不过我还是推荐使用`GIT`来checkout代码，之后也可以通过`git pull`来快速更新。\n\n#### 1.1 安装主题\n\n在根目录下打开终端窗口：\n``` bash git bash\n$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake\n```\n\n#### 1.2 安装主题渲染器\n\nBlueLake是基于`jade`和`stylus`写的，所以需要安装`hexo-renderer-jade`和`hexo-renderer-stylus`来渲染。\n``` bash git bash\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n#### 1.3 启用主题\n\n打开`根_config.yml`配置文件，找到theme字段，将其值改为`BlueLake`(先确认主题文件夹名称是否为BlueLake)。\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntheme: BlueLake\n```\n\n#### 1.4 验证\n\n首先启动 Hexo 本地站点，并开启调试模式：\n``` bash git bash\n$ hexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：`INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n此时即可使用浏览器访问 `http://localhost:4000`，检查站点是否正确运行。\n\n#### 1.5 更新主题\n\n今后若主题添加了新功能正是您需要的，您可以直接`git pull`来更新主题。\n``` bash git bash\ncd themes/BlueLake\ngit pull\n```\n\n### 2. 配置\n\n#### 2.1 配置网站头部显示文字\n\n打开`根_config.yml`，找到：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntitle: \nsubtitle: \ndescription: \nauthor: \n```\n`title`和`subtitle`分别是网站主标题和副标题，会显示在网站头部；`description`在网站界面不会显示，内容会加入网站源码的`meta`标签中，主要用于SEO；`author`就填写网站所有者的名字，会在网站底部的`Copyright`处有所显示。\n\n#### 2.2 设置语言\n\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在`根_config.yml`配置如下：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\nlanguage: zh-CN\n```\n\n#### 2.3 设置菜单\n\n打开`主题_config.yml`，找到：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即`主页home`，`归档archive`，`关于about`，`订阅RSS`；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n每个页面底部的`footer`中`联系博主`的三个图标分别是`邮箱`，`微博主页链接地址`，`GitHUb个人页链接地址`，直接使用`主题_config.yml`中`about页面`的配置，若不需要about页面，只需要如下配置就好：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n##### 2.3.1 添加about页\n\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n``` bash git bash\n$ hexo new page 'about'\n```\n打开`主题_config.yml`，补全关于我页面的详细信息：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改`layout/page.jade`模板就好。\n\n##### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n\n在根目录下打开命令行窗口：\n``` bash git bash\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加`主题_config.yml`配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\n\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n#### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)来创建JSON数据文件：\n``` bash git bash\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在`根_config.yml`添加配置：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在`主题_config.yml`添加配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nlocal_search: true\n```\n\n#### 2.5 修改站点图标\n\n站点图标存放在主题的`Source`目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为** favicon.ico **，请将其放入hexo目录的`source`文件夹，建议大小：32px X 32px。\n您需要为苹果设备添加网站徽标，请命名为** apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n#### 2.6 添加站点关键字\n\n请在hexo目录的`根_config.yml`中添加keywords字段，如：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n\n#### 2.7 首页添加文章置顶\n\n在根目录下打开命令行窗口安装：\n``` bash git bash\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n然后在需要置顶的文章的Front-matter中加上top: true即可。\n``` md\n---\ntitle: BlueLake博客主题的详细配置\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: true\n---\n```\n\n#### 2.8 更换主题背景和添加文章版权信息\n更换主题背景为深色\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\ndark: true #true/false\n```\n添加文章版权信息\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\n#Copyright\ncopyright: \n  enable: true #true/false  \n  describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述\n```\n\n#### 2.9 其他配置\n`主题_config.yml`的其他配置\n1. `show_category_count`——是否显示分类下的文章数。\n2. `widgets_on_small_screens`——是否在小屏显示侧边栏，若`true`,则侧边栏挂件将显示在底部。\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nshow_category_count: true \nwidgets_on_small_screens: true \n```\n\n### 3.集成第三方服务\n\n#### 3.1 添加评论\n\n目前主题集成六种第三方评论，分别是[多说评论](http://duoshuo.com)、[Disqus评论](https://disqus.com)、[来必力评论](https://livere.com)、[友言评论](http://www.uyan.cc/)、[网易云跟帖评论](https://gentie.163.com/info.html)、[畅言评论](http://changyan.kuaizhan.com)，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。\n1. 注册并获得代码。\n  - 若使用[多说评论](http://duoshuo.com)，注册多说后获得short_name。\n  - 若使用[Disqus评论](https://disqus.com)，注册Disqus后获得short_name。\n  - 若使用[来必力评论](https://livere.com)，注册来必力,获得data-uid。\n  - 若使用[友言评论](http://www.uyan.cc/)，注册友言,获得uid。\n  - 若使用[网易云跟帖评论](https://gentie.163.com/info.html)，注册网易云跟帖,获得productKey。\n  - 若使用[畅言评论](http://changyan.kuaizhan.com)，注册畅言，获得appid，appkey。\n2. 配置`主题_config.yml`：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n\n#### 3.2 百度统计\n\n1. 登录[百度统计](http://tongji.baidu.com/)，定位到站点的代码获取页面。\n2. 复制`//hm.baidu.com/hm.js?`后面那串统计脚本id(假设为：8006843039519956000)\n3. 配置`主题_config.yml`:\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nbaidu_analytics: 8006843039519956000\n```\n> 注意： `baidu_analytics`不是你的百度`id`或者百度统计`id`\n如若使用谷歌统计，配置方法与百度统计类似。\n\n#### 3.3 卜算子阅读次数统计\n\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nbusuanzi: true\n```\n若设置为`true`将计算文章的阅读量(Hits)，并显示在文章标题下的`小手图标`旁。\n\n#### 3.4 微博秀\n\n微博秀挂件的代码放在`layout/_widget/weibo.jade`下，需要您去[微博开放平台](http://open.weibo.com/)获取您自己的微博秀代码来替换。\n1. 登录[微博开放平台](http://open.weibo.com/)，选择微博秀。\n2. 为了与主题风格统一，作如下配置\n  - 基础设置：高`400px`；勾选宽度自适应；颜色选择`白色`；\n  - 样式设置：主字色`#333`；链接色`#40759b`；鼠标悬停色`#f7f8f8`；\n  - 模块设置：去掉`标题`、`边框`、`粉丝`的勾选框，只留`微博`。\n3. 复制代码里`src=\"\"`里引号包裹的内容，替换到`layout/_widget/weibo.jade`\n{% codeblock weibo.jade lang:stylus mark:1,7-8,10 https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade layout/_widget/weibo.jade %}\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\n  iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n{% endcodeblock %}\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n> 注意：最主要是是要把`src`里`uid=`和`verifier=`后面的字段替换为您自己代码里的就好。","source":"_posts/BlueLake博客主题的详细配置.md","raw":"---\ntitle: BlueLake博客主题的详细配置\ndate: 2016-12-29 11:25:33\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: 9\n---\n### 开始之前\n\n[BlueLake主题](https://github.com/chaooo/hexo-theme-BlueLake)写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。\n<!-- more -->\n在阅读本文之前，假定您已经成功安装了[Hexo](https://hexo.io/zh-cn/)，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n> 需要特别注意的是Hexo有两个`_config.yml`配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为**`根_config.yml`**；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为**`主题_config.yml`**。\n\n### 1. 安装\n\n您可以直接到[BlueLake发布页](https://github.com/chaooo/hexo-theme-BlueLake)下载，然后解压拷贝到`themes`目录下，修改配置即可。\n不过我还是推荐使用`GIT`来checkout代码，之后也可以通过`git pull`来快速更新。\n\n#### 1.1 安装主题\n\n在根目录下打开终端窗口：\n``` bash git bash\n$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake\n```\n\n#### 1.2 安装主题渲染器\n\nBlueLake是基于`jade`和`stylus`写的，所以需要安装`hexo-renderer-jade`和`hexo-renderer-stylus`来渲染。\n``` bash git bash\n$ npm install hexo-renderer-jade@0.3.0 --save\n$ npm install hexo-renderer-stylus --save\n```\n\n#### 1.3 启用主题\n\n打开`根_config.yml`配置文件，找到theme字段，将其值改为`BlueLake`(先确认主题文件夹名称是否为BlueLake)。\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntheme: BlueLake\n```\n\n#### 1.4 验证\n\n首先启动 Hexo 本地站点，并开启调试模式：\n``` bash git bash\n$ hexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：`INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.`\n此时即可使用浏览器访问 `http://localhost:4000`，检查站点是否正确运行。\n\n#### 1.5 更新主题\n\n今后若主题添加了新功能正是您需要的，您可以直接`git pull`来更新主题。\n``` bash git bash\ncd themes/BlueLake\ngit pull\n```\n\n### 2. 配置\n\n#### 2.1 配置网站头部显示文字\n\n打开`根_config.yml`，找到：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\ntitle: \nsubtitle: \ndescription: \nauthor: \n```\n`title`和`subtitle`分别是网站主标题和副标题，会显示在网站头部；`description`在网站界面不会显示，内容会加入网站源码的`meta`标签中，主要用于SEO；`author`就填写网站所有者的名字，会在网站底部的`Copyright`处有所显示。\n\n#### 2.2 设置语言\n\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在`根_config.yml`配置如下：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\nlanguage: zh-CN\n```\n\n#### 2.3 设置菜单\n\n打开`主题_config.yml`，找到：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n主题默认是展示四个菜单，即`主页home`，`归档archive`，`关于about`，`订阅RSS`；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。\n每个页面底部的`footer`中`联系博主`的三个图标分别是`邮箱`，`微博主页链接地址`，`GitHUb个人页链接地址`，直接使用`主题_config.yml`中`about页面`的配置，若不需要about页面，只需要如下配置就好：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  github_url: ## github主页链接地址\n```\n\n##### 2.3.1 添加about页\n\n此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\n``` bash git bash\n$ hexo new page 'about'\n```\n打开`主题_config.yml`，补全关于我页面的详细信息：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n# About page \nabout:\n  photo_url: ## 头像的链接地址\n  email: ## 个人邮箱 \n  weibo_url: ## 微博主页链接地址\n  weibo_name: ## 微博用户名 \n  github_url: ## github主页链接地址\n  github_name: ## github用户名\n```\n当然您也可以自定义重新布局about页面，只需要修改`layout/page.jade`模板就好。\n\n##### 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n\n在根目录下打开命令行窗口：\n``` bash git bash\n$ npm install hexo-generator-feed --save\n$ npm install hexo-generator-sitemap --save\n$ npm install hexo-generator-baidu-sitemap --save\n```\n添加`主题_config.yml`配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\n\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n#### 2.4 添加本地搜索\n默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件[hexo-generator-json-content](https://github.com/alexbruno/hexo-generator-json-content)来创建JSON数据文件：\n``` bash git bash\n$ npm install hexo-generator-json-content@2.2.0 --save\n```\n然后在`根_config.yml`添加配置：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n最后在`主题_config.yml`添加配置：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nlocal_search: true\n```\n\n#### 2.5 修改站点图标\n\n站点图标存放在主题的`Source`目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。\n您需要准备一张ico格式并命名为** favicon.ico **，请将其放入hexo目录的`source`文件夹，建议大小：32px X 32px。\n您需要为苹果设备添加网站徽标，请命名为** apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。\n(有很多网站都可以在线生成ico格式的图片。)\n\n#### 2.6 添加站点关键字\n\n请在hexo目录的`根_config.yml`中添加keywords字段，如：\n``` yml 根_config.yml https://hexo.io/zh-cn/docs/configuration.html _config.yml\n# Site\ntitle: Hexo\nsubtitle: 副标题\ndescription: 网站简要描述,如：Charles·Zheng's blog.\nkeywords: 网站关键字, key, key1, key2, key3\nauthor: Charles\nlanguage: zh-CN\n```\n\n#### 2.7 首页添加文章置顶\n\n在根目录下打开命令行窗口安装：\n``` bash git bash\n$ npm uninstall hexo-generator-index --save\n$ npm install hexo-generator-index-pin-top --save\n```\n然后在需要置顶的文章的Front-matter中加上top: true即可。\n``` md\n---\ntitle: BlueLake博客主题的详细配置\ntags: [hexo,BlueLake]\ncategories: hexo博客折腾\ntop: true\n---\n```\n\n#### 2.8 更换主题背景和添加文章版权信息\n更换主题背景为深色\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\ndark: true #true/false\n```\n添加文章版权信息\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \n# Theme tone\n#Copyright\ncopyright: \n  enable: true #true/false  \n  describe: 转载请注明出处(必须保留原文作者署名原文链接) #自定义描述替换默认描述\n```\n\n#### 2.9 其他配置\n`主题_config.yml`的其他配置\n1. `show_category_count`——是否显示分类下的文章数。\n2. `widgets_on_small_screens`——是否在小屏显示侧边栏，若`true`,则侧边栏挂件将显示在底部。\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nshow_category_count: true \nwidgets_on_small_screens: true \n```\n\n### 3.集成第三方服务\n\n#### 3.1 添加评论\n\n目前主题集成六种第三方评论，分别是[多说评论](http://duoshuo.com)、[Disqus评论](https://disqus.com)、[来必力评论](https://livere.com)、[友言评论](http://www.uyan.cc/)、[网易云跟帖评论](https://gentie.163.com/info.html)、[畅言评论](http://changyan.kuaizhan.com)，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。\n1. 注册并获得代码。\n  - 若使用[多说评论](http://duoshuo.com)，注册多说后获得short_name。\n  - 若使用[Disqus评论](https://disqus.com)，注册Disqus后获得short_name。\n  - 若使用[来必力评论](https://livere.com)，注册来必力,获得data-uid。\n  - 若使用[友言评论](http://www.uyan.cc/)，注册友言,获得uid。\n  - 若使用[网易云跟帖评论](https://gentie.163.com/info.html)，注册网易云跟帖,获得productKey。\n  - 若使用[畅言评论](http://changyan.kuaizhan.com)，注册畅言，获得appid，appkey。\n2. 配置`主题_config.yml`：\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\n#Cmments\ncomment:\n  duoshuo: ## duoshuo_shortname\n  disqus: ## disqus_shortname\n  livere: ## 来必力(data-uid)\n  uyan: ## 友言(uid)\n  cloudTie: ## 网易云跟帖(productKey)\n  changyan: ## 畅言需在下方配置两个参数，此处不填。\n    appid: ## 畅言(appid)\n    appkey: ##畅言(appkey)\n```\n\n#### 3.2 百度统计\n\n1. 登录[百度统计](http://tongji.baidu.com/)，定位到站点的代码获取页面。\n2. 复制`//hm.baidu.com/hm.js?`后面那串统计脚本id(假设为：8006843039519956000)\n3. 配置`主题_config.yml`:\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml \nbaidu_analytics: 8006843039519956000\n```\n> 注意： `baidu_analytics`不是你的百度`id`或者百度统计`id`\n如若使用谷歌统计，配置方法与百度统计类似。\n\n#### 3.3 卜算子阅读次数统计\n\n``` yml 主题_config.yml https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml themes/BlueLake/_config.yml\nbusuanzi: true\n```\n若设置为`true`将计算文章的阅读量(Hits)，并显示在文章标题下的`小手图标`旁。\n\n#### 3.4 微博秀\n\n微博秀挂件的代码放在`layout/_widget/weibo.jade`下，需要您去[微博开放平台](http://open.weibo.com/)获取您自己的微博秀代码来替换。\n1. 登录[微博开放平台](http://open.weibo.com/)，选择微博秀。\n2. 为了与主题风格统一，作如下配置\n  - 基础设置：高`400px`；勾选宽度自适应；颜色选择`白色`；\n  - 样式设置：主字色`#333`；链接色`#40759b`；鼠标悬停色`#f7f8f8`；\n  - 模块设置：去掉`标题`、`边框`、`粉丝`的勾选框，只留`微博`。\n3. 复制代码里`src=\"\"`里引号包裹的内容，替换到`layout/_widget/weibo.jade`\n{% codeblock weibo.jade lang:stylus mark:1,7-8,10 https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade layout/_widget/weibo.jade %}\n.widget\n  .widget-title\n    i(class='fa fa-weibo')= ' ' + __('新浪微博')\n  iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=400&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=1&isFans=0&uid=1700139362&verifier=85be6061&colors=d6f3f7,ffffff,333,40759b,f7f8f8&dpc=1\")\n{% endcodeblock %}\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。\n> 注意：最主要是是要把`src`里`uid=`和`verifier=`后面的字段替换为您自己代码里的就好。","slug":"BlueLake博客主题的详细配置","published":1,"updated":"2019-07-20T14:09:22.498Z","_id":"cjyblnrst001jxwt3c3slimry","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p><a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake主题</a>写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>\n<a id=\"more\"></a>\n<p>在阅读本文之前，假定您已经成功安装了<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<blockquote>\n<p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>您可以直接到<a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p>\n<h4 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">BlueLake</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\n<h4 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><h4 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> </span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> </span><br><span class=\"line\"><span class=\"attr\">description:</span> </span><br><span class=\"line\"><span class=\"attr\">author:</span></span><br></pre></td></tr></table></figure>\n\n<p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p>\n<h4 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">archives/</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># - page: about</span></span><br><span class=\"line\">  <span class=\"comment\">#   directory: about/</span></span><br><span class=\"line\">  <span class=\"comment\">#   icon: fa-user</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">rss</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></table></figure>\n\n<p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">'about'</span></span><br></pre></td></tr></table></figure>\n\n<p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  photo_url:</span> <span class=\"comment\">## 头像的链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  weibo_name:</span> <span class=\"comment\">## 微博用户名 </span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_name:</span> <span class=\"comment\">## github用户名</span></span><br></pre></td></tr></table></figure>\n\n<p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p>\n<h5 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n\n<p>添加<code>主题_config.yml</code>配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Plugins:</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-feed</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-sitemap</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-baidu-sitemap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">atom</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">  limit:</span> <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>来创建JSON数据文件：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>根_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后在<code>主题_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">local_search:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为** favicon.ico <strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为</strong> apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h4 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站简要描述,如：Charles·Zheng's</span> <span class=\"string\">blog.</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站关键字,</span> <span class=\"string\">key,</span> <span class=\"string\">key1,</span> <span class=\"string\">key2,</span> <span class=\"string\">key3</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Charles</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-7-首页添加文章置顶\"><a href=\"#2-7-首页添加文章置顶\" class=\"headerlink\" title=\"2.7 首页添加文章置顶\"></a>2.7 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm uninstall hexo-generator-index --save</span><br><span class=\"line\">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: BlueLake博客主题的详细配置</span><br><span class=\"line\">tags: [hexo,BlueLake]</span><br><span class=\"line\">categories: hexo博客折腾</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-8-更换主题背景和添加文章版权信息\"><a href=\"#2-8-更换主题背景和添加文章版权信息\" class=\"headerlink\" title=\"2.8 更换主题背景和添加文章版权信息\"></a>2.8 更换主题背景和添加文章版权信息</h4><p>更换主题背景为深色</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"attr\">dark:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false</span></span><br></pre></td></tr></table></figure>\n\n<p>添加文章版权信息</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"comment\">#Copyright</span></span><br><span class=\"line\"><span class=\"attr\">copyright:</span> </span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false  </span></span><br><span class=\"line\"><span class=\"attr\">  describe:</span> <span class=\"string\">转载请注明出处(必须保留原文作者署名原文链接)</span> <span class=\"comment\">#自定义描述替换默认描述</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-9-其他配置\"><a href=\"#2-9-其他配置\" class=\"headerlink\" title=\"2.9 其他配置\"></a>2.9 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p>\n<ol>\n<li><code>show_category_count</code>——是否显示分类下的文章数。</li>\n<li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">show_category_count:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"attr\">widgets_on_small_screens:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h3><h4 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>、<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>、<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>、<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>、<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>、<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。</p>\n<ol>\n<li>注册并获得代码。<ul>\n<li>若使用<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>，注册多说后获得short_name。</li>\n<li>若使用<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>，注册Disqus后获得short_name。</li>\n<li>若使用<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>，注册来必力,获得data-uid。</li>\n<li>若使用<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>，注册友言,获得uid。</li>\n<li>若使用<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li>\n<li>若使用<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，注册畅言，获得appid，appkey。</li>\n</ul>\n</li>\n<li>配置<code>主题_config.yml</code>：<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Cmments</span></span><br><span class=\"line\"><span class=\"attr\">comment:</span></span><br><span class=\"line\"><span class=\"attr\">  duoshuo:</span> <span class=\"comment\">## duoshuo_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  disqus:</span> <span class=\"comment\">## disqus_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  livere:</span> <span class=\"comment\">## 来必力(data-uid)</span></span><br><span class=\"line\"><span class=\"attr\">  uyan:</span> <span class=\"comment\">## 友言(uid)</span></span><br><span class=\"line\"><span class=\"attr\">  cloudTie:</span> <span class=\"comment\">## 网易云跟帖(productKey)</span></span><br><span class=\"line\"><span class=\"attr\">  changyan:</span> <span class=\"comment\">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class=\"line\"><span class=\"attr\">    appid:</span> <span class=\"comment\">## 畅言(appid)</span></span><br><span class=\"line\"><span class=\"attr\">    appkey:</span> <span class=\"comment\">##畅言(appkey)</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h4><ol>\n<li>登录<a href=\"http://tongji.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度统计</a>，定位到站点的代码获取页面。</li>\n<li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li>\n<li>配置<code>主题_config.yml</code>:<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"number\">8006843039519956000</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n</blockquote>\n<h4 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h4><figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p>\n<h4 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>获取您自己的微博秀代码来替换。</p>\n<ol>\n<li>登录<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，选择微博秀。</li>\n<li>为了与主题风格统一，作如下配置<ul>\n<li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li>\n<li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li>\n<li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li>\n</ul>\n</li>\n<li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class=\"highlight stylus\"><figcaption><span>weibo.jade</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade\" target=\"_blank\" rel=\"noopener\">layout/_widget/weibo.jade</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line marked\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=<span class=\"string\">'fa fa-weibo'</span>)= <span class=\"string\">' '</span> + __(<span class=\"string\">'新浪微博'</span>)</span><br><span class=\"line\">  iframe(<span class=\"attribute\">width</span>=<span class=\"string\">\"100%\"</span>,height=<span class=\"string\">\"400\"</span>,class=<span class=\"string\">\"share_self\"</span>,frameborder=<span class=\"string\">\"0\"</span>,scrolling=<span class=\"string\">\"no\"</span>,src=<span class=\"string\">\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\"</span>)</span><br></pre></td></tr></table></figure>\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote>\n<p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h3><p><a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake主题</a>写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>","more":"<p>在阅读本文之前，假定您已经成功安装了<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>\n<blockquote>\n<p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p>\n</blockquote>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><p>您可以直接到<a href=\"https://github.com/chaooo/hexo-theme-BlueLake\" target=\"_blank\" rel=\"noopener\">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p>\n<h4 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-安装主题渲染器\"><a href=\"#1-2-安装主题渲染器\" class=\"headerlink\" title=\"1.2 安装主题渲染器\"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-renderer-jade@0.3.0 --save</span><br><span class=\"line\">$ npm install hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-启用主题\"><a href=\"#1-3-启用主题\" class=\"headerlink\" title=\"1.3 启用主题\"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">BlueLake</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s --debug</span><br></pre></td></tr></table></figure>\n\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p>\n<h4 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> themes/BlueLake</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h3><h4 id=\"2-1-配置网站头部显示文字\"><a href=\"#2-1-配置网站头部显示文字\" class=\"headerlink\" title=\"2.1 配置网站头部显示文字\"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> </span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> </span><br><span class=\"line\"><span class=\"attr\">description:</span> </span><br><span class=\"line\"><span class=\"attr\">author:</span></span><br></pre></td></tr></table></figure>\n\n<p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p>\n<h4 id=\"2-2-设置语言\"><a href=\"#2-2-设置语言\" class=\"headerlink\" title=\"2.2 设置语言\"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-设置菜单\"><a href=\"#2-3-设置菜单\" class=\"headerlink\" title=\"2.3 设置菜单\"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">home</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">.</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-home</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">archives/</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-archive</span></span><br><span class=\"line\">  <span class=\"comment\"># - page: about</span></span><br><span class=\"line\">  <span class=\"comment\">#   directory: about/</span></span><br><span class=\"line\">  <span class=\"comment\">#   icon: fa-user</span></span><br><span class=\"line\"><span class=\"attr\">  - page:</span> <span class=\"string\">rss</span></span><br><span class=\"line\"><span class=\"attr\">    directory:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">    icon:</span> <span class=\"string\">fa-rss</span></span><br></pre></td></tr></table></figure>\n\n<p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-3-1-添加about页\"><a href=\"#2-3-1-添加about页\" class=\"headerlink\" title=\"2.3.1 添加about页\"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new page <span class=\"string\">'about'</span></span><br></pre></td></tr></table></figure>\n\n<p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># About page </span></span><br><span class=\"line\"><span class=\"attr\">about:</span></span><br><span class=\"line\"><span class=\"attr\">  photo_url:</span> <span class=\"comment\">## 头像的链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  email:</span> <span class=\"comment\">## 个人邮箱 </span></span><br><span class=\"line\"><span class=\"attr\">  weibo_url:</span> <span class=\"comment\">## 微博主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  weibo_name:</span> <span class=\"comment\">## 微博用户名 </span></span><br><span class=\"line\"><span class=\"attr\">  github_url:</span> <span class=\"comment\">## github主页链接地址</span></span><br><span class=\"line\"><span class=\"attr\">  github_name:</span> <span class=\"comment\">## github用户名</span></span><br></pre></td></tr></table></figure>\n\n<p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p>\n<h5 id=\"2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-feed --save</span><br><span class=\"line\">$ npm install hexo-generator-sitemap --save</span><br><span class=\"line\">$ npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>\n\n<p>添加<code>主题_config.yml</code>配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">Plugins:</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-feed</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-sitemap</span></span><br><span class=\"line\">  <span class=\"string\">hexo-generator-baidu-sitemap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">feed:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">atom</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">atom.xml</span></span><br><span class=\"line\"><span class=\"attr\">  limit:</span> <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">sitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">sitemap.xml</span></span><br><span class=\"line\"><span class=\"attr\">baidusitemap:</span></span><br><span class=\"line\"><span class=\"attr\">  path:</span> <span class=\"string\">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-4-添加本地搜索\"><a href=\"#2-4-添加本地搜索\" class=\"headerlink\" title=\"2.4 添加本地搜索\"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href=\"https://github.com/alexbruno/hexo-generator-json-content\" target=\"_blank\" rel=\"noopener\">hexo-generator-json-content</a>来创建JSON数据文件：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在<code>根_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">jsonContent:</span></span><br><span class=\"line\"><span class=\"attr\">  meta:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  pages:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">  posts:</span></span><br><span class=\"line\"><span class=\"attr\">    title:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    date:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    path:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    text:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    raw:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    content:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    slug:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    updated:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    comments:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    link:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    permalink:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    excerpt:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    categories:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    tags:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>最后在<code>主题_config.yml</code>添加配置：</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">local_search:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-5-修改站点图标\"><a href=\"#2-5-修改站点图标\" class=\"headerlink\" title=\"2.5 修改站点图标\"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为** favicon.ico <strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为</strong> apple-touch-icon.png **的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p>\n<h4 id=\"2-6-添加站点关键字\"><a href=\"#2-6-添加站点关键字\" class=\"headerlink\" title=\"2.6 添加站点关键字\"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：</p>\n<figure class=\"highlight yml\"><figcaption><span>根_config.yml</span><a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Site</span></span><br><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">Hexo</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站简要描述,如：Charles·Zheng's</span> <span class=\"string\">blog.</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站关键字,</span> <span class=\"string\">key,</span> <span class=\"string\">key1,</span> <span class=\"string\">key2,</span> <span class=\"string\">key3</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">Charles</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-CN</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-7-首页添加文章置顶\"><a href=\"#2-7-首页添加文章置顶\" class=\"headerlink\" title=\"2.7 首页添加文章置顶\"></a>2.7 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p>\n<figure class=\"highlight bash\"><figcaption><span>git bash</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm uninstall hexo-generator-index --save</span><br><span class=\"line\">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p>\n<figure class=\"highlight md\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: BlueLake博客主题的详细配置</span><br><span class=\"line\">tags: [hexo,BlueLake]</span><br><span class=\"line\">categories: hexo博客折腾</span><br><span class=\"line\">top: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-8-更换主题背景和添加文章版权信息\"><a href=\"#2-8-更换主题背景和添加文章版权信息\" class=\"headerlink\" title=\"2.8 更换主题背景和添加文章版权信息\"></a>2.8 更换主题背景和添加文章版权信息</h4><p>更换主题背景为深色</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"attr\">dark:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false</span></span><br></pre></td></tr></table></figure>\n\n<p>添加文章版权信息</p>\n<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Theme tone</span></span><br><span class=\"line\"><span class=\"comment\">#Copyright</span></span><br><span class=\"line\"><span class=\"attr\">copyright:</span> </span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span> <span class=\"comment\">#true/false  </span></span><br><span class=\"line\"><span class=\"attr\">  describe:</span> <span class=\"string\">转载请注明出处(必须保留原文作者署名原文链接)</span> <span class=\"comment\">#自定义描述替换默认描述</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-9-其他配置\"><a href=\"#2-9-其他配置\" class=\"headerlink\" title=\"2.9 其他配置\"></a>2.9 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p>\n<ol>\n<li><code>show_category_count</code>——是否显示分类下的文章数。</li>\n<li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">show_category_count:</span> <span class=\"literal\">true</span> </span><br><span class=\"line\"><span class=\"attr\">widgets_on_small_screens:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"3-集成第三方服务\"><a href=\"#3-集成第三方服务\" class=\"headerlink\" title=\"3.集成第三方服务\"></a>3.集成第三方服务</h3><h4 id=\"3-1-添加评论\"><a href=\"#3-1-添加评论\" class=\"headerlink\" title=\"3.1 添加评论\"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>、<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>、<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>、<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>、<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>、<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了。</p>\n<ol>\n<li>注册并获得代码。<ul>\n<li>若使用<a href=\"http://duoshuo.com\" target=\"_blank\" rel=\"noopener\">多说评论</a>，注册多说后获得short_name。</li>\n<li>若使用<a href=\"https://disqus.com\" target=\"_blank\" rel=\"noopener\">Disqus评论</a>，注册Disqus后获得short_name。</li>\n<li>若使用<a href=\"https://livere.com\" target=\"_blank\" rel=\"noopener\">来必力评论</a>，注册来必力,获得data-uid。</li>\n<li>若使用<a href=\"http://www.uyan.cc/\" target=\"_blank\" rel=\"noopener\">友言评论</a>，注册友言,获得uid。</li>\n<li>若使用<a href=\"https://gentie.163.com/info.html\" target=\"_blank\" rel=\"noopener\">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li>\n<li>若使用<a href=\"http://changyan.kuaizhan.com\" target=\"_blank\" rel=\"noopener\">畅言评论</a>，注册畅言，获得appid，appkey。</li>\n</ul>\n</li>\n<li>配置<code>主题_config.yml</code>：<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Cmments</span></span><br><span class=\"line\"><span class=\"attr\">comment:</span></span><br><span class=\"line\"><span class=\"attr\">  duoshuo:</span> <span class=\"comment\">## duoshuo_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  disqus:</span> <span class=\"comment\">## disqus_shortname</span></span><br><span class=\"line\"><span class=\"attr\">  livere:</span> <span class=\"comment\">## 来必力(data-uid)</span></span><br><span class=\"line\"><span class=\"attr\">  uyan:</span> <span class=\"comment\">## 友言(uid)</span></span><br><span class=\"line\"><span class=\"attr\">  cloudTie:</span> <span class=\"comment\">## 网易云跟帖(productKey)</span></span><br><span class=\"line\"><span class=\"attr\">  changyan:</span> <span class=\"comment\">## 畅言需在下方配置两个参数，此处不填。</span></span><br><span class=\"line\"><span class=\"attr\">    appid:</span> <span class=\"comment\">## 畅言(appid)</span></span><br><span class=\"line\"><span class=\"attr\">    appkey:</span> <span class=\"comment\">##畅言(appkey)</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"3-2-百度统计\"><a href=\"#3-2-百度统计\" class=\"headerlink\" title=\"3.2 百度统计\"></a>3.2 百度统计</h4><ol>\n<li>登录<a href=\"http://tongji.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度统计</a>，定位到站点的代码获取页面。</li>\n<li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li>\n<li>配置<code>主题_config.yml</code>:<figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">baidu_analytics:</span> <span class=\"number\">8006843039519956000</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<blockquote>\n<p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p>\n</blockquote>\n<h4 id=\"3-3-卜算子阅读次数统计\"><a href=\"#3-3-卜算子阅读次数统计\" class=\"headerlink\" title=\"3.3 卜算子阅读次数统计\"></a>3.3 卜算子阅读次数统计</h4><figure class=\"highlight yml\"><figcaption><span>主题_config.yml</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml\" target=\"_blank\" rel=\"noopener\">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">busuanzi:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p>\n<h4 id=\"3-4-微博秀\"><a href=\"#3-4-微博秀\" class=\"headerlink\" title=\"3.4 微博秀\"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>获取您自己的微博秀代码来替换。</p>\n<ol>\n<li>登录<a href=\"http://open.weibo.com/\" target=\"_blank\" rel=\"noopener\">微博开放平台</a>，选择微博秀。</li>\n<li>为了与主题风格统一，作如下配置<ul>\n<li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li>\n<li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li>\n<li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li>\n</ul>\n</li>\n<li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class=\"highlight stylus\"><figcaption><span>weibo.jade</span><a href=\"https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade\" target=\"_blank\" rel=\"noopener\">layout/_widget/weibo.jade</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line marked\">.widget</span><br><span class=\"line\">  .widget-title</span><br><span class=\"line\">    i(class=<span class=\"string\">'fa fa-weibo'</span>)= <span class=\"string\">' '</span> + __(<span class=\"string\">'新浪微博'</span>)</span><br><span class=\"line\">  iframe(<span class=\"attribute\">width</span>=<span class=\"string\">\"100%\"</span>,height=<span class=\"string\">\"400\"</span>,class=<span class=\"string\">\"share_self\"</span>,frameborder=<span class=\"string\">\"0\"</span>,scrolling=<span class=\"string\">\"no\"</span>,src=<span class=\"string\">\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\"</span>)</span><br></pre></td></tr></table></figure>\n这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote>\n<p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p>\n</blockquote>\n</li>\n</ol>"},{"title":"MongoDB学习笔记","date":"2016-07-30T10:20:16.000Z","_content":"\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","source":"_posts/MongoDB学习笔记.md","raw":"---\ntitle: MongoDB学习笔记\ndate: 2016-07-30 18:20:16\ntags: mongodb\ncategories: 数据库\n---\n\n## part1 安装配置\n\n### 一、安装：\n\n在mongodb官网下载对应自己电脑系统的安装包，地址为： [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)。\n<!-- more --> \n1、以Windows64bit为例，下载.msi文件双击安装。\n2、安装过程中，点击 \"Custom(自定义)\" 按钮来设置安装目录(D:\\MongoDB\\bin)。\n3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。\n4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod --dbpath D:\\MongoDB\\data\\db)\n``` bash\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --dbpath D:\\MongoDB\\data\\db\n```\n5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)\n``` bash\n  MongoDB shell version: 3.2.4  //mongodb版本\n  connecting to: test  //默认shell连接的是本机localhost 上面的test库\n```\n此时就可以操作数据库了。\n\n### 二、将MongoDB服务器作为Windows服务运行\n\n1、在D:\\MongoDB目录下创建mongodb.config,写入如下：\n``` bash\n  ## 数据库文件目录\n  dbpath=D:/MongoDB/data\n  ## 日志目录\n  logpath=D:/MongoDB/log/mongo.log\n  diaglog=3\n```\n2、常规命令(cmd管理员):\n```\n  D:\n  cd D:\\MongoDB\\bin\n  mongod --config D:\\MongoDB\\mongodb.config \n```\n3、若常规方式失败，则sc方式(cmd管理员)：\n```\n  D:\n  cd D:\\MongoDB\\bin\n  sc create mongodb binPath= \"D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config\" \n```\n访问地址：localhost:27017测试是否启动成功\n\n\n## part2 CRUD操作(Creat,Read,Update,Delete)\n\n### 一、基础：\n\n1、document(文档)\n\nMongoDB把所有数据存放在类似于JSON数据结构的文档内：\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" }\n```\n\n2、collection(集合)\n\n集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。\n``` json\n  { \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" }\n  { \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" }\n  { \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" }\n```\n\n3、database(数据库)\n\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。\n\n### 二、数据库操作：\n\n连接及运行mongoDB\n\"`show dbs`\"命令可以显示所有的数据的列表\n\"`db`\"命令可以显示当前数据库对象或集合\n\"`use`\"命令可以连接到一个指定的数据库\n数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。\n  1.不能是空字符串（\"\")。\n  2.不得含有' '（空格)、.、$、/、\\和\\0 (空宇符)。\n  3.应全部小写。\n  4.最多64字节。\n\n1、创建数据库：`use Database_Name`\n``` bash\n  use test  ##创建名为test的数据库\n```\n2、删除当前数据库：\n``` bash\n  db.dropDatabase()\n```\n\n### 三、文档操作（以 Collection_Name = col 为例）\n\n#### 1、插入：\n``` bash\n  db.col.insert(Document)     ##插入一条或多组数据\n  db.col.insertOne(Document)  ##插入一条数据\n  db.col.insertMany(Document) ##插入多条数据\n  ##例如：\n      db.col.insertOne({ \"item\": \"pencil\", \"type\": \"no.1\" })\n      db.col.insertMany([\n      { \"item\": \"dog\", \"type\": \"no.2\" },\n      { \"item\": \"apple\", \"type\": \"no.3\" },\n      { \"item\": \"orange\", \"type\": \"no.4\" }\n      ])\n```\n\n#### 2、删除：\n``` bash\n  db.col.remove({})                    ##删除所有数据\n  db.col.remove(query <,options>)\n      #  query: 查询条件(数据索引或名字)\n      #  ptions:两个可选参数\n      #      {justOne: <boolean>,     //默认false，删除所有匹配到的。\n      #       writeConcern: <document>//抛出异常的级别。\n      #      }\n  db.col.deleteOne(query <,options>)   ##同上，无justOne参数，只删除第一条\n  db.col.deleteMany(query <,options>)  ##同上，无justOne参数，只删除多条\n```\n\n### 3、更新：\n``` bash\n  db.col.update(query, update <,options>)\n      #  query:  查询条件(数据索引或名字)\n      #  update: 更新的内容，语法：{$set:query}\n      #  options:三个可选参数\n      #      {upsert: <boolean>,      //如果不存在update的记录，是否插入新数据，默认:false。\n      #       multi: <boolean>,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。\n      #       writeConcern: <document>//#抛出异常的级别。\n      #      }\n  ##例如：\n      db.col.update(\n          {\"type\": \"no.1\"}, \n          {$set: {\"item\": \"human\"}}, \n          {upsert: true, multi: true}\n          )\n  db.col.updateOne()                    ##同上，无multi参数，只更新第一条\n  db.col.updateMany()                   ##同上，无multi参数\n  db.col.replaceOne()                   ##同updateOne\n  db.col.save(document <,writeConcern>) ##通过传入的文档整个替换\n```\n##### insert 与 save的区别\n如果插入的数据的_id相同,save将会更新该文档,而insert将会报错\n\n##### update常用操作符\n``` bash\n  $set         ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.\n  $unset       ##删除文档中的一个字段.\n  $rename      ##重命名某个列\n  $inc         ##增长某个列\n  $setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段\n  $push        ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.\n  $pushAll     ##将多个数值一次存入数组.上面的push只能一个一个的存入\n  $addToSet    ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.\n  $pop         ##删除数组最后一个元素\n  $pull        ##删除数组中的指定的元素,如果删除的字段不是数组,会报错\n  $pullAll     ##删除数组中的多个值,跟pushAll与push的关系类似.\n```\n\n### 4、查询\n``` bash\n  db.col.find({})          ##查询所有文档\n  db.col.find().pretty()   ##以易读的方式来读取数据\n  db.collection.find(query, projection)\n      #  query：查询条件(数据索引或名字)\n      #  projection：可选。指定返回的字段。\n```\n\n#### 4.1、深入查询表达式\n``` bash\n  db.col.find()##查询所有\n  db.col.find({filed: value})                              ##等值查询\n  db.col.find({filed: {$ne: value}})                       ##不等于 $ne\n  db.col.find({filed: {$nin: [value1, value2, ...]}})      ##不能包含给定的值 $nin\n  db.col.find({filed: {$all: [value1, value2, ...]}})      ##必须包含所有给定的值 $all\n  db.col.find({filed: {$in: [value1, value2, ...]}})       ##只要包含一个或多个给定的值 $in\n  db.col.find({filed: {$exists:1}})                        ##存在filed字段的\n  db.col.find({filed: {$exists:0}})                        ##不存在filed字段的\n  db.col.find({filed: {$mod:[3,1]}})                       ##模三余一，$mod(取模操作)\n  db.col.find({$or: [{filed1: vulue1}, {filed2: vulue2}]}) ##或 $or\n  db.col.find({$nor: [{filed1: vulue1}, {filed2: vulue2}]})##排除 $nor\n  db.col.find({filed: {$size: 3}})                         ##返回值得数组是给定的长度(3) $size\n  db.col.find({$where: function(){return ...}})            ##回调，隐式迭代，符合条件才返回\n  db.col.find({$where: '...'}})                            ##同上\n  db.col.find({age: {$lt: 5}}).limit(3)                    ##查询age的值小于5，限制3条\n      #范围查询：\n      #    $lt  （小于）\n      #    $gt  （大于）\n      #    $lte （小于等于）\n      #    $gte （大于等于）\n      #    limit（限制显示）\n  db.col.find().skip(2).limit(3)                           ##跳过前两个文档查询后面三个\n      #  skip(num):表示跳过前面num个文档\n  db.col.find().sort({age: 1})                             ##查询后以age升序排列显示\n      #  sort():排序，这里 1 代表升序, -1 代表降序.\n  db.col.find({filed: /user.*/i})                          ##正则，查询filed以user开头不区分大小写（正则效率低）\n  db.col.find({filed: {$type: 1}})                         ##查找filed为双精度的文档\n      # 根据数据类型查询 $type\n      #      |类型　　　　　　　　|编号|\n      #      |双精度　　　　　　　|1 　|\n      #      |字符串　　　　　　　|2 　|\n      #      |对象　　　　　　　　|3   |\n      #      |数组　　　　　　　　|4   |\n      #      |二进制数据　　　　　|5   |\n      #      |对象ID　　　　　　　|7   |\n      #      |布尔值　　　　　　　|8   |\n      #      |日期　　　　　　　　|9   |\n      #      |空　　　　　　　　　|10  |\n      #      |正则表达式　　　　　|11  |\n      #      |JavaScript　　　　|13  |\n      #      |符号　　　　　　　　|14  |\n      #      |JavaScript(带范围)|15  |\n      #      |32位整数　　　　　　|16  |\n      #      |时间戳　　　　　　　|17  |\n      #      |64位整数　　　　　　|18  |\n      #      |最小键　　　　　　　|255 |\n      #      |最大键　　　　　　　|127 |\n```\n\n#### 4.2、group分组查询\ngroup做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。\n``` bash\n  group({\n    key:{字段:1},\n    initial:{变量:初始值},\n    $reduce:function(doc,prev){函数代码}\n  })\n```\n其中key下的字段代表,需要按哪个字段分组.\ninitial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.\n$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.\n\n栗子：如下我们按年龄分组,同级不同年龄的用户的多少:\n``` bash\n  db.user.find()\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n      { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.group({\n      key:{age:1},\n      initial:{count:0},\n      $reduce:function(doc,prev){\n          prev.count++\n      }\n  }); \n      [\n          {\"age\": 0, \"count\": 1},\n          {\"age\": 1, \"count\": 3},\n          {\"age\": 2, \"count\": 2}\n      ]\n\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      }\n  });\n    [\n        {\"age\": 0, \"users\": [\"user0\"]},\n        {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n        {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n    ]\n```\n\n另外本函数还有两个可选参数 condition 和 finalize\ncondition就是分组的条件筛选类似mysql中的having\n``` bash\n  db.user.group({\n      key:{age:1},\n      initial:{users:[]},\n      $reduce:function(doc,prev){\n          prev.users.push(doc.name)\n      },\n      condition:{age:{$gt:0}}})\n　##筛选出age大于0的:\n  [\n      {\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]},\n      {\"age\": 2, \"users\": [\"user2\", \"user5\"]}\n  ]\n```\n\n#### 4.3、count统计\n``` bash\n  db.goods.count()            ##统计该集合总数\n  db.goods.count({cat_id: 3}) ##统计cat_id=3的总数\n```\n\n#### 4.4、distinct排重\n``` bash\n db.user.find()\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 }\n    { \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 }\n\n  db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象;\n      [0, 1, 2]\n```\n#### 4.5、子文档查询$elemMatch\n\nelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。\n注意：\n(1)数组中元素是内嵌文档。\n(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。\n假设集合school有如下数据：\n``` bash\n{\n _id: 1,\n zipcode: 63109,\n students: [\n              { name: \"john\", school: 102, age: 10 },\n              { name: \"jess\", school: 102, age: 11 },\n              { name: \"jeff\", school: 108, age: 15 }\n           ]\n}\n{\n _id: 2,\n zipcode: 63110,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 3,\n zipcode: 63109,\n students: [\n              { name: \"ajax\", school: 100, age: 7 },\n              { name: \"achilles\", school: 100, age: 8 },\n           ]\n}\n{\n _id: 4,\n zipcode: 63109,\n students: [\n              { name: \"barney\", school: 102, age: 7 },\n           ]\n}\n```\n下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。\n``` bash\n  db.school.find({zipcode: 63109 },{ students: { $elemMatch: { school: 102 } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"john\", \"school\":102, \"age\":10}]}\n  {\"_id\": 3}\n  {\"_id\": 4, \"students\": [{\"name\":\"barney\", \"school\":102, \"age\":7}]}\n```\n查询结果说明：\n`_id为1的文档`，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。\n`_id为3的文档`，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含\"students\"字段。\n\n$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。\n``` bash\ndb.school.find( { zipcode: 63109 },{ students: { $elemMatch: { school: 102, age: { $gt: 10} } } } );\n\n  {\"_id\": 1, \"students\": [{\"name\":\"jess\", \"school\":102, \"age\":11}]}\n  {\"_id\": 3}\n  {\"_id\": 4}\n```\n","slug":"MongoDB学习笔记","published":1,"updated":"2019-07-07T06:36:14.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyblnrsw001mxwt3vx0jjl6w","content":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\" target=\"_blank\" rel=\"noopener\">http://www.mongodb.org/downloads</a>。</p>\n<a id=\"more\"></a> \n<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config</span><br></pre></td></tr></table></figure>\n\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot;</span><br></pre></td></tr></table></figure>\n\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil2\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">550</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil3\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">800</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"orange\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.4\"</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">\"item\"</span>: <span class=\"string\">\"human\"</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">'...'</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"count\"</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"count\"</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"count\"</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user0\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">\"age\"</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"john\"</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jess\"</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jeff\"</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"barney\"</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"john\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 4, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"barney\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"jess\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 4&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h2 id=\"part1-安装配置\"><a href=\"#part1-安装配置\" class=\"headerlink\" title=\"part1 安装配置\"></a>part1 安装配置</h2><h3 id=\"一、安装：\"><a href=\"#一、安装：\" class=\"headerlink\" title=\"一、安装：\"></a>一、安装：</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href=\"http://www.mongodb.org/downloads\" target=\"_blank\" rel=\"noopener\">http://www.mongodb.org/downloads</a>。</p>","more":"<p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。<br>3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。<br>4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\"><span class=\"built_in\">cd</span> D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --dbpath D:\\MongoDB\\data\\db</span><br></pre></td></tr></table></figure>\n\n<p>5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class=\"line\">connecting to: <span class=\"built_in\">test</span>  //默认shell连接的是本机localhost 上面的<span class=\"built_in\">test</span>库</span><br></pre></td></tr></table></figure>\n\n<p>此时就可以操作数据库了。</p>\n<h3 id=\"二、将MongoDB服务器作为Windows服务运行\"><a href=\"#二、将MongoDB服务器作为Windows服务运行\" class=\"headerlink\" title=\"二、将MongoDB服务器作为Windows服务运行\"></a>二、将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\\MongoDB目录下创建mongodb.config,写入如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 数据库文件目录</span></span><br><span class=\"line\">dbpath=D:/MongoDB/data</span><br><span class=\"line\"><span class=\"comment\">## 日志目录</span></span><br><span class=\"line\">logpath=D:/MongoDB/<span class=\"built_in\">log</span>/mongo.log</span><br><span class=\"line\">diaglog=3</span><br></pre></td></tr></table></figure>\n\n<p>2、常规命令(cmd管理员):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">mongod --config D:\\MongoDB\\mongodb.config</span><br></pre></td></tr></table></figure>\n\n<p>3、若常规方式失败，则sc方式(cmd管理员)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:</span><br><span class=\"line\">cd D:\\MongoDB\\bin</span><br><span class=\"line\">sc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot;</span><br></pre></td></tr></table></figure>\n\n<p>访问地址：localhost:27017测试是否启动成功</p>\n<h2 id=\"part2-CRUD操作-Creat-Read-Update-Delete\"><a href=\"#part2-CRUD操作-Creat-Read-Update-Delete\" class=\"headerlink\" title=\"part2 CRUD操作(Creat,Read,Update,Delete)\"></a>part2 CRUD操作(Creat,Read,Update,Delete)</h2><h3 id=\"一、基础：\"><a href=\"#一、基础：\" class=\"headerlink\" title=\"一、基础：\"></a>一、基础：</h3><p>1、document(文档)</p>\n<p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>2、collection(集合)</p>\n<p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">500</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil2\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">550</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;</span><br><span class=\"line\">&#123; <span class=\"attr\">\"item\"</span>: <span class=\"string\">\"pencil3\"</span>, <span class=\"attr\">\"qty\"</span>: <span class=\"number\">800</span>, <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3、database(数据库)</p>\n<p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p>\n<h3 id=\"二、数据库操作：\"><a href=\"#二、数据库操作：\" class=\"headerlink\" title=\"二、数据库操作：\"></a>二、数据库操作：</h3><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p>\n<p>1、创建数据库：<code>use Database_Name</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use <span class=\"built_in\">test</span>  <span class=\"comment\">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure>\n\n<p>2、删除当前数据库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.dropDatabase()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、文档操作（以-Collection-Name-col-为例）\"><a href=\"#三、文档操作（以-Collection-Name-col-为例）\" class=\"headerlink\" title=\"三、文档操作（以 Collection_Name = col 为例）\"></a>三、文档操作（以 Collection_Name = col 为例）</h3><h4 id=\"1、插入：\"><a href=\"#1、插入：\" class=\"headerlink\" title=\"1、插入：\"></a>1、插入：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.insert(Document)     <span class=\"comment\">##插入一条或多组数据</span></span><br><span class=\"line\">db.col.insertOne(Document)  <span class=\"comment\">##插入一条数据</span></span><br><span class=\"line\">db.col.insertMany(Document) <span class=\"comment\">##插入多条数据</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.insertOne(&#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"pencil\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span> &#125;)</span><br><span class=\"line\">    db.col.insertMany([</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.2\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"apple\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.3\"</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">\"item\"</span>: <span class=\"string\">\"orange\"</span>, <span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.4\"</span> &#125;</span><br><span class=\"line\">    ])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、删除：\"><a href=\"#2、删除：\" class=\"headerlink\" title=\"2、删除：\"></a>2、删除：</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.remove(&#123;&#125;)                    <span class=\"comment\">##删除所有数据</span></span><br><span class=\"line\">db.col.remove(query &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query: 查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  ptions:两个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\">db.col.deleteOne(query &lt;,options&gt;)   <span class=\"comment\">##同上，无justOne参数，只删除第一条</span></span><br><span class=\"line\">db.col.deleteMany(query &lt;,options&gt;)  <span class=\"comment\">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3、更新：\"><a href=\"#3、更新：\" class=\"headerlink\" title=\"3、更新：\"></a>3、更新：</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.update(query, update &lt;,options&gt;)</span><br><span class=\"line\">    <span class=\"comment\">#  query:  查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">#  options:三个可选参数</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class=\"line\">    <span class=\"comment\">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class=\"line\">    <span class=\"comment\">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class=\"line\">    <span class=\"comment\">#      &#125;</span></span><br><span class=\"line\"><span class=\"comment\">##例如：</span></span><br><span class=\"line\">    db.col.update(</span><br><span class=\"line\">        &#123;<span class=\"string\">\"type\"</span>: <span class=\"string\">\"no.1\"</span>&#125;, </span><br><span class=\"line\">        &#123;<span class=\"variable\">$set</span>: &#123;<span class=\"string\">\"item\"</span>: <span class=\"string\">\"human\"</span>&#125;&#125;, </span><br><span class=\"line\">        &#123;upsert: <span class=\"literal\">true</span>, multi: <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">db.col.updateOne()                    <span class=\"comment\">##同上，无multi参数，只更新第一条</span></span><br><span class=\"line\">db.col.updateMany()                   <span class=\"comment\">##同上，无multi参数</span></span><br><span class=\"line\">db.col.replaceOne()                   <span class=\"comment\">##同updateOne</span></span><br><span class=\"line\">db.col.save(document &lt;,writeConcern&gt;) <span class=\"comment\">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"insert-与-save的区别\"><a href=\"#insert-与-save的区别\" class=\"headerlink\" title=\"insert 与 save的区别\"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p>\n<h5 id=\"update常用操作符\"><a href=\"#update常用操作符\" class=\"headerlink\" title=\"update常用操作符\"></a>update常用操作符</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$set</span>         <span class=\"comment\">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$unset</span>       <span class=\"comment\">##删除文档中的一个字段.</span></span><br><span class=\"line\"><span class=\"variable\">$rename</span>      <span class=\"comment\">##重命名某个列</span></span><br><span class=\"line\"><span class=\"variable\">$inc</span>         <span class=\"comment\">##增长某个列</span></span><br><span class=\"line\"><span class=\"variable\">$setOnInsert</span> <span class=\"comment\">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class=\"line\"><span class=\"variable\">$push</span>        <span class=\"comment\">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class=\"line\"><span class=\"variable\">$pushAll</span>     <span class=\"comment\">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class=\"line\"><span class=\"variable\">$addToSet</span>    <span class=\"comment\">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class=\"line\"><span class=\"variable\">$pop</span>         <span class=\"comment\">##删除数组最后一个元素</span></span><br><span class=\"line\"><span class=\"variable\">$pull</span>        <span class=\"comment\">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class=\"line\"><span class=\"variable\">$pullAll</span>     <span class=\"comment\">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4、查询\"><a href=\"#4、查询\" class=\"headerlink\" title=\"4、查询\"></a>4、查询</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find(&#123;&#125;)          <span class=\"comment\">##查询所有文档</span></span><br><span class=\"line\">db.col.find().pretty()   <span class=\"comment\">##以易读的方式来读取数据</span></span><br><span class=\"line\">db.collection.find(query, projection)</span><br><span class=\"line\">    <span class=\"comment\">#  query：查询条件(数据索引或名字)</span></span><br><span class=\"line\">    <span class=\"comment\">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-1、深入查询表达式\"><a href=\"#4-1、深入查询表达式\" class=\"headerlink\" title=\"4.1、深入查询表达式\"></a>4.1、深入查询表达式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.col.find()<span class=\"comment\">##查询所有</span></span><br><span class=\"line\">db.col.find(&#123;filed: value&#125;)                              <span class=\"comment\">##等值查询</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$ne</span>: value&#125;&#125;)                       <span class=\"comment\">##不等于 $ne</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##不能包含给定的值 $nin</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class=\"comment\">##必须包含所有给定的值 $all</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class=\"comment\">##只要包含一个或多个给定的值 $in</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:1&#125;&#125;)                        <span class=\"comment\">##存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$exists</span>:0&#125;&#125;)                        <span class=\"comment\">##不存在filed字段的</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$mod</span>:[3,1]&#125;&#125;)                       <span class=\"comment\">##模三余一，$mod(取模操作)</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class=\"comment\">##或 $or</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class=\"comment\">##排除 $nor</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$size</span>: 3&#125;&#125;)                         <span class=\"comment\">##返回值得数组是给定的长度(3) $size</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"function\"><span class=\"title\">function</span></span>()&#123;<span class=\"built_in\">return</span> ...&#125;&#125;)            <span class=\"comment\">##回调，隐式迭代，符合条件才返回</span></span><br><span class=\"line\">db.col.find(&#123;<span class=\"variable\">$where</span>: <span class=\"string\">'...'</span>&#125;&#125;)                            <span class=\"comment\">##同上</span></span><br><span class=\"line\">db.col.find(&#123;age: &#123;<span class=\"variable\">$lt</span>: 5&#125;&#125;).<span class=\"built_in\">limit</span>(3)                    <span class=\"comment\">##查询age的值小于5，限制3条</span></span><br><span class=\"line\">    <span class=\"comment\">#范围查询：</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lt  （小于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gt  （大于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $lte （小于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    $gte （大于等于）</span></span><br><span class=\"line\">    <span class=\"comment\">#    limit（限制显示）</span></span><br><span class=\"line\">db.col.find().skip(2).<span class=\"built_in\">limit</span>(3)                           <span class=\"comment\">##跳过前两个文档查询后面三个</span></span><br><span class=\"line\">    <span class=\"comment\">#  skip(num):表示跳过前面num个文档</span></span><br><span class=\"line\">db.col.find().sort(&#123;age: 1&#125;)                             <span class=\"comment\">##查询后以age升序排列显示</span></span><br><span class=\"line\">    <span class=\"comment\">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class=\"line\">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class=\"comment\">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class=\"line\">db.col.find(&#123;filed: &#123;<span class=\"variable\">$type</span>: 1&#125;&#125;)                         <span class=\"comment\">##查找filed为双精度的文档</span></span><br><span class=\"line\">    <span class=\"comment\"># 根据数据类型查询 $type</span></span><br><span class=\"line\">    <span class=\"comment\">#      |类型　　　　　　　　|编号|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |双精度　　　　　　　|1 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |字符串　　　　　　　|2 　|</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象　　　　　　　　|3   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |数组　　　　　　　　|4   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |二进制数据　　　　　|5   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |对象ID　　　　　　　|7   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |布尔值　　　　　　　|8   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |日期　　　　　　　　|9   |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |空　　　　　　　　　|10  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |正则表达式　　　　　|11  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript　　　　|13  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |符号　　　　　　　　|14  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |JavaScript(带范围)|15  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |32位整数　　　　　　|16  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |时间戳　　　　　　　|17  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |64位整数　　　　　　|18  |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最小键　　　　　　　|255 |</span></span><br><span class=\"line\">    <span class=\"comment\">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-2、group分组查询\"><a href=\"#4-2、group分组查询\" class=\"headerlink\" title=\"4.2、group分组查询\"></a>4.2、group分组查询</h4><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">group(&#123;</span><br><span class=\"line\">  key:&#123;字段:1&#125;,</span><br><span class=\"line\">  initial:&#123;变量:初始值&#125;,</span><br><span class=\"line\">  <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p>\n<p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">    &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;count:0&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">    [</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"count\"</span>: 1&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"count\"</span>: 3&#125;,</span><br><span class=\"line\">        &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"count\"</span>: 2&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\"></span><br><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    reduce:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">  [</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 0, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user0\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">      &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">  ]</span><br></pre></td></tr></table></figure>\n\n<p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.group(&#123;</span><br><span class=\"line\">    key:&#123;age:1&#125;,</span><br><span class=\"line\">    initial:&#123;users:[]&#125;,</span><br><span class=\"line\">    <span class=\"variable\">$reduce</span>:<span class=\"keyword\">function</span>(doc,prev)&#123;</span><br><span class=\"line\">        prev.users.push(doc.name)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    condition:&#123;age:&#123;<span class=\"variable\">$gt</span>:0&#125;&#125;&#125;)</span><br><span class=\"line\">　<span class=\"comment\">##筛选出age大于0的:</span></span><br><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 1, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user1\"</span>, <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"user4\"</span>]&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"age\"</span>: 2, <span class=\"string\">\"users\"</span>: [<span class=\"string\">\"user2\"</span>, <span class=\"string\">\"user5\"</span>]&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-3、count统计\"><a href=\"#4-3、count统计\" class=\"headerlink\" title=\"4.3、count统计\"></a>4.3、count统计</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.goods.count()            <span class=\"comment\">##统计该集合总数</span></span><br><span class=\"line\">db.goods.count(&#123;cat_id: 3&#125;) <span class=\"comment\">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4、distinct排重\"><a href=\"#4-4、distinct排重\" class=\"headerlink\" title=\"4.4、distinct排重\"></a>4.4、distinct排重</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b2\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user0\"</span>, <span class=\"string\">\"age\"</span> : 0 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b3\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user1\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b4\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user2\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b5\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user3\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b6\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user4\"</span>, <span class=\"string\">\"age\"</span> : 1 &#125;</span><br><span class=\"line\">   &#123; <span class=\"string\">\"_id\"</span> : ObjectId(<span class=\"string\">\"5198c286c686eb50e2c843b7\"</span>), <span class=\"string\">\"name\"</span> : <span class=\"string\">\"user5\"</span>, <span class=\"string\">\"age\"</span> : 2 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> db.user.distinct(<span class=\"string\">\"age\"</span>) <span class=\"comment\">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class=\"line\">     [0, 1, 2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-5、子文档查询-elemMatch\"><a href=\"#4-5、子文档查询-elemMatch\" class=\"headerlink\" title=\"4.5、子文档查询$elemMatch\"></a>4.5、子文档查询$elemMatch</h4><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 1,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"john\"</span>, school: 102, age: 10 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jess\"</span>, school: 102, age: 11 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"jeff\"</span>, school: 108, age: 15 &#125;</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 2,</span><br><span class=\"line\"> zipcode: 63110,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 3,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"ajax\"</span>, school: 100, age: 7 &#125;,</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"achilles\"</span>, school: 100, age: 8 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> _id: 4,</span><br><span class=\"line\"> zipcode: 63109,</span><br><span class=\"line\"> students: [</span><br><span class=\"line\">              &#123; name: <span class=\"string\">\"barney\"</span>, school: 102, age: 7 &#125;,</span><br><span class=\"line\">           ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"john\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:10&#125;]&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">\"_id\"</span>: 4, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"barney\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p>\n<p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class=\"variable\">$elemMatch</span>: &#123; school: 102, age: &#123; <span class=\"variable\">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 1, <span class=\"string\">\"students\"</span>: [&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"jess\"</span>, <span class=\"string\">\"school\"</span>:102, <span class=\"string\">\"age\"</span>:11&#125;]&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 3&#125;</span><br><span class=\"line\">  &#123;<span class=\"string\">\"_id\"</span>: 4&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"[post]","title":"Win10下配置Nginx+PHP-7+MySQL-5.6","date":"2019-02-22T03:39:12.000Z","_content":"\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","source":"_posts/Win10下配置Nginx-php7-mysql-5-6.md","raw":"---\nlayout: '[post]'\ntitle: Win10下配置Nginx+PHP-7+MySQL-5.6\ndate: 2019-02-22 11:39:12\ntags:\n---\n\n### 1. 软件下载\n  - Windows操作系统。\n  - Nginx，下载地址：[http://nginx.org/en/download.html](http://nginx.org/en/download.html)。\n  - PHP，下载地址：[http://php.net/downloads.php](http://php.net/downloads.php)（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。\n  - MySQL，下载地址：[https://www.mysql.com/downloads/](https://www.mysql.com/downloads/)。（选择社区版`Community`->`MySQL Community Server`->`MySQL Community Server 5.6`，根据Windows系统选择对应zip包）。\n<!-- more -->\n### 2. 软件安装\n在C盘新建安装目录`C:\\PHP`。\n#### 2.1 Nginx安装\n  Nginx本身就是绿色软件，下载zip安装包解压到`C:\\PHP`，打开目录`C:\\PHP\\nginx-1.15.8`双击nginx.exe就可以运行，然后在浏览器打开[http://127.0.0.1](http://127.0.0.1)，出现欢迎界面表示NGINX正常工作。\n  确认NGINX正常工作后在任务管理器中结束nginx.exe任务。\n#### 2.2 PHP安装\n  把PHP的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\php-7.3.2`。\n  cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。\n  将`C:\\PHP\\php-7.3.2`加入系统环境变量。\n#### 2.3 准备网站根目录\n  准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把`C:\\PHP\\web`作为我的网站根目录。\n  在根目录`C:\\PHP\\web`下新建一个info.php文件，输入如下内容：\n    ``` php\n    <?php\n        phpinfo();\n    ?>\n    ```\n#### 2.4 让nginx识别PHP\n  配置PHP (`C:\\PHP\\php-7.3.2`)\n  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:\n  在PHP根目录下修改配置文件`C:\\PHP\\php-7.3.2\\php.ini-development`并另存为`php.ini`,在其中修改或添加配置：\n  ```\n  cgi.fix_pathinfo=1\n  ```\n  配置nginx conf(`C:\\PHP\\nginx-1.15.8\\conf`)\n  在Nginx根目录下找到conf目录，编辑器打开`C:\\PHP\\nginx-1.15.8\\confnginx.conf`:\n    ```\n    error_log  logs/error.log; #打开error_log\n    http {\n\n        # ...\n\n        server {\n\n            # ...\n\n            location / {\n                root     C:\\PHP\\web; #配置根目录\n                index   index.html index.htm index.php;\n            }\n\n            # ...\n\n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            # 打开下面几行注释\n            location ~ \\.php$ {\n                root             C:\\PHP\\web; #配置根目录\n                fastcgi_pass     127.0.0.1:9000;\n                fastcgi_index    index.php;\n                #重要: 把下面 /scripts 修改成 $document_root\n                fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; \n                include          fastcgi_params;\n            }\n\n            # ...\n        }\n    }\n    ```\n#### 2.5 运行与测试\nnginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么`nginx.conf`中有这样一句`fastcgi_pass 127.0.0.1:9000;`。\n1. 在任务管理器中结束nginx.exe任务，然后到`C:\\PHP\\nginx-1.15.8`目录双击nginx.exe开启服务。\n2. 在命令行中，cd到php的home目录`C:\\PHP\\php-7.3.2`，然后执行如下命令：\n  ``` cmd\n  php-cgi.exe -b 127.0.0.1:9000 -c php.ini\n  ```\n3. 打开浏览器，输入 [http://127.0.0.1/info.php](http://127.0.0.1/info.php)，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。\n\n#### 2.6 MySQL安装\n  把MySQL的zip安装包解压到`C:\\PHP`，解压后PHP安装目录为：`C:\\PHP\\mysql-5.6.43-winx64`。\n  将`C:\\PHP\\mysql-5.6.43-winx64\\bin`加入系统环境变量。\n  修改配置文件`C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini`并另存为`my.ini`,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：\n    ```\n    basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录\n    datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data\n    ```\n  以管理员身份运行cmd,到安装目录的bin下，输入`mysqld -install`：\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin> mysqld -install\n    Service successfully installed.\n    ```\n  输入命令:`mysql --version`,正常会显示版本信息。\n  输入命令:`net start mysql`启动服务(停止命令：net stop mysql):\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>net start mysql\n    MySQL 服务正在启动 ..\n    MySQL 服务已经启动成功。\n    ```\n  服务启动成功之后，输入命令：`mysql -u root -p`（第一次登录没有密码，直接按回车过）:\n    ```\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>mysql -u root -p\n    Enter password:\n    Welcome to the MySQL monitor.  Commands end with ; or \\g.\n    Your MySQL connection id is 1\n    Server version: 5.6.43 MySQL Community Server (GPL)\n    Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n    Oracle is a registered trademark of Oracle Corporation and/or its\n    affiliates. Other names may be trademarks of their respective\n    owners.\n    Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n    mysql>\n    ```\n  如出现`mysql>`,即登录成功。\n  输入命令`exit`,退出登录。\n    ```\n    mysql> exit\n    Bye\n    C:\\PHP\\mysql-5.6.43-winx64\\bin>\n    ```\n### 3. 制作自动启动脚本\n控制台就一直开着，很不方便。这个时候可以使用 [RunHiddenConsole.zip](https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip) 来得管理服务的启动与关闭。\n#### 3.1 启动脚本\n在目录`C:\\PHP`下新建一个`start.bat`作为启动脚本文件：\n``` bat\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n#### 3.2 停止脚本\n在目录`C:\\PHP`下新建一个`stop.bat`作为停止脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\n:请按任意键继续. . .\npause\n```\n#### 3.3 重启脚本\n在目录`C:\\PHP`下新建一个`restart.bat`作为重启脚本文件：\n``` bat\n:停止脚本\n@echo off\necho Stopping nginx...  \ntaskkill /F /IM nginx.exe > nul\necho nginx 已停止\n:换行\necho.\necho Stopping PHP FastCGI...\ntaskkill /F /IM php-cgi.exe > nul\necho FastCGI 已停止\necho.\n\n:启动脚本\n@echo off\nset php_home=./php-7.3.2\nset nginx_home=./nginx-1.15.8\n\nREM Windows 下无效\nREM set PHP_FCGI_CHILDREN=5\n\nREM 每个进程处理的最大请求数，或设置为 Windows 环境变量\nset PHP_FCGI_MAX_REQUESTS=1000\necho Starting PHP FastCGI...\nRunHiddenConsole %php_home%/php-cgi.exe -b 127.0.0.1:9000 -c %php_home%/php.ini\necho FastCGI 启动成功\necho.\necho Starting nginx...\nRunHiddenConsole %nginx_home%/nginx.exe -p %nginx_home%\necho nginx 启动成功\necho.\n:echo 15秒后自动退出\n:ping 0.0.0.0  -n 15 > null\n:请按任意键继续. . .\npause\n```\n### 4.最后\n我的根目录结构\n``` cmd\nC:\\PHP>dir\n 驱动器 C 中的卷是 系统\n 卷的序列号是 09C1-B27D\n\n C:\\PHP 的目录\n\n2019/02/22  15:46    <DIR>          .\n2019/02/22  15:46    <DIR>          ..\n2019/02/22  11:23    <DIR>          mysql-5.6.43-winx64\n2018/12/25  17:54    <DIR>          nginx-1.15.8\n2019/02/21  15:59    <DIR>          php-7.3.2\n2019/02/22  15:41               758 restart.bat\n2010/10/26  11:43             1,536 RunHiddenConsole.exe\n2019/02/22  15:41               549 start.bat\n2019/02/22  15:41               227 stop.bat\n2019/02/21  16:56    <DIR>          web\n               4 个文件          3,070 字节\n               6 个目录 100,959,772,672 可用字节\n```\n","slug":"Win10下配置Nginx-php7-mysql-5-6","published":1,"updated":"2019-07-07T03:06:11.448Z","comments":1,"photos":[],"link":"","_id":"cjyblnrsy001qxwt3fji98be9","content":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\" target=\"_blank\" rel=\"noopener\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。<a id=\"more\"></a>\n<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p>\n<p>  配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p>\n<ol>\n<li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p>\n</li>\n<li><p>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>\n</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure></p>\n<p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure></p>\n<p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p>\n<p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\" target=\"_blank\" rel=\"noopener\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<h3 id=\"1-软件下载\"><a href=\"#1-软件下载\" class=\"headerlink\" title=\"1. 软件下载\"></a>1. 软件下载</h3><ul>\n<li>Windows操作系统。</li>\n<li>Nginx，下载地址：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a>。</li>\n<li>PHP，下载地址：<a href=\"http://php.net/downloads.php\" target=\"_blank\" rel=\"noopener\">http://php.net/downloads.php</a>（nginx下php是以FastCGI的方式运行，所以我们下载非线程安全也就是nts的php包）。</li>\n<li>MySQL，下载地址：<a href=\"https://www.mysql.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.mysql.com/downloads/</a>。（选择社区版<code>Community</code>-&gt;<code>MySQL Community Server</code>-&gt;<code>MySQL Community Server 5.6</code>，根据Windows系统选择对应zip包）。","more":"<h3 id=\"2-软件安装\"><a href=\"#2-软件安装\" class=\"headerlink\" title=\"2. 软件安装\"></a>2. 软件安装</h3>在C盘新建安装目录<code>C:\\PHP</code>。<h4 id=\"2-1-Nginx安装\"><a href=\"#2-1-Nginx安装\" class=\"headerlink\" title=\"2.1 Nginx安装\"></a>2.1 Nginx安装</h4>Nginx本身就是绿色软件，下载zip安装包解压到<code>C:\\PHP</code>，打开目录<code>C:\\PHP\\nginx-1.15.8</code>双击nginx.exe就可以运行，然后在浏览器打开<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1</a>，出现欢迎界面表示NGINX正常工作。<br>确认NGINX正常工作后在任务管理器中结束nginx.exe任务。<h4 id=\"2-2-PHP安装\"><a href=\"#2-2-PHP安装\" class=\"headerlink\" title=\"2.2 PHP安装\"></a>2.2 PHP安装</h4>把PHP的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\php-7.3.2</code>。<br>cmd进行到安装目录，输入php.exe -v,正常会显示版本信息。<br>将<code>C:\\PHP\\php-7.3.2</code>加入系统环境变量。<h4 id=\"2-3-准备网站根目录\"><a href=\"#2-3-准备网站根目录\" class=\"headerlink\" title=\"2.3 准备网站根目录\"></a>2.3 准备网站根目录</h4>准备一个文件夹，作为网站的根目录，这个在下面的配置文件中会多次用到，我把<code>C:\\PHP\\web</code>作为我的网站根目录。<br>在根目录<code>C:\\PHP\\web</code>下新建一个info.php文件，输入如下内容：<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">    phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"2-4-让nginx识别PHP\"><a href=\"#2-4-让nginx识别PHP\" class=\"headerlink\" title=\"2.4 让nginx识别PHP\"></a>2.4 让nginx识别PHP</h4><p>  配置PHP (<code>C:\\PHP\\php-7.3.2</code>)<br>  在PHP根目录下找到php.ini-development文件，编辑器打开nginx.conf:<br>  在PHP根目录下修改配置文件<code>C:\\PHP\\php-7.3.2\\php.ini-development</code>并另存为<code>php.ini</code>,在其中修改或添加配置：<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cgi.fix_pathinfo=1</span><br></pre></td></tr></table></figure></p>\n<p>  配置nginx conf(<code>C:\\PHP\\nginx-1.15.8\\conf</code>)<br>  在Nginx根目录下找到conf目录，编辑器打开<code>C:\\PHP\\nginx-1.15.8\\confnginx.conf</code>:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error_log  logs/error.log; #打开error_log</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    # ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root     C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            index   index.html index.htm index.php;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\"></span><br><span class=\"line\">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class=\"line\">        # 打开下面几行注释</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            root             C:\\PHP\\web; #配置根目录</span><br><span class=\"line\">            fastcgi_pass     127.0.0.1:9000;</span><br><span class=\"line\">            fastcgi_index    index.php;</span><br><span class=\"line\">            #重要: 把下面 /scripts 修改成 $document_root</span><br><span class=\"line\">            fastcgi_param    SCRIPT_FILENAME  $document_root$fastcgi_script_name; </span><br><span class=\"line\">            include          fastcgi_params;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-5-运行与测试\"><a href=\"#2-5-运行与测试\" class=\"headerlink\" title=\"2.5 运行与测试\"></a>2.5 运行与测试</h4><p>nginx是一个反向代理的web服务器，因此它其实必须依赖一个真正的web服务器才能执行动态的网页内容，因此这里php就是使用fastcgi来充当这个真正的web服务器，它运行在9000端口上，这也是为什么<code>nginx.conf</code>中有这样一句<code>fastcgi_pass 127.0.0.1:9000;</code>。</p>\n<ol>\n<li><p>在任务管理器中结束nginx.exe任务，然后到<code>C:\\PHP\\nginx-1.15.8</code>目录双击nginx.exe开启服务。</p>\n</li>\n<li><p>在命令行中，cd到php的home目录<code>C:\\PHP\\php-7.3.2</code>，然后执行如下命令：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c php.ini</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开浏览器，输入 <a href=\"http://127.0.0.1/info.php\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1/info.php</a>，这时候可以看到phpinfo页面：页面内容包含了PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>\n</li>\n</ol>\n<h4 id=\"2-6-MySQL安装\"><a href=\"#2-6-MySQL安装\" class=\"headerlink\" title=\"2.6 MySQL安装\"></a>2.6 MySQL安装</h4><p>  把MySQL的zip安装包解压到<code>C:\\PHP</code>，解压后PHP安装目录为：<code>C:\\PHP\\mysql-5.6.43-winx64</code>。<br>  将<code>C:\\PHP\\mysql-5.6.43-winx64\\bin</code>加入系统环境变量。<br>  修改配置文件<code>C:\\PHP\\mysql-5.6.43-winx64\\my-default.ini</code>并另存为<code>my.ini</code>,在其中修改或添加配置 （my.ini文件的编码必须是英文编码（如windows中的ANSI），不能是UTF-8或GBK等）：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">basedir=C:\\PHP\\mysql-5.6.43-winx64       #mysql所在目录</span><br><span class=\"line\">datadir=C:\\PHP\\mysql-5.6.43-winx64\\data  #mysql所在目录\\data</span><br></pre></td></tr></table></figure></p>\n<p>  以管理员身份运行cmd,到安装目录的bin下，输入<code>mysqld -install</code>：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt; mysqld -install</span><br><span class=\"line\">Service successfully installed.</span><br></pre></td></tr></table></figure></p>\n<p>  输入命令:<code>mysql --version</code>,正常会显示版本信息。<br>  输入命令:<code>net start mysql</code>启动服务(停止命令：net stop mysql):<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;net start mysql</span><br><span class=\"line\">MySQL 服务正在启动 ..</span><br><span class=\"line\">MySQL 服务已经启动成功。</span><br></pre></td></tr></table></figure></p>\n<p>  服务启动成功之后，输入命令：<code>mysql -u root -p</code>（第一次登录没有密码，直接按回车过）:<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;mysql -u root -p</span><br><span class=\"line\">Enter password:</span><br><span class=\"line\">Welcome to the MySQL monitor.  Commands end with ; or \\g.</span><br><span class=\"line\">Your MySQL connection id is 1</span><br><span class=\"line\">Server version: 5.6.43 MySQL Community Server (GPL)</span><br><span class=\"line\">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class=\"line\">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class=\"line\">affiliates. Other names may be trademarks of their respective</span><br><span class=\"line\">owners.</span><br><span class=\"line\">Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement.</span><br><span class=\"line\">mysql&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  如出现<code>mysql&gt;</code>,即登录成功。<br>  输入命令<code>exit</code>,退出登录。<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; exit</span><br><span class=\"line\">Bye</span><br><span class=\"line\">C:\\PHP\\mysql-5.6.43-winx64\\bin&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-制作自动启动脚本\"><a href=\"#3-制作自动启动脚本\" class=\"headerlink\" title=\"3. 制作自动启动脚本\"></a>3. 制作自动启动脚本</h3><p>控制台就一直开着，很不方便。这个时候可以使用 <a href=\"https://link.jianshu.com?t=http://www.inbeijing.org/wp-content/uploads/2015/06/RunHiddenConsole.zip\" target=\"_blank\" rel=\"noopener\">RunHiddenConsole.zip</a> 来得管理服务的启动与关闭。</p>\n<h4 id=\"3-1-启动脚本\"><a href=\"#3-1-启动脚本\" class=\"headerlink\" title=\"3.1 启动脚本\"></a>3.1 启动脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>start.bat</code>作为启动脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-2-停止脚本\"><a href=\"#3-2-停止脚本\" class=\"headerlink\" title=\"3.2 停止脚本\"></a>3.2 停止脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>stop.bat</code>作为停止脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-重启脚本\"><a href=\"#3-3-重启脚本\" class=\"headerlink\" title=\"3.3 重启脚本\"></a>3.3 重启脚本</h4><p>在目录<code>C:\\PHP</code>下新建一个<code>restart.bat</code>作为重启脚本文件：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:停止脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping nginx...  </span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM nginx.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 已停止</span><br><span class=\"line\">:换行</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Stopping PHP FastCGI...</span><br><span class=\"line\"><span class=\"built_in\">taskkill</span> /F /IM php-cgi.exe &gt; <span class=\"built_in\">nul</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 已停止</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">:启动脚本</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"built_in\">set</span> php_home=./php-<span class=\"number\">7</span>.<span class=\"number\">3</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> nginx_home=./nginx-<span class=\"number\">1</span>.<span class=\"number\">15</span>.<span class=\"number\">8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM Windows 下无效</span></span><br><span class=\"line\"><span class=\"comment\">REM set PHP_FCGI_CHILDREN=5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">REM 每个进程处理的最大请求数，或设置为 Windows 环境变量</span></span><br><span class=\"line\"><span class=\"built_in\">set</span> PHP_FCGI_MAX_REQUESTS=<span class=\"number\">1000</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting PHP FastCGI...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%php_home%</span>/php-cgi.exe -b <span class=\"number\">127</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">1</span>:<span class=\"number\">9000</span> -c <span class=\"variable\">%php_home%</span>/php.ini</span><br><span class=\"line\"><span class=\"built_in\">echo</span> FastCGI 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\"><span class=\"built_in\">echo</span> Starting nginx...</span><br><span class=\"line\">RunHiddenConsole <span class=\"variable\">%nginx_home%</span>/nginx.exe -p <span class=\"variable\">%nginx_home%</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> nginx 启动成功</span><br><span class=\"line\"><span class=\"built_in\">echo</span>.</span><br><span class=\"line\">:<span class=\"built_in\">echo</span> <span class=\"number\">15</span>秒后自动退出</span><br><span class=\"line\">:<span class=\"built_in\">ping</span> <span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">0</span>  -n <span class=\"number\">15</span> &gt; null</span><br><span class=\"line\">:请按任意键继续. . .</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-最后\"><a href=\"#4-最后\" class=\"headerlink\" title=\"4.最后\"></a>4.最后</h3><p>我的根目录结构</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">PHP</span>&gt;<span class=\"title\">dir</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 系统</span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 09<span class=\"title\">C1</span>-<span class=\"title\">B27D</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">PHP</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:46    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  11:23    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">mysql</span>-5.6.43-<span class=\"title\">winx64</span></span></span><br><span class=\"line\"><span class=\"function\">2018/12/25  17:54    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">nginx</span>-1.15.8</span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  15:59    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">php</span>-7.3.2</span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               758 <span class=\"title\">restart.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2010/10/26  11:43             1,536 <span class=\"title\">RunHiddenConsole.exe</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               549 <span class=\"title\">start.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/22  15:41               227 <span class=\"title\">stop.bat</span></span></span><br><span class=\"line\"><span class=\"function\">2019/02/21  16:56    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">web</span></span></span><br><span class=\"line\"><span class=\"function\">               4 个文件          3,070 字节</span></span><br><span class=\"line\"><span class=\"function\">               6 个目录 100,959,772,672 可用字节</span></span><br></pre></td></tr></table></figure>"},{"title":"四、JavaSE集合框架","date":"2019-07-08T14:10:57.000Z","_content":"\n\n为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。\n<!-- more -->\n\n1. [Collection集合](#id1)\n2. [List集合](#id2)\n3. [泛型机制](#id3)\n4. [Queue集合](#id4)\n5. [*ArrayList类](#id5)\n6. [Vector类](#id6)\n7. [Stack类](#id7)\n8. [*LinkedList类](#id8)\n9. [Set集合](#id9)\n10. [HashSet类](#id10)\n11. [TreeSet类](#id11)\n12. [Map集合](#id12)\n13. [HashMap类](#id13)\n14. [TreeMap类](#id14)\n15. [Lambda表达式](#id15)\n16. [Stream API](#id16)\n\n\n<span id=\"id1\"><span>\n### 1. Collection集合\n- Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。\n\n> 数组与集合的比较\n> - 数组的特点：\n    1. 数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；\n    2. 支持下标访问，实现随机访问非常方便；\n    3. 增删操作不方便，可能会移动大量元素；\n    4. 数组一旦声明长度固定无法更改；\n    5. 数组支持基本数据类型，也支持引用数据类型；\n> - 集合的特点：\n    1. 集合的存储单元可以不连续，数据类容可以不相同；\n    2. 集合部分支持下标访问，部分不支持；\n    3. 集合中增删元素可以不移动大量元素；\n    4. 集合大小可以随时动态调整；\n    5. 集合中的元素必须是引用数据类型（基本数据类型可用包装类）；\n\n```\n-Collection接口\n    |————List接口\n        |————ArrayList类\n        |————LinkedList类\n        |————Stack类\n        |————Vector类\n    |————Queue接口\n        |————LinkedList类\n    |————Set接口\n        |————HashSet类\n        |————TreeSet类\n-Map接口\n    |————HashMap类\n    |————TreeMap类\n```\n\n> - Collection存储的都是value,其中List有序可重复，Set无序无重复\n> - Map存储的是以key-value形式,key无序无重复 value无序可重复\n> - 序 : 顺序--添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序\n\n|Collection集合的常用方法||\n|----------|------------|\n|boolean add(E e); | 向集合中添加对象|\n|boolean contains(Object o); | 判断是否包含指定对象|\n|boolean remove(Object o); | 从集合中删除对象|\n|void clear(); | 清空集合 |\n|int size(); | 返回包含对象的个数 |\n|boolean isEmpty(); | 判断是否为空 |\n\n``` java\nCollection c2 = new ArrayList(); //多态\nboolean b1 = c2.add(new String(\"one\")); //true\nboolean b2 = c2.add(new Integer(2)); //true\nSystem.out.println(\"c2 = \" + c2); //[one, 2]\n\nboolean b3 = c2.contains(new Integer(2));//true\n//contains方法工作原理：(o==null ? e==null : o.equals(e));\n```\n\n\n<span id=\"id2\"><span>\n### 2. List集合\n- java.util.List集合是Collection集合的子集合。\n- List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。\n    - ArrayList类的底层使用**数组**进行数据管理，访问元素方便，增删不方便。\n    - LinkedList类的底层使用**链表**进行数据管理，访问不方便，增删方便。\n    - Stark类的底层使用数组进行数据管理，该类主要描述具有**后进先出**的特征的数据结构，叫做**栈**。\n    - Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。\n- List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。\n\n|List类常用方法|   |\n|----|---|\n|void add(int index, E element)|向集合指定位置添加元素|\n|boolean addAll(int index, Collection<?extends E> c)|向集合中添加所有元素|\n|E get(int index)|从集合中获取指定位置的元素|\n|E set(int index, E element)|修改指定位置的元素|\n|E remove(int index)|删除指定位置的元素|\n|int indexOf(Object o)|在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))|\n|<T> T[] toArray(T[] a)|将集合中的对象序列化以对象数组的形式返回。|\n|List<E> subList(int fromIndex, int toIndex)|获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图|\n \n\n<span id=\"id3\"><span>\n### 3. 泛型机制\n- 集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。\n- 从jdk1.5开始推出泛型机制，在集合名称后面使用<数据类型>的方式明确要求该集合中可以存放的数据类型。如：`List<String> lt = new LinkedList<String>();`。\n- 从jdk1.7开始可省略后面<>的数据类型，叫做`菱形特性`，如：`List<String> lt = new ArrayList<>();`。\n- 泛型本质就是参数化类型，让数据类型作为参数传递，`public interface List<E>{}`其中`E`是占位形参，由于实参可以支持各种广泛的类型，因此得名`泛型`。\n- 泛型可以用在哪里：\n    1. 泛型类：类定义的时候描述某种数据类型，集合的使用就是这样\n    2. 泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型\n    3. 泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中\n    4. 方法参数泛型限制，高级泛型，规范边界，extends，super\n\n\n<span id=\"id4\"><span>\n### 4. Queue集合\n- java.util.Queue集合是Collection集合的子集合。\n- Queue集合主要描述具有**先进先出**特性的数据结构，叫做**队列**(FIFO:First Input First Output)。\n- Queue集合主要实现类是`LinkedList类`，因为该类在增删方面有一定优势。\n\n|Queue接口中主要方法| |\n|----------|--------|\n|boolean offer(E e)| 将一个对象添加至队尾，若添加成功则返回true|\n|E poll()|从队首删除并返回一个元素|\n|E peek()|返回队首的元素（但并不删除）|\n\n``` java\nQueue<Integer> q1 = new LinkedList<Integer>();\n//将数据11、22、33、44、55依次入队\nfor(int i=1; i<=5; i++) {\n    q1.offer(i*11);\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. *ArrayList类\n1. 底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util\n2. ArrayList特点适合遍历轮询，不适合插入删除\n3. 如何构建一个ArrayList对象\n    - 无参数构造方法，带默认容量构造方法，带collection参数的构造方法\n4. ArrayList中常用的方法\n    - 增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()\n5. 类中其他常用的方法\n    - addAll并集，removeAll差集，ratainAll交集;\n    - indexOf()，lastIndexOf()，contains()，List=subList();\n    - isEmpty()，clear()，ensureCapacity()，iterator();迭代器\n    - toArray(T[] x)，trimToSize();\n\n\n<span id=\"id6\"><span>\n### 6. Vector类\n1. 是ArrayList集合的早期版本，所属的包 java.util\n    - Vector底层也是利用(动态)数组的形式存储\n    - Vector是线程同步的(synchronized)，安全性高，效率较低\n2. 扩容方式与ArrayList不同\n    - 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制\n3. 构造方法和常用方法与ArrayList类似\n\n\n<span id=\"id7\"><span>\n### 7. Stack类\n1. Stack类，栈，java.util包\n2. 构造方法只有一个无参数\n3. 除了继承自Vacton类的方法外还有特殊的方法\n    - push(E e)将某一个元素压入栈顶(add())\n    - E = pop()将某一个元素从栈顶取出并删掉(E = remove())\n    - E = peek()查看栈顶的一个元素 不删除(get())\n    - boolean = empty()判断栈内元素是否为空(isEmpty())\n    - int = search()查找给定的元素在占中的位置(indexOf())\n4. 应用场景\n    - 中国象棋，悔棋\n    - 栈中存储每一次操作的步骤\n    - 撤销功能\n\n\n<span id=\"id8\"><span>\n### 8. *LinkedList类\n1. LinkedList类，java.util包\n2. 底层使用**双向链表**的数据结构形式来存储\n    - 适合于插入或删除  不适合遍历轮询\n3. 构建对象\n    - 无参数构造方法，带参数的构造方法(collection)\n4. 常用的方法\n    - 增删改查：add()，remove()，set()，get()，size()，offer，poll，peek\n    - 手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()\n5. 插入删除的特性是否像想的那样\n    - 对比ArrayList  Linked\n\n\n<span id=\"id9\"><span>\n### 9. Set集合\n- java.util.Set集合是Collection集合的子集合。\n- Set集合没有先后放入次序，并且不允许有重复关系，实现类有`HashSet类`和`TreeSet`类。\n- 其中`HashSet类`底层是采用哈希表进行数据管理的。\n- 其中`TreeSet类`的底层是采用二叉树进行数据管理的。\n\n``` java\n//方法和Collection集合基本一样\nSet<String> set1 = new HashSet<String>();\nset1.add(\"one\");\nSystem.out.println(\"s1=\"+s1);\n```\n\n- set集合的无重复特性\n    * HashSet，无重复原则有两个方法同时起作用\n        - equals    hashCode\n        - 默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入\n        - 如果想要改变其比较的规则  可以重写上述两个方法\n    * TreeSet，无重复原则有一个方法起作用\n        - compareTo\n        - 上述这个方法不是每一个对象都有的\n        - 若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable\n        - 实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后\n\n#### 9.1 Set集合的遍历\n- 所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。\n\n|迭代器`Iterator<E> iterator()`，主要方法有||\n|---------------|-------------------------|\n|boolean hasNext() | 判断集合中是否有可以迭代/访问的元素 |\n|E next() | 用于取出一个元素并指向下一个元素|\n|void remove() | 用于删除访问到的最后一个元素|\n\n``` java\nIterator<String> it = set1.iterator();//获取当前集合的迭代器对象\nwhile(it.hasNext()) {//判断是否有可以访问的元素\n    String temp = it.next();//取出一个并指向下一个\n    System.out.println( temp );\n    if(\"two\".equals(temp)){\n        it.remove();//删除set1中该元素\n    }\n}\n```\n\n- 增强for循环(for each结构)\n- 语法格式：`for(元素类型 变量名:集合/数组){ 循环体; }`。\n- 执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。\n\n``` java\n//遍历集合\nfor(String ts : s1) {\n    System.out.println(ts);\n}\n//遍历数组\nint[] arr = {11,22,33,44,55};\nfor(int ti : arr) {\n    System.out.println(ti);\n}\n```\n\n\n<span id=\"id10\"><span>\n### 10. HashSet类\n1. HashSet集合底层采用HashMap（数组+链表-->散列表），java.util包。\n2. 它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 \n3. 创建对象：无参数，有参数\n4. 集合容器的基本使用\n    - 增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)\n    - 没有修改方法\n    - iterator()  获取一个迭代器对象\n    - size()\n5. 无重复的原则\n    - 在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)\n\n\n<span id=\"id11\"><span>\n### 11. TreeSet类\n1. TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))\n2. 创建对象： 无参数构造方法 ，带Collection构造方法\n3. 基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()\n4. 二叉树主要指每个节点最多只有两个子节点的树形结构。\n5. 满足以下三个特征的二叉树叫做**有序二叉树**：\n    * 左子树中的任意节点元素都小于根节点元素；\n    * 右子树中的任意节点元素都大于根节点元素；\n    * 左子树和右子树内部也遵守上述规则；\n6. 无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。\n\n7. 元素放入TreeSet集合过程：\n由于TreeSet集合底层采用**有序二叉树**进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：\n    1. 使用元素的**自然排序**规则进行比较并排序，让元素类型实现java.lang.Comparable接口；\n    2. 使用**比较器规则**进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；\n\n> 注意：\n    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；\n    2. 可以使用Collections工具类对集合中的元素进行操作；\n\n\n<span id=\"id12\"><span>\n### 12. Map集合\n- java.util.Map<K, V>集合存取元素的基本单位是：单对元素（键值对key-value）。\n- Map：映射，通过某一个key可以直接定位到一个value值\n- key无序无重复   value无序可重复\n    * key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致\n- 主要有两个实现类：`HashMap类`和`TreeMap类`。\n- Map基本使用：HashMap，TreeMap，Properties\n- Map集合常用方法：\n    * 增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)\n- Map集合的遍历方式：a.迭代Key，b.迭代Entry\n- Map集合的性能调优：\n    - 加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）\n\n\n<span id=\"id13\"><span>\n### 13. HashMap类\n1. 包:java.util，底层散列表的形式（数组+链表）\n2. 构造方法创建对象   无参数  带默认容量的  带map参数的构造方法\n3. 特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复\n    - 找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry\n4. 基本方法：\n    - 增 put(key,value)，存放一组映射关系key-value\n        1. key存储的顺序与取得顺序不同\n        2. 不同的key可以存储相同的value\n        3. key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)\n    - 删 E = remove(key);\n    - 改 replace(key,newValue)，put(key,value2)\n    - 查 E = get(key)；\n    - Set<Key> = keySet()获取全部的key\n    - Set<Entry> = entrySet();\n    - size();\n\n``` java\nSet<Entry<Integer,String>> entrys = map.entrySet();//获取集合中全部的entry对象\nIterator<Entry<Integer,String>> it = entrys.iterator();\nwhile(it.hasNext()){\n    Entry<Integer,String> entry = it.next();//entry  key value\n    Integer key = entry.getKey();\n    String value = entry.getValue();\n    System.out.println(key+\"--\"+value);\n}\n```\n\n5. 除了上述几个常用的方法外  其他API中提供的方法\n    - clear，containsKey(key)，containsValue(value)\n    - getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值\n    - isEmpty()\n    - putAll(map)\n    - putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦\n6. map集合在什么情形下用?\n    1. 想要存储一组元素\n        - 数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合\n    2. 如果发现长度以后不确定--->集合\n\n| list | Set | Map |\n|:------:|:----:|:------:|\n| List家族有序的 | Set家族无重复 | Map家族k-v |\n|存储有顺序用这个|存储元素希望自动去掉重复元素用这个|通过唯一的k快速找寻v用这个|\n|ArrayList:更适合遍历轮询|HashSet:性能更高|HashMap:性能更高|\n|LinkedList:更适合插入和删除|TreeSet:希望存进去的元素自动去重复,同时还能自动排序|Tree:希望存进去的元素key自动排序|\n|Stack:LIFO|-|-|\n\n\n<span id=\"id14\"><span>\n### 14. TreeMap类\n1. java.util包\n2. 构造方法：无参数，带map参数\n3. 常用方法：put， get，remove，replace，size\n4. 底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）\n5. 自然有序，按照Unicode编码自然有序\n    - ap集合中的key需要可比较的   key的对象需要实现Comparable接口\n\n\n<span id=\"id15\"><span>\n### 15. Lambda表达式\n- java8支持的新的语法格式，Lambda允许`把函数作为一个方法的参数`(函数作为参数传递进方法中)，使用lambda表达式可以`使代码变得更加简洁紧凑`。\n- 函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。\n- lambda表达式语法由**参数列表**、**箭头函数`->`**和**函数体**组成，函数体即可以是一个表达式，也可以是一个语句块。\n\n``` lambda\n(int a, int b) -> a+b\n() -> 42\n(String s) -> {System.out.println(s);}\n```\n\n- 函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。\n- jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。\n\n#### 15.1 Lambda表达式-方法引用\n- 方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n- 方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。\n\n\n<span id=\"id16\"><span>\n### 16. Stream API\n- Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。\n- 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：\n    * **无存储**。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n    * **为函数式编程而生**。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。\n    * **惰式执行**。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n    * **可消费性**。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n- 对stream的操作分为为两类，中间操作和结束操作，二者特点是：\n    * **中间操作**总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。\n    * **结束操作**会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n#### 16.1 stream方法使用\n- stream跟**函数接口**关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。\n\n``` java\n// 找出最长的单词\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n\n","source":"_posts/04_JavaSE集合框架.md","raw":"---\ntitle: 四、JavaSE集合框架\ndate: 2019-07-08 22:10:57\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。\n<!-- more -->\n\n1. [Collection集合](#id1)\n2. [List集合](#id2)\n3. [泛型机制](#id3)\n4. [Queue集合](#id4)\n5. [*ArrayList类](#id5)\n6. [Vector类](#id6)\n7. [Stack类](#id7)\n8. [*LinkedList类](#id8)\n9. [Set集合](#id9)\n10. [HashSet类](#id10)\n11. [TreeSet类](#id11)\n12. [Map集合](#id12)\n13. [HashMap类](#id13)\n14. [TreeMap类](#id14)\n15. [Lambda表达式](#id15)\n16. [Stream API](#id16)\n\n\n<span id=\"id1\"><span>\n### 1. Collection集合\n- Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。\n\n> 数组与集合的比较\n> - 数组的特点：\n    1. 数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；\n    2. 支持下标访问，实现随机访问非常方便；\n    3. 增删操作不方便，可能会移动大量元素；\n    4. 数组一旦声明长度固定无法更改；\n    5. 数组支持基本数据类型，也支持引用数据类型；\n> - 集合的特点：\n    1. 集合的存储单元可以不连续，数据类容可以不相同；\n    2. 集合部分支持下标访问，部分不支持；\n    3. 集合中增删元素可以不移动大量元素；\n    4. 集合大小可以随时动态调整；\n    5. 集合中的元素必须是引用数据类型（基本数据类型可用包装类）；\n\n```\n-Collection接口\n    |————List接口\n        |————ArrayList类\n        |————LinkedList类\n        |————Stack类\n        |————Vector类\n    |————Queue接口\n        |————LinkedList类\n    |————Set接口\n        |————HashSet类\n        |————TreeSet类\n-Map接口\n    |————HashMap类\n    |————TreeMap类\n```\n\n> - Collection存储的都是value,其中List有序可重复，Set无序无重复\n> - Map存储的是以key-value形式,key无序无重复 value无序可重复\n> - 序 : 顺序--添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序\n\n|Collection集合的常用方法||\n|----------|------------|\n|boolean add(E e); | 向集合中添加对象|\n|boolean contains(Object o); | 判断是否包含指定对象|\n|boolean remove(Object o); | 从集合中删除对象|\n|void clear(); | 清空集合 |\n|int size(); | 返回包含对象的个数 |\n|boolean isEmpty(); | 判断是否为空 |\n\n``` java\nCollection c2 = new ArrayList(); //多态\nboolean b1 = c2.add(new String(\"one\")); //true\nboolean b2 = c2.add(new Integer(2)); //true\nSystem.out.println(\"c2 = \" + c2); //[one, 2]\n\nboolean b3 = c2.contains(new Integer(2));//true\n//contains方法工作原理：(o==null ? e==null : o.equals(e));\n```\n\n\n<span id=\"id2\"><span>\n### 2. List集合\n- java.util.List集合是Collection集合的子集合。\n- List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。\n    - ArrayList类的底层使用**数组**进行数据管理，访问元素方便，增删不方便。\n    - LinkedList类的底层使用**链表**进行数据管理，访问不方便，增删方便。\n    - Stark类的底层使用数组进行数据管理，该类主要描述具有**后进先出**的特征的数据结构，叫做**栈**。\n    - Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。\n- List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。\n\n|List类常用方法|   |\n|----|---|\n|void add(int index, E element)|向集合指定位置添加元素|\n|boolean addAll(int index, Collection<?extends E> c)|向集合中添加所有元素|\n|E get(int index)|从集合中获取指定位置的元素|\n|E set(int index, E element)|修改指定位置的元素|\n|E remove(int index)|删除指定位置的元素|\n|int indexOf(Object o)|在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))|\n|<T> T[] toArray(T[] a)|将集合中的对象序列化以对象数组的形式返回。|\n|List<E> subList(int fromIndex, int toIndex)|获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图|\n \n\n<span id=\"id3\"><span>\n### 3. 泛型机制\n- 集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。\n- 从jdk1.5开始推出泛型机制，在集合名称后面使用<数据类型>的方式明确要求该集合中可以存放的数据类型。如：`List<String> lt = new LinkedList<String>();`。\n- 从jdk1.7开始可省略后面<>的数据类型，叫做`菱形特性`，如：`List<String> lt = new ArrayList<>();`。\n- 泛型本质就是参数化类型，让数据类型作为参数传递，`public interface List<E>{}`其中`E`是占位形参，由于实参可以支持各种广泛的类型，因此得名`泛型`。\n- 泛型可以用在哪里：\n    1. 泛型类：类定义的时候描述某种数据类型，集合的使用就是这样\n    2. 泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型\n    3. 泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中\n    4. 方法参数泛型限制，高级泛型，规范边界，extends，super\n\n\n<span id=\"id4\"><span>\n### 4. Queue集合\n- java.util.Queue集合是Collection集合的子集合。\n- Queue集合主要描述具有**先进先出**特性的数据结构，叫做**队列**(FIFO:First Input First Output)。\n- Queue集合主要实现类是`LinkedList类`，因为该类在增删方面有一定优势。\n\n|Queue接口中主要方法| |\n|----------|--------|\n|boolean offer(E e)| 将一个对象添加至队尾，若添加成功则返回true|\n|E poll()|从队首删除并返回一个元素|\n|E peek()|返回队首的元素（但并不删除）|\n\n``` java\nQueue<Integer> q1 = new LinkedList<Integer>();\n//将数据11、22、33、44、55依次入队\nfor(int i=1; i<=5; i++) {\n    q1.offer(i*11);\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. *ArrayList类\n1. 底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util\n2. ArrayList特点适合遍历轮询，不适合插入删除\n3. 如何构建一个ArrayList对象\n    - 无参数构造方法，带默认容量构造方法，带collection参数的构造方法\n4. ArrayList中常用的方法\n    - 增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()\n5. 类中其他常用的方法\n    - addAll并集，removeAll差集，ratainAll交集;\n    - indexOf()，lastIndexOf()，contains()，List=subList();\n    - isEmpty()，clear()，ensureCapacity()，iterator();迭代器\n    - toArray(T[] x)，trimToSize();\n\n\n<span id=\"id6\"><span>\n### 6. Vector类\n1. 是ArrayList集合的早期版本，所属的包 java.util\n    - Vector底层也是利用(动态)数组的形式存储\n    - Vector是线程同步的(synchronized)，安全性高，效率较低\n2. 扩容方式与ArrayList不同\n    - 默认是扩容2倍，可以通过构造方法创建对象时修改这一机制\n3. 构造方法和常用方法与ArrayList类似\n\n\n<span id=\"id7\"><span>\n### 7. Stack类\n1. Stack类，栈，java.util包\n2. 构造方法只有一个无参数\n3. 除了继承自Vacton类的方法外还有特殊的方法\n    - push(E e)将某一个元素压入栈顶(add())\n    - E = pop()将某一个元素从栈顶取出并删掉(E = remove())\n    - E = peek()查看栈顶的一个元素 不删除(get())\n    - boolean = empty()判断栈内元素是否为空(isEmpty())\n    - int = search()查找给定的元素在占中的位置(indexOf())\n4. 应用场景\n    - 中国象棋，悔棋\n    - 栈中存储每一次操作的步骤\n    - 撤销功能\n\n\n<span id=\"id8\"><span>\n### 8. *LinkedList类\n1. LinkedList类，java.util包\n2. 底层使用**双向链表**的数据结构形式来存储\n    - 适合于插入或删除  不适合遍历轮询\n3. 构建对象\n    - 无参数构造方法，带参数的构造方法(collection)\n4. 常用的方法\n    - 增删改查：add()，remove()，set()，get()，size()，offer，poll，peek\n    - 手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()\n5. 插入删除的特性是否像想的那样\n    - 对比ArrayList  Linked\n\n\n<span id=\"id9\"><span>\n### 9. Set集合\n- java.util.Set集合是Collection集合的子集合。\n- Set集合没有先后放入次序，并且不允许有重复关系，实现类有`HashSet类`和`TreeSet`类。\n- 其中`HashSet类`底层是采用哈希表进行数据管理的。\n- 其中`TreeSet类`的底层是采用二叉树进行数据管理的。\n\n``` java\n//方法和Collection集合基本一样\nSet<String> set1 = new HashSet<String>();\nset1.add(\"one\");\nSystem.out.println(\"s1=\"+s1);\n```\n\n- set集合的无重复特性\n    * HashSet，无重复原则有两个方法同时起作用\n        - equals    hashCode\n        - 默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入\n        - 如果想要改变其比较的规则  可以重写上述两个方法\n    * TreeSet，无重复原则有一个方法起作用\n        - compareTo\n        - 上述这个方法不是每一个对象都有的\n        - 若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable\n        - 实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后\n\n#### 9.1 Set集合的遍历\n- 所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。\n\n|迭代器`Iterator<E> iterator()`，主要方法有||\n|---------------|-------------------------|\n|boolean hasNext() | 判断集合中是否有可以迭代/访问的元素 |\n|E next() | 用于取出一个元素并指向下一个元素|\n|void remove() | 用于删除访问到的最后一个元素|\n\n``` java\nIterator<String> it = set1.iterator();//获取当前集合的迭代器对象\nwhile(it.hasNext()) {//判断是否有可以访问的元素\n    String temp = it.next();//取出一个并指向下一个\n    System.out.println( temp );\n    if(\"two\".equals(temp)){\n        it.remove();//删除set1中该元素\n    }\n}\n```\n\n- 增强for循环(for each结构)\n- 语法格式：`for(元素类型 变量名:集合/数组){ 循环体; }`。\n- 执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。\n\n``` java\n//遍历集合\nfor(String ts : s1) {\n    System.out.println(ts);\n}\n//遍历数组\nint[] arr = {11,22,33,44,55};\nfor(int ti : arr) {\n    System.out.println(ti);\n}\n```\n\n\n<span id=\"id10\"><span>\n### 10. HashSet类\n1. HashSet集合底层采用HashMap（数组+链表-->散列表），java.util包。\n2. 它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 \n3. 创建对象：无参数，有参数\n4. 集合容器的基本使用\n    - 增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)\n    - 没有修改方法\n    - iterator()  获取一个迭代器对象\n    - size()\n5. 无重复的原则\n    - 在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)\n\n\n<span id=\"id11\"><span>\n### 11. TreeSet类\n1. TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))\n2. 创建对象： 无参数构造方法 ，带Collection构造方法\n3. 基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()\n4. 二叉树主要指每个节点最多只有两个子节点的树形结构。\n5. 满足以下三个特征的二叉树叫做**有序二叉树**：\n    * 左子树中的任意节点元素都小于根节点元素；\n    * 右子树中的任意节点元素都大于根节点元素；\n    * 左子树和右子树内部也遵守上述规则；\n6. 无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。\n\n7. 元素放入TreeSet集合过程：\n由于TreeSet集合底层采用**有序二叉树**进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：\n    1. 使用元素的**自然排序**规则进行比较并排序，让元素类型实现java.lang.Comparable接口；\n    2. 使用**比较器规则**进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；\n\n> 注意：\n    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；\n    2. 可以使用Collections工具类对集合中的元素进行操作；\n\n\n<span id=\"id12\"><span>\n### 12. Map集合\n- java.util.Map<K, V>集合存取元素的基本单位是：单对元素（键值对key-value）。\n- Map：映射，通过某一个key可以直接定位到一个value值\n- key无序无重复   value无序可重复\n    * key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致\n- 主要有两个实现类：`HashMap类`和`TreeMap类`。\n- Map基本使用：HashMap，TreeMap，Properties\n- Map集合常用方法：\n    * 增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)\n- Map集合的遍历方式：a.迭代Key，b.迭代Entry\n- Map集合的性能调优：\n    - 加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）\n\n\n<span id=\"id13\"><span>\n### 13. HashMap类\n1. 包:java.util，底层散列表的形式（数组+链表）\n2. 构造方法创建对象   无参数  带默认容量的  带map参数的构造方法\n3. 特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复\n    - 找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry\n4. 基本方法：\n    - 增 put(key,value)，存放一组映射关系key-value\n        1. key存储的顺序与取得顺序不同\n        2. 不同的key可以存储相同的value\n        3. key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)\n    - 删 E = remove(key);\n    - 改 replace(key,newValue)，put(key,value2)\n    - 查 E = get(key)；\n    - Set<Key> = keySet()获取全部的key\n    - Set<Entry> = entrySet();\n    - size();\n\n``` java\nSet<Entry<Integer,String>> entrys = map.entrySet();//获取集合中全部的entry对象\nIterator<Entry<Integer,String>> it = entrys.iterator();\nwhile(it.hasNext()){\n    Entry<Integer,String> entry = it.next();//entry  key value\n    Integer key = entry.getKey();\n    String value = entry.getValue();\n    System.out.println(key+\"--\"+value);\n}\n```\n\n5. 除了上述几个常用的方法外  其他API中提供的方法\n    - clear，containsKey(key)，containsValue(value)\n    - getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值\n    - isEmpty()\n    - putAll(map)\n    - putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦\n6. map集合在什么情形下用?\n    1. 想要存储一组元素\n        - 数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合\n    2. 如果发现长度以后不确定--->集合\n\n| list | Set | Map |\n|:------:|:----:|:------:|\n| List家族有序的 | Set家族无重复 | Map家族k-v |\n|存储有顺序用这个|存储元素希望自动去掉重复元素用这个|通过唯一的k快速找寻v用这个|\n|ArrayList:更适合遍历轮询|HashSet:性能更高|HashMap:性能更高|\n|LinkedList:更适合插入和删除|TreeSet:希望存进去的元素自动去重复,同时还能自动排序|Tree:希望存进去的元素key自动排序|\n|Stack:LIFO|-|-|\n\n\n<span id=\"id14\"><span>\n### 14. TreeMap类\n1. java.util包\n2. 构造方法：无参数，带map参数\n3. 常用方法：put， get，remove，replace，size\n4. 底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）\n5. 自然有序，按照Unicode编码自然有序\n    - ap集合中的key需要可比较的   key的对象需要实现Comparable接口\n\n\n<span id=\"id15\"><span>\n### 15. Lambda表达式\n- java8支持的新的语法格式，Lambda允许`把函数作为一个方法的参数`(函数作为参数传递进方法中)，使用lambda表达式可以`使代码变得更加简洁紧凑`。\n- 函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。\n- lambda表达式语法由**参数列表**、**箭头函数`->`**和**函数体**组成，函数体即可以是一个表达式，也可以是一个语句块。\n\n``` lambda\n(int a, int b) -> a+b\n() -> 42\n(String s) -> {System.out.println(s);}\n```\n\n- 函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。\n- jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。\n\n#### 15.1 Lambda表达式-方法引用\n- 方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。\n- 方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。\n\n\n<span id=\"id16\"><span>\n### 16. Stream API\n- Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。\n- 虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：\n    * **无存储**。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。\n    * **为函数式编程而生**。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。\n    * **惰式执行**。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。\n    * **可消费性**。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。\n\n- 对stream的操作分为为两类，中间操作和结束操作，二者特点是：\n    * **中间操作**总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。\n    * **结束操作**会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。\n\n#### 16.1 stream方法使用\n- stream跟**函数接口**关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。\n\n``` java\n// 找出最长的单词\nStream<String> stream = Stream.of(\"I\", \"love\", \"you\", \"too\");\nOptional<String> longest = stream.reduce((s1, s2) -> s1.length()>=s2.length() ? s1 : s2);\n//Optional<String> longest = stream.max((s1, s2) -> s1.length()-s2.length());\nSystem.out.println(longest.get());\n```\n\n","slug":"04_JavaSE集合框架","published":1,"updated":"2019-07-20T14:46:43.086Z","_id":"cjyblnrwu0022xwt3lpfp4kb5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Collection集合</a></li>\n<li><a href=\"#id2\">List集合</a></li>\n<li><a href=\"#id3\">泛型机制</a></li>\n<li><a href=\"#id4\">Queue集合</a></li>\n<li><a href=\"#id5\">*ArrayList类</a></li>\n<li><a href=\"#id6\">Vector类</a></li>\n<li><a href=\"#id7\">Stack类</a></li>\n<li><a href=\"#id8\">*LinkedList类</a></li>\n<li><a href=\"#id9\">Set集合</a></li>\n<li><a href=\"#id10\">HashSet类</a></li>\n<li><a href=\"#id11\">TreeSet类</a></li>\n<li><a href=\"#id12\">Map集合</a></li>\n<li><a href=\"#id13\">HashMap类</a></li>\n<li><a href=\"#id14\">TreeMap类</a></li>\n<li><a href=\"#id15\">Lambda表达式</a></li>\n<li><a href=\"#id16\">Stream API</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Collection集合\"><a href=\"#1-Collection集合\" class=\"headerlink\" title=\"1. Collection集合\"></a>1. Collection集合</h3><ul>\n<li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li>\n</ul>\n<blockquote>\n<p>数组与集合的比较</p>\n<ul>\n<li>数组的特点：<ol>\n<li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li>\n<li>支持下标访问，实现随机访问非常方便；</li>\n<li>增删操作不方便，可能会移动大量元素；</li>\n<li>数组一旦声明长度固定无法更改；</li>\n<li>数组支持基本数据类型，也支持引用数据类型；</li>\n</ol>\n</li>\n<li>集合的特点：<ol>\n<li>集合的存储单元可以不连续，数据类容可以不相同；</li>\n<li>集合部分支持下标访问，部分不支持；</li>\n<li>集合中增删元素可以不移动大量元素；</li>\n<li>集合大小可以随时动态调整；</li>\n<li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Collection接口</span><br><span class=\"line\">    |————List接口</span><br><span class=\"line\">        |————ArrayList类</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">        |————Stack类</span><br><span class=\"line\">        |————Vector类</span><br><span class=\"line\">    |————Queue接口</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">    |————Set接口</span><br><span class=\"line\">        |————HashSet类</span><br><span class=\"line\">        |————TreeSet类</span><br><span class=\"line\">-Map接口</span><br><span class=\"line\">    |————HashMap类</span><br><span class=\"line\">    |————TreeMap类</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li>\n<li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li>\n<li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Collection集合的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e);</td>\n<td>向集合中添加对象</td>\n</tr>\n<tr>\n<td>boolean contains(Object o);</td>\n<td>判断是否包含指定对象</td>\n</tr>\n<tr>\n<td>boolean remove(Object o);</td>\n<td>从集合中删除对象</td>\n</tr>\n<tr>\n<td>void clear();</td>\n<td>清空集合</td>\n</tr>\n<tr>\n<td>int size();</td>\n<td>返回包含对象的个数</td>\n</tr>\n<tr>\n<td>boolean isEmpty();</td>\n<td>判断是否为空</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection c2 = <span class=\"keyword\">new</span> ArrayList(); <span class=\"comment\">//多态</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = c2.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"one\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = c2.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"c2 = \"</span> + c2); <span class=\"comment\">//[one, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b3 = c2.contains(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-List集合\"><a href=\"#2-List集合\" class=\"headerlink\" title=\"2. List集合\"></a>2. List集合</h3><ul>\n<li>java.util.List集合是Collection集合的子集合。</li>\n<li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul>\n<li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li>\n<li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li>\n<li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li>\n<li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li>\n</ul>\n</li>\n<li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>List类常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index, E element)</td>\n<td>向集合指定位置添加元素</td>\n</tr>\n<tr>\n<td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td>\n<td>向集合中添加所有元素</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>从集合中获取指定位置的元素</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定位置的元素</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定位置的元素</td>\n</tr>\n<tr>\n<td>int indexOf(Object o)</td>\n<td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td>\n</tr>\n<tr>\n<td><t> T[] toArray(T[] a)</t></td>\n<td>将集合中的对象序列化以对象数组的形式返回。</td>\n</tr>\n<tr>\n<td>List<e> subList(int fromIndex, int toIndex)</e></td>\n<td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-泛型机制\"><a href=\"#3-泛型机制\" class=\"headerlink\" title=\"3. 泛型机制\"></a>3. 泛型机制</h3><ul>\n<li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li>\n<li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li>\n<li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li>\n<li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li>\n<li>泛型可以用在哪里：<ol>\n<li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li>\n<li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li>\n<li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li>\n<li>方法参数泛型限制，高级泛型，规范边界，extends，super</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Queue集合\"><a href=\"#4-Queue集合\" class=\"headerlink\" title=\"4. Queue集合\"></a>4. Queue集合</h3><ul>\n<li>java.util.Queue集合是Collection集合的子集合。</li>\n<li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li>\n<li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Queue接口中主要方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean offer(E e)</td>\n<td>将一个对象添加至队尾，若添加成功则返回true</td>\n</tr>\n<tr>\n<td>E poll()</td>\n<td>从队首删除并返回一个元素</td>\n</tr>\n<tr>\n<td>E peek()</td>\n<td>返回队首的元素（但并不删除）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; q1 = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//将数据11、22、33、44、55依次入队</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    q1.offer(i*<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-ArrayList类\"><a href=\"#5-ArrayList类\" class=\"headerlink\" title=\"5. *ArrayList类\"></a>5. *ArrayList类</h3><ol>\n<li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li>\n<li>ArrayList特点适合遍历轮询，不适合插入删除</li>\n<li>如何构建一个ArrayList对象<ul>\n<li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li>\n</ul>\n</li>\n<li>ArrayList中常用的方法<ul>\n<li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li>\n</ul>\n</li>\n<li>类中其他常用的方法<ul>\n<li>addAll并集，removeAll差集，ratainAll交集;</li>\n<li>indexOf()，lastIndexOf()，contains()，List=subList();</li>\n<li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li>\n<li>toArray(T[] x)，trimToSize();</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Vector类\"><a href=\"#6-Vector类\" class=\"headerlink\" title=\"6. Vector类\"></a>6. Vector类</h3><ol>\n<li>是ArrayList集合的早期版本，所属的包 java.util<ul>\n<li>Vector底层也是利用(动态)数组的形式存储</li>\n<li>Vector是线程同步的(synchronized)，安全性高，效率较低</li>\n</ul>\n</li>\n<li>扩容方式与ArrayList不同<ul>\n<li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li>\n</ul>\n</li>\n<li>构造方法和常用方法与ArrayList类似</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Stack类\"><a href=\"#7-Stack类\" class=\"headerlink\" title=\"7. Stack类\"></a>7. Stack类</h3><ol>\n<li>Stack类，栈，java.util包</li>\n<li>构造方法只有一个无参数</li>\n<li>除了继承自Vacton类的方法外还有特殊的方法<ul>\n<li>push(E e)将某一个元素压入栈顶(add())</li>\n<li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li>\n<li>E = peek()查看栈顶的一个元素 不删除(get())</li>\n<li>boolean = empty()判断栈内元素是否为空(isEmpty())</li>\n<li>int = search()查找给定的元素在占中的位置(indexOf())</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>中国象棋，悔棋</li>\n<li>栈中存储每一次操作的步骤</li>\n<li>撤销功能</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-LinkedList类\"><a href=\"#8-LinkedList类\" class=\"headerlink\" title=\"8. *LinkedList类\"></a>8. *LinkedList类</h3><ol>\n<li>LinkedList类，java.util包</li>\n<li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul>\n<li>适合于插入或删除  不适合遍历轮询</li>\n</ul>\n</li>\n<li>构建对象<ul>\n<li>无参数构造方法，带参数的构造方法(collection)</li>\n</ul>\n</li>\n<li>常用的方法<ul>\n<li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li>\n<li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li>\n</ul>\n</li>\n<li>插入删除的特性是否像想的那样<ul>\n<li>对比ArrayList  Linked</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Set集合\"><a href=\"#9-Set集合\" class=\"headerlink\" title=\"9. Set集合\"></a>9. Set集合</h3><ul>\n<li>java.util.Set集合是Collection集合的子集合。</li>\n<li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li>\n<li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li>\n<li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法和Collection集合基本一样</span></span><br><span class=\"line\">Set&lt;String&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">set1.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s1=\"</span>+s1);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>set集合的无重复特性<ul>\n<li>HashSet，无重复原则有两个方法同时起作用<ul>\n<li>equals    hashCode</li>\n<li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li>\n<li>如果想要改变其比较的规则  可以重写上述两个方法</li>\n</ul>\n</li>\n<li>TreeSet，无重复原则有一个方法起作用<ul>\n<li>compareTo</li>\n<li>上述这个方法不是每一个对象都有的</li>\n<li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li>\n<li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-1-Set集合的遍历\"><a href=\"#9-1-Set集合的遍历\" class=\"headerlink\" title=\"9.1 Set集合的遍历\"></a>9.1 Set集合的遍历</h4><ul>\n<li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td>判断集合中是否有可以迭代/访问的元素</td>\n</tr>\n<tr>\n<td>E next()</td>\n<td>用于取出一个元素并指向下一个元素</td>\n</tr>\n<tr>\n<td>void remove()</td>\n<td>用于删除访问到的最后一个元素</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; it = set1.iterator();<span class=\"comment\">//获取当前集合的迭代器对象</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()) &#123;<span class=\"comment\">//判断是否有可以访问的元素</span></span><br><span class=\"line\">    String temp = it.next();<span class=\"comment\">//取出一个并指向下一个</span></span><br><span class=\"line\">    System.out.println( temp );</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"two\"</span>.equals(temp))&#123;</span><br><span class=\"line\">        it.remove();<span class=\"comment\">//删除set1中该元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>增强for循环(for each结构)</li>\n<li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li>\n<li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(String ts : s1) &#123;</span><br><span class=\"line\">    System.out.println(ts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">44</span>,<span class=\"number\">55</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> ti : arr) &#123;</span><br><span class=\"line\">    System.out.println(ti);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-HashSet类\"><a href=\"#10-HashSet类\" class=\"headerlink\" title=\"10. HashSet类\"></a>10. HashSet类</h3><ol>\n<li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li>\n<li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li>\n<li>创建对象：无参数，有参数</li>\n<li>集合容器的基本使用<ul>\n<li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li>\n<li>没有修改方法</li>\n<li>iterator()  获取一个迭代器对象</li>\n<li>size()</li>\n</ul>\n</li>\n<li>无重复的原则<ul>\n<li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-TreeSet类\"><a href=\"#11-TreeSet类\" class=\"headerlink\" title=\"11. TreeSet类\"></a>11. TreeSet类</h3><ol>\n<li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p>\n</li>\n<li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p>\n</li>\n<li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p>\n</li>\n<li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p>\n</li>\n<li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p>\n<ul>\n<li>左子树中的任意节点元素都小于根节点元素；</li>\n<li>右子树中的任意节点元素都大于根节点元素；</li>\n<li>左子树和右子树内部也遵守上述规则；</li>\n</ul>\n</li>\n<li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p>\n</li>\n<li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p>\n<ol>\n<li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li>\n<li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p>\n</blockquote>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-Map集合\"><a href=\"#12-Map集合\" class=\"headerlink\" title=\"12. Map集合\"></a>12. Map集合</h3><ul>\n<li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li>\n<li>Map：映射，通过某一个key可以直接定位到一个value值</li>\n<li>key无序无重复   value无序可重复<ul>\n<li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li>\n</ul>\n</li>\n<li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li>\n<li>Map基本使用：HashMap，TreeMap，Properties</li>\n<li>Map集合常用方法：<ul>\n<li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li>\n</ul>\n</li>\n<li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li>\n<li>Map集合的性能调优：<ul>\n<li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-HashMap类\"><a href=\"#13-HashMap类\" class=\"headerlink\" title=\"13. HashMap类\"></a>13. HashMap类</h3><ol>\n<li>包:java.util，底层散列表的形式（数组+链表）</li>\n<li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li>\n<li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul>\n<li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li>\n</ul>\n</li>\n<li>基本方法：<ul>\n<li>增 put(key,value)，存放一组映射关系key-value<ol>\n<li>key存储的顺序与取得顺序不同</li>\n<li>不同的key可以存储相同的value</li>\n<li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li>\n</ol>\n</li>\n<li>删 E = remove(key);</li>\n<li>改 replace(key,newValue)，put(key,value2)</li>\n<li>查 E = get(key)；</li>\n<li>Set<key> = keySet()获取全部的key</key></li>\n<li>Set<entry> = entrySet();</entry></li>\n<li>size();</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class=\"comment\">//获取集合中全部的entry对象</span></span><br><span class=\"line\">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    Entry&lt;Integer,String&gt; entry = it.next();<span class=\"comment\">//entry  key value</span></span><br><span class=\"line\">    Integer key = entry.getKey();</span><br><span class=\"line\">    String value = entry.getValue();</span><br><span class=\"line\">    System.out.println(key+<span class=\"string\">\"--\"</span>+value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>除了上述几个常用的方法外  其他API中提供的方法<ul>\n<li>clear，containsKey(key)，containsValue(value)</li>\n<li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li>\n<li>isEmpty()</li>\n<li>putAll(map)</li>\n<li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li>\n</ul>\n</li>\n<li>map集合在什么情形下用?<ol>\n<li>想要存储一组元素<ul>\n<li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li>\n</ul>\n</li>\n<li>如果发现长度以后不确定—&gt;集合</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">list</th>\n<th align=\"center\">Set</th>\n<th align=\"center\">Map</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">List家族有序的</td>\n<td align=\"center\">Set家族无重复</td>\n<td align=\"center\">Map家族k-v</td>\n</tr>\n<tr>\n<td align=\"center\">存储有顺序用这个</td>\n<td align=\"center\">存储元素希望自动去掉重复元素用这个</td>\n<td align=\"center\">通过唯一的k快速找寻v用这个</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayList:更适合遍历轮询</td>\n<td align=\"center\">HashSet:性能更高</td>\n<td align=\"center\">HashMap:性能更高</td>\n</tr>\n<tr>\n<td align=\"center\">LinkedList:更适合插入和删除</td>\n<td align=\"center\">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td>\n<td align=\"center\">Tree:希望存进去的元素key自动排序</td>\n</tr>\n<tr>\n<td align=\"center\">Stack:LIFO</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-TreeMap类\"><a href=\"#14-TreeMap类\" class=\"headerlink\" title=\"14. TreeMap类\"></a>14. TreeMap类</h3><ol>\n<li>java.util包</li>\n<li>构造方法：无参数，带map参数</li>\n<li>常用方法：put， get，remove，replace，size</li>\n<li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li>\n<li>自然有序，按照Unicode编码自然有序<ul>\n<li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-Lambda表达式\"><a href=\"#15-Lambda表达式\" class=\"headerlink\" title=\"15. Lambda表达式\"></a>15. Lambda表达式</h3><ul>\n<li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li>\n<li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li>\n<li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(int a, int b) -&gt; a+b</span><br><span class=\"line\">() -&gt; 42</span><br><span class=\"line\">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li>\n<li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li>\n</ul>\n<h4 id=\"15-1-Lambda表达式-方法引用\"><a href=\"#15-1-Lambda表达式-方法引用\" class=\"headerlink\" title=\"15.1 Lambda表达式-方法引用\"></a>15.1 Lambda表达式-方法引用</h4><ul>\n<li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li>\n<li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li>\n</ul>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-Stream-API\"><a href=\"#16-Stream-API\" class=\"headerlink\" title=\"16. Stream API\"></a>16. Stream API</h3><ul>\n<li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p>\n</li>\n<li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>\n<ul>\n<li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>\n<li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n</li>\n<li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p>\n<ul>\n<li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>\n<li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-1-stream方法使用\"><a href=\"#16-1-stream方法使用\" class=\"headerlink\" title=\"16.1 stream方法使用\"></a>16.1 stream方法使用</h4><ul>\n<li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找出最长的单词</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p>","more":"<ol>\n<li><a href=\"#id1\">Collection集合</a></li>\n<li><a href=\"#id2\">List集合</a></li>\n<li><a href=\"#id3\">泛型机制</a></li>\n<li><a href=\"#id4\">Queue集合</a></li>\n<li><a href=\"#id5\">*ArrayList类</a></li>\n<li><a href=\"#id6\">Vector类</a></li>\n<li><a href=\"#id7\">Stack类</a></li>\n<li><a href=\"#id8\">*LinkedList类</a></li>\n<li><a href=\"#id9\">Set集合</a></li>\n<li><a href=\"#id10\">HashSet类</a></li>\n<li><a href=\"#id11\">TreeSet类</a></li>\n<li><a href=\"#id12\">Map集合</a></li>\n<li><a href=\"#id13\">HashMap类</a></li>\n<li><a href=\"#id14\">TreeMap类</a></li>\n<li><a href=\"#id15\">Lambda表达式</a></li>\n<li><a href=\"#id16\">Stream API</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Collection集合\"><a href=\"#1-Collection集合\" class=\"headerlink\" title=\"1. Collection集合\"></a>1. Collection集合</h3><ul>\n<li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li>\n</ul>\n<blockquote>\n<p>数组与集合的比较</p>\n<ul>\n<li>数组的特点：<ol>\n<li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li>\n<li>支持下标访问，实现随机访问非常方便；</li>\n<li>增删操作不方便，可能会移动大量元素；</li>\n<li>数组一旦声明长度固定无法更改；</li>\n<li>数组支持基本数据类型，也支持引用数据类型；</li>\n</ol>\n</li>\n<li>集合的特点：<ol>\n<li>集合的存储单元可以不连续，数据类容可以不相同；</li>\n<li>集合部分支持下标访问，部分不支持；</li>\n<li>集合中增删元素可以不移动大量元素；</li>\n<li>集合大小可以随时动态调整；</li>\n<li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Collection接口</span><br><span class=\"line\">    |————List接口</span><br><span class=\"line\">        |————ArrayList类</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">        |————Stack类</span><br><span class=\"line\">        |————Vector类</span><br><span class=\"line\">    |————Queue接口</span><br><span class=\"line\">        |————LinkedList类</span><br><span class=\"line\">    |————Set接口</span><br><span class=\"line\">        |————HashSet类</span><br><span class=\"line\">        |————TreeSet类</span><br><span class=\"line\">-Map接口</span><br><span class=\"line\">    |————HashMap类</span><br><span class=\"line\">    |————TreeMap类</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li>\n<li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li>\n<li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li>\n</ul>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Collection集合的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e);</td>\n<td>向集合中添加对象</td>\n</tr>\n<tr>\n<td>boolean contains(Object o);</td>\n<td>判断是否包含指定对象</td>\n</tr>\n<tr>\n<td>boolean remove(Object o);</td>\n<td>从集合中删除对象</td>\n</tr>\n<tr>\n<td>void clear();</td>\n<td>清空集合</td>\n</tr>\n<tr>\n<td>int size();</td>\n<td>返回包含对象的个数</td>\n</tr>\n<tr>\n<td>boolean isEmpty();</td>\n<td>判断是否为空</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collection c2 = <span class=\"keyword\">new</span> ArrayList(); <span class=\"comment\">//多态</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b1 = c2.add(<span class=\"keyword\">new</span> String(<span class=\"string\">\"one\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b2 = c2.add(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"c2 = \"</span> + c2); <span class=\"comment\">//[one, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> b3 = c2.contains(<span class=\"keyword\">new</span> Integer(<span class=\"number\">2</span>));<span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-List集合\"><a href=\"#2-List集合\" class=\"headerlink\" title=\"2. List集合\"></a>2. List集合</h3><ul>\n<li>java.util.List集合是Collection集合的子集合。</li>\n<li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul>\n<li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li>\n<li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li>\n<li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li>\n<li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li>\n</ul>\n</li>\n<li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>List类常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index, E element)</td>\n<td>向集合指定位置添加元素</td>\n</tr>\n<tr>\n<td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td>\n<td>向集合中添加所有元素</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>从集合中获取指定位置的元素</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定位置的元素</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定位置的元素</td>\n</tr>\n<tr>\n<td>int indexOf(Object o)</td>\n<td>在集合中检索某个对象，判断逻辑(o==null?get(i)==null:o.equals(get(i)))</td>\n</tr>\n<tr>\n<td><t> T[] toArray(T[] a)</t></td>\n<td>将集合中的对象序列化以对象数组的形式返回。</td>\n</tr>\n<tr>\n<td>List<e> subList(int fromIndex, int toIndex)</e></td>\n<td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td>\n</tr>\n</tbody></table>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-泛型机制\"><a href=\"#3-泛型机制\" class=\"headerlink\" title=\"3. 泛型机制\"></a>3. 泛型机制</h3><ul>\n<li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li>\n<li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li>\n<li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li>\n<li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;{}</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li>\n<li>泛型可以用在哪里：<ol>\n<li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li>\n<li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li>\n<li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li>\n<li>方法参数泛型限制，高级泛型，规范边界，extends，super</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Queue集合\"><a href=\"#4-Queue集合\" class=\"headerlink\" title=\"4. Queue集合\"></a>4. Queue集合</h3><ul>\n<li>java.util.Queue集合是Collection集合的子集合。</li>\n<li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li>\n<li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Queue接口中主要方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean offer(E e)</td>\n<td>将一个对象添加至队尾，若添加成功则返回true</td>\n</tr>\n<tr>\n<td>E poll()</td>\n<td>从队首删除并返回一个元素</td>\n</tr>\n<tr>\n<td>E peek()</td>\n<td>返回队首的元素（但并不删除）</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue&lt;Integer&gt; q1 = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">//将数据11、22、33、44、55依次入队</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    q1.offer(i*<span class=\"number\">11</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-ArrayList类\"><a href=\"#5-ArrayList类\" class=\"headerlink\" title=\"5. *ArrayList类\"></a>5. *ArrayList类</h3><ol>\n<li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li>\n<li>ArrayList特点适合遍历轮询，不适合插入删除</li>\n<li>如何构建一个ArrayList对象<ul>\n<li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li>\n</ul>\n</li>\n<li>ArrayList中常用的方法<ul>\n<li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li>\n</ul>\n</li>\n<li>类中其他常用的方法<ul>\n<li>addAll并集，removeAll差集，ratainAll交集;</li>\n<li>indexOf()，lastIndexOf()，contains()，List=subList();</li>\n<li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li>\n<li>toArray(T[] x)，trimToSize();</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-Vector类\"><a href=\"#6-Vector类\" class=\"headerlink\" title=\"6. Vector类\"></a>6. Vector类</h3><ol>\n<li>是ArrayList集合的早期版本，所属的包 java.util<ul>\n<li>Vector底层也是利用(动态)数组的形式存储</li>\n<li>Vector是线程同步的(synchronized)，安全性高，效率较低</li>\n</ul>\n</li>\n<li>扩容方式与ArrayList不同<ul>\n<li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li>\n</ul>\n</li>\n<li>构造方法和常用方法与ArrayList类似</li>\n</ol>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-Stack类\"><a href=\"#7-Stack类\" class=\"headerlink\" title=\"7. Stack类\"></a>7. Stack类</h3><ol>\n<li>Stack类，栈，java.util包</li>\n<li>构造方法只有一个无参数</li>\n<li>除了继承自Vacton类的方法外还有特殊的方法<ul>\n<li>push(E e)将某一个元素压入栈顶(add())</li>\n<li>E = pop()将某一个元素从栈顶取出并删掉(E = remove())</li>\n<li>E = peek()查看栈顶的一个元素 不删除(get())</li>\n<li>boolean = empty()判断栈内元素是否为空(isEmpty())</li>\n<li>int = search()查找给定的元素在占中的位置(indexOf())</li>\n</ul>\n</li>\n<li>应用场景<ul>\n<li>中国象棋，悔棋</li>\n<li>栈中存储每一次操作的步骤</li>\n<li>撤销功能</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-LinkedList类\"><a href=\"#8-LinkedList类\" class=\"headerlink\" title=\"8. *LinkedList类\"></a>8. *LinkedList类</h3><ol>\n<li>LinkedList类，java.util包</li>\n<li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul>\n<li>适合于插入或删除  不适合遍历轮询</li>\n</ul>\n</li>\n<li>构建对象<ul>\n<li>无参数构造方法，带参数的构造方法(collection)</li>\n</ul>\n</li>\n<li>常用的方法<ul>\n<li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li>\n<li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li>\n</ul>\n</li>\n<li>插入删除的特性是否像想的那样<ul>\n<li>对比ArrayList  Linked</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-Set集合\"><a href=\"#9-Set集合\" class=\"headerlink\" title=\"9. Set集合\"></a>9. Set集合</h3><ul>\n<li>java.util.Set集合是Collection集合的子集合。</li>\n<li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li>\n<li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li>\n<li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法和Collection集合基本一样</span></span><br><span class=\"line\">Set&lt;String&gt; set1 = <span class=\"keyword\">new</span> HashSet&lt;String&gt;();</span><br><span class=\"line\">set1.add(<span class=\"string\">\"one\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"s1=\"</span>+s1);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>set集合的无重复特性<ul>\n<li>HashSet，无重复原则有两个方法同时起作用<ul>\n<li>equals    hashCode</li>\n<li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li>\n<li>如果想要改变其比较的规则  可以重写上述两个方法</li>\n</ul>\n</li>\n<li>TreeSet，无重复原则有一个方法起作用<ul>\n<li>compareTo</li>\n<li>上述这个方法不是每一个对象都有的</li>\n<li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li>\n<li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"9-1-Set集合的遍历\"><a href=\"#9-1-Set集合的遍历\" class=\"headerlink\" title=\"9.1 Set集合的遍历\"></a>9.1 Set集合的遍历</h4><ul>\n<li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td>判断集合中是否有可以迭代/访问的元素</td>\n</tr>\n<tr>\n<td>E next()</td>\n<td>用于取出一个元素并指向下一个元素</td>\n</tr>\n<tr>\n<td>void remove()</td>\n<td>用于删除访问到的最后一个元素</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Iterator&lt;String&gt; it = set1.iterator();<span class=\"comment\">//获取当前集合的迭代器对象</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext()) &#123;<span class=\"comment\">//判断是否有可以访问的元素</span></span><br><span class=\"line\">    String temp = it.next();<span class=\"comment\">//取出一个并指向下一个</span></span><br><span class=\"line\">    System.out.println( temp );</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"string\">\"two\"</span>.equals(temp))&#123;</span><br><span class=\"line\">        it.remove();<span class=\"comment\">//删除set1中该元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>增强for循环(for each结构)</li>\n<li>语法格式：<code>for(元素类型 变量名:集合/数组){ 循环体; }</code>。</li>\n<li>执行流程：不断从集合/数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历集合</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(String ts : s1) &#123;</span><br><span class=\"line\">    System.out.println(ts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//遍历数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] arr = &#123;<span class=\"number\">11</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">44</span>,<span class=\"number\">55</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> ti : arr) &#123;</span><br><span class=\"line\">    System.out.println(ti);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-HashSet类\"><a href=\"#10-HashSet类\" class=\"headerlink\" title=\"10. HashSet类\"></a>10. HashSet类</h3><ol>\n<li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li>\n<li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li>\n<li>创建对象：无参数，有参数</li>\n<li>集合容器的基本使用<ul>\n<li>增删改查：boolean = add(value)，addAll(collection c)，retainAll，removeAll，boolean = remove(Object)</li>\n<li>没有修改方法</li>\n<li>iterator()  获取一个迭代器对象</li>\n<li>size()</li>\n</ul>\n</li>\n<li>无重复的原则<ul>\n<li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT = new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-TreeSet类\"><a href=\"#11-TreeSet类\" class=\"headerlink\" title=\"11. TreeSet类\"></a>11. TreeSet类</h3><ol>\n<li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p>\n</li>\n<li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p>\n</li>\n<li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p>\n</li>\n<li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p>\n</li>\n<li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p>\n<ul>\n<li>左子树中的任意节点元素都小于根节点元素；</li>\n<li>右子树中的任意节点元素都大于根节点元素；</li>\n<li>左子树和右子树内部也遵守上述规则；</li>\n</ul>\n</li>\n<li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p>\n</li>\n<li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p>\n<ol>\n<li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li>\n<li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p>\n</blockquote>\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-Map集合\"><a href=\"#12-Map集合\" class=\"headerlink\" title=\"12. Map集合\"></a>12. Map集合</h3><ul>\n<li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li>\n<li>Map：映射，通过某一个key可以直接定位到一个value值</li>\n<li>key无序无重复   value无序可重复<ul>\n<li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li>\n</ul>\n</li>\n<li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li>\n<li>Map基本使用：HashMap，TreeMap，Properties</li>\n<li>Map集合常用方法：<ul>\n<li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li>\n</ul>\n</li>\n<li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li>\n<li>Map集合的性能调优：<ul>\n<li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size/capacity),默认0.75）</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-HashMap类\"><a href=\"#13-HashMap类\" class=\"headerlink\" title=\"13. HashMap类\"></a>13. HashMap类</h3><ol>\n<li>包:java.util，底层散列表的形式（数组+链表）</li>\n<li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li>\n<li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul>\n<li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li>\n</ul>\n</li>\n<li>基本方法：<ul>\n<li>增 put(key,value)，存放一组映射关系key-value<ol>\n<li>key存储的顺序与取得顺序不同</li>\n<li>不同的key可以存储相同的value</li>\n<li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li>\n</ol>\n</li>\n<li>删 E = remove(key);</li>\n<li>改 replace(key,newValue)，put(key,value2)</li>\n<li>查 E = get(key)；</li>\n<li>Set<key> = keySet()获取全部的key</key></li>\n<li>Set<entry> = entrySet();</entry></li>\n<li>size();</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class=\"comment\">//获取集合中全部的entry对象</span></span><br><span class=\"line\">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(it.hasNext())&#123;</span><br><span class=\"line\">    Entry&lt;Integer,String&gt; entry = it.next();<span class=\"comment\">//entry  key value</span></span><br><span class=\"line\">    Integer key = entry.getKey();</span><br><span class=\"line\">    String value = entry.getValue();</span><br><span class=\"line\">    System.out.println(key+<span class=\"string\">\"--\"</span>+value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>除了上述几个常用的方法外  其他API中提供的方法<ul>\n<li>clear，containsKey(key)，containsValue(value)</li>\n<li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li>\n<li>isEmpty()</li>\n<li>putAll(map)</li>\n<li>putIfAbsent(key,value);//如果key不存在才向集合内添加  如果key存在就不添加啦</li>\n</ul>\n</li>\n<li>map集合在什么情形下用?<ol>\n<li>想要存储一组元素<ul>\n<li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li>\n</ul>\n</li>\n<li>如果发现长度以后不确定—&gt;集合</li>\n</ol>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\">list</th>\n<th align=\"center\">Set</th>\n<th align=\"center\">Map</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">List家族有序的</td>\n<td align=\"center\">Set家族无重复</td>\n<td align=\"center\">Map家族k-v</td>\n</tr>\n<tr>\n<td align=\"center\">存储有顺序用这个</td>\n<td align=\"center\">存储元素希望自动去掉重复元素用这个</td>\n<td align=\"center\">通过唯一的k快速找寻v用这个</td>\n</tr>\n<tr>\n<td align=\"center\">ArrayList:更适合遍历轮询</td>\n<td align=\"center\">HashSet:性能更高</td>\n<td align=\"center\">HashMap:性能更高</td>\n</tr>\n<tr>\n<td align=\"center\">LinkedList:更适合插入和删除</td>\n<td align=\"center\">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td>\n<td align=\"center\">Tree:希望存进去的元素key自动排序</td>\n</tr>\n<tr>\n<td align=\"center\">Stack:LIFO</td>\n<td align=\"center\">-</td>\n<td align=\"center\">-</td>\n</tr>\n</tbody></table>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-TreeMap类\"><a href=\"#14-TreeMap类\" class=\"headerlink\" title=\"14. TreeMap类\"></a>14. TreeMap类</h3><ol>\n<li>java.util包</li>\n<li>构造方法：无参数，带map参数</li>\n<li>常用方法：put， get，remove，replace，size</li>\n<li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li>\n<li>自然有序，按照Unicode编码自然有序<ul>\n<li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-Lambda表达式\"><a href=\"#15-Lambda表达式\" class=\"headerlink\" title=\"15. Lambda表达式\"></a>15. Lambda表达式</h3><ul>\n<li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li>\n<li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li>\n<li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code></strong>和<strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(int a, int b) -&gt; a+b</span><br><span class=\"line\">() -&gt; 42</span><br><span class=\"line\">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li>\n<li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li>\n</ul>\n<h4 id=\"15-1-Lambda表达式-方法引用\"><a href=\"#15-1-Lambda表达式-方法引用\" class=\"headerlink\" title=\"15.1 Lambda表达式-方法引用\"></a>15.1 Lambda表达式-方法引用</h4><ul>\n<li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li>\n<li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li>\n</ul>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-Stream-API\"><a href=\"#16-Stream-API\" class=\"headerlink\" title=\"16. Stream API\"></a>16. Stream API</h3><ul>\n<li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p>\n</li>\n<li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p>\n<ul>\n<li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>\n<li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li>\n<li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>\n<li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>\n</ul>\n</li>\n<li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p>\n<ul>\n<li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li>\n<li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"16-1-stream方法使用\"><a href=\"#16-1-stream方法使用\" class=\"headerlink\" title=\"16.1 stream方法使用\"></a>16.1 stream方法使用</h4><ul>\n<li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 找出最长的单词</span></span><br><span class=\"line\">Stream&lt;String&gt; stream = Stream.of(<span class=\"string\">\"I\"</span>, <span class=\"string\">\"love\"</span>, <span class=\"string\">\"you\"</span>, <span class=\"string\">\"too\"</span>);</span><br><span class=\"line\">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class=\"line\"><span class=\"comment\">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class=\"line\">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>"},{"title":"七、JavaSE多线程","date":"2019-07-09T10:07:41.000Z","_content":"\n\n多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。 \n程序的执行其实都是在抢CPU的资源，CPU的执行权。 \n多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [实现线程的过程](#id2)\n3. [线程常用方法](#id3)\n4. [线程池](#id4)\n5. [线程的主要状态](#id5)\n6. [线程的同步机制](#id6)\n7. [线程的死锁](#id7)\n8. [内存可见性](#id8)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  \n- 进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个**进程包含n个线程**；(进程是系统进行资源分配和调度的一个独立单位)。\n- 线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。\n- 多进程是指操作系统能同时运行多个任务（程序）。\n- 多线程是指在同一程序(一个进程)中有多个顺序流在执行。\n- 并行与并发：\n    * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。\n    * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。\n- 线程和进程一样分为五个阶段：**创建**、**就绪状态**、**执行状态**、**等待/挂起/阻塞**、**终止/异常/消亡**。\n\n\n<span id=\"id2\"><span>\n### 2. 实现线程的过程\njava.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。\n\n- 自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  \n- 自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 \n\n#### 2.1 实现方式一：继承Thread类\n1. 自己描述一个类\n2. 继承父类Thread\n3. 重写run方法\n4. new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)\n\n``` java\nclass MyThread extends Thread{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nmt.start();\n```\n\n#### 2.2 实现方式二：实现Runnable接口\n1. 自己描述一个类\n2. 实现一个父接口Runnable\n3. 重写run方法\n4. new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态\n\n``` java\nclass MyThread implements Runnable{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nThread td = new Thread(mt);\ntd.start();\n```\n\n#### 2.3 两种方式优缺点：\n- 使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类\n- 使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。\n\n\n<span id=\"id3\"><span>\n### 3. 线程常用方法\n\n![Thread常用方法](http://cdn.chaooo.top/java/thread.jpg)\n\n#### 3.1 相关方法的解析：\n* Thread()：使用无参方式构造对象  \n* Thread(String name)：根据参数指定的名称来构造对象。  \n* Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   \n* Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。\n* void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  \n* void **start()**：用于**启动线程**，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。\n- int getPriority()：用于获取线程的优先级，优先级1-10\n- void setPriority(int)：更改线程的优先级\n\n#### 3.2 多线程原理分析\n1. 执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  \n2. 对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  \n3. 当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  \n4. 两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  \n\n#### 3.3 线程的编号和名称\n- long getId()：用于获取调用对象所表示线程的编号\n- String getName()：用于获取调用对象所表示线程的名称\n- void setName()：用于设置线程的名称为参数指定的数值\n- static Thread currentThread()：获取当前正在执行线程的引用\n\n\n<span id=\"id4\"><span>\n### 4. 线程池\n- 为了避免重复的创建线程，线程池的出现可以**让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。\n- 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。\n- 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务\n    * 接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService\n    * 抽象类：AbstractExecutorService\n    * 实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor\n- 创建线程的第三种方式是实现Callable接口，主要用于线程池\n\n\n<span id=\"id5\"><span>\n### 5. 线程的主要状态\n\n![线程的生命周期](http://cdn.chaooo.top/java/threadLife.jpg)\n\n1. 新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行\n2. 就绪状态：调用start()进入的状态，此时线程还是没有开始执行\n3. 运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态\n4. 消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止\n5. 阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态\n\n#### 5.1 线程的休眠\n- **终止线程**：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。\n- static void **yield()**：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。\n- static void **sleep(times)**：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。\n\n#### 5.1 线程的等待\n- void **join()**：等待该线程终止，让多个线程同步执行，变成单个线程\n- void **join(long millis)**：表示等待参数指定的毫秒数\n- **对象.wait()** 和 **对象.notify()/notifyAll()**可以让线程的状态来回切换\n- sleep()和wait()的区别：\n\n|sleep()和wait()的区别|sleep() |wait()|\n|------|----------------|------|\n|1.类  |Thread类        |Object类|\n|2.调用|静态 类名.       | 对象. |\n|3.理解|调用位置的线程等待|对象调用，访问对象的其他线程等待|\n|4.唤醒|不需要唤醒       |需要其他对象调用notify唤醒|\n|5.锁  |不会释放锁       |等待后会释放锁|\n\n#### 5.2 守护线程\n- boolean **isDeamon()**：用于判断是否为守护线程\n- void **setDeamon(boolean on)**：用于设置线程为守护线程\n- Java线程有两类：\n    * 用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程\n    * 守护线程：运行在后台，为其他前台线程服务\n- 守护线程特点：\n    * **一旦所有线程都结束运行，守护线程会随JVM一起结束工作**\n- 守护线程应用：\n    * 数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。\n- 设置守护线程：\n    * 可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程\n\n\n<span id=\"id6\"><span>\n### 6. 线程的同步机制\n- 条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。\n- 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做**线程的同步机制**。\n\n- Java提供了一种**内置的锁机制**来支持**原子性**，使用**synchronized**关键字来保证线程执行操作的原子性，叫做**对象/同步锁机制**。\n- 特征修饰符synchronized：表示同步，一个时间点只有一个线程访问\n- 线程安全锁：两种形式是（锁定的永远是对象）\n    1. 使用同步代码块的方式，将synchronized关键字放在方法体内部\n    ``` java\n    synchronized(对象){\n        //需同步执行(锁定)的代码\n    }\n    ```\n    2. 使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象\n    ``` java\n    public synchronized void 方法名(){}\n    ```\n\n- 使用synchronized保证线程同步时应当注意：\n    1. 多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用\n    2. 在使用同步块时应当尽量减少同步范围以提高并发的执行效率\n\n> 1. 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。\n> 2. 每个对象只有一个锁（lock）与之相关联。\n> 3. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。\n\n\n<span id=\"id7\"><span>\n### 7. 线程的死锁\nJava线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。\n\n``` java\n/**当两个线程或多个线程之间相互锁定时就形成了死锁**/\n//线程一：\npublic void run() {   \n    synchronized(a) { //表示:持有对象锁a,等待对象锁b\n        synchronized(b) {\n            //...\n        }\n    }\n}\n//线程二：\npublic void run() {   \n    synchronized(b) { //表示:持有对象锁b,等待对象锁a\n        synchronized(a) {\n            //...\n        }\n    }\n}\n// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。\n```\n\n- 产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。\n- 隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。\n- 两种导致隐性死锁的情况：加锁次序和占有并等待。\n    * 加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。\n    * 占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。\n\n#### 7.1 死锁的避免 \n- 避免死锁的原则：顺序上锁，反向解锁，不要回头\n- 静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。\n- 动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：**安全序列**和**银行家算法**。\n\n\n\n\n<span id=\"id8\"><span>\n### 8.内存可见性\n#### 8.1 基本概念\n- 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到\n- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量\n- Java内存模型(JMM)：\n    * Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。\n    * 所有的变量都存储在主内存中\n    * 每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)\n- Java内存模型规定：\n    * 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。\n    * 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\n- 要实现共享变量的可见性，必须保证两点：\n    * 线程修改后的共享变量值能够及时从工作内存中刷新到主内存中\n    * 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。\n- Java**语言层面**支持的可见性实现方式：Synchronized，volatile\n\n#### 8.2 Synchronized实现可见性\n- Synchronized能够实现：原子性(同步)、可见性\n- JMM关于synchronized的两条规定：\n    * 线程解锁前，必须把共享变量的最新值刷新到主内存中\n    * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）\n- 线程执行互斥代码的过程：\n    1. 获得互斥锁\n    2. 清空工作内存\n    3. 从主内存拷贝变量的最新副本到工作内存\n    4. 执行代码\n    5. 将更改后的共享变量的值刷新到主内存\n    6. 释放互斥锁\n- 重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化\n    1. 编译器优化重排序（编译器处理）\n    2. 指令级并行重排序（处理器优化）\n    3. 内存系统的重排序（处理器读写缓存的优化）\n- as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致\n- 单线程中重排序不会带来内存可见性问题\n- 多线程中程序交错执行时，重排序可能造成内存可见性问题\n\n|  不可见的原因        |syschronized解决方案 |\n|---------------------|-------|\n|1.线程的交叉执行       |原子性|\n|2.重排序结合线程交叉执行|原子性|\n|3.共享变量未及时更新    |可见性|\n\n\n#### 8.3 volatile实现可见性\n- 深入来说：通过加入内存屏障和禁止重排序优化来实现的。\n    * 对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令\n    * 对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令\n- 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。\n- 线程**写**volatile变量的过程：\n    1. 改变线程工作内存中volatile变量副本的值\n    2. 将改变后的副本的值从工作内存刷新到主内存\n- 线程**读**volatile变量的过程：\n    1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n    2. 从工作内存中读取volatile变量的副本\n- volatile不能保证volatile变量复合操作的原子性\n- volatile适用场景：\n    1. 对变量的写操作不依赖其当前值\n    2. 该变量没有包含在具有其他变量的不变式中\n\n#### 8.4 Synchronized和volatile比较\n- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n- 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁\n- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性\n- volatile没有synchronized使用广泛。\n\n\n","source":"_posts/07_JavaSE多线程.md","raw":"---\ntitle: 七、JavaSE多线程\ndate: 2019-07-09 18:07:41\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。 \n程序的执行其实都是在抢CPU的资源，CPU的执行权。 \n多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。\n<!-- more -->\n\n1. [基本概念](#id1)\n2. [实现线程的过程](#id2)\n3. [线程常用方法](#id3)\n4. [线程池](#id4)\n5. [线程的主要状态](#id5)\n6. [线程的同步机制](#id6)\n7. [线程的死锁](#id7)\n8. [内存可见性](#id8)\n\n<span id=\"id1\"><span>\n### 1. 基本概念\n- 程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  \n- 进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个**进程包含n个线程**；(进程是系统进行资源分配和调度的一个独立单位)。\n- 线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。\n- 多进程是指操作系统能同时运行多个任务（程序）。\n- 多线程是指在同一程序(一个进程)中有多个顺序流在执行。\n- 并行与并发：\n    * 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。\n    * 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。\n- 线程和进程一样分为五个阶段：**创建**、**就绪状态**、**执行状态**、**等待/挂起/阻塞**、**终止/异常/消亡**。\n\n\n<span id=\"id2\"><span>\n### 2. 实现线程的过程\njava.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。\n\n- 自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  \n- 自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 \n\n#### 2.1 实现方式一：继承Thread类\n1. 自己描述一个类\n2. 继承父类Thread\n3. 重写run方法\n4. new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)\n\n``` java\nclass MyThread extends Thread{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nmt.start();\n```\n\n#### 2.2 实现方式二：实现Runnable接口\n1. 自己描述一个类\n2. 实现一个父接口Runnable\n3. 重写run方法\n4. new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态\n\n``` java\nclass MyThread implements Runnable{\n    @Override\n    public void run(){ \n        //这里编写该线程的执行任务\n    }\n}\nMyThread mt = new MyThread();\nThread td = new Thread(mt);\ntd.start();\n```\n\n#### 2.3 两种方式优缺点：\n- 使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类\n- 使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。\n\n\n<span id=\"id3\"><span>\n### 3. 线程常用方法\n\n![Thread常用方法](http://cdn.chaooo.top/java/thread.jpg)\n\n#### 3.1 相关方法的解析：\n* Thread()：使用无参方式构造对象  \n* Thread(String name)：根据参数指定的名称来构造对象。  \n* Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   \n* Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。\n* void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  \n* void **start()**：用于**启动线程**，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。\n- int getPriority()：用于获取线程的优先级，优先级1-10\n- void setPriority(int)：更改线程的优先级\n\n#### 3.2 多线程原理分析\n1. 执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  \n2. 对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  \n3. 当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  \n4. 两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  \n\n#### 3.3 线程的编号和名称\n- long getId()：用于获取调用对象所表示线程的编号\n- String getName()：用于获取调用对象所表示线程的名称\n- void setName()：用于设置线程的名称为参数指定的数值\n- static Thread currentThread()：获取当前正在执行线程的引用\n\n\n<span id=\"id4\"><span>\n### 4. 线程池\n- 为了避免重复的创建线程，线程池的出现可以**让线程进行复用**。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。\n- 在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。\n- 一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务\n    * 接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService\n    * 抽象类：AbstractExecutorService\n    * 实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor\n- 创建线程的第三种方式是实现Callable接口，主要用于线程池\n\n\n<span id=\"id5\"><span>\n### 5. 线程的主要状态\n\n![线程的生命周期](http://cdn.chaooo.top/java/threadLife.jpg)\n\n1. 新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行\n2. 就绪状态：调用start()进入的状态，此时线程还是没有开始执行\n3. 运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态\n4. 消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止\n5. 阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态\n\n#### 5.1 线程的休眠\n- **终止线程**：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。\n- static void **yield()**：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。\n- static void **sleep(times)**：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。\n\n#### 5.1 线程的等待\n- void **join()**：等待该线程终止，让多个线程同步执行，变成单个线程\n- void **join(long millis)**：表示等待参数指定的毫秒数\n- **对象.wait()** 和 **对象.notify()/notifyAll()**可以让线程的状态来回切换\n- sleep()和wait()的区别：\n\n|sleep()和wait()的区别|sleep() |wait()|\n|------|----------------|------|\n|1.类  |Thread类        |Object类|\n|2.调用|静态 类名.       | 对象. |\n|3.理解|调用位置的线程等待|对象调用，访问对象的其他线程等待|\n|4.唤醒|不需要唤醒       |需要其他对象调用notify唤醒|\n|5.锁  |不会释放锁       |等待后会释放锁|\n\n#### 5.2 守护线程\n- boolean **isDeamon()**：用于判断是否为守护线程\n- void **setDeamon(boolean on)**：用于设置线程为守护线程\n- Java线程有两类：\n    * 用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程\n    * 守护线程：运行在后台，为其他前台线程服务\n- 守护线程特点：\n    * **一旦所有线程都结束运行，守护线程会随JVM一起结束工作**\n- 守护线程应用：\n    * 数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。\n- 设置守护线程：\n    * 可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程\n\n\n<span id=\"id6\"><span>\n### 6. 线程的同步机制\n- 条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。\n- 当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做**线程的同步机制**。\n\n- Java提供了一种**内置的锁机制**来支持**原子性**，使用**synchronized**关键字来保证线程执行操作的原子性，叫做**对象/同步锁机制**。\n- 特征修饰符synchronized：表示同步，一个时间点只有一个线程访问\n- 线程安全锁：两种形式是（锁定的永远是对象）\n    1. 使用同步代码块的方式，将synchronized关键字放在方法体内部\n    ``` java\n    synchronized(对象){\n        //需同步执行(锁定)的代码\n    }\n    ```\n    2. 使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象\n    ``` java\n    public synchronized void 方法名(){}\n    ```\n\n- 使用synchronized保证线程同步时应当注意：\n    1. 多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用\n    2. 在使用同步块时应当尽量减少同步范围以提高并发的执行效率\n\n> 1. 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。\n> 2. 每个对象只有一个锁（lock）与之相关联。\n> 3. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。\n\n\n<span id=\"id7\"><span>\n### 7. 线程的死锁\nJava线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。\n\n``` java\n/**当两个线程或多个线程之间相互锁定时就形成了死锁**/\n//线程一：\npublic void run() {   \n    synchronized(a) { //表示:持有对象锁a,等待对象锁b\n        synchronized(b) {\n            //...\n        }\n    }\n}\n//线程二：\npublic void run() {   \n    synchronized(b) { //表示:持有对象锁b,等待对象锁a\n        synchronized(a) {\n            //...\n        }\n    }\n}\n// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。\n```\n\n- 产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。\n- 隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。\n- 两种导致隐性死锁的情况：加锁次序和占有并等待。\n    * 加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。\n    * 占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。\n\n#### 7.1 死锁的避免 \n- 避免死锁的原则：顺序上锁，反向解锁，不要回头\n- 静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。\n- 动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：**安全序列**和**银行家算法**。\n\n\n\n\n<span id=\"id8\"><span>\n### 8.内存可见性\n#### 8.1 基本概念\n- 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到\n- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量\n- Java内存模型(JMM)：\n    * Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。\n    * 所有的变量都存储在主内存中\n    * 每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)\n- Java内存模型规定：\n    * 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。\n    * 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。\n- 要实现共享变量的可见性，必须保证两点：\n    * 线程修改后的共享变量值能够及时从工作内存中刷新到主内存中\n    * 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。\n- Java**语言层面**支持的可见性实现方式：Synchronized，volatile\n\n#### 8.2 Synchronized实现可见性\n- Synchronized能够实现：原子性(同步)、可见性\n- JMM关于synchronized的两条规定：\n    * 线程解锁前，必须把共享变量的最新值刷新到主内存中\n    * 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）\n- 线程执行互斥代码的过程：\n    1. 获得互斥锁\n    2. 清空工作内存\n    3. 从主内存拷贝变量的最新副本到工作内存\n    4. 执行代码\n    5. 将更改后的共享变量的值刷新到主内存\n    6. 释放互斥锁\n- 重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化\n    1. 编译器优化重排序（编译器处理）\n    2. 指令级并行重排序（处理器优化）\n    3. 内存系统的重排序（处理器读写缓存的优化）\n- as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致\n- 单线程中重排序不会带来内存可见性问题\n- 多线程中程序交错执行时，重排序可能造成内存可见性问题\n\n|  不可见的原因        |syschronized解决方案 |\n|---------------------|-------|\n|1.线程的交叉执行       |原子性|\n|2.重排序结合线程交叉执行|原子性|\n|3.共享变量未及时更新    |可见性|\n\n\n#### 8.3 volatile实现可见性\n- 深入来说：通过加入内存屏障和禁止重排序优化来实现的。\n    * 对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令\n    * 对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令\n- 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。\n- 线程**写**volatile变量的过程：\n    1. 改变线程工作内存中volatile变量副本的值\n    2. 将改变后的副本的值从工作内存刷新到主内存\n- 线程**读**volatile变量的过程：\n    1. 从主内存中读取volatile变量的最新值到线程的工作内存中\n    2. 从工作内存中读取volatile变量的副本\n- volatile不能保证volatile变量复合操作的原子性\n- volatile适用场景：\n    1. 对变量的写操作不依赖其当前值\n    2. 该变量没有包含在具有其他变量的不变式中\n\n#### 8.4 Synchronized和volatile比较\n- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；\n- 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁\n- synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性\n- volatile没有synchronized使用广泛。\n\n\n","slug":"07_JavaSE多线程","published":1,"updated":"2019-07-20T14:51:55.308Z","_id":"cjyblnrww0023xwt3c7zzkv5r","comments":1,"layout":"post","photos":[],"link":"","content":"<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">实现线程的过程</a></li>\n<li><a href=\"#id3\">线程常用方法</a></li>\n<li><a href=\"#id4\">线程池</a></li>\n<li><a href=\"#id5\">线程的主要状态</a></li>\n<li><a href=\"#id6\">线程的同步机制</a></li>\n<li><a href=\"#id7\">线程的死锁</a></li>\n<li><a href=\"#id8\">内存可见性</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li>\n<li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li>\n<li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li>\n<li>多进程是指操作系统能同时运行多个任务（程序）。</li>\n<li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li>\n<li>并行与并发：<ul>\n<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>\n<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>\n</ul>\n</li>\n<li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-实现线程的过程\"><a href=\"#2-实现线程的过程\" class=\"headerlink\" title=\"2. 实现线程的过程\"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p>\n<ul>\n<li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li>\n<li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li>\n</ul>\n<h4 id=\"2-1-实现方式一：继承Thread类\"><a href=\"#2-1-实现方式一：继承Thread类\" class=\"headerlink\" title=\"2.1 实现方式一：继承Thread类\"></a>2.1 实现方式一：继承Thread类</h4><ol>\n<li>自己描述一个类</li>\n<li>继承父类Thread</li>\n<li>重写run方法</li>\n<li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">mt.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-实现方式二：实现Runnable接口\"><a href=\"#2-2-实现方式二：实现Runnable接口\" class=\"headerlink\" title=\"2.2 实现方式二：实现Runnable接口\"></a>2.2 实现方式二：实现Runnable接口</h4><ol>\n<li>自己描述一个类</li>\n<li>实现一个父接口Runnable</li>\n<li>重写run方法</li>\n<li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread td = <span class=\"keyword\">new</span> Thread(mt);</span><br><span class=\"line\">td.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-两种方式优缺点：\"><a href=\"#2-3-两种方式优缺点：\" class=\"headerlink\" title=\"2.3 两种方式优缺点：\"></a>2.3 两种方式优缺点：</h4><ul>\n<li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li>\n<li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-线程常用方法\"><a href=\"#3-线程常用方法\" class=\"headerlink\" title=\"3. 线程常用方法\"></a>3. 线程常用方法</h3><p><img src=\"http://cdn.chaooo.top/java/thread.jpg\" alt=\"Thread常用方法\"></p>\n<h4 id=\"3-1-相关方法的解析：\"><a href=\"#3-1-相关方法的解析：\" class=\"headerlink\" title=\"3.1 相关方法的解析：\"></a>3.1 相关方法的解析：</h4><ul>\n<li>Thread()：使用无参方式构造对象  </li>\n<li>Thread(String name)：根据参数指定的名称来构造对象。  </li>\n<li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li>\n<li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li>\n<li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li>\n<li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li>\n</ul>\n<ul>\n<li>int getPriority()：用于获取线程的优先级，优先级1-10</li>\n<li>void setPriority(int)：更改线程的优先级</li>\n</ul>\n<h4 id=\"3-2-多线程原理分析\"><a href=\"#3-2-多线程原理分析\" class=\"headerlink\" title=\"3.2 多线程原理分析\"></a>3.2 多线程原理分析</h4><ol>\n<li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li>\n<li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li>\n<li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li>\n<li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li>\n</ol>\n<h4 id=\"3-3-线程的编号和名称\"><a href=\"#3-3-线程的编号和名称\" class=\"headerlink\" title=\"3.3 线程的编号和名称\"></a>3.3 线程的编号和名称</h4><ul>\n<li>long getId()：用于获取调用对象所表示线程的编号</li>\n<li>String getName()：用于获取调用对象所表示线程的名称</li>\n<li>void setName()：用于设置线程的名称为参数指定的数值</li>\n<li>static Thread currentThread()：获取当前正在执行线程的引用</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4. 线程池\"></a>4. 线程池</h3><ul>\n<li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li>\n<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li>\n<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul>\n<li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li>\n<li>抽象类：AbstractExecutorService</li>\n<li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-线程的主要状态\"><a href=\"#5-线程的主要状态\" class=\"headerlink\" title=\"5. 线程的主要状态\"></a>5. 线程的主要状态</h3><p><img src=\"http://cdn.chaooo.top/java/threadLife.jpg\" alt=\"线程的生命周期\"></p>\n<ol>\n<li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li>\n<li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li>\n<li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li>\n<li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li>\n<li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li>\n</ol>\n<h4 id=\"5-1-线程的休眠\"><a href=\"#5-1-线程的休眠\" class=\"headerlink\" title=\"5.1 线程的休眠\"></a>5.1 线程的休眠</h4><ul>\n<li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li>\n<li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li>\n<li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li>\n</ul>\n<h4 id=\"5-1-线程的等待\"><a href=\"#5-1-线程的等待\" class=\"headerlink\" title=\"5.1 线程的等待\"></a>5.1 线程的等待</h4><ul>\n<li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li>\n<li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li>\n<li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li>\n<li>sleep()和wait()的区别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sleep()和wait()的区别</th>\n<th>sleep()</th>\n<th>wait()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.类</td>\n<td>Thread类</td>\n<td>Object类</td>\n</tr>\n<tr>\n<td>2.调用</td>\n<td>静态 类名.</td>\n<td>对象.</td>\n</tr>\n<tr>\n<td>3.理解</td>\n<td>调用位置的线程等待</td>\n<td>对象调用，访问对象的其他线程等待</td>\n</tr>\n<tr>\n<td>4.唤醒</td>\n<td>不需要唤醒</td>\n<td>需要其他对象调用notify唤醒</td>\n</tr>\n<tr>\n<td>5.锁</td>\n<td>不会释放锁</td>\n<td>等待后会释放锁</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-2-守护线程\"><a href=\"#5-2-守护线程\" class=\"headerlink\" title=\"5.2 守护线程\"></a>5.2 守护线程</h4><ul>\n<li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li>\n<li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li>\n<li>Java线程有两类：<ul>\n<li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li>\n<li>守护线程：运行在后台，为其他前台线程服务</li>\n</ul>\n</li>\n<li>守护线程特点：<ul>\n<li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li>\n</ul>\n</li>\n<li>守护线程应用：<ul>\n<li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li>\n</ul>\n</li>\n<li>设置守护线程：<ul>\n<li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-线程的同步机制\"><a href=\"#6-线程的同步机制\" class=\"headerlink\" title=\"6. 线程的同步机制\"></a>6. 线程的同步机制</h3><ul>\n<li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p>\n</li>\n<li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p>\n</li>\n<li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p>\n</li>\n<li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p>\n</li>\n<li><p>线程安全锁：两种形式是（锁定的永远是对象）</p>\n<ol>\n<li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//需同步执行(锁定)的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>使用synchronized保证线程同步时应当注意：</p>\n<ol>\n<li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li>\n<li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li>\n<li>每个对象只有一个锁（lock）与之相关联。</li>\n<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>\n</ol>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-线程的死锁\"><a href=\"#7-线程的死锁\" class=\"headerlink\" title=\"7. 线程的死锁\"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class=\"line\"><span class=\"comment\">//线程一：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(a) &#123; <span class=\"comment\">//表示:持有对象锁a,等待对象锁b</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//线程二：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(b) &#123; <span class=\"comment\">//表示:持有对象锁b,等待对象锁a</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(a) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li>\n<li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li>\n<li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul>\n<li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li>\n<li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-1-死锁的避免\"><a href=\"#7-1-死锁的避免\" class=\"headerlink\" title=\"7.1 死锁的避免\"></a>7.1 死锁的避免</h4><ul>\n<li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li>\n<li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li>\n<li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-内存可见性\"><a href=\"#8-内存可见性\" class=\"headerlink\" title=\"8.内存可见性\"></a>8.内存可见性</h3><h4 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h4><ul>\n<li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li>\n<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li>\n<li>Java内存模型(JMM)：<ul>\n<li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li>\n<li>所有的变量都存储在主内存中</li>\n<li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li>\n</ul>\n</li>\n<li>Java内存模型规定：<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n</li>\n<li>要实现共享变量的可见性，必须保证两点：<ul>\n<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>\n<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li>\n</ul>\n</li>\n<li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li>\n</ul>\n<h4 id=\"8-2-Synchronized实现可见性\"><a href=\"#8-2-Synchronized实现可见性\" class=\"headerlink\" title=\"8.2 Synchronized实现可见性\"></a>8.2 Synchronized实现可见性</h4><ul>\n<li>Synchronized能够实现：原子性(同步)、可见性</li>\n<li>JMM关于synchronized的两条规定：<ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>\n</ul>\n</li>\n<li>线程执行互斥代码的过程：<ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n</li>\n<li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol>\n<li>编译器优化重排序（编译器处理）</li>\n<li>指令级并行重排序（处理器优化）</li>\n<li>内存系统的重排序（处理器读写缓存的优化）</li>\n</ol>\n</li>\n<li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li>\n<li>单线程中重排序不会带来内存可见性问题</li>\n<li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>不可见的原因</th>\n<th>syschronized解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.线程的交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>2.重排序结合线程交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>3.共享变量未及时更新</td>\n<td>可见性</td>\n</tr>\n</tbody></table>\n<h4 id=\"8-3-volatile实现可见性\"><a href=\"#8-3-volatile实现可见性\" class=\"headerlink\" title=\"8.3 volatile实现可见性\"></a>8.3 volatile实现可见性</h4><ul>\n<li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li>\n</ul>\n</li>\n<li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li>\n<li>线程<strong>写</strong>volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程<strong>读</strong>volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n<li>volatile不能保证volatile变量复合操作的原子性</li>\n<li>volatile适用场景：<ol>\n<li>对变量的写操作不依赖其当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-4-Synchronized和volatile比较\"><a href=\"#8-4-Synchronized和volatile比较\" class=\"headerlink\" title=\"8.4 Synchronized和volatile比较\"></a>8.4 Synchronized和volatile比较</h4><ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li>\n<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li>\n<li>volatile没有synchronized使用广泛。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢CPU的资源，CPU的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到CPU的执行权。</p>","more":"<ol>\n<li><a href=\"#id1\">基本概念</a></li>\n<li><a href=\"#id2\">实现线程的过程</a></li>\n<li><a href=\"#id3\">线程常用方法</a></li>\n<li><a href=\"#id4\">线程池</a></li>\n<li><a href=\"#id5\">线程的主要状态</a></li>\n<li><a href=\"#id6\">线程的同步机制</a></li>\n<li><a href=\"#id7\">线程的死锁</a></li>\n<li><a href=\"#id8\">内存可见性</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h3><ul>\n<li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。  </li>\n<li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含n个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li>\n<li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是cpu调度和分派的最小单位)。</li>\n<li>多进程是指操作系统能同时运行多个任务（程序）。</li>\n<li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li>\n<li>并行与并发：<ul>\n<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>\n<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>\n</ul>\n</li>\n<li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待/挂起/阻塞</strong>、<strong>终止/异常/消亡</strong>。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-实现线程的过程\"><a href=\"#2-实现线程的过程\" class=\"headerlink\" title=\"2. 实现线程的过程\"></a>2. 实现线程的过程</h3><p>java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序并发地运行多个执行线程。</p>\n<ul>\n<li>自定义类继承Thread类并重写run方法，然后创建该类的实例调用start方法。  </li>\n<li>自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参去构造Thread类型的对象，最后使用Thread类对象调用start方法。 </li>\n</ul>\n<h4 id=\"2-1-实现方式一：继承Thread类\"><a href=\"#2-1-实现方式一：继承Thread类\" class=\"headerlink\" title=\"2.1 实现方式一：继承Thread类\"></a>2.1 实现方式一：继承Thread类</h4><ol>\n<li>自己描述一个类</li>\n<li>继承父类Thread</li>\n<li>重写run方法</li>\n<li>new一个线程对象，调用start()方法，让线程进入就绪状态(需要注意的是start方法是Thread类中的)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">mt.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-实现方式二：实现Runnable接口\"><a href=\"#2-2-实现方式二：实现Runnable接口\" class=\"headerlink\" title=\"2.2 实现方式二：实现Runnable接口\"></a>2.2 实现方式二：实现Runnable接口</h4><ol>\n<li>自己描述一个类</li>\n<li>实现一个父接口Runnable</li>\n<li>重写run方法</li>\n<li>new一个线程对象，new一个Thread并传入线程对象，调用start()方法，让线程进入就绪状态</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">        <span class=\"comment\">//这里编写该线程的执行任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyThread mt = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread td = <span class=\"keyword\">new</span> Thread(mt);</span><br><span class=\"line\">td.start();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-两种方式优缺点：\"><a href=\"#2-3-两种方式优缺点：\" class=\"headerlink\" title=\"2.3 两种方式优缺点：\"></a>2.3 两种方式优缺点：</h4><ul>\n<li>使用继承Thread方式代码简单，但Java语言只支持单继承，若该类继承Thread类后则无法继承其他类</li>\n<li>使用实现Runnable的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-线程常用方法\"><a href=\"#3-线程常用方法\" class=\"headerlink\" title=\"3. 线程常用方法\"></a>3. 线程常用方法</h3><p><img src=\"http://cdn.chaooo.top/java/thread.jpg\" alt=\"Thread常用方法\"></p>\n<h4 id=\"3-1-相关方法的解析：\"><a href=\"#3-1-相关方法的解析：\" class=\"headerlink\" title=\"3.1 相关方法的解析：\"></a>3.1 相关方法的解析：</h4><ul>\n<li>Thread()：使用无参方式构造对象  </li>\n<li>Thread(String name)：根据参数指定的名称来构造对象。  </li>\n<li>Thread(Runnable target)：根据参数指定的Runnable引用来构造对象。   </li>\n<li>Thread(Runnable target, String name)：根据参数指定的Runnable引用和名称构造对象。</li>\n<li>void run()：若使用Runnable对象作为参数构造的对象来调用该方法，则最终调用Runnable对象中的run方法，否则该方法啥也不做。  </li>\n<li>void <strong>start()</strong>：用于<strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java虚拟机会自动调用该线程的run方法。</li>\n</ul>\n<ul>\n<li>int getPriority()：用于获取线程的优先级，优先级1-10</li>\n<li>void setPriority(int)：更改线程的优先级</li>\n</ul>\n<h4 id=\"3-2-多线程原理分析\"><a href=\"#3-2-多线程原理分析\" class=\"headerlink\" title=\"3.2 多线程原理分析\"></a>3.2 多线程原理分析</h4><ol>\n<li>执行main方法的线程叫做主线程，而执行run方法的线程叫做子线程。  </li>\n<li>对于start方法之前的代码来说，由主线程执行一次，当start方法调用成功之后，线程的个数由1个变成了2个，主线程继续向下执行，而新启动的线程去执行run方法的代码，两个线程各自独立运行。  </li>\n<li>当run方法执行完毕后，则子线程结束；当main方法执行完毕后，则主线程结束。  </li>\n<li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。  </li>\n</ol>\n<h4 id=\"3-3-线程的编号和名称\"><a href=\"#3-3-线程的编号和名称\" class=\"headerlink\" title=\"3.3 线程的编号和名称\"></a>3.3 线程的编号和名称</h4><ul>\n<li>long getId()：用于获取调用对象所表示线程的编号</li>\n<li>String getName()：用于获取调用对象所表示线程的名称</li>\n<li>void setName()：用于设置线程的名称为参数指定的数值</li>\n<li>static Thread currentThread()：获取当前正在执行线程的引用</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-线程池\"><a href=\"#4-线程池\" class=\"headerlink\" title=\"4. 线程池\"></a>4. 线程池</h3><ul>\n<li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li>\n<li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li>\n<li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul>\n<li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li>\n<li>抽象类：AbstractExecutorService</li>\n<li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li>\n</ul>\n</li>\n<li>创建线程的第三种方式是实现Callable接口，主要用于线程池</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-线程的主要状态\"><a href=\"#5-线程的主要状态\" class=\"headerlink\" title=\"5. 线程的主要状态\"></a>5. 线程的主要状态</h3><p><img src=\"http://cdn.chaooo.top/java/threadLife.jpg\" alt=\"线程的生命周期\"></p>\n<ol>\n<li>新建状态：使用new关键字创建线程后进入状态，此时线程还没有开始执行</li>\n<li>就绪状态：调用start()进入的状态，此时线程还是没有开始执行</li>\n<li>运行状态：使用线程调度器调用该线程后进入的状态(获得CPU执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li>\n<li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li>\n<li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li>\n</ol>\n<h4 id=\"5-1-线程的休眠\"><a href=\"#5-1-线程的休眠\" class=\"headerlink\" title=\"5.1 线程的休眠\"></a>5.1 线程的休眠</h4><ul>\n<li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li>\n<li>static void <strong>yield()</strong>：当线程让出处理器(离开Running状态)，使用当前线程进入Runnable状态等待。</li>\n<li>static void <strong>sleep(times)</strong>：使当前线程从Running放弃处理器进入Block状态，休眠times毫秒，再返回到Runnable如果其他线程打断当前线程的Block(sleep)，就会发生InterruptException。</li>\n</ul>\n<h4 id=\"5-1-线程的等待\"><a href=\"#5-1-线程的等待\" class=\"headerlink\" title=\"5.1 线程的等待\"></a>5.1 线程的等待</h4><ul>\n<li>void <strong>join()</strong>：等待该线程终止，让多个线程同步执行，变成单个线程</li>\n<li>void <strong>join(long millis)</strong>：表示等待参数指定的毫秒数</li>\n<li><strong>对象.wait()</strong> 和 <strong>对象.notify()/notifyAll()</strong>可以让线程的状态来回切换</li>\n<li>sleep()和wait()的区别：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>sleep()和wait()的区别</th>\n<th>sleep()</th>\n<th>wait()</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.类</td>\n<td>Thread类</td>\n<td>Object类</td>\n</tr>\n<tr>\n<td>2.调用</td>\n<td>静态 类名.</td>\n<td>对象.</td>\n</tr>\n<tr>\n<td>3.理解</td>\n<td>调用位置的线程等待</td>\n<td>对象调用，访问对象的其他线程等待</td>\n</tr>\n<tr>\n<td>4.唤醒</td>\n<td>不需要唤醒</td>\n<td>需要其他对象调用notify唤醒</td>\n</tr>\n<tr>\n<td>5.锁</td>\n<td>不会释放锁</td>\n<td>等待后会释放锁</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-2-守护线程\"><a href=\"#5-2-守护线程\" class=\"headerlink\" title=\"5.2 守护线程\"></a>5.2 守护线程</h4><ul>\n<li>boolean <strong>isDeamon()</strong>：用于判断是否为守护线程</li>\n<li>void <strong>setDeamon(boolean on)</strong>：用于设置线程为守护线程</li>\n<li>Java线程有两类：<ul>\n<li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li>\n<li>守护线程：运行在后台，为其他前台线程服务</li>\n</ul>\n</li>\n<li>守护线程特点：<ul>\n<li><strong>一旦所有线程都结束运行，守护线程会随JVM一起结束工作</strong></li>\n</ul>\n</li>\n<li>守护线程应用：<ul>\n<li>数据库连接池中检测的线路，JVM虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li>\n</ul>\n</li>\n<li>设置守护线程：<ul>\n<li>可以通过调用Thread类的setDeamon(true)方法来设置当前的线程为守护线程</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-线程的同步机制\"><a href=\"#6-线程的同步机制\" class=\"headerlink\" title=\"6. 线程的同步机制\"></a>6. 线程的同步机制</h3><ul>\n<li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p>\n</li>\n<li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p>\n</li>\n<li><p>Java提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象/同步锁机制</strong>。</p>\n</li>\n<li><p>特征修饰符synchronized：表示同步，一个时间点只有一个线程访问</p>\n</li>\n<li><p>线程安全锁：两种形式是（锁定的永远是对象）</p>\n<ol>\n<li><p>使用同步代码块的方式，将synchronized关键字放在方法体内部</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(对象)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//需同步执行(锁定)的代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用同步方法的方式处理，直接使用synchronized关键字修饰整个方法，锁定的是调用方法的那个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><p>使用synchronized保证线程同步时应当注意：</p>\n<ol>\n<li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li>\n<li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<ol>\n<li>无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li>\n<li>每个对象只有一个锁（lock）与之相关联。</li>\n<li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li>\n</ol>\n</blockquote>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-线程的死锁\"><a href=\"#7-线程的死锁\" class=\"headerlink\" title=\"7. 线程的死锁\"></a>7. 线程的死锁</h3><p>Java线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class=\"line\"><span class=\"comment\">//线程一：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(a) &#123; <span class=\"comment\">//表示:持有对象锁a,等待对象锁b</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//线程二：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;   </span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(b) &#123; <span class=\"comment\">//表示:持有对象锁b,等待对象锁a</span></span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(a) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li>\n<li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li>\n<li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul>\n<li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li>\n<li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-1-死锁的避免\"><a href=\"#7-1-死锁的避免\" class=\"headerlink\" title=\"7.1 死锁的避免\"></a>7.1 死锁的避免</h4><ul>\n<li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li>\n<li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li>\n<li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-内存可见性\"><a href=\"#8-内存可见性\" class=\"headerlink\" title=\"8.内存可见性\"></a>8.内存可见性</h3><h4 id=\"8-1-基本概念\"><a href=\"#8-1-基本概念\" class=\"headerlink\" title=\"8.1 基本概念\"></a>8.1 基本概念</h4><ul>\n<li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li>\n<li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li>\n<li>Java内存模型(JMM)：<ul>\n<li>Java Memory Model描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存中和从内存中读取变量这样的底层细节。</li>\n<li>所有的变量都存储在主内存中</li>\n<li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li>\n</ul>\n</li>\n<li>Java内存模型规定：<ul>\n<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li>\n<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li>\n</ul>\n</li>\n<li>要实现共享变量的可见性，必须保证两点：<ul>\n<li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li>\n<li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li>\n</ul>\n</li>\n<li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li>\n</ul>\n<h4 id=\"8-2-Synchronized实现可见性\"><a href=\"#8-2-Synchronized实现可见性\" class=\"headerlink\" title=\"8.2 Synchronized实现可见性\"></a>8.2 Synchronized实现可见性</h4><ul>\n<li>Synchronized能够实现：原子性(同步)、可见性</li>\n<li>JMM关于synchronized的两条规定：<ul>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n<li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>\n</ul>\n</li>\n<li>线程执行互斥代码的过程：<ol>\n<li>获得互斥锁</li>\n<li>清空工作内存</li>\n<li>从主内存拷贝变量的最新副本到工作内存</li>\n<li>执行代码</li>\n<li>将更改后的共享变量的值刷新到主内存</li>\n<li>释放互斥锁</li>\n</ol>\n</li>\n<li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol>\n<li>编译器优化重排序（编译器处理）</li>\n<li>指令级并行重排序（处理器优化）</li>\n<li>内存系统的重排序（处理器读写缓存的优化）</li>\n</ol>\n</li>\n<li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li>\n<li>单线程中重排序不会带来内存可见性问题</li>\n<li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>不可见的原因</th>\n<th>syschronized解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1.线程的交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>2.重排序结合线程交叉执行</td>\n<td>原子性</td>\n</tr>\n<tr>\n<td>3.共享变量未及时更新</td>\n<td>可见性</td>\n</tr>\n</tbody></table>\n<h4 id=\"8-3-volatile实现可见性\"><a href=\"#8-3-volatile实现可见性\" class=\"headerlink\" title=\"8.3 volatile实现可见性\"></a>8.3 volatile实现可见性</h4><ul>\n<li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul>\n<li>对volatile变量执行写操作时，会在写操作后加入一条store屏蔽指令</li>\n<li>对volatile变量执行读操作时，会在读操作前加入一条load屏蔽指令</li>\n</ul>\n</li>\n<li>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li>\n<li>线程<strong>写</strong>volatile变量的过程：<ol>\n<li>改变线程工作内存中volatile变量副本的值</li>\n<li>将改变后的副本的值从工作内存刷新到主内存</li>\n</ol>\n</li>\n<li>线程<strong>读</strong>volatile变量的过程：<ol>\n<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>\n<li>从工作内存中读取volatile变量的副本</li>\n</ol>\n</li>\n<li>volatile不能保证volatile变量复合操作的原子性</li>\n<li>volatile适用场景：<ol>\n<li>对变量的写操作不依赖其当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-4-Synchronized和volatile比较\"><a href=\"#8-4-Synchronized和volatile比较\" class=\"headerlink\" title=\"8.4 Synchronized和volatile比较\"></a>8.4 Synchronized和volatile比较</h4><ul>\n<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>\n<li>从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁</li>\n<li>synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性</li>\n<li>volatile没有synchronized使用广泛。</li>\n</ul>"},{"title":"十二、JavaWeb编程基础","date":"2019-07-20T12:59:40.000Z","_content":"\n\nJavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。\n<!-- more -->\n\n1. [http协议](#id1)\n2. [Servlet](#id2)\n3. [get和post区别](#id3)\n4. [上下文对象ServletContext](#id4)\n5. [会话跟踪（状态管理）](#id5)\n6. [JSP](#id6)\n\n\n<span id=\"id1\"><span>\n### 1. http协议\n超文本传输协议，是一种应用层的网络传输协议\n\n- http协议的特点：\n  1. 简单，快速：支持多种不同的的数据提交方式，如get/post\n  2. 数据传输灵活，支持任意类型数据的传输\n  3. 无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。\n  4. 无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。\n- http协议的组成部分：\n  1. 请求：浏览器连接服务器的过程\n  2. 响应：服务器回复浏览器的过程\n- http协议的请求：\n  1. 请求头：描述客户端的信息\n  2. 请求体：GET没有请求体，请求体用于存储POST请求发送的数据。\n  3. 请求空行：请求头与请求体之间的一行空白\n  4. 请求行：描述请求方式，服务器地址，协议版本等\n- http协议的响应：\n  1. 响应头：描述服务器的信息\n  2. 响应体：响应的内容，文本，json数据等。\n  3. 响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。\n\n<span id=\"id2\"><span>\n### 2. Servlet\nservlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。\n\n#### 2.1 Servlet编写步骤：\n1. 编写一个Java类，继承HttpServlet类\n2. 重新service方法\n3. 在service方法中，对用户请求进行响应。\n\n``` java\n//注解：添加访问的网址\n@WebServlet(\"/hello\")\npublic class MyServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t@Override\n    public void service(ServletRequest req, ServletResponse res) throws IOException {\n\t\t//1.设置响应体的编码，以及内容类型\n\t\tres.setContentType(\"text/html;charset=utf-8\");\n\t\t//2.得到响应体输出的打印流\n\t\tPrintWriter out = res.getWriter();\n\t\t//3.打印文字\n\t\tout.println(\"<h1>Hello Servlet!</h1>\");\n\t}\n\n}\n```\n\n\n#### 2.2 配置ervlet类的访问网址\n- web3.0版本之后使用注解的方式配置ervlet类的访问网址\n- web3.0版本之前配置Servlet访问网址的方式：\n  * 将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 \n  * 配置Servlet类的别名，并给指定别名的Servlet添加映射网址。\n\n``` xml\n  <!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 -->\n  <servlet>\n  \t<!-- Servlet类别名，用于后续添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<!-- Servlet类全名 -->\n  \t<servlet-class>day01_Servlet.demo1.MyServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<!-- 给指定别名的Servlet添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<url-pattern>/hello</url-pattern>\n  </servlet-mapping>\n```\n\n\n#### 2.3 Servlet生命周期\n- 实例化 --> 初始化(init) --> 服务(service) --> 销毁(销毁之前调用destory) --> 不可用\n- 创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。\n- 销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。\n- tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：\n  * init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。\n  * service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。\n  * destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。\n\n\n#### 2.4 get和post区别\n- GET请求：\n  * 没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&连接键值对。\n  * 只能传输字符串类型参数\n  * 浏览器url地址最大长度4kb\n  * 数据传输时，参数在url中明文显示，不安全。\n- POST请求：\n  * 有请求体，是一个单独的数据包，用于存储请求中的多个参数\n  * 可传输任意类型的数据，进行文件上传必须POST请求\n  * 可以传递的数据大小，理论上没有上限\n  * 数据传输时在单独的数据包，较为安全。\n\n\n#### 2.5 接收请求中的参数\n1. 根据参数的名称，接收参数的单个值\n  - String value = request.getParameter(String name);\n2. 根据参数的名称，接收一组参数的值\n  - String[] values = request.getParameterValues(String name);\n\n``` java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  request.setCharacterEncoding(\"UTF-8\");\n  response.setContentType(\"text/html;charset=utf-8\");\n  //1.接收\n  String username = request.getParameter(\"username\");\n  String[] password = request.getParameterValues(\"password\");\n  //2.打印\n  System.out.println(\"username:\" + username);\n  System.out.println(\"password:\" + password[0]);\n  System.out.println(\"password2:\" + password[1]);\n  //3.浏览器输出\n  response.getWriter().append(\"<div>很遗憾注册失败，点击<a href=\\\"demo1.html\\\">重新注册</a></div>\");\n\n}\n```\n\n\n#### 2.6 乱码处理\n#### 2.6.1 乱码情况：\n* 浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。\n* tomcat8版本之前(不包含tomcat8版本), GET请求乱码\n* 任何版本, POST请求乱码\n\n#### 2.6.2 请求乱码处理：\n* 适用于所有乱码问题：(Tomcat8之后get无乱码)\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. 将接收到的中文乱码重新编码：\n\n``` java\nString name = request.getParameter(\"userName\");\nString userName = new String( name.getByte(\"ISO-8859-1\"),\"utf-8\");\n```\n\n* 仅适用于POST请求：\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. Servlet接收之前设置解码（需在调用request.getParameter(\"key\")之前设置）`request.setCharacterEncoding(\"utf-8\")`;\n\n#### 2.6.3 响应乱码的处理：\n* 方式一：设置响应的内容类型, 以及编码格式:`response.setContentType(\"text/html;charset=utf-8\")`;\n* 方式二：进设置编码格式, 不设置响应内容类型:`response.setCharacterEncoding(\"UTF-8\")`(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);\n\n\n#### 2.7 Servlet的创建时机\n- 通过web.xml配置Servlet, 可以修改Servlet加载的时机。\n- 可以给Servlet节点，添加`<load-on-startup>`节点来制定servlet启动顺序。\n- 节点中的值为数字：\n  * `-1`：默认-1，表示当用户第一次请求时，创建对象\n  * `>=0`：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建\n\n``` xml\n<servlet>\n    <servlet>\n        <servlet-name>s1</servlet-name>\n        <servlet-class>demo.ServletDemo</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>s1</servlet-name>\n        <url-pattern>/s1</url-pattern>\n    </servlet-mapping>\n</servlet>\n<servlet-mapping></servlet-mapping>\n```\n\n\n<span id=\"id3\"><span>\n### 3. 请求的转发与重定向\n#### 3.1 请求对象request的常用操作\n1. getMethod() : 得到请求的方式\n2. getRequestURI() : 获取浏览器请求地址\n3. getRemoteAddr() : 获取客户端ip地址\n4. getRemoteHost() : 获取客户端名称\n5. getServerName() : 获取服务器名称\n6. getServerPort() : 获取服务器端口号\n7. getQueryString() : 获取get请求参数字符串，其他请求返回null\n\n\n#### 3.1 请求的转发与重定向注意事项\n* 请求转发与重定向操作，必须要有出口。\n* 当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了\n\n\n#### 3.2 转发*\n- 一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理\n- 步骤：\n  1. 获取请求转发器：`RequestDispather rd = request.getRequestDispacher(\"转发地址\");`\n  2. 进行转发操作：`rd.forward(request, response);`\n- 因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:\n  * `request.getRequestDispacher(\"转发地址\").forward(request, response);`\n- 特点：\n  * 转发过程中，多个web组件之间共享一个请求对象request与响应对象response\n  * 在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变\n  * 转发不能跨项目实现\n  * 比重定向效率更高\n\n\n#### 3.3 重定向*\n- 一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址\n- 格式：`response.sendRedirect(\"重定向地址\")`；\n- 原理：当客户端请求服务器时，发起重定向流程：\n  1. 给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.\n  2. 当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.\n  3. 浏览器自动发起新的请求 , 跳转到新地址.\n- 特点：\n  1. 重定向会产生两个请求对象，多个请求对象中数据不互通\n  2. 浏览器地址发生了改变\n  3. 重定向可以跨域实现\n  4. 比转发效率低\n\n\n<span id=\"id4\"><span>\n### 4. 上下文对象ServletContext\n- 用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享\n- 每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。\n\n获取ServletContext对象：`ServletContext context = getServletContext();`\n\n- 常用方法\n  * context.setAttributes(String key, Objexct value); //设置替换数据\n  * context.getAttributes(String key); //获取数据\n  * context.removeAttributes(String key); //删除数据\n  * context.getRealPath(\"/\"); //获取项目运行时所在文件路径\n\n\n<span id=\"id5\"><span>\n### 5. 会话跟踪（状态管理）\n- 存在两种实现：\n  1. cookie: 将浏览器产生的状态存储在浏览器中\n  2. Session: 将浏览器产生的状态存储在服务器中\n\n- cookie技术原理：\n  * 服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，\n  * 浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来\n  * 当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器\n- Session技术原理：\n  * 当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，\n  * 该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器\n  * 浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。\n\n#### 5.1 Cookie\n- 创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对\n  * `Cookie cookie = new Cookie(String key, String value);`\n  * 注意：tomcat8.5版本之前，cookie无法出场中文\n- 通过响应对象，将cookie添加到响应头,可添加多个\n  * response.addCookie(Cookie cookie);\n- 通过请求头得到cookie数组，没有则返回null\n  * Cookie[] cookies = request.getCookies();\n  * 取键：cookie.getName();\n  * 取值：cookie.getValue()\n- Cookie的存储时长：\n  * cookie.setMaxAge(int 秒)；\n    + 正数：倒计时秒数\n    + 0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它\n    + 负数：默认-1，表示会话结束时自动删除（关闭浏览器）\n- Cookie的存储路径问题\n  * 存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同\n  * 为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(\"/\");\n\n#### 5.2 Cookie的优缺点\n- 缺点：\n  1. Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。\n  2. 数据存储在客户的计算机中，不安全，不建议存储安全敏感数据\n  3. 保存数据量有限制，大约4kb左右\n  3. 依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除\n- 优点：\n  1. 分散服务器的压力\n\n#### 5.3 Session\n- 获取Session\n  * 格式1：request.getSession();//等价参数传true\n  * 格式2：request.getSession(boolean isNew);\n    + true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回\n    + false，根据浏览器的SessionId查找一个session，若没有就返回null\n- Session常用方法\n  * session.setAttribute(String key, object value);//设置/替换值\n  * session.getAttribute(String key);//获取值\n  * session.invalidate();//销毁\n- 设置session存活时长\n  * 默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。\n  * 可以通过修改配置文件，修改所有的session时长\n    + 修改`conf/web.xml`的`<session-config><session-tiomeout>数值分钟</session-tiomeout></session-config>`\n  * 可以通过session对象，修改单个对象的session时长\n    + void session.setMaxInactiveInterval(int seconds)\n\n#### 5.4 Session的优缺点\n- 缺点：\n  * 数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源\n- 优点：\n  1. 数据存储在服务器中，安全\n  2. 数据类型为Object，在Java中表示可以存储所有类型的数据\n  3. session存储的数据大小，理论上无限的。\n\n#### 5.5 Cookie和Session的使用\n- Cookie和Session不是互斥的，是相辅相成的\n- 在项目开发时：\n  * 对安全敏感的数据，存储在session中\n  * 对安全不敏感的字符串数据，可以选择存储在Cookie中\n  * 对于大的数据，应该存在数据库和文件中\n\n> 注意：cookie和session是为了管理状态而非存储数据。\n\n\n<span id=\"id6\"><span>\n### 6.JSP\n#### 6.1 JSP语法基础\n- Java Server Pages：java动态网页技术\n- JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应\n- 注意：\n  1. JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet\n  2. 执行流程：浏览器请求-->tomcat-->JSP引擎转换为Servlet-->转换的Servlet-->准备响应体-->响应给浏览器-->浏览器解析html\n\n- JSP语法结构\n  1. html代码\n  2. Java代码\n  3. Jsp特有的语法结构\n\n- Java代码声明区：指的是类的成员位置\n\n``` jsp\n<%!\n  // Java代码声明区\n%>\n```\n\n- Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来\n\n``` jsp\n<%\n  // Java代码执行区\n%>\n```\n\n- JSP输出表达式\n  * 用于快速的将Java中的数据，输出到网页中..\n  * 语法格式：`<%=数据 %>`，编译后被转换成out.print(数据)\n- JSP注释：\n  * html中可以用`<!-- -->`\n  * java中可以用`//，/**/，/** */`\n  * jsp注释`<%-- --%>`\n    + html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略\n\n#### 6.2 JSP三大指令\n* page指令\n* include指令\n* taglib指令\n\n- 指令使用格式：<%@ 指令名称 属性1=值 属性2=值 属性n=值 %>\n  *语法上，JSP允许在单个页面出现多个相同的JSP指令\n  \n##### 6.2.1 page指令\n- 用于配置页面信息\n\n``` jsp\n<%@ page\n  language=\"java\"：语言\n  contentType=\"text/html;charset=utf-8\"：响应的内容类型，以及响应的编码格式\n  pageEncoding=\"UTF-8\"：文件存储的编码格式\n  extends=\"继承的父类\"\n  buffer=\"数字/none\"：是否允许缓存，默认值8kb\n  autoFlush=\"true/false\"：是否自动清除缓存，默认true\n  session=\"true/false\"：是否提前准备session对象，默认true\n  isThreadSafe=\"true/false\"：是否线程安全的\n  import=\"java.util.List\"：用于导包，多个包使用\",\"隔开\n  errorPage=\"网址\"：当页面发生BUG后，显示哪个页面\n  isErrorPage=\"true/false\"：当前页面是否是一个错误处理页面，如果结果为true，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息\n%>\n```\n\n#### 6.3 项目发生错误时，统一的处理方式\n  1. 打开项目的web.xml\n  2. 加入子节点`<error-page><error-code>错误码</error-code><location>处理网址</location></error-page>`\n\n``` xml\n<error-page>\n    <error-code>500</error-code>\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n</error-page>\n```\n\n- include指令：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<%@ include file=\"地址\" %>`\n- include动作：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<jsp:include page=\"地址\">`\n  \n>include指令 与 include动作区别：\n<br>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp => 一个Servlet）\n<br>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp => 多个Servlet）","source":"_posts/12_JavaWeb编程基础.md","raw":"---\ntitle: 十二、JavaWeb编程基础\ndate: 2019-07-20 20:59:40\ntags: [javaEE, 后端开发]\ncategories: JavaWeb编程\n---\n\n\nJavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。\n<!-- more -->\n\n1. [http协议](#id1)\n2. [Servlet](#id2)\n3. [get和post区别](#id3)\n4. [上下文对象ServletContext](#id4)\n5. [会话跟踪（状态管理）](#id5)\n6. [JSP](#id6)\n\n\n<span id=\"id1\"><span>\n### 1. http协议\n超文本传输协议，是一种应用层的网络传输协议\n\n- http协议的特点：\n  1. 简单，快速：支持多种不同的的数据提交方式，如get/post\n  2. 数据传输灵活，支持任意类型数据的传输\n  3. 无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。\n  4. 无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。\n- http协议的组成部分：\n  1. 请求：浏览器连接服务器的过程\n  2. 响应：服务器回复浏览器的过程\n- http协议的请求：\n  1. 请求头：描述客户端的信息\n  2. 请求体：GET没有请求体，请求体用于存储POST请求发送的数据。\n  3. 请求空行：请求头与请求体之间的一行空白\n  4. 请求行：描述请求方式，服务器地址，协议版本等\n- http协议的响应：\n  1. 响应头：描述服务器的信息\n  2. 响应体：响应的内容，文本，json数据等。\n  3. 响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。\n\n<span id=\"id2\"><span>\n### 2. Servlet\nservlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。\n\n#### 2.1 Servlet编写步骤：\n1. 编写一个Java类，继承HttpServlet类\n2. 重新service方法\n3. 在service方法中，对用户请求进行响应。\n\n``` java\n//注解：添加访问的网址\n@WebServlet(\"/hello\")\npublic class MyServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\t@Override\n    public void service(ServletRequest req, ServletResponse res) throws IOException {\n\t\t//1.设置响应体的编码，以及内容类型\n\t\tres.setContentType(\"text/html;charset=utf-8\");\n\t\t//2.得到响应体输出的打印流\n\t\tPrintWriter out = res.getWriter();\n\t\t//3.打印文字\n\t\tout.println(\"<h1>Hello Servlet!</h1>\");\n\t}\n\n}\n```\n\n\n#### 2.2 配置ervlet类的访问网址\n- web3.0版本之后使用注解的方式配置ervlet类的访问网址\n- web3.0版本之前配置Servlet访问网址的方式：\n  * 将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 \n  * 配置Servlet类的别名，并给指定别名的Servlet添加映射网址。\n\n``` xml\n  <!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 -->\n  <servlet>\n  \t<!-- Servlet类别名，用于后续添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<!-- Servlet类全名 -->\n  \t<servlet-class>day01_Servlet.demo1.MyServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n  \t<!-- 给指定别名的Servlet添加映射网址 -->\n  \t<servlet-name>demo1</servlet-name>\n  \t<url-pattern>/hello</url-pattern>\n  </servlet-mapping>\n```\n\n\n#### 2.3 Servlet生命周期\n- 实例化 --> 初始化(init) --> 服务(service) --> 销毁(销毁之前调用destory) --> 不可用\n- 创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。\n- 销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。\n- tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：\n  * init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。\n  * service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。\n  * destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。\n\n\n#### 2.4 get和post区别\n- GET请求：\n  * 没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&连接键值对。\n  * 只能传输字符串类型参数\n  * 浏览器url地址最大长度4kb\n  * 数据传输时，参数在url中明文显示，不安全。\n- POST请求：\n  * 有请求体，是一个单独的数据包，用于存储请求中的多个参数\n  * 可传输任意类型的数据，进行文件上传必须POST请求\n  * 可以传递的数据大小，理论上没有上限\n  * 数据传输时在单独的数据包，较为安全。\n\n\n#### 2.5 接收请求中的参数\n1. 根据参数的名称，接收参数的单个值\n  - String value = request.getParameter(String name);\n2. 根据参数的名称，接收一组参数的值\n  - String[] values = request.getParameterValues(String name);\n\n``` java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  request.setCharacterEncoding(\"UTF-8\");\n  response.setContentType(\"text/html;charset=utf-8\");\n  //1.接收\n  String username = request.getParameter(\"username\");\n  String[] password = request.getParameterValues(\"password\");\n  //2.打印\n  System.out.println(\"username:\" + username);\n  System.out.println(\"password:\" + password[0]);\n  System.out.println(\"password2:\" + password[1]);\n  //3.浏览器输出\n  response.getWriter().append(\"<div>很遗憾注册失败，点击<a href=\\\"demo1.html\\\">重新注册</a></div>\");\n\n}\n```\n\n\n#### 2.6 乱码处理\n#### 2.6.1 乱码情况：\n* 浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。\n* tomcat8版本之前(不包含tomcat8版本), GET请求乱码\n* 任何版本, POST请求乱码\n\n#### 2.6.2 请求乱码处理：\n* 适用于所有乱码问题：(Tomcat8之后get无乱码)\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. 将接收到的中文乱码重新编码：\n\n``` java\nString name = request.getParameter(\"userName\");\nString userName = new String( name.getByte(\"ISO-8859-1\"),\"utf-8\");\n```\n\n* 仅适用于POST请求：\n  1. 指定浏览器打开页面的编码`<meta charset=\"UTF-8\">`;\n  2. Servlet接收之前设置解码（需在调用request.getParameter(\"key\")之前设置）`request.setCharacterEncoding(\"utf-8\")`;\n\n#### 2.6.3 响应乱码的处理：\n* 方式一：设置响应的内容类型, 以及编码格式:`response.setContentType(\"text/html;charset=utf-8\")`;\n* 方式二：进设置编码格式, 不设置响应内容类型:`response.setCharacterEncoding(\"UTF-8\")`(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);\n\n\n#### 2.7 Servlet的创建时机\n- 通过web.xml配置Servlet, 可以修改Servlet加载的时机。\n- 可以给Servlet节点，添加`<load-on-startup>`节点来制定servlet启动顺序。\n- 节点中的值为数字：\n  * `-1`：默认-1，表示当用户第一次请求时，创建对象\n  * `>=0`：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建\n\n``` xml\n<servlet>\n    <servlet>\n        <servlet-name>s1</servlet-name>\n        <servlet-class>demo.ServletDemo</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>s1</servlet-name>\n        <url-pattern>/s1</url-pattern>\n    </servlet-mapping>\n</servlet>\n<servlet-mapping></servlet-mapping>\n```\n\n\n<span id=\"id3\"><span>\n### 3. 请求的转发与重定向\n#### 3.1 请求对象request的常用操作\n1. getMethod() : 得到请求的方式\n2. getRequestURI() : 获取浏览器请求地址\n3. getRemoteAddr() : 获取客户端ip地址\n4. getRemoteHost() : 获取客户端名称\n5. getServerName() : 获取服务器名称\n6. getServerPort() : 获取服务器端口号\n7. getQueryString() : 获取get请求参数字符串，其他请求返回null\n\n\n#### 3.1 请求的转发与重定向注意事项\n* 请求转发与重定向操作，必须要有出口。\n* 当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了\n\n\n#### 3.2 转发*\n- 一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理\n- 步骤：\n  1. 获取请求转发器：`RequestDispather rd = request.getRequestDispacher(\"转发地址\");`\n  2. 进行转发操作：`rd.forward(request, response);`\n- 因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:\n  * `request.getRequestDispacher(\"转发地址\").forward(request, response);`\n- 特点：\n  * 转发过程中，多个web组件之间共享一个请求对象request与响应对象response\n  * 在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变\n  * 转发不能跨项目实现\n  * 比重定向效率更高\n\n\n#### 3.3 重定向*\n- 一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址\n- 格式：`response.sendRedirect(\"重定向地址\")`；\n- 原理：当客户端请求服务器时，发起重定向流程：\n  1. 给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.\n  2. 当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.\n  3. 浏览器自动发起新的请求 , 跳转到新地址.\n- 特点：\n  1. 重定向会产生两个请求对象，多个请求对象中数据不互通\n  2. 浏览器地址发生了改变\n  3. 重定向可以跨域实现\n  4. 比转发效率低\n\n\n<span id=\"id4\"><span>\n### 4. 上下文对象ServletContext\n- 用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享\n- 每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。\n\n获取ServletContext对象：`ServletContext context = getServletContext();`\n\n- 常用方法\n  * context.setAttributes(String key, Objexct value); //设置替换数据\n  * context.getAttributes(String key); //获取数据\n  * context.removeAttributes(String key); //删除数据\n  * context.getRealPath(\"/\"); //获取项目运行时所在文件路径\n\n\n<span id=\"id5\"><span>\n### 5. 会话跟踪（状态管理）\n- 存在两种实现：\n  1. cookie: 将浏览器产生的状态存储在浏览器中\n  2. Session: 将浏览器产生的状态存储在服务器中\n\n- cookie技术原理：\n  * 服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，\n  * 浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来\n  * 当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器\n- Session技术原理：\n  * 当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，\n  * 该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器\n  * 浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。\n\n#### 5.1 Cookie\n- 创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对\n  * `Cookie cookie = new Cookie(String key, String value);`\n  * 注意：tomcat8.5版本之前，cookie无法出场中文\n- 通过响应对象，将cookie添加到响应头,可添加多个\n  * response.addCookie(Cookie cookie);\n- 通过请求头得到cookie数组，没有则返回null\n  * Cookie[] cookies = request.getCookies();\n  * 取键：cookie.getName();\n  * 取值：cookie.getValue()\n- Cookie的存储时长：\n  * cookie.setMaxAge(int 秒)；\n    + 正数：倒计时秒数\n    + 0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它\n    + 负数：默认-1，表示会话结束时自动删除（关闭浏览器）\n- Cookie的存储路径问题\n  * 存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同\n  * 为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(\"/\");\n\n#### 5.2 Cookie的优缺点\n- 缺点：\n  1. Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。\n  2. 数据存储在客户的计算机中，不安全，不建议存储安全敏感数据\n  3. 保存数据量有限制，大约4kb左右\n  3. 依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除\n- 优点：\n  1. 分散服务器的压力\n\n#### 5.3 Session\n- 获取Session\n  * 格式1：request.getSession();//等价参数传true\n  * 格式2：request.getSession(boolean isNew);\n    + true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回\n    + false，根据浏览器的SessionId查找一个session，若没有就返回null\n- Session常用方法\n  * session.setAttribute(String key, object value);//设置/替换值\n  * session.getAttribute(String key);//获取值\n  * session.invalidate();//销毁\n- 设置session存活时长\n  * 默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。\n  * 可以通过修改配置文件，修改所有的session时长\n    + 修改`conf/web.xml`的`<session-config><session-tiomeout>数值分钟</session-tiomeout></session-config>`\n  * 可以通过session对象，修改单个对象的session时长\n    + void session.setMaxInactiveInterval(int seconds)\n\n#### 5.4 Session的优缺点\n- 缺点：\n  * 数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源\n- 优点：\n  1. 数据存储在服务器中，安全\n  2. 数据类型为Object，在Java中表示可以存储所有类型的数据\n  3. session存储的数据大小，理论上无限的。\n\n#### 5.5 Cookie和Session的使用\n- Cookie和Session不是互斥的，是相辅相成的\n- 在项目开发时：\n  * 对安全敏感的数据，存储在session中\n  * 对安全不敏感的字符串数据，可以选择存储在Cookie中\n  * 对于大的数据，应该存在数据库和文件中\n\n> 注意：cookie和session是为了管理状态而非存储数据。\n\n\n<span id=\"id6\"><span>\n### 6.JSP\n#### 6.1 JSP语法基础\n- Java Server Pages：java动态网页技术\n- JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应\n- 注意：\n  1. JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet\n  2. 执行流程：浏览器请求-->tomcat-->JSP引擎转换为Servlet-->转换的Servlet-->准备响应体-->响应给浏览器-->浏览器解析html\n\n- JSP语法结构\n  1. html代码\n  2. Java代码\n  3. Jsp特有的语法结构\n\n- Java代码声明区：指的是类的成员位置\n\n``` jsp\n<%!\n  // Java代码声明区\n%>\n```\n\n- Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来\n\n``` jsp\n<%\n  // Java代码执行区\n%>\n```\n\n- JSP输出表达式\n  * 用于快速的将Java中的数据，输出到网页中..\n  * 语法格式：`<%=数据 %>`，编译后被转换成out.print(数据)\n- JSP注释：\n  * html中可以用`<!-- -->`\n  * java中可以用`//，/**/，/** */`\n  * jsp注释`<%-- --%>`\n    + html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略\n\n#### 6.2 JSP三大指令\n* page指令\n* include指令\n* taglib指令\n\n- 指令使用格式：<%@ 指令名称 属性1=值 属性2=值 属性n=值 %>\n  *语法上，JSP允许在单个页面出现多个相同的JSP指令\n  \n##### 6.2.1 page指令\n- 用于配置页面信息\n\n``` jsp\n<%@ page\n  language=\"java\"：语言\n  contentType=\"text/html;charset=utf-8\"：响应的内容类型，以及响应的编码格式\n  pageEncoding=\"UTF-8\"：文件存储的编码格式\n  extends=\"继承的父类\"\n  buffer=\"数字/none\"：是否允许缓存，默认值8kb\n  autoFlush=\"true/false\"：是否自动清除缓存，默认true\n  session=\"true/false\"：是否提前准备session对象，默认true\n  isThreadSafe=\"true/false\"：是否线程安全的\n  import=\"java.util.List\"：用于导包，多个包使用\",\"隔开\n  errorPage=\"网址\"：当页面发生BUG后，显示哪个页面\n  isErrorPage=\"true/false\"：当前页面是否是一个错误处理页面，如果结果为true，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息\n%>\n```\n\n#### 6.3 项目发生错误时，统一的处理方式\n  1. 打开项目的web.xml\n  2. 加入子节点`<error-page><error-code>错误码</error-code><location>处理网址</location></error-page>`\n\n``` xml\n<error-page>\n    <error-code>500</error-code>\n    <location>/error.jsp</location>\n</error-page>\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n</error-page>\n```\n\n- include指令：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<%@ include file=\"地址\" %>`\n- include动作：用于将jsp或html引入到另一个jsp中\n  * 语法格式：`<jsp:include page=\"地址\">`\n  \n>include指令 与 include动作区别：\n<br>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp => 一个Servlet）\n<br>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp => 多个Servlet）","slug":"12_JavaWeb编程基础","published":1,"updated":"2019-07-20T15:08:16.463Z","_id":"cjyblnrwy0025xwt3qui7c7c1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">http协议</a></li>\n<li><a href=\"#id2\">Servlet</a></li>\n<li><a href=\"#id3\">get和post区别</a></li>\n<li><a href=\"#id4\">上下文对象ServletContext</a></li>\n<li><a href=\"#id5\">会话跟踪（状态管理）</a></li>\n<li><a href=\"#id6\">JSP</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-http协议\"><a href=\"#1-http协议\" class=\"headerlink\" title=\"1. http协议\"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p>\n<ul>\n<li>http协议的特点：<ol>\n<li>简单，快速：支持多种不同的的数据提交方式，如get/post</li>\n<li>数据传输灵活，支持任意类型数据的传输</li>\n<li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li>\n<li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li>\n</ol>\n</li>\n<li>http协议的组成部分：<ol>\n<li>请求：浏览器连接服务器的过程</li>\n<li>响应：服务器回复浏览器的过程</li>\n</ol>\n</li>\n<li>http协议的请求：<ol>\n<li>请求头：描述客户端的信息</li>\n<li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li>\n<li>请求空行：请求头与请求体之间的一行空白</li>\n<li>请求行：描述请求方式，服务器地址，协议版本等</li>\n</ol>\n</li>\n<li>http协议的响应：<ol>\n<li>响应头：描述服务器的信息</li>\n<li>响应体：响应的内容，文本，json数据等。</li>\n<li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Servlet\"><a href=\"#2-Servlet\" class=\"headerlink\" title=\"2. Servlet\"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p>\n<h4 id=\"2-1-Servlet编写步骤：\"><a href=\"#2-1-Servlet编写步骤：\" class=\"headerlink\" title=\"2.1 Servlet编写步骤：\"></a>2.1 Servlet编写步骤：</h4><ol>\n<li>编写一个Java类，继承HttpServlet类</li>\n<li>重新service方法</li>\n<li>在service方法中，对用户请求进行响应。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解：添加访问的网址</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1.设置响应体的编码，以及内容类型</span></span><br><span class=\"line\">\t\tres.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2.得到响应体输出的打印流</span></span><br><span class=\"line\">\t\tPrintWriter out = res.getWriter();</span><br><span class=\"line\">\t\t<span class=\"comment\">//3.打印文字</span></span><br><span class=\"line\">\t\tout.println(<span class=\"string\">\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-配置ervlet类的访问网址\"><a href=\"#2-2-配置ervlet类的访问网址\" class=\"headerlink\" title=\"2.2 配置ervlet类的访问网址\"></a>2.2 配置ervlet类的访问网址</h4><ul>\n<li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li>\n<li>web3.0版本之前配置Servlet访问网址的方式：<ul>\n<li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li>\n<li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-Servlet生命周期\"><a href=\"#2-3-Servlet生命周期\" class=\"headerlink\" title=\"2.3 Servlet生命周期\"></a>2.3 Servlet生命周期</h4><ul>\n<li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li>\n<li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li>\n<li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li>\n<li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul>\n<li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li>\n<li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li>\n<li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-get和post区别\"><a href=\"#2-4-get和post区别\" class=\"headerlink\" title=\"2.4 get和post区别\"></a>2.4 get和post区别</h4><ul>\n<li>GET请求：<ul>\n<li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li>\n<li>只能传输字符串类型参数</li>\n<li>浏览器url地址最大长度4kb</li>\n<li>数据传输时，参数在url中明文显示，不安全。</li>\n</ul>\n</li>\n<li>POST请求：<ul>\n<li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li>\n<li>可传输任意类型的数据，进行文件上传必须POST请求</li>\n<li>可以传递的数据大小，理论上没有上限</li>\n<li>数据传输时在单独的数据包，较为安全。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-接收请求中的参数\"><a href=\"#2-5-接收请求中的参数\" class=\"headerlink\" title=\"2.5 接收请求中的参数\"></a>2.5 接收请求中的参数</h4><ol>\n<li>根据参数的名称，接收参数的单个值<ul>\n<li>String value = request.getParameter(String name);</li>\n</ul>\n</li>\n<li>根据参数的名称，接收一组参数的值<ul>\n<li>String[] values = request.getParameterValues(String name);</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">  request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">  response.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//1.接收</span></span><br><span class=\"line\">  String username = request.getParameter(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">  String[] password = request.getParameterValues(<span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//2.打印</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password:\"</span> + password[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password2:\"</span> + password[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"comment\">//3.浏览器输出</span></span><br><span class=\"line\">  response.getWriter().append(<span class=\"string\">\"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\\\"demo1.html\\\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-乱码处理\"><a href=\"#2-6-乱码处理\" class=\"headerlink\" title=\"2.6 乱码处理\"></a>2.6 乱码处理</h4><h4 id=\"2-6-1-乱码情况：\"><a href=\"#2-6-1-乱码情况：\" class=\"headerlink\" title=\"2.6.1 乱码情况：\"></a>2.6.1 乱码情况：</h4><ul>\n<li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li>\n<li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li>\n<li>任何版本, POST请求乱码</li>\n</ul>\n<h4 id=\"2-6-2-请求乱码处理：\"><a href=\"#2-6-2-请求乱码处理：\" class=\"headerlink\" title=\"2.6.2 请求乱码处理：\"></a>2.6.2 请求乱码处理：</h4><ul>\n<li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>将接收到的中文乱码重新编码：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = request.getParameter(<span class=\"string\">\"userName\"</span>);</span><br><span class=\"line\">String userName = <span class=\"keyword\">new</span> String( name.getByte(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"utf-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>仅适用于POST请求：<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-6-3-响应乱码的处理：\"><a href=\"#2-6-3-响应乱码的处理：\" class=\"headerlink\" title=\"2.6.3 响应乱码的处理：\"></a>2.6.3 响应乱码的处理：</h4><ul>\n<li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li>\n<li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li>\n</ul>\n<h4 id=\"2-7-Servlet的创建时机\"><a href=\"#2-7-Servlet的创建时机\" class=\"headerlink\" title=\"2.7 Servlet的创建时机\"></a>2.7 Servlet的创建时机</h4><ul>\n<li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li>\n<li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li>\n<li>节点中的值为数字：<ul>\n<li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li>\n<li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>demo.ServletDemo<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/s1<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-请求的转发与重定向\"><a href=\"#3-请求的转发与重定向\" class=\"headerlink\" title=\"3. 请求的转发与重定向\"></a>3. 请求的转发与重定向</h3><h4 id=\"3-1-请求对象request的常用操作\"><a href=\"#3-1-请求对象request的常用操作\" class=\"headerlink\" title=\"3.1 请求对象request的常用操作\"></a>3.1 请求对象request的常用操作</h4><ol>\n<li>getMethod() : 得到请求的方式</li>\n<li>getRequestURI() : 获取浏览器请求地址</li>\n<li>getRemoteAddr() : 获取客户端ip地址</li>\n<li>getRemoteHost() : 获取客户端名称</li>\n<li>getServerName() : 获取服务器名称</li>\n<li>getServerPort() : 获取服务器端口号</li>\n<li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li>\n</ol>\n<h4 id=\"3-1-请求的转发与重定向注意事项\"><a href=\"#3-1-请求的转发与重定向注意事项\" class=\"headerlink\" title=\"3.1 请求的转发与重定向注意事项\"></a>3.1 请求的转发与重定向注意事项</h4><ul>\n<li>请求转发与重定向操作，必须要有出口。</li>\n<li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li>\n</ul>\n<h4 id=\"3-2-转发\"><a href=\"#3-2-转发\" class=\"headerlink\" title=\"3.2 转发*\"></a>3.2 转发*</h4><ul>\n<li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li>\n<li>步骤：<ol>\n<li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li>\n<li>进行转发操作：<code>rd.forward(request, response);</code></li>\n</ol>\n</li>\n<li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul>\n<li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li>\n<li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li>\n<li>转发不能跨项目实现</li>\n<li>比重定向效率更高</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-重定向\"><a href=\"#3-3-重定向\" class=\"headerlink\" title=\"3.3 重定向*\"></a>3.3 重定向*</h4><ul>\n<li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li>\n<li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li>\n<li>原理：当客户端请求服务器时，发起重定向流程：<ol>\n<li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li>\n<li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li>\n<li>浏览器自动发起新的请求 , 跳转到新地址.</li>\n</ol>\n</li>\n<li>特点：<ol>\n<li>重定向会产生两个请求对象，多个请求对象中数据不互通</li>\n<li>浏览器地址发生了改变</li>\n<li>重定向可以跨域实现</li>\n<li>比转发效率低</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-上下文对象ServletContext\"><a href=\"#4-上下文对象ServletContext\" class=\"headerlink\" title=\"4. 上下文对象ServletContext\"></a>4. 上下文对象ServletContext</h3><ul>\n<li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li>\n<li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li>\n</ul>\n<p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p>\n<ul>\n<li>常用方法<ul>\n<li>context.setAttributes(String key, Objexct value); //设置替换数据</li>\n<li>context.getAttributes(String key); //获取数据</li>\n<li>context.removeAttributes(String key); //删除数据</li>\n<li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-会话跟踪（状态管理）\"><a href=\"#5-会话跟踪（状态管理）\" class=\"headerlink\" title=\"5. 会话跟踪（状态管理）\"></a>5. 会话跟踪（状态管理）</h3><ul>\n<li><p>存在两种实现：</p>\n<ol>\n<li>cookie: 将浏览器产生的状态存储在浏览器中</li>\n<li>Session: 将浏览器产生的状态存储在服务器中</li>\n</ol>\n</li>\n<li><p>cookie技术原理：</p>\n<ul>\n<li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li>\n<li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li>\n<li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li>\n</ul>\n</li>\n<li><p>Session技术原理：</p>\n<ul>\n<li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li>\n<li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li>\n<li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-Cookie\"><a href=\"#5-1-Cookie\" class=\"headerlink\" title=\"5.1 Cookie\"></a>5.1 Cookie</h4><ul>\n<li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul>\n<li><code>Cookie cookie = new Cookie(String key, String value);</code></li>\n<li>注意：tomcat8.5版本之前，cookie无法出场中文</li>\n</ul>\n</li>\n<li>通过响应对象，将cookie添加到响应头,可添加多个<ul>\n<li>response.addCookie(Cookie cookie);</li>\n</ul>\n</li>\n<li>通过请求头得到cookie数组，没有则返回null<ul>\n<li>Cookie[] cookies = request.getCookies();</li>\n<li>取键：cookie.getName();</li>\n<li>取值：cookie.getValue()</li>\n</ul>\n</li>\n<li>Cookie的存储时长：<ul>\n<li>cookie.setMaxAge(int 秒)；<ul>\n<li>正数：倒计时秒数</li>\n<li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li>\n<li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Cookie的存储路径问题<ul>\n<li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li>\n<li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-Cookie的优缺点\"><a href=\"#5-2-Cookie的优缺点\" class=\"headerlink\" title=\"5.2 Cookie的优缺点\"></a>5.2 Cookie的优缺点</h4><ul>\n<li>缺点：<ol>\n<li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li>\n<li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li>\n<li>保存数据量有限制，大约4kb左右</li>\n<li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>分散服务器的压力</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-3-Session\"><a href=\"#5-3-Session\" class=\"headerlink\" title=\"5.3 Session\"></a>5.3 Session</h4><ul>\n<li>获取Session<ul>\n<li>格式1：request.getSession();//等价参数传true</li>\n<li>格式2：request.getSession(boolean isNew);<ul>\n<li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li>\n<li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Session常用方法<ul>\n<li>session.setAttribute(String key, object value);//设置/替换值</li>\n<li>session.getAttribute(String key);//获取值</li>\n<li>session.invalidate();//销毁</li>\n</ul>\n</li>\n<li>设置session存活时长<ul>\n<li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li>\n<li>可以通过修改配置文件，修改所有的session时长<ul>\n<li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li>\n</ul>\n</li>\n<li>可以通过session对象，修改单个对象的session时长<ul>\n<li>void session.setMaxInactiveInterval(int seconds)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-4-Session的优缺点\"><a href=\"#5-4-Session的优缺点\" class=\"headerlink\" title=\"5.4 Session的优缺点\"></a>5.4 Session的优缺点</h4><ul>\n<li>缺点：<ul>\n<li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li>\n</ul>\n</li>\n<li>优点：<ol>\n<li>数据存储在服务器中，安全</li>\n<li>数据类型为Object，在Java中表示可以存储所有类型的数据</li>\n<li>session存储的数据大小，理论上无限的。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-5-Cookie和Session的使用\"><a href=\"#5-5-Cookie和Session的使用\" class=\"headerlink\" title=\"5.5 Cookie和Session的使用\"></a>5.5 Cookie和Session的使用</h4><ul>\n<li>Cookie和Session不是互斥的，是相辅相成的</li>\n<li>在项目开发时：<ul>\n<li>对安全敏感的数据，存储在session中</li>\n<li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li>\n<li>对于大的数据，应该存在数据库和文件中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：cookie和session是为了管理状态而非存储数据。</p>\n</blockquote>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-JSP\"><a href=\"#6-JSP\" class=\"headerlink\" title=\"6.JSP\"></a>6.JSP</h3><h4 id=\"6-1-JSP语法基础\"><a href=\"#6-1-JSP语法基础\" class=\"headerlink\" title=\"6.1 JSP语法基础\"></a>6.1 JSP语法基础</h4><ul>\n<li><p>Java Server Pages：java动态网页技术</p>\n</li>\n<li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p>\n</li>\n<li><p>注意：</p>\n<ol>\n<li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li>\n<li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li>\n</ol>\n</li>\n<li><p>JSP语法结构</p>\n<ol>\n<li>html代码</li>\n<li>Java代码</li>\n<li>Jsp特有的语法结构</li>\n</ol>\n</li>\n<li><p>Java代码声明区：指的是类的成员位置</p>\n</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">  <span class=\"comment\">// Java代码声明区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">  <span class=\"comment\">// Java代码执行区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JSP输出表达式<ul>\n<li>用于快速的将Java中的数据，输出到网页中..</li>\n<li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li>\n</ul>\n</li>\n<li>JSP注释：<ul>\n<li>html中可以用<code>&lt;!-- --&gt;</code></li>\n<li>java中可以用<code>//，/**/，/** */</code></li>\n<li>jsp注释<code>&lt;%-- --%&gt;</code><ul>\n<li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-JSP三大指令\"><a href=\"#6-2-JSP三大指令\" class=\"headerlink\" title=\"6.2 JSP三大指令\"></a>6.2 JSP三大指令</h4><ul>\n<li>page指令</li>\n<li>include指令</li>\n<li>taglib指令</li>\n</ul>\n<ul>\n<li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li>\n</ul>\n<h5 id=\"6-2-1-page指令\"><a href=\"#6-2-1-page指令\" class=\"headerlink\" title=\"6.2.1 page指令\"></a>6.2.1 page指令</h5><ul>\n<li>用于配置页面信息</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page</span><br><span class=\"line\">  language=<span class=\"string\">\"java\"</span>：语言</span><br><span class=\"line\">  contentType=<span class=\"string\">\"text/html;charset=utf-8\"</span>：响应的内容类型，以及响应的编码格式</span><br><span class=\"line\">  pageEncoding=<span class=\"string\">\"UTF-8\"</span>：文件存储的编码格式</span><br><span class=\"line\">  extends=<span class=\"string\">\"继承的父类\"</span></span><br><span class=\"line\">  buffer=<span class=\"string\">\"数字/none\"</span>：是否允许缓存，默认值<span class=\"number\">8</span>kb</span><br><span class=\"line\">  autoFlush=<span class=\"string\">\"true/false\"</span>：是否自动清除缓存，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  session=<span class=\"string\">\"true/false\"</span>：是否提前准备session对象，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  isThreadSafe=<span class=\"string\">\"true/false\"</span>：是否线程安全的</span><br><span class=\"line\">  <span class=\"keyword\">import</span>=<span class=\"string\">\"java.util.List\"</span>：用于导包，多个包使用<span class=\"string\">\",\"</span>隔开</span><br><span class=\"line\">  errorPage=<span class=\"string\">\"网址\"</span>：当页面发生BUG后，显示哪个页面</span><br><span class=\"line\">  isErrorPage=<span class=\"string\">\"true/false\"</span>：当前页面是否是一个错误处理页面，如果结果为<span class=\"keyword\">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-项目发生错误时，统一的处理方式\"><a href=\"#6-3-项目发生错误时，统一的处理方式\" class=\"headerlink\" title=\"6.3 项目发生错误时，统一的处理方式\"></a>6.3 项目发生错误时，统一的处理方式</h4><ol>\n<li>打开项目的web.xml</li>\n<li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>500<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>404<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>include指令：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li>\n</ul>\n</li>\n<li>include动作：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>include指令 与 include动作区别：<br><br>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）<br><br>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p>","more":"<ol>\n<li><a href=\"#id1\">http协议</a></li>\n<li><a href=\"#id2\">Servlet</a></li>\n<li><a href=\"#id3\">get和post区别</a></li>\n<li><a href=\"#id4\">上下文对象ServletContext</a></li>\n<li><a href=\"#id5\">会话跟踪（状态管理）</a></li>\n<li><a href=\"#id6\">JSP</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-http协议\"><a href=\"#1-http协议\" class=\"headerlink\" title=\"1. http协议\"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p>\n<ul>\n<li>http协议的特点：<ol>\n<li>简单，快速：支持多种不同的的数据提交方式，如get/post</li>\n<li>数据传输灵活，支持任意类型数据的传输</li>\n<li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li>\n<li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li>\n</ol>\n</li>\n<li>http协议的组成部分：<ol>\n<li>请求：浏览器连接服务器的过程</li>\n<li>响应：服务器回复浏览器的过程</li>\n</ol>\n</li>\n<li>http协议的请求：<ol>\n<li>请求头：描述客户端的信息</li>\n<li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li>\n<li>请求空行：请求头与请求体之间的一行空白</li>\n<li>请求行：描述请求方式，服务器地址，协议版本等</li>\n</ol>\n</li>\n<li>http协议的响应：<ol>\n<li>响应头：描述服务器的信息</li>\n<li>响应体：响应的内容，文本，json数据等。</li>\n<li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-Servlet\"><a href=\"#2-Servlet\" class=\"headerlink\" title=\"2. Servlet\"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p>\n<h4 id=\"2-1-Servlet编写步骤：\"><a href=\"#2-1-Servlet编写步骤：\" class=\"headerlink\" title=\"2.1 Servlet编写步骤：\"></a>2.1 Servlet编写步骤：</h4><ol>\n<li>编写一个Java类，继承HttpServlet类</li>\n<li>重新service方法</li>\n<li>在service方法中，对用户请求进行响应。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//注解：添加访问的网址</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/hello\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(ServletRequest req, ServletResponse res)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//1.设置响应体的编码，以及内容类型</span></span><br><span class=\"line\">\t\tres.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//2.得到响应体输出的打印流</span></span><br><span class=\"line\">\t\tPrintWriter out = res.getWriter();</span><br><span class=\"line\">\t\t<span class=\"comment\">//3.打印文字</span></span><br><span class=\"line\">\t\tout.println(<span class=\"string\">\"&lt;h1&gt;Hello Servlet!&lt;/h1&gt;\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-配置ervlet类的访问网址\"><a href=\"#2-2-配置ervlet类的访问网址\" class=\"headerlink\" title=\"2.2 配置ervlet类的访问网址\"></a>2.2 配置ervlet类的访问网址</h4><ul>\n<li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li>\n<li>web3.0版本之前配置Servlet访问网址的方式：<ul>\n<li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li>\n<li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>demo1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/hello<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-Servlet生命周期\"><a href=\"#2-3-Servlet生命周期\" class=\"headerlink\" title=\"2.3 Servlet生命周期\"></a>2.3 Servlet生命周期</h4><ul>\n<li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li>\n<li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li>\n<li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li>\n<li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul>\n<li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li>\n<li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li>\n<li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-4-get和post区别\"><a href=\"#2-4-get和post区别\" class=\"headerlink\" title=\"2.4 get和post区别\"></a>2.4 get和post区别</h4><ul>\n<li>GET请求：<ul>\n<li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由=连接的键值对组成，&amp;连接键值对。</li>\n<li>只能传输字符串类型参数</li>\n<li>浏览器url地址最大长度4kb</li>\n<li>数据传输时，参数在url中明文显示，不安全。</li>\n</ul>\n</li>\n<li>POST请求：<ul>\n<li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li>\n<li>可传输任意类型的数据，进行文件上传必须POST请求</li>\n<li>可以传递的数据大小，理论上没有上限</li>\n<li>数据传输时在单独的数据包，较为安全。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-5-接收请求中的参数\"><a href=\"#2-5-接收请求中的参数\" class=\"headerlink\" title=\"2.5 接收请求中的参数\"></a>2.5 接收请求中的参数</h4><ol>\n<li>根据参数的名称，接收参数的单个值<ul>\n<li>String value = request.getParameter(String name);</li>\n</ul>\n</li>\n<li>根据参数的名称，接收一组参数的值<ul>\n<li>String[] values = request.getParameterValues(String name);</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doPost</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">  request.setCharacterEncoding(<span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">  response.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//1.接收</span></span><br><span class=\"line\">  String username = request.getParameter(<span class=\"string\">\"username\"</span>);</span><br><span class=\"line\">  String[] password = request.getParameterValues(<span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">//2.打印</span></span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password:\"</span> + password[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"password2:\"</span> + password[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"comment\">//3.浏览器输出</span></span><br><span class=\"line\">  response.getWriter().append(<span class=\"string\">\"&lt;div&gt;很遗憾注册失败，点击&lt;a href=\\\"demo1.html\\\"&gt;重新注册&lt;/a&gt;&lt;/div&gt;\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-6-乱码处理\"><a href=\"#2-6-乱码处理\" class=\"headerlink\" title=\"2.6 乱码处理\"></a>2.6 乱码处理</h4><h4 id=\"2-6-1-乱码情况：\"><a href=\"#2-6-1-乱码情况：\" class=\"headerlink\" title=\"2.6.1 乱码情况：\"></a>2.6.1 乱码情况：</h4><ul>\n<li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li>\n<li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li>\n<li>任何版本, POST请求乱码</li>\n</ul>\n<h4 id=\"2-6-2-请求乱码处理：\"><a href=\"#2-6-2-请求乱码处理：\" class=\"headerlink\" title=\"2.6.2 请求乱码处理：\"></a>2.6.2 请求乱码处理：</h4><ul>\n<li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>将接收到的中文乱码重新编码：</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = request.getParameter(<span class=\"string\">\"userName\"</span>);</span><br><span class=\"line\">String userName = <span class=\"keyword\">new</span> String( name.getByte(<span class=\"string\">\"ISO-8859-1\"</span>),<span class=\"string\">\"utf-8\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>仅适用于POST请求：<ol>\n<li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li>\n<li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-6-3-响应乱码的处理：\"><a href=\"#2-6-3-响应乱码的处理：\" class=\"headerlink\" title=\"2.6.3 响应乱码的处理：\"></a>2.6.3 响应乱码的处理：</h4><ul>\n<li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li>\n<li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li>\n</ul>\n<h4 id=\"2-7-Servlet的创建时机\"><a href=\"#2-7-Servlet的创建时机\" class=\"headerlink\" title=\"2.7 Servlet的创建时机\"></a>2.7 Servlet的创建时机</h4><ul>\n<li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li>\n<li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li>\n<li>节点中的值为数字：<ul>\n<li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li>\n<li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>demo.ServletDemo<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>s1<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/s1<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-请求的转发与重定向\"><a href=\"#3-请求的转发与重定向\" class=\"headerlink\" title=\"3. 请求的转发与重定向\"></a>3. 请求的转发与重定向</h3><h4 id=\"3-1-请求对象request的常用操作\"><a href=\"#3-1-请求对象request的常用操作\" class=\"headerlink\" title=\"3.1 请求对象request的常用操作\"></a>3.1 请求对象request的常用操作</h4><ol>\n<li>getMethod() : 得到请求的方式</li>\n<li>getRequestURI() : 获取浏览器请求地址</li>\n<li>getRemoteAddr() : 获取客户端ip地址</li>\n<li>getRemoteHost() : 获取客户端名称</li>\n<li>getServerName() : 获取服务器名称</li>\n<li>getServerPort() : 获取服务器端口号</li>\n<li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li>\n</ol>\n<h4 id=\"3-1-请求的转发与重定向注意事项\"><a href=\"#3-1-请求的转发与重定向注意事项\" class=\"headerlink\" title=\"3.1 请求的转发与重定向注意事项\"></a>3.1 请求的转发与重定向注意事项</h4><ul>\n<li>请求转发与重定向操作，必须要有出口。</li>\n<li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li>\n</ul>\n<h4 id=\"3-2-转发\"><a href=\"#3-2-转发\" class=\"headerlink\" title=\"3.2 转发*\"></a>3.2 转发*</h4><ul>\n<li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li>\n<li>步骤：<ol>\n<li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li>\n<li>进行转发操作：<code>rd.forward(request, response);</code></li>\n</ol>\n</li>\n<li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul>\n<li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li>\n</ul>\n</li>\n<li>特点：<ul>\n<li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li>\n<li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li>\n<li>转发不能跨项目实现</li>\n<li>比重定向效率更高</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-3-重定向\"><a href=\"#3-3-重定向\" class=\"headerlink\" title=\"3.3 重定向*\"></a>3.3 重定向*</h4><ul>\n<li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li>\n<li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li>\n<li>原理：当客户端请求服务器时，发起重定向流程：<ol>\n<li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li>\n<li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li>\n<li>浏览器自动发起新的请求 , 跳转到新地址.</li>\n</ol>\n</li>\n<li>特点：<ol>\n<li>重定向会产生两个请求对象，多个请求对象中数据不互通</li>\n<li>浏览器地址发生了改变</li>\n<li>重定向可以跨域实现</li>\n<li>比转发效率低</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-上下文对象ServletContext\"><a href=\"#4-上下文对象ServletContext\" class=\"headerlink\" title=\"4. 上下文对象ServletContext\"></a>4. 上下文对象ServletContext</h3><ul>\n<li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li>\n<li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li>\n</ul>\n<p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p>\n<ul>\n<li>常用方法<ul>\n<li>context.setAttributes(String key, Objexct value); //设置替换数据</li>\n<li>context.getAttributes(String key); //获取数据</li>\n<li>context.removeAttributes(String key); //删除数据</li>\n<li>context.getRealPath(“/“); //获取项目运行时所在文件路径</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-会话跟踪（状态管理）\"><a href=\"#5-会话跟踪（状态管理）\" class=\"headerlink\" title=\"5. 会话跟踪（状态管理）\"></a>5. 会话跟踪（状态管理）</h3><ul>\n<li><p>存在两种实现：</p>\n<ol>\n<li>cookie: 将浏览器产生的状态存储在浏览器中</li>\n<li>Session: 将浏览器产生的状态存储在服务器中</li>\n</ol>\n</li>\n<li><p>cookie技术原理：</p>\n<ul>\n<li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li>\n<li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li>\n<li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li>\n</ul>\n</li>\n<li><p>Session技术原理：</p>\n<ul>\n<li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li>\n<li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li>\n<li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-1-Cookie\"><a href=\"#5-1-Cookie\" class=\"headerlink\" title=\"5.1 Cookie\"></a>5.1 Cookie</h4><ul>\n<li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul>\n<li><code>Cookie cookie = new Cookie(String key, String value);</code></li>\n<li>注意：tomcat8.5版本之前，cookie无法出场中文</li>\n</ul>\n</li>\n<li>通过响应对象，将cookie添加到响应头,可添加多个<ul>\n<li>response.addCookie(Cookie cookie);</li>\n</ul>\n</li>\n<li>通过请求头得到cookie数组，没有则返回null<ul>\n<li>Cookie[] cookies = request.getCookies();</li>\n<li>取键：cookie.getName();</li>\n<li>取值：cookie.getValue()</li>\n</ul>\n</li>\n<li>Cookie的存储时长：<ul>\n<li>cookie.setMaxAge(int 秒)；<ul>\n<li>正数：倒计时秒数</li>\n<li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li>\n<li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Cookie的存储路径问题<ul>\n<li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li>\n<li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“/“);</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-2-Cookie的优缺点\"><a href=\"#5-2-Cookie的优缺点\" class=\"headerlink\" title=\"5.2 Cookie的优缺点\"></a>5.2 Cookie的优缺点</h4><ul>\n<li>缺点：<ol>\n<li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li>\n<li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li>\n<li>保存数据量有限制，大约4kb左右</li>\n<li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li>\n</ol>\n</li>\n<li>优点：<ol>\n<li>分散服务器的压力</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-3-Session\"><a href=\"#5-3-Session\" class=\"headerlink\" title=\"5.3 Session\"></a>5.3 Session</h4><ul>\n<li>获取Session<ul>\n<li>格式1：request.getSession();//等价参数传true</li>\n<li>格式2：request.getSession(boolean isNew);<ul>\n<li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li>\n<li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Session常用方法<ul>\n<li>session.setAttribute(String key, object value);//设置/替换值</li>\n<li>session.getAttribute(String key);//获取值</li>\n<li>session.invalidate();//销毁</li>\n</ul>\n</li>\n<li>设置session存活时长<ul>\n<li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li>\n<li>可以通过修改配置文件，修改所有的session时长<ul>\n<li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li>\n</ul>\n</li>\n<li>可以通过session对象，修改单个对象的session时长<ul>\n<li>void session.setMaxInactiveInterval(int seconds)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-4-Session的优缺点\"><a href=\"#5-4-Session的优缺点\" class=\"headerlink\" title=\"5.4 Session的优缺点\"></a>5.4 Session的优缺点</h4><ul>\n<li>缺点：<ul>\n<li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li>\n</ul>\n</li>\n<li>优点：<ol>\n<li>数据存储在服务器中，安全</li>\n<li>数据类型为Object，在Java中表示可以存储所有类型的数据</li>\n<li>session存储的数据大小，理论上无限的。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"5-5-Cookie和Session的使用\"><a href=\"#5-5-Cookie和Session的使用\" class=\"headerlink\" title=\"5.5 Cookie和Session的使用\"></a>5.5 Cookie和Session的使用</h4><ul>\n<li>Cookie和Session不是互斥的，是相辅相成的</li>\n<li>在项目开发时：<ul>\n<li>对安全敏感的数据，存储在session中</li>\n<li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li>\n<li>对于大的数据，应该存在数据库和文件中</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：cookie和session是为了管理状态而非存储数据。</p>\n</blockquote>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-JSP\"><a href=\"#6-JSP\" class=\"headerlink\" title=\"6.JSP\"></a>6.JSP</h3><h4 id=\"6-1-JSP语法基础\"><a href=\"#6-1-JSP语法基础\" class=\"headerlink\" title=\"6.1 JSP语法基础\"></a>6.1 JSP语法基础</h4><ul>\n<li><p>Java Server Pages：java动态网页技术</p>\n</li>\n<li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p>\n</li>\n<li><p>注意：</p>\n<ol>\n<li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li>\n<li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li>\n</ol>\n</li>\n<li><p>JSP语法结构</p>\n<ol>\n<li>html代码</li>\n<li>Java代码</li>\n<li>Jsp特有的语法结构</li>\n</ol>\n</li>\n<li><p>Java代码声明区：指的是类的成员位置</p>\n</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%!</span><br><span class=\"line\">  <span class=\"comment\">// Java代码声明区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%</span><br><span class=\"line\">  <span class=\"comment\">// Java代码执行区</span></span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>JSP输出表达式<ul>\n<li>用于快速的将Java中的数据，输出到网页中..</li>\n<li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li>\n</ul>\n</li>\n<li>JSP注释：<ul>\n<li>html中可以用<code>&lt;!-- --&gt;</code></li>\n<li>java中可以用<code>//，/**/，/** */</code></li>\n<li>jsp注释<code>&lt;%-- --%&gt;</code><ul>\n<li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-2-JSP三大指令\"><a href=\"#6-2-JSP三大指令\" class=\"headerlink\" title=\"6.2 JSP三大指令\"></a>6.2 JSP三大指令</h4><ul>\n<li>page指令</li>\n<li>include指令</li>\n<li>taglib指令</li>\n</ul>\n<ul>\n<li>指令使用格式：&lt;%@ 指令名称 属性1=值 属性2=值 属性n=值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li>\n</ul>\n<h5 id=\"6-2-1-page指令\"><a href=\"#6-2-1-page指令\" class=\"headerlink\" title=\"6.2.1 page指令\"></a>6.2.1 page指令</h5><ul>\n<li>用于配置页面信息</li>\n</ul>\n<figure class=\"highlight jsp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page</span><br><span class=\"line\">  language=<span class=\"string\">\"java\"</span>：语言</span><br><span class=\"line\">  contentType=<span class=\"string\">\"text/html;charset=utf-8\"</span>：响应的内容类型，以及响应的编码格式</span><br><span class=\"line\">  pageEncoding=<span class=\"string\">\"UTF-8\"</span>：文件存储的编码格式</span><br><span class=\"line\">  extends=<span class=\"string\">\"继承的父类\"</span></span><br><span class=\"line\">  buffer=<span class=\"string\">\"数字/none\"</span>：是否允许缓存，默认值<span class=\"number\">8</span>kb</span><br><span class=\"line\">  autoFlush=<span class=\"string\">\"true/false\"</span>：是否自动清除缓存，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  session=<span class=\"string\">\"true/false\"</span>：是否提前准备session对象，默认<span class=\"keyword\">true</span></span><br><span class=\"line\">  isThreadSafe=<span class=\"string\">\"true/false\"</span>：是否线程安全的</span><br><span class=\"line\">  <span class=\"keyword\">import</span>=<span class=\"string\">\"java.util.List\"</span>：用于导包，多个包使用<span class=\"string\">\",\"</span>隔开</span><br><span class=\"line\">  errorPage=<span class=\"string\">\"网址\"</span>：当页面发生BUG后，显示哪个页面</span><br><span class=\"line\">  isErrorPage=<span class=\"string\">\"true/false\"</span>：当前页面是否是一个错误处理页面，如果结果为<span class=\"keyword\">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class=\"line\">%&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-项目发生错误时，统一的处理方式\"><a href=\"#6-3-项目发生错误时，统一的处理方式\" class=\"headerlink\" title=\"6.3 项目发生错误时，统一的处理方式\"></a>6.3 项目发生错误时，统一的处理方式</h4><ol>\n<li>打开项目的web.xml</li>\n<li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>500<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/error.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">error-page</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">error-code</span>&gt;</span>404<span class=\"tag\">&lt;/<span class=\"name\">error-code</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">location</span>&gt;</span>/404.jsp<span class=\"tag\">&lt;/<span class=\"name\">location</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>include指令：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li>\n</ul>\n</li>\n<li>include动作：用于将jsp或html引入到另一个jsp中<ul>\n<li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>include指令 与 include动作区别：<br><br>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp =&gt; 一个Servlet）<br><br>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp =&gt; 多个Servlet）</p>\n</blockquote>"},{"title":"二、JavaSE面向对象","date":"2019-07-07T10:50:47.000Z","_content":"\n面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。\nJava中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。\n<!-- more -->\n\n1. [类与对象](#id1)\n2. [构造方法和方法重载](#id2)\n3. [this关键字](#id3)\n4. [方法的传递和递归](#id4)\n5. [封装](#id5)\n6. [static关键字](#id6)\n7. [单例设计模式](#id7)\n8. [继承（extends）](#id8)\n9. [方法的重写（Override）](#id9)\n10. [访问控制](#id10)\n11. [包（Package）](#id11)\n12. [final关键字](#id12)\n13. [对象的创建过程](#id13)\n14. [多态](#id14)\n15. [抽象类](#id15)\n16. [接口](#id16)\n17. [内部类](#id17)\n18. [回调模式](#id18)\n19. [抽象方法的笔试考点](#id19)\n20. [枚举类（enum）](#id20)\n21. [内存机制问题](#id21)\n\n\n<span id=\"id1\"><span>\n### 1. 类与对象\n#### 1.1 类的定义\n``` java\nclass 类名 {类体}\n```\n\n> 类名由多个单词组成时，要求每个单词首字母大写\n\n#### 1.2 成员变量的定义\n``` java\nclass 类名 { 数据类型 成员变量名=初始值; ... }\n```\n\n> 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写\n\n#### 1.3 对象的创建\n``` java\nnew 类名();\n```\n\n> 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。\n\n#### 1.4 引用\n``` java\n类名 引用变量名;\nPerson p = new Person(); //声明person类型的引用p指向Person类型对象\n```\n\n``` java\n引用变量名.成员变量名;\np.name = 'zhangsan';\n```\n\n>- 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。\n>- 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。\n\n- 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。\n\n\n#### 1.5 成员方法\n``` java\nclass 类名 {\n    返回值类型 成员方法名(形参列表){方法体;}\n}\n```\n\n- 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void\n- 形参列表：数据类型 形参1, 数据类型 形参2, ...\n\n\n<span id=\"id2\"><span>\n### 2. 构造方法和方法重载\n#### 2.1 构造方法\n``` java\nclass 类名 { 构造方法名(形参列表){构造方法体;} }\n```\n\n- 构造方法名与类名相同且没有返回值\n- 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。\n\n#### 2.2 默认构造方法\n- 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。\n- 若类中出现自定义构造方法，则编译器不再提供构造方法。\n\n#### 2.3 方法重载（overload）\n在Java中，方法名相同，参数列表不同的方法构成重载关系。\n\n- 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）\n- 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。\n\n\n<span id=\"id3\"><span>\n### 3. this关键字\n在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。\n- 使用方式：\n    1. 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名\n    2. 在构造方法的的第一行，可以调用本类中的其他构造方法。\n\n\n<span id=\"id4\"><span>\n### 4. 方法的传递和递归\n#### 4.1 传参\n- 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。\n- 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。\n- 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。\n\n#### 4.2 递归的调用\n- 递归是指方法体内部调用自身\n- 必须有递归的规律和退出条件\n- 使用递归必须使得问题简单化而不是复杂化\n- 若递归影响到程序的执行性能时，则用递推取代之\n\n\n<span id=\"id5\"><span>\n### 5. 封装\n面向对象的三大特征：封装，继承，多态。\n- 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断\n- 封装基本流程：\n    1. 私有化成员变量(private)\n    2. 提供公有的get、set方法，并在set方法体中进行合理性判断\n    3. 在构方法中调用set方法进行合理值的判断\n\n\n<span id=\"id6\"><span>\n### 6. static关键字\n基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。\n\n> 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。\n\n- static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)\n- 特点\n    * 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问\n    * 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突\n    * 静态元素只加载一次，全部类对象及类本身共享\n    * 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存\n    * 非静态成员和静态成员都可以访问静态成员\n    * 静态成员不可以访问非静态成员\n    * 静态元素中不可出现this或super关键字，静态元素属于类的\n\n\n<span id=\"id7\"><span>\n### 7. 单例设计模式\n基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。\n\n``` java\n/**\n * 编程实现Singleton类的封装\n */\npublic class Singleton{\n    private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象\n    private Singleton(){} //1.私有化构造方法\n    public static Singleton getInstance(){//3.提供公有的get方法将上述成员变量的数值返回出去\n        return sin;\n    }\n}\n```\n\n- 实现流程：\n    1. 私有化构造方法（private）\n    2. 提供本类类型的引用指向本类类型对象（private static）\n    3. 提供公有的get方法将上述对象return出去（public static）\n    4. 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。\n\n\n<span id=\"id8\"><span>\n### 8. 继承（extends）\n- 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系\n- 使用继承可以提高代码复用性、扩展性、以及可维护性。\n    1. 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。\n    2. 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。\n    3. 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。\n    4. 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。\n\n``` java\nclass Cricle extends Shape{\n    int r;\n    Cricle(){}   //编译器会加入无参的调用 super()。\n    Cricle(int x, int y, int r){\n        super(x, y);  //通过super关键字调用父类的构造方法。\n        setR(r);\n    }\n    public void setR(int r){\n        this.r = r;\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 方法的重写（Override）\n概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。\n<br>原则：\n1. 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。\n2. 要求访问权限不能变小，可以相同或变大\n3. 重写的方法不能抛出更大的异常\n\n\n<span id=\"id10\"><span>\n### 10. 访问控制\n- public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，\n- 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰\n\n| 访问控制符 | 访问权限    | 本类内部    | 本类中的包 | 子类    | 其他包 |\n| ---------    |:---------:| ------:    |-------:    |-----:    |------:|\n| public    | 共有的        | Y            | Y            | Y        | Y        |\n| protected    | 保护的        | Y            | Y            | Y        | N        |\n| 不写        | 默认的        | Y            | Y            | N        | N        |\n| private    | 私有的        | Y            | N            | N        | N        |\n\n\n<span id=\"id11\"><span>\n### 11. 包（Package）\n为了解决命名冲突问题，便于文件的管理\n\n``` java\npackage 包名；\npackage 包名1.包名2.包名3...包名n;\n/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */\norg.apache.commons.lang.StringUtil;\n```\n\n\n<span id=\"id12\"><span>\n### 12. final关键字\n1. final关键字修饰**类**体现该类**不能被继承**（防止滥用继承）。\n2. final关键字修饰**方法**体现在该方法**不能被重新，但可以被继承**（防止不经意间造成的方法重写）。\n3. final关键字修饰**成员变量**体现在改成员变量**必须初始化且不能更改**（防止不经意间造成的数据更改）。\n\n> 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用**`public static final`**共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。\n\n\n<span id=\"id13\"><span>\n### 13. 对象的创建过程\n- 单个对象的创建过程\n    1. main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；\n    2. 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；\n    3. 执行构造块中的代码可以对成员变量进行赋值；\n    4. 执行构造方法体中的代码可以对成员变量进行再次赋值；\n    5. 此时对象构造完毕，继续向下执行后续的代码；\n- 子类对象的创建过程\n    1. main方法是程序的入口，先加载父类的的代码再加载子类的代码；\n    2. 先执行父类静态代码块，再执行子类的静态代码块；\n    3. 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；\n    4. 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。\n\n\n<span id=\"id14\"><span>\n### 14. 多态\n1. 语法：父类的引用指向子类的对象\n\n``` java\n父类类型 引用变量名 = new 子类类型();\nPerson pw = new Worker();\npw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。\n```\n\n2. 多态的效果：\n    1. 父类的引用**可以**直接调用**父类独有**的方法。\n    2. 父类的引用**不可以**直接调用**子类独有**的方法。\n    3. 对于父类子类都有的**非静态方法**来说，编译阶段调用父类的，运行阶段调用子类重写后的。\n    4. 对于父类子类都有的**静态方法**来说，只调用父类的。\n3. 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。\n4. 多态的表现形式\n    1. 多态的前提要有继承的关系\n    2. 使用父类引用指向子类对象 Person p = new Teacher();//向上转型\n    3. 该引用只能调用父类中定义的属性/方法\n    4. 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写\n    5. 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException\n5. 引用数据类型之间的转换\n    - 转换必须发生在父子类之间，否则编译报错。\n    - 自动类型转换：小到大，子类型向父类型的转换，eg:`Person pw = new Worker();`。\n    - 强制类型转换：大到小，父类型向子类型转换，eg:`((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法`。\n6. 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。\n\n``` java\n/*语法格式：*/ 对象 instanceof 类型  //返回布尔值\nif(pw instanceof Teacher){\n    Teacher t = (Teacher) pw;\n}else{\n    System.out.println(\"转换会有异常\");\n}\n```\n\n7. 多态的使用场合：\n\n``` java\n// 通过方法的参数传递形成多态。\npublic static void draw(Shape s){}\nTestShape.draw(new Rect(1,2,3,4));\n\n// 在方法体中直接使用多态的语法格式。\nTestAbstrat ta = new SubTestAbstract();\nta.show();\n```\n\n\n<span id=\"id15\"><span>\n### 15. 抽象类\n1. 基本概念\n    - 用**abstract**关键字修饰的类称为抽象类。\n    - 抽象类不能实例化，抽象类的意义在于被继承。\n    - 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。\n    - 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。\n\n``` java\npublic abstract class Shape{ //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类\n    private int x;\n    private int y;\n    public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体\n}\n```\n\n2. 注意：\n    1. 抽象类中可以有成员变量，成员方法，以及构造方法。\n    2. 抽象类中可以没有抽象方法，也可以有抽象方法。\n    3. 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。\n    4. 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。\n    5. 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。\n    6. 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。\n\n> 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。\n\n\n<span id=\"id16\"><span>\n### 16. 接口\n1. 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过**interface**关键字定义。\n\n``` java\ninterface Runner { //-通过interface关键字定义接口\n    public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量\n    public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）\n}\n```\n\n2. 一个类可以通过**implements**关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。\n\n``` java\nclass American implements Runner,... { //与继承不同，可以实现多个接口\n    @Override\n    public void run(){//该类需要实现接口中定义的所有方法\n        System.out.println(\"run...\");\n    }\n    public static void main(String[] args) {\n        Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象\n        ra.run();//通过该变量可以调用该接口定义的方法\n    }\n}\n```\n\n3. 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。\n\n``` java\ninterface Hunter extends Runner{...}\n```\n\n4. 类与接口的关系\n    - 类和类使用`extends`继承，仅支持**单继承**。\n    - 接口和接口使用`extends`继承，支持多继承。\n    - 类使用`implements`实现接口，支持**多实现**。\n5. 抽象类与接口的关系（笔试题）\n    1. 定义抽象类:`abstract class`，而定义接口:`interface`；\n    2. 类继承抽象类:`extends`单继承，而类实现接口:`implements`多实现；\n    3. 抽象类可以`有`构造方法，而接口`不能有`构造方法；\n    4. 抽象类可以有`成员变量`，而接口只能有`常量`；\n    5. 抽象类可以有`成员方法`，而接口只能有`抽象方法`；\n    6. 抽象类中增加方法子类可以`不用重写`，而接口中增加方法子类`必须重写`；\n    7. 从jdk1.8开始允许接口中有非抽象方法，但需要`default`关键字修饰。\n\n\n<span id=\"id17\"><span>\n### 17. 内部类\n- 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部\n- 内部类定义在 类的内部 ，与类成员层次一致\n- 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）\n    * 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n    * 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n    * 匿名内部类：成员匿名内部类，局部匿名内部类\n    * 静态内部类：成员静态内部类\n\n#### 17.1 *成员内部类\n- 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n- 成员内部类可以与正常类一样 使用不同的修饰符来修饰\n- 好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的\n- 若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;\n- 内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class\n\n#### 17.2 局部内部类\n- 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n- 局部内部类像是一个局部的变量一样，不能用public protected private及static\n- 只能用abstract或final\n- 局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod\n- 局部内部类使用的变量只能是final修饰\n\n#### 17.3 *匿名内部类\n将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类\n<br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体\n<br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类\n<br>匿名类内部没有构造方法，也不能用任何修饰符来修饰\n\n- 当接口类型的引用作为方法的形参时，实参的传递方式有两种：\n    1. 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。\n    2. 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。\n\n``` java\npublic interface A {\n    public abstract void show();\n}\n//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递\npublic class SubA implements A {\n    @Override\n    public void show() {\n        System.out.println(\"这里自定义类实现接口并重写抽象方法！\");\n    }\n}\n//测试类\npublic class ATest {\n    public static void test(A a) {\n        a.show();\n    }\n    public static void main(String[] args) {\n        //ATest.test(new A());//报错，A是接口，不能new对象\n        //-方式1：接口实现类的对象作为实参传递\n        ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。\n        \n        //-方式2：匿名内部类\n        // 接口/父类类型 引用变量名 = new 接口/父类类型() {方法的重写};\n        A ta = new A() {\n            @Override\n            public void show() {\n                System.out.println(\"这里是匿名内部类\");\n            }\n        };\n        ATest.test(ta);//得到接口类型的引用，再作为实参传递\n    }\n}\n```\n\n- 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。\n- 语法格式：`接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};`。\n\n``` java\nSuperType obj = new SuperType(...){ ... };\n```\n\n\n#### 17.4 静态内部类\n- 成员静态内部类\n- 不需要外部类对象，通过正常的方式直接创建内部类\n- 静态元素不能访问非静态成员(自己类和外部类)\n\n\n<span id=\"id18\"><span>\n### 18. 回调模式\n回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法\n\n``` java\ninterface Action{\n    public void doSth();\n}\n//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次\npublic static void repeat(int n, Action ac){\n    for(int i=0; i<n; i++){ ac.doSth();}\n}\n//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。\npublic static void main(String[] args){\n    repeat(5, new Action(){//通过匿名内部类传递参数\n        public void doSth(){\n            System.out.println(\"Hello\")\n        }\n    });\n}\n```\n\n\n<span id=\"id19\"><span>\n### 19. 抽象方法的笔试考点\n- `abstract`与哪些关键字不能共存：\n    1. `final`关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。\n    2. `static`关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。\n    3. `private`关键字；因为private修饰的私有方法不能被继承，就不能重写，而`abstract`方法需要重写。\n\n\n<span id=\"id20\"><span>\n### 20. 枚举类（enum）\n- 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来\n- 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum<E extends Enum<E>>，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。\n- 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object\n- Enum类型，有两个属性\n    * name----->枚举对象的名字，name()获取name属性\n    * ordinal--->枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号\n- 一些常用的方法\n    * valueOf()   通过给定的name获取对应的枚举对象\n    * values()     获取全部的枚举对象  ---> 返回一个数组  Day[]\n    * compareTo()   可以比较两个枚举对象   int\n    * toString()      由于这个方法没有final修饰  可以覆盖(重写)\n- switch内部判断枚举的应用\n- 我们也可以在enum中描述自己的一些属性或方法\n    * 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;\n    * 可以定义自己的属性\n    * 类创建的过程中  帮我们创建枚举类型的对象\n    * 需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载\n\n``` java\npublic enum Day{\n    //描述了七个当前类的对象\n    monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday;\n\n    private String name;\n    private int index;\n    \n    private Day(){}\n    private Day(String  name,int index){\n        this.name=name;\n        this.index=index;\n    }\n    \n    public String getName(){\n        return this.name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n}\n```\n\n\n<span id=\"id21\"><span>\n### 21. 内存机制问题\n- 类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行\n- 栈内存--->Person p = new Person();---->堆内存    方法区---类模板\n    * 栈内存----变量空间,方法临时执行空间（从创建开始执行完毕,**立即回收**）\n    * 堆内存----new申请对象空间（**垃圾回收器GC**,对象空间没有任何引用指向视为垃圾）\n    * 方法区----常量  类模板  静态成员（有且只有一份,**不回收**）\n- Runtime类(是单例模式)之中提供了几个管理内存的方法\n    * maxMemory\n    * totalMemory\n    * freeMemory\n    * 栈内存溢出错误StackOverflowError \n    * 堆内存溢出错误OutOfMemoryError\n- Object类中有一个finalize方法  如果重写也能看见对象回收的效果\n- GC系统提供的一个线程    回收算法\n\n","source":"_posts/02_JavaSE面向对象.md","raw":"---\ntitle: 二、JavaSE面向对象\ndate: 2019-07-07 18:50:47\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。\nJava中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。\n<!-- more -->\n\n1. [类与对象](#id1)\n2. [构造方法和方法重载](#id2)\n3. [this关键字](#id3)\n4. [方法的传递和递归](#id4)\n5. [封装](#id5)\n6. [static关键字](#id6)\n7. [单例设计模式](#id7)\n8. [继承（extends）](#id8)\n9. [方法的重写（Override）](#id9)\n10. [访问控制](#id10)\n11. [包（Package）](#id11)\n12. [final关键字](#id12)\n13. [对象的创建过程](#id13)\n14. [多态](#id14)\n15. [抽象类](#id15)\n16. [接口](#id16)\n17. [内部类](#id17)\n18. [回调模式](#id18)\n19. [抽象方法的笔试考点](#id19)\n20. [枚举类（enum）](#id20)\n21. [内存机制问题](#id21)\n\n\n<span id=\"id1\"><span>\n### 1. 类与对象\n#### 1.1 类的定义\n``` java\nclass 类名 {类体}\n```\n\n> 类名由多个单词组成时，要求每个单词首字母大写\n\n#### 1.2 成员变量的定义\n``` java\nclass 类名 { 数据类型 成员变量名=初始值; ... }\n```\n\n> 成员变量名由多个单词组成时，要求第二个起每个单词首字母大写\n\n#### 1.3 对象的创建\n``` java\nnew 类名();\n```\n\n> 当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。\n\n#### 1.4 引用\n``` java\n类名 引用变量名;\nPerson p = new Person(); //声明person类型的引用p指向Person类型对象\n```\n\n``` java\n引用变量名.成员变量名;\np.name = 'zhangsan';\n```\n\n>- 在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。\n>- 使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。\n\n- 除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。\n\n\n#### 1.5 成员方法\n``` java\nclass 类名 {\n    返回值类型 成员方法名(形参列表){方法体;}\n}\n```\n\n- 返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void\n- 形参列表：数据类型 形参1, 数据类型 形参2, ...\n\n\n<span id=\"id2\"><span>\n### 2. 构造方法和方法重载\n#### 2.1 构造方法\n``` java\nclass 类名 { 构造方法名(形参列表){构造方法体;} }\n```\n\n- 构造方法名与类名相同且没有返回值\n- 当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。\n\n#### 2.2 默认构造方法\n- 当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。\n- 若类中出现自定义构造方法，则编译器不再提供构造方法。\n\n#### 2.3 方法重载（overload）\n在Java中，方法名相同，参数列表不同的方法构成重载关系。\n\n- 体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）\n- 实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。\n\n\n<span id=\"id3\"><span>\n### 3. this关键字\n在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。\n- 使用方式：\n    1. 当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名\n    2. 在构造方法的的第一行，可以调用本类中的其他构造方法。\n\n\n<span id=\"id4\"><span>\n### 4. 方法的传递和递归\n#### 4.1 传参\n- 基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。\n- 引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。\n- 引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。\n\n#### 4.2 递归的调用\n- 递归是指方法体内部调用自身\n- 必须有递归的规律和退出条件\n- 使用递归必须使得问题简单化而不是复杂化\n- 若递归影响到程序的执行性能时，则用递推取代之\n\n\n<span id=\"id5\"><span>\n### 5. 封装\n面向对象的三大特征：封装，继承，多态。\n- 封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断\n- 封装基本流程：\n    1. 私有化成员变量(private)\n    2. 提供公有的get、set方法，并在set方法体中进行合理性判断\n    3. 在构方法中调用set方法进行合理值的判断\n\n\n<span id=\"id6\"><span>\n### 6. static关键字\n基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。\n\n> 为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。\n\n- static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)\n- 特点\n    * 静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问\n    * 静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突\n    * 静态元素只加载一次，全部类对象及类本身共享\n    * 静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存\n    * 非静态成员和静态成员都可以访问静态成员\n    * 静态成员不可以访问非静态成员\n    * 静态元素中不可出现this或super关键字，静态元素属于类的\n\n\n<span id=\"id7\"><span>\n### 7. 单例设计模式\n基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。\n\n``` java\n/**\n * 编程实现Singleton类的封装\n */\npublic class Singleton{\n    private static Singleton sin = new Singleton();//2.提供本类的引用指向本类的对象\n    private Singleton(){} //1.私有化构造方法\n    public static Singleton getInstance(){//3.提供公有的get方法将上述成员变量的数值返回出去\n        return sin;\n    }\n}\n```\n\n- 实现流程：\n    1. 私有化构造方法（private）\n    2. 提供本类类型的引用指向本类类型对象（private static）\n    3. 提供公有的get方法将上述对象return出去（public static）\n    4. 实现方式：饿汉式和懒汉式，开发中推荐饿汉式。\n\n\n<span id=\"id8\"><span>\n### 8. 继承（extends）\n- 继承就是子类复用父类的代码，关键字extends表示类和类的继承关系\n- 使用继承可以提高代码复用性、扩展性、以及可维护性。\n    1. 子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。\n    2. 无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。\n    3. 使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。\n    4. 在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。\n\n``` java\nclass Cricle extends Shape{\n    int r;\n    Cricle(){}   //编译器会加入无参的调用 super()。\n    Cricle(int x, int y, int r){\n        super(x, y);  //通过super关键字调用父类的构造方法。\n        setR(r);\n    }\n    public void setR(int r){\n        this.r = r;\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 方法的重写（Override）\n概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。\n<br>原则：\n1. 要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。\n2. 要求访问权限不能变小，可以相同或变大\n3. 重写的方法不能抛出更大的异常\n\n\n<span id=\"id10\"><span>\n### 10. 访问控制\n- public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，\n- 通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰\n\n| 访问控制符 | 访问权限    | 本类内部    | 本类中的包 | 子类    | 其他包 |\n| ---------    |:---------:| ------:    |-------:    |-----:    |------:|\n| public    | 共有的        | Y            | Y            | Y        | Y        |\n| protected    | 保护的        | Y            | Y            | Y        | N        |\n| 不写        | 默认的        | Y            | Y            | N        | N        |\n| private    | 私有的        | Y            | N            | N        | N        |\n\n\n<span id=\"id11\"><span>\n### 11. 包（Package）\n为了解决命名冲突问题，便于文件的管理\n\n``` java\npackage 包名；\npackage 包名1.包名2.包名3...包名n;\n/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */\norg.apache.commons.lang.StringUtil;\n```\n\n\n<span id=\"id12\"><span>\n### 12. final关键字\n1. final关键字修饰**类**体现该类**不能被继承**（防止滥用继承）。\n2. final关键字修饰**方法**体现在该方法**不能被重新，但可以被继承**（防止不经意间造成的方法重写）。\n3. final关键字修饰**成员变量**体现在改成员变量**必须初始化且不能更改**（防止不经意间造成的数据更改）。\n\n> 扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用**`public static final`**共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。\n\n\n<span id=\"id13\"><span>\n### 13. 对象的创建过程\n- 单个对象的创建过程\n    1. main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；\n    2. 若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；\n    3. 执行构造块中的代码可以对成员变量进行赋值；\n    4. 执行构造方法体中的代码可以对成员变量进行再次赋值；\n    5. 此时对象构造完毕，继续向下执行后续的代码；\n- 子类对象的创建过程\n    1. main方法是程序的入口，先加载父类的的代码再加载子类的代码；\n    2. 先执行父类静态代码块，再执行子类的静态代码块；\n    3. 先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；\n    4. 先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。\n\n\n<span id=\"id14\"><span>\n### 14. 多态\n1. 语法：父类的引用指向子类的对象\n\n``` java\n父类类型 引用变量名 = new 子类类型();\nPerson pw = new Worker();\npw.show();//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。\n```\n\n2. 多态的效果：\n    1. 父类的引用**可以**直接调用**父类独有**的方法。\n    2. 父类的引用**不可以**直接调用**子类独有**的方法。\n    3. 对于父类子类都有的**非静态方法**来说，编译阶段调用父类的，运行阶段调用子类重写后的。\n    4. 对于父类子类都有的**静态方法**来说，只调用父类的。\n3. 多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。\n4. 多态的表现形式\n    1. 多态的前提要有继承的关系\n    2. 使用父类引用指向子类对象 Person p = new Teacher();//向上转型\n    3. 该引用只能调用父类中定义的属性/方法\n    4. 执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写\n    5. 若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException\n5. 引用数据类型之间的转换\n    - 转换必须发生在父子类之间，否则编译报错。\n    - 自动类型转换：小到大，子类型向父类型的转换，eg:`Person pw = new Worker();`。\n    - 强制类型转换：大到小，父类型向子类型转换，eg:`((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法`。\n6. 为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。\n\n``` java\n/*语法格式：*/ 对象 instanceof 类型  //返回布尔值\nif(pw instanceof Teacher){\n    Teacher t = (Teacher) pw;\n}else{\n    System.out.println(\"转换会有异常\");\n}\n```\n\n7. 多态的使用场合：\n\n``` java\n// 通过方法的参数传递形成多态。\npublic static void draw(Shape s){}\nTestShape.draw(new Rect(1,2,3,4));\n\n// 在方法体中直接使用多态的语法格式。\nTestAbstrat ta = new SubTestAbstract();\nta.show();\n```\n\n\n<span id=\"id15\"><span>\n### 15. 抽象类\n1. 基本概念\n    - 用**abstract**关键字修饰的类称为抽象类。\n    - 抽象类不能实例化，抽象类的意义在于被继承。\n    - 抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。\n    - 抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。\n\n``` java\npublic abstract class Shape{ //一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类\n    private int x;\n    private int y;\n    public abstract boolean contains(int x, int y);//用abstract修饰的方法，称之为抽象方法，没有方法体\n}\n```\n\n2. 注意：\n    1. 抽象类中可以有成员变量，成员方法，以及构造方法。\n    2. 抽象类中可以没有抽象方法，也可以有抽象方法。\n    3. 具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。\n    4. 子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。\n    5. 抽象类对子类具有强制性和规范性，因此叫做模板设计模式。\n    6. 推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。\n\n> 多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。\n\n\n<span id=\"id16\"><span>\n### 16. 接口\n1. 基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过**interface**关键字定义。\n\n``` java\ninterface Runner { //-通过interface关键字定义接口\n    public static final int SEF_SPEED=100;//-接口中不能定义成员变量，只能定义常量\n    public void run();//-接口中只可以定义没有实现的方法（可以省略public abstract）\n}\n```\n\n2. 一个类可以通过**implements**关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。\n\n``` java\nclass American implements Runner,... { //与继承不同，可以实现多个接口\n    @Override\n    public void run(){//该类需要实现接口中定义的所有方法\n        System.out.println(\"run...\");\n    }\n    public static void main(String[] args) {\n        Runner ra = new American();//接口作为一种类型声明，并且声明的变量可以引用实现类的对象\n        ra.run();//通过该变量可以调用该接口定义的方法\n    }\n}\n```\n\n3. 一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。\n\n``` java\ninterface Hunter extends Runner{...}\n```\n\n4. 类与接口的关系\n    - 类和类使用`extends`继承，仅支持**单继承**。\n    - 接口和接口使用`extends`继承，支持多继承。\n    - 类使用`implements`实现接口，支持**多实现**。\n5. 抽象类与接口的关系（笔试题）\n    1. 定义抽象类:`abstract class`，而定义接口:`interface`；\n    2. 类继承抽象类:`extends`单继承，而类实现接口:`implements`多实现；\n    3. 抽象类可以`有`构造方法，而接口`不能有`构造方法；\n    4. 抽象类可以有`成员变量`，而接口只能有`常量`；\n    5. 抽象类可以有`成员方法`，而接口只能有`抽象方法`；\n    6. 抽象类中增加方法子类可以`不用重写`，而接口中增加方法子类`必须重写`；\n    7. 从jdk1.8开始允许接口中有非抽象方法，但需要`default`关键字修饰。\n\n\n<span id=\"id17\"><span>\n### 17. 内部类\n- 内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部\n- 内部类定义在 类的内部 ，与类成员层次一致\n- 内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）\n    * 成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n    * 局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n    * 匿名内部类：成员匿名内部类，局部匿名内部类\n    * 静态内部类：成员静态内部类\n\n#### 17.1 *成员内部类\n- 将一个类直接定义在类的里面，作为成员，与属性或方法层次一致\n- 成员内部类可以与正常类一样 使用不同的修饰符来修饰\n- 好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的\n- 若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;\n- 内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class\n\n#### 17.2 局部内部类\n- 将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次\n- 局部内部类像是一个局部的变量一样，不能用public protected private及static\n- 只能用abstract或final\n- 局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod\n- 局部内部类使用的变量只能是final修饰\n\n#### 17.3 *匿名内部类\n将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类\n<br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体\n<br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类\n<br>匿名类内部没有构造方法，也不能用任何修饰符来修饰\n\n- 当接口类型的引用作为方法的形参时，实参的传递方式有两种：\n    1. 自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。\n    2. 直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。\n\n``` java\npublic interface A {\n    public abstract void show();\n}\n//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递\npublic class SubA implements A {\n    @Override\n    public void show() {\n        System.out.println(\"这里自定义类实现接口并重写抽象方法！\");\n    }\n}\n//测试类\npublic class ATest {\n    public static void test(A a) {\n        a.show();\n    }\n    public static void main(String[] args) {\n        //ATest.test(new A());//报错，A是接口，不能new对象\n        //-方式1：接口实现类的对象作为实参传递\n        ATest.test(new ASub());//接口类型引用指向实现类的对象，形成了多态。\n        \n        //-方式2：匿名内部类\n        // 接口/父类类型 引用变量名 = new 接口/父类类型() {方法的重写};\n        A ta = new A() {\n            @Override\n            public void show() {\n                System.out.println(\"这里是匿名内部类\");\n            }\n        };\n        ATest.test(ta);//得到接口类型的引用，再作为实参传递\n    }\n}\n```\n\n- 匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。\n- 语法格式：`接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};`。\n\n``` java\nSuperType obj = new SuperType(...){ ... };\n```\n\n\n#### 17.4 静态内部类\n- 成员静态内部类\n- 不需要外部类对象，通过正常的方式直接创建内部类\n- 静态元素不能访问非静态成员(自己类和外部类)\n\n\n<span id=\"id18\"><span>\n### 18. 回调模式\n回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法\n\n``` java\ninterface Action{\n    public void doSth();\n}\n//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次\npublic static void repeat(int n, Action ac){\n    for(int i=0; i<n; i++){ ac.doSth();}\n}\n//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。\npublic static void main(String[] args){\n    repeat(5, new Action(){//通过匿名内部类传递参数\n        public void doSth(){\n            System.out.println(\"Hello\")\n        }\n    });\n}\n```\n\n\n<span id=\"id19\"><span>\n### 19. 抽象方法的笔试考点\n- `abstract`与哪些关键字不能共存：\n    1. `final`关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。\n    2. `static`关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。\n    3. `private`关键字；因为private修饰的私有方法不能被继承，就不能重写，而`abstract`方法需要重写。\n\n\n<span id=\"id20\"><span>\n### 20. 枚举类（enum）\n- 一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来\n- 创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum<E extends Enum<E>>，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。\n- 我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object\n- Enum类型，有两个属性\n    * name----->枚举对象的名字，name()获取name属性\n    * ordinal--->枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号\n- 一些常用的方法\n    * valueOf()   通过给定的name获取对应的枚举对象\n    * values()     获取全部的枚举对象  ---> 返回一个数组  Day[]\n    * compareTo()   可以比较两个枚举对象   int\n    * toString()      由于这个方法没有final修饰  可以覆盖(重写)\n- switch内部判断枚举的应用\n- 我们也可以在enum中描述自己的一些属性或方法\n    * 必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;\n    * 可以定义自己的属性\n    * 类创建的过程中  帮我们创建枚举类型的对象\n    * 需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载\n\n``` java\npublic enum Day{\n    //描述了七个当前类的对象\n    monday(\"星期一\",1),tuesday(\"星期二\",2),wednesday,thursday,friday,saturday,sunday;\n\n    private String name;\n    private int index;\n    \n    private Day(){}\n    private Day(String  name,int index){\n        this.name=name;\n        this.index=index;\n    }\n    \n    public String getName(){\n        return this.name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n}\n```\n\n\n<span id=\"id21\"><span>\n### 21. 内存机制问题\n- 类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行\n- 栈内存--->Person p = new Person();---->堆内存    方法区---类模板\n    * 栈内存----变量空间,方法临时执行空间（从创建开始执行完毕,**立即回收**）\n    * 堆内存----new申请对象空间（**垃圾回收器GC**,对象空间没有任何引用指向视为垃圾）\n    * 方法区----常量  类模板  静态成员（有且只有一份,**不回收**）\n- Runtime类(是单例模式)之中提供了几个管理内存的方法\n    * maxMemory\n    * totalMemory\n    * freeMemory\n    * 栈内存溢出错误StackOverflowError \n    * 堆内存溢出错误OutOfMemoryError\n- Object类中有一个finalize方法  如果重写也能看见对象回收的效果\n- GC系统提供的一个线程    回收算法\n\n","slug":"02_JavaSE面向对象","published":1,"updated":"2019-07-20T14:45:51.139Z","_id":"cjyblnrxt002gxwt3tl63xxkh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br>Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">类与对象</a></li>\n<li><a href=\"#id2\">构造方法和方法重载</a></li>\n<li><a href=\"#id3\">this关键字</a></li>\n<li><a href=\"#id4\">方法的传递和递归</a></li>\n<li><a href=\"#id5\">封装</a></li>\n<li><a href=\"#id6\">static关键字</a></li>\n<li><a href=\"#id7\">单例设计模式</a></li>\n<li><a href=\"#id8\">继承（extends）</a></li>\n<li><a href=\"#id9\">方法的重写（Override）</a></li>\n<li><a href=\"#id10\">访问控制</a></li>\n<li><a href=\"#id11\">包（Package）</a></li>\n<li><a href=\"#id12\">final关键字</a></li>\n<li><a href=\"#id13\">对象的创建过程</a></li>\n<li><a href=\"#id14\">多态</a></li>\n<li><a href=\"#id15\">抽象类</a></li>\n<li><a href=\"#id16\">接口</a></li>\n<li><a href=\"#id17\">内部类</a></li>\n<li><a href=\"#id18\">回调模式</a></li>\n<li><a href=\"#id19\">抽象方法的笔试考点</a></li>\n<li><a href=\"#id20\">枚举类（enum）</a></li>\n<li><a href=\"#id21\">内存机制问题</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-类与对象\"><a href=\"#1-类与对象\" class=\"headerlink\" title=\"1. 类与对象\"></a>1. 类与对象</h3><h4 id=\"1-1-类的定义\"><a href=\"#1-1-类的定义\" class=\"headerlink\" title=\"1.1 类的定义\"></a>1.1 类的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;类体&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类名由多个单词组成时，要求每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-2-成员变量的定义\"><a href=\"#1-2-成员变量的定义\" class=\"headerlink\" title=\"1.2 成员变量的定义\"></a>1.2 成员变量的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-3-对象的创建\"><a href=\"#1-3-对象的创建\" class=\"headerlink\" title=\"1.3 对象的创建\"></a>1.3 对象的创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。</p>\n</blockquote>\n<h4 id=\"1-4-引用\"><a href=\"#1-4-引用\" class=\"headerlink\" title=\"1.4 引用\"></a>1.4 引用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名 引用变量名;</span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用变量名.成员变量名;</span><br><span class=\"line\">p.name = <span class=\"string\">'zhangsan'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li>\n<li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li>\n</ul>\n</blockquote>\n<ul>\n<li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li>\n</ul>\n<h4 id=\"1-5-成员方法\"><a href=\"#1-5-成员方法\" class=\"headerlink\" title=\"1.5 成员方法\"></a>1.5 成员方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;</span><br><span class=\"line\">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li>\n<li>形参列表：数据类型 形参1, 数据类型 形参2, …</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-构造方法和方法重载\"><a href=\"#2-构造方法和方法重载\" class=\"headerlink\" title=\"2. 构造方法和方法重载\"></a>2. 构造方法和方法重载</h3><h4 id=\"2-1-构造方法\"><a href=\"#2-1-构造方法\" class=\"headerlink\" title=\"2.1 构造方法\"></a>2.1 构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造方法名与类名相同且没有返回值</li>\n<li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li>\n</ul>\n<h4 id=\"2-2-默认构造方法\"><a href=\"#2-2-默认构造方法\" class=\"headerlink\" title=\"2.2 默认构造方法\"></a>2.2 默认构造方法</h4><ul>\n<li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。</li>\n<li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li>\n</ul>\n<h4 id=\"2-3-方法重载（overload）\"><a href=\"#2-3-方法重载（overload）\" class=\"headerlink\" title=\"2.3 方法重载（overload）\"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p>\n<ul>\n<li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li>\n<li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-this关键字\"><a href=\"#3-this关键字\" class=\"headerlink\" title=\"3. this关键字\"></a>3. this关键字</h3><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p>\n<ul>\n<li>使用方式：<ol>\n<li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li>\n<li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-方法的传递和递归\"><a href=\"#4-方法的传递和递归\" class=\"headerlink\" title=\"4. 方法的传递和递归\"></a>4. 方法的传递和递归</h3><h4 id=\"4-1-传参\"><a href=\"#4-1-传参\" class=\"headerlink\" title=\"4.1 传参\"></a>4.1 传参</h4><ul>\n<li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li>\n<li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li>\n<li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li>\n</ul>\n<h4 id=\"4-2-递归的调用\"><a href=\"#4-2-递归的调用\" class=\"headerlink\" title=\"4.2 递归的调用\"></a>4.2 递归的调用</h4><ul>\n<li>递归是指方法体内部调用自身</li>\n<li>必须有递归的规律和退出条件</li>\n<li>使用递归必须使得问题简单化而不是复杂化</li>\n<li>若递归影响到程序的执行性能时，则用递推取代之</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-封装\"><a href=\"#5-封装\" class=\"headerlink\" title=\"5. 封装\"></a>5. 封装</h3><p>面向对象的三大特征：封装，继承，多态。</p>\n<ul>\n<li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li>\n<li>封装基本流程：<ol>\n<li>私有化成员变量(private)</li>\n<li>提供公有的get、set方法，并在set方法体中进行合理性判断</li>\n<li>在构方法中调用set方法进行合理值的判断</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-static关键字\"><a href=\"#6-static关键字\" class=\"headerlink\" title=\"6. static关键字\"></a>6. static关键字</h3><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p>\n<blockquote>\n<p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p>\n</blockquote>\n<ul>\n<li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li>\n<li>特点<ul>\n<li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li>\n<li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li>\n<li>静态元素只加载一次，全部类对象及类本身共享</li>\n<li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li>\n<li>非静态成员和静态成员都可以访问静态成员</li>\n<li>静态成员不可以访问非静态成员</li>\n<li>静态元素中不可出现this或super关键字，静态元素属于类的</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-单例设计模式\"><a href=\"#7-单例设计模式\" class=\"headerlink\" title=\"7. 单例设计模式\"></a>7. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 编程实现Singleton类的封装</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton sin = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//2.提供本类的引用指向本类的对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125; <span class=\"comment\">//1.私有化构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现流程：<ol>\n<li>私有化构造方法（private）</li>\n<li>提供本类类型的引用指向本类类型对象（private static）</li>\n<li>提供公有的get方法将上述对象return出去（public static）</li>\n<li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-继承（extends）\"><a href=\"#8-继承（extends）\" class=\"headerlink\" title=\"8. 继承（extends）\"></a>8. 继承（extends）</h3><ul>\n<li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li>\n<li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol>\n<li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li>\n<li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li>\n<li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li>\n<li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cricle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    Cricle()&#123;&#125;   <span class=\"comment\">//编译器会加入无参的调用 super()。</span></span><br><span class=\"line\">    Cricle(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(x, y);  <span class=\"comment\">//通过super关键字调用父类的构造方法。</span></span><br><span class=\"line\">        setR(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setR</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-方法的重写（Override）\"><a href=\"#9-方法的重写（Override）\" class=\"headerlink\" title=\"9. 方法的重写（Override）\"></a>9. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p>\n<ol>\n<li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li>\n<li>要求访问权限不能变小，可以相同或变大</li>\n<li>重写的方法不能抛出更大的异常</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-访问控制\"><a href=\"#10-访问控制\" class=\"headerlink\" title=\"10. 访问控制\"></a>10. 访问控制</h3><ul>\n<li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li>\n<li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>访问控制符</th>\n<th align=\"center\">访问权限</th>\n<th align=\"right\">本类内部</th>\n<th align=\"right\">本类中的包</th>\n<th align=\"right\">子类</th>\n<th align=\"right\">其他包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td align=\"center\">共有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n</tr>\n<tr>\n<td>protected</td>\n<td align=\"center\">保护的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>不写</td>\n<td align=\"center\">默认的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">私有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n</tbody></table>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-包（Package）\"><a href=\"#11-包（Package）\" class=\"headerlink\" title=\"11. 包（Package）\"></a>11. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> 包名；</span><br><span class=\"line\"><span class=\"keyword\">package</span> 包名<span class=\"number\">1</span>.包名<span class=\"number\">2</span>.包名<span class=\"number\">3</span>...包名n;</span><br><span class=\"line\"><span class=\"comment\">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class=\"line\">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-final关键字\"><a href=\"#12-final关键字\" class=\"headerlink\" title=\"12. final关键字\"></a>12. final关键字</h3><ol>\n<li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li>\n<li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li>\n<li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li>\n</ol>\n<blockquote>\n<p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用<strong><code>public static final</code></strong>共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p>\n</blockquote>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-对象的创建过程\"><a href=\"#13-对象的创建过程\" class=\"headerlink\" title=\"13. 对象的创建过程\"></a>13. 对象的创建过程</h3><ul>\n<li>单个对象的创建过程<ol>\n<li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li>\n<li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li>\n<li>执行构造块中的代码可以对成员变量进行赋值；</li>\n<li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li>\n<li>此时对象构造完毕，继续向下执行后续的代码；</li>\n</ol>\n</li>\n<li>子类对象的创建过程<ol>\n<li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li>\n<li>先执行父类静态代码块，再执行子类的静态代码块；</li>\n<li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li>\n<li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-多态\"><a href=\"#14-多态\" class=\"headerlink\" title=\"14. 多态\"></a>14. 多态</h3><ol>\n<li>语法：父类的引用指向子类的对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类类型 引用变量名 = <span class=\"keyword\">new</span> 子类类型();</span><br><span class=\"line\">Person pw = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">pw.show();<span class=\"comment\">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>多态的效果：<ol>\n<li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li>\n<li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li>\n<li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li>\n<li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li>\n</ol>\n</li>\n<li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li>\n<li>多态的表现形式<ol>\n<li>多态的前提要有继承的关系</li>\n<li>使用父类引用指向子类对象 Person p = new Teacher();//向上转型</li>\n<li>该引用只能调用父类中定义的属性/方法</li>\n<li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li>\n<li>若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li>\n</ol>\n</li>\n<li>引用数据类型之间的转换<ul>\n<li>转换必须发生在父子类之间，否则编译报错。</li>\n<li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li>\n<li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li>\n</ul>\n</li>\n<li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*语法格式：*/</span> 对象 <span class=\"keyword\">instanceof</span> 类型  <span class=\"comment\">//返回布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw <span class=\"keyword\">instanceof</span> Teacher)&#123;</span><br><span class=\"line\">    Teacher t = (Teacher) pw;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"转换会有异常\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>多态的使用场合：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过方法的参数传递形成多态。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Shape s)</span></span>&#123;&#125;</span><br><span class=\"line\">TestShape.draw(<span class=\"keyword\">new</span> Rect(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在方法体中直接使用多态的语法格式。</span></span><br><span class=\"line\">TestAbstrat ta = <span class=\"keyword\">new</span> SubTestAbstract();</span><br><span class=\"line\">ta.show();</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-抽象类\"><a href=\"#15-抽象类\" class=\"headerlink\" title=\"15. 抽象类\"></a>15. 抽象类</h3><ol>\n<li>基本概念<ul>\n<li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li>\n<li>抽象类不能实例化，抽象类的意义在于被继承。</li>\n<li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li>\n<li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span>&#123; <span class=\"comment\">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;<span class=\"comment\">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>注意：<ol>\n<li>抽象类中可以有成员变量，成员方法，以及构造方法。</li>\n<li>抽象类中可以没有抽象方法，也可以有抽象方法。</li>\n<li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li>\n<li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li>\n<li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>\n<li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p>\n</blockquote>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-接口\"><a href=\"#16-接口\" class=\"headerlink\" title=\"16. 接口\"></a>16. 接口</h3><ol>\n<li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runner</span> </span>&#123; <span class=\"comment\">//-通过interface关键字定义接口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SEF_SPEED=<span class=\"number\">100</span>;<span class=\"comment\">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;<span class=\"comment\">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">American</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runner</span>,... </span>&#123; <span class=\"comment\">//与继承不同，可以实现多个接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//该类需要实现接口中定义的所有方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"run...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runner ra = <span class=\"keyword\">new</span> American();<span class=\"comment\">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class=\"line\">        ra.run();<span class=\"comment\">//通过该变量可以调用该接口定义的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hunter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runner</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>类与接口的关系<ul>\n<li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li>\n<li>接口和接口使用<code>extends</code>继承，支持多继承。</li>\n<li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li>\n</ul>\n</li>\n<li>抽象类与接口的关系（笔试题）<ol>\n<li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li>\n<li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li>\n<li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li>\n<li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li>\n<li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li>\n<li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li>\n<li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id17\"><span></span></span></p>\n<h3 id=\"17-内部类\"><a href=\"#17-内部类\" class=\"headerlink\" title=\"17. 内部类\"></a>17. 内部类</h3><ul>\n<li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li>\n<li>内部类定义在 类的内部 ，与类成员层次一致</li>\n<li>内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul>\n<li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>匿名内部类：成员匿名内部类，局部匿名内部类</li>\n<li>静态内部类：成员静态内部类</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"17-1-成员内部类\"><a href=\"#17-1-成员内部类\" class=\"headerlink\" title=\"17.1 *成员内部类\"></a>17.1 *成员内部类</h4><ul>\n<li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li>\n<li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li>\n<li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li>\n<li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li>\n</ul>\n<h4 id=\"17-2-局部内部类\"><a href=\"#17-2-局部内部类\" class=\"headerlink\" title=\"17.2 局部内部类\"></a>17.2 局部内部类</h4><ul>\n<li>将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li>\n<li>只能用abstract或final</li>\n<li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li>\n<li>局部内部类使用的变量只能是final修饰</li>\n</ul>\n<h4 id=\"17-3-匿名内部类\"><a href=\"#17-3-匿名内部类\" class=\"headerlink\" title=\"17.3 *匿名内部类\"></a>17.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p>\n<ul>\n<li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol>\n<li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li>\n<li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubA</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这里自定义类实现接口并重写抽象方法！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ATest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(A a)</span> </span>&#123;</span><br><span class=\"line\">        a.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class=\"line\">        <span class=\"comment\">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class=\"line\">        ATest.test(<span class=\"keyword\">new</span> ASub());<span class=\"comment\">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//-方式2：匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class=\"line\">        A ta = <span class=\"keyword\">new</span> A() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"这里是匿名内部类\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ATest.test(ta);<span class=\"comment\">//得到接口类型的引用，再作为实参传递</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li>\n<li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SuperType obj = <span class=\"keyword\">new</span> SuperType(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-静态内部类\"><a href=\"#17-4-静态内部类\" class=\"headerlink\" title=\"17.4 静态内部类\"></a>17.4 静态内部类</h4><ul>\n<li>成员静态内部类</li>\n<li>不需要外部类对象，通过正常的方式直接创建内部类</li>\n<li>静态元素不能访问非静态成员(自己类和外部类)</li>\n</ul>\n<p><span id=\"id18\"><span></span></span></p>\n<h3 id=\"18-回调模式\"><a href=\"#18-回调模式\" class=\"headerlink\" title=\"18. 回调模式\"></a>18. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">repeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Action ac)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    repeat(<span class=\"number\">5</span>, <span class=\"keyword\">new</span> Action()&#123;<span class=\"comment\">//通过匿名内部类传递参数</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id19\"><span></span></span></p>\n<h3 id=\"19-抽象方法的笔试考点\"><a href=\"#19-抽象方法的笔试考点\" class=\"headerlink\" title=\"19. 抽象方法的笔试考点\"></a>19. 抽象方法的笔试考点</h3><ul>\n<li><code>abstract</code>与哪些关键字不能共存：<ol>\n<li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li>\n<li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li>\n<li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id20\"><span></span></span></p>\n<h3 id=\"20-枚举类（enum）\"><a href=\"#20-枚举类（enum）\" class=\"headerlink\" title=\"20. 枚举类（enum）\"></a>20. 枚举类（enum）</h3><ul>\n<li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li>\n<li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></li>\n<li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li>\n<li>Enum类型，有两个属性<ul>\n<li>name—–&gt;枚举对象的名字，name()获取name属性</li>\n<li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li>\n</ul>\n</li>\n<li>一些常用的方法<ul>\n<li>valueOf()   通过给定的name获取对应的枚举对象</li>\n<li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li>\n<li>compareTo()   可以比较两个枚举对象   int</li>\n<li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li>\n</ul>\n</li>\n<li>switch内部判断枚举的应用</li>\n<li>我们也可以在enum中描述自己的一些属性或方法<ul>\n<li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li>\n<li>可以定义自己的属性</li>\n<li>类创建的过程中  帮我们创建枚举类型的对象</li>\n<li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Day&#123;</span><br><span class=\"line\">    <span class=\"comment\">//描述了七个当前类的对象</span></span><br><span class=\"line\">    monday(<span class=\"string\">\"星期一\"</span>,<span class=\"number\">1</span>),tuesday(<span class=\"string\">\"星期二\"</span>,<span class=\"number\">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">(String  name,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index=index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id21\"><span></span></span></p>\n<h3 id=\"21-内存机制问题\"><a href=\"#21-内存机制问题\" class=\"headerlink\" title=\"21. 内存机制问题\"></a>21. 内存机制问题</h3><ul>\n<li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li>\n<li>栈内存—&gt;Person p = new Person();—-&gt;堆内存    方法区—类模板<ul>\n<li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li>\n<li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li>\n<li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li>\n</ul>\n</li>\n<li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul>\n<li>maxMemory</li>\n<li>totalMemory</li>\n<li>freeMemory</li>\n<li>栈内存溢出错误StackOverflowError </li>\n<li>堆内存溢出错误OutOfMemoryError</li>\n</ul>\n</li>\n<li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li>\n<li>GC系统提供的一个线程    回收算法</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br>Java中的面向对象（Object Oriented）是一种新兴的程序设计方法，或者是一种新的程序设计规范(paradigm)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p>","more":"<ol>\n<li><a href=\"#id1\">类与对象</a></li>\n<li><a href=\"#id2\">构造方法和方法重载</a></li>\n<li><a href=\"#id3\">this关键字</a></li>\n<li><a href=\"#id4\">方法的传递和递归</a></li>\n<li><a href=\"#id5\">封装</a></li>\n<li><a href=\"#id6\">static关键字</a></li>\n<li><a href=\"#id7\">单例设计模式</a></li>\n<li><a href=\"#id8\">继承（extends）</a></li>\n<li><a href=\"#id9\">方法的重写（Override）</a></li>\n<li><a href=\"#id10\">访问控制</a></li>\n<li><a href=\"#id11\">包（Package）</a></li>\n<li><a href=\"#id12\">final关键字</a></li>\n<li><a href=\"#id13\">对象的创建过程</a></li>\n<li><a href=\"#id14\">多态</a></li>\n<li><a href=\"#id15\">抽象类</a></li>\n<li><a href=\"#id16\">接口</a></li>\n<li><a href=\"#id17\">内部类</a></li>\n<li><a href=\"#id18\">回调模式</a></li>\n<li><a href=\"#id19\">抽象方法的笔试考点</a></li>\n<li><a href=\"#id20\">枚举类（enum）</a></li>\n<li><a href=\"#id21\">内存机制问题</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-类与对象\"><a href=\"#1-类与对象\" class=\"headerlink\" title=\"1. 类与对象\"></a>1. 类与对象</h3><h4 id=\"1-1-类的定义\"><a href=\"#1-1-类的定义\" class=\"headerlink\" title=\"1.1 类的定义\"></a>1.1 类的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;类体&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类名由多个单词组成时，要求每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-2-成员变量的定义\"><a href=\"#1-2-成员变量的定义\" class=\"headerlink\" title=\"1.2 成员变量的定义\"></a>1.2 成员变量的定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p>\n</blockquote>\n<h4 id=\"1-3-对象的创建\"><a href=\"#1-3-对象的创建\" class=\"headerlink\" title=\"1.3 对象的创建\"></a>1.3 对象的创建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> 类名();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当一个类定义完毕后使用new关键字创建/构造该类的对象的过程叫做类的实例化。</p>\n</blockquote>\n<h4 id=\"1-4-引用\"><a href=\"#1-4-引用\" class=\"headerlink\" title=\"1.4 引用\"></a>1.4 引用</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名 引用变量名;</span><br><span class=\"line\">Person p = <span class=\"keyword\">new</span> Person(); <span class=\"comment\">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用变量名.成员变量名;</span><br><span class=\"line\">p.name = <span class=\"string\">'zhangsan'</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li>\n<li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li>\n</ul>\n</blockquote>\n<ul>\n<li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li>\n</ul>\n<h4 id=\"1-5-成员方法\"><a href=\"#1-5-成员方法\" class=\"headerlink\" title=\"1.5 成员方法\"></a>1.5 成员方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123;</span><br><span class=\"line\">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li>\n<li>形参列表：数据类型 形参1, 数据类型 形参2, …</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-构造方法和方法重载\"><a href=\"#2-构造方法和方法重载\" class=\"headerlink\" title=\"2. 构造方法和方法重载\"></a>2. 构造方法和方法重载</h3><h4 id=\"2-1-构造方法\"><a href=\"#2-1-构造方法\" class=\"headerlink\" title=\"2.1 构造方法\"></a>2.1 构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 类名 </span>&#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造方法名与类名相同且没有返回值</li>\n<li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li>\n</ul>\n<h4 id=\"2-2-默认构造方法\"><a href=\"#2-2-默认构造方法\" class=\"headerlink\" title=\"2.2 默认构造方法\"></a>2.2 默认构造方法</h4><ul>\n<li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认/缺省构造方法。</li>\n<li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li>\n</ul>\n<h4 id=\"2-3-方法重载（overload）\"><a href=\"#2-3-方法重载（overload）\" class=\"headerlink\" title=\"2.3 方法重载（overload）\"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p>\n<ul>\n<li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li>\n<li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li>\n</ul>\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-this关键字\"><a href=\"#3-this关键字\" class=\"headerlink\" title=\"3. this关键字\"></a>3. this关键字</h3><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p>\n<ul>\n<li>使用方式：<ol>\n<li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li>\n<li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-方法的传递和递归\"><a href=\"#4-方法的传递和递归\" class=\"headerlink\" title=\"4. 方法的传递和递归\"></a>4. 方法的传递和递归</h3><h4 id=\"4-1-传参\"><a href=\"#4-1-传参\" class=\"headerlink\" title=\"4.1 传参\"></a>4.1 传参</h4><ul>\n<li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li>\n<li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li>\n<li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li>\n</ul>\n<h4 id=\"4-2-递归的调用\"><a href=\"#4-2-递归的调用\" class=\"headerlink\" title=\"4.2 递归的调用\"></a>4.2 递归的调用</h4><ul>\n<li>递归是指方法体内部调用自身</li>\n<li>必须有递归的规律和退出条件</li>\n<li>使用递归必须使得问题简单化而不是复杂化</li>\n<li>若递归影响到程序的执行性能时，则用递推取代之</li>\n</ul>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-封装\"><a href=\"#5-封装\" class=\"headerlink\" title=\"5. 封装\"></a>5. 封装</h3><p>面向对象的三大特征：封装，继承，多态。</p>\n<ul>\n<li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li>\n<li>封装基本流程：<ol>\n<li>私有化成员变量(private)</li>\n<li>提供公有的get、set方法，并在set方法体中进行合理性判断</li>\n<li>在构方法中调用set方法进行合理值的判断</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-static关键字\"><a href=\"#6-static关键字\" class=\"headerlink\" title=\"6. static关键字\"></a>6. static关键字</h3><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p>\n<blockquote>\n<p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p>\n</blockquote>\n<ul>\n<li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li>\n<li>特点<ul>\n<li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li>\n<li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li>\n<li>静态元素只加载一次，全部类对象及类本身共享</li>\n<li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li>\n<li>非静态成员和静态成员都可以访问静态成员</li>\n<li>静态成员不可以访问非静态成员</li>\n<li>静态元素中不可出现this或super关键字，静态元素属于类的</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-单例设计模式\"><a href=\"#7-单例设计模式\" class=\"headerlink\" title=\"7. 单例设计模式\"></a>7. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 编程实现Singleton类的封装</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton sin = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//2.提供本类的引用指向本类的对象</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125; <span class=\"comment\">//1.私有化构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实现流程：<ol>\n<li>私有化构造方法（private）</li>\n<li>提供本类类型的引用指向本类类型对象（private static）</li>\n<li>提供公有的get方法将上述对象return出去（public static）</li>\n<li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-继承（extends）\"><a href=\"#8-继承（extends）\" class=\"headerlink\" title=\"8. 继承（extends）\"></a>8. 继承（extends）</h3><ul>\n<li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li>\n<li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol>\n<li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li>\n<li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li>\n<li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li>\n<li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cricle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    Cricle()&#123;&#125;   <span class=\"comment\">//编译器会加入无参的调用 super()。</span></span><br><span class=\"line\">    Cricle(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(x, y);  <span class=\"comment\">//通过super关键字调用父类的构造方法。</span></span><br><span class=\"line\">        setR(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setR</span><span class=\"params\">(<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.r = r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-方法的重写（Override）\"><a href=\"#9-方法的重写（Override）\" class=\"headerlink\" title=\"9. 方法的重写（Override）\"></a>9. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p>\n<ol>\n<li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li>\n<li>要求访问权限不能变小，可以相同或变大</li>\n<li>重写的方法不能抛出更大的异常</li>\n</ol>\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-访问控制\"><a href=\"#10-访问控制\" class=\"headerlink\" title=\"10. 访问控制\"></a>10. 访问控制</h3><ul>\n<li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li>\n<li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>访问控制符</th>\n<th align=\"center\">访问权限</th>\n<th align=\"right\">本类内部</th>\n<th align=\"right\">本类中的包</th>\n<th align=\"right\">子类</th>\n<th align=\"right\">其他包</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td align=\"center\">共有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n</tr>\n<tr>\n<td>protected</td>\n<td align=\"center\">保护的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>不写</td>\n<td align=\"center\">默认的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n<tr>\n<td>private</td>\n<td align=\"center\">私有的</td>\n<td align=\"right\">Y</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n<td align=\"right\">N</td>\n</tr>\n</tbody></table>\n<p><span id=\"id11\"><span></span></span></p>\n<h3 id=\"11-包（Package）\"><a href=\"#11-包（Package）\" class=\"headerlink\" title=\"11. 包（Package）\"></a>11. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> 包名；</span><br><span class=\"line\"><span class=\"keyword\">package</span> 包名<span class=\"number\">1</span>.包名<span class=\"number\">2</span>.包名<span class=\"number\">3</span>...包名n;</span><br><span class=\"line\"><span class=\"comment\">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class=\"line\">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id12\"><span></span></span></p>\n<h3 id=\"12-final关键字\"><a href=\"#12-final关键字\" class=\"headerlink\" title=\"12. final关键字\"></a>12. final关键字</h3><ol>\n<li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li>\n<li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li>\n<li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li>\n</ol>\n<blockquote>\n<p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用<strong><code>public static final</code></strong>共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p>\n</blockquote>\n<p><span id=\"id13\"><span></span></span></p>\n<h3 id=\"13-对象的创建过程\"><a href=\"#13-对象的创建过程\" class=\"headerlink\" title=\"13. 对象的创建过程\"></a>13. 对象的创建过程</h3><ul>\n<li>单个对象的创建过程<ol>\n<li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li>\n<li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li>\n<li>执行构造块中的代码可以对成员变量进行赋值；</li>\n<li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li>\n<li>此时对象构造完毕，继续向下执行后续的代码；</li>\n</ol>\n</li>\n<li>子类对象的创建过程<ol>\n<li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li>\n<li>先执行父类静态代码块，再执行子类的静态代码块；</li>\n<li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li>\n<li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id14\"><span></span></span></p>\n<h3 id=\"14-多态\"><a href=\"#14-多态\" class=\"headerlink\" title=\"14. 多态\"></a>14. 多态</h3><ol>\n<li>语法：父类的引用指向子类的对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">父类类型 引用变量名 = <span class=\"keyword\">new</span> 子类类型();</span><br><span class=\"line\">Person pw = <span class=\"keyword\">new</span> Worker();</span><br><span class=\"line\">pw.show();<span class=\"comment\">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>多态的效果：<ol>\n<li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li>\n<li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li>\n<li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li>\n<li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li>\n</ol>\n</li>\n<li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li>\n<li>多态的表现形式<ol>\n<li>多态的前提要有继承的关系</li>\n<li>使用父类引用指向子类对象 Person p = new Teacher();//向上转型</li>\n<li>该引用只能调用父类中定义的属性/方法</li>\n<li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li>\n<li>若想要调用子类独有的成员，将身份还原回去(向下转型/造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li>\n</ol>\n</li>\n<li>引用数据类型之间的转换<ul>\n<li>转换必须发生在父子类之间，否则编译报错。</li>\n<li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li>\n<li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li>\n</ul>\n</li>\n<li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*语法格式：*/</span> 对象 <span class=\"keyword\">instanceof</span> 类型  <span class=\"comment\">//返回布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(pw <span class=\"keyword\">instanceof</span> Teacher)&#123;</span><br><span class=\"line\">    Teacher t = (Teacher) pw;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"转换会有异常\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>多态的使用场合：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过方法的参数传递形成多态。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">(Shape s)</span></span>&#123;&#125;</span><br><span class=\"line\">TestShape.draw(<span class=\"keyword\">new</span> Rect(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在方法体中直接使用多态的语法格式。</span></span><br><span class=\"line\">TestAbstrat ta = <span class=\"keyword\">new</span> SubTestAbstract();</span><br><span class=\"line\">ta.show();</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id15\"><span></span></span></p>\n<h3 id=\"15-抽象类\"><a href=\"#15-抽象类\" class=\"headerlink\" title=\"15. 抽象类\"></a>15. 抽象类</h3><ol>\n<li>基本概念<ul>\n<li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li>\n<li>抽象类不能实例化，抽象类的意义在于被继承。</li>\n<li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li>\n<li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span>&#123; <span class=\"comment\">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span>;<span class=\"comment\">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>注意：<ol>\n<li>抽象类中可以有成员变量，成员方法，以及构造方法。</li>\n<li>抽象类中可以没有抽象方法，也可以有抽象方法。</li>\n<li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li>\n<li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li>\n<li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li>\n<li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p>\n</blockquote>\n<p><span id=\"id16\"><span></span></span></p>\n<h3 id=\"16-接口\"><a href=\"#16-接口\" class=\"headerlink\" title=\"16. 接口\"></a>16. 接口</h3><ol>\n<li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runner</span> </span>&#123; <span class=\"comment\">//-通过interface关键字定义接口</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SEF_SPEED=<span class=\"number\">100</span>;<span class=\"comment\">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;<span class=\"comment\">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">American</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runner</span>,... </span>&#123; <span class=\"comment\">//与继承不同，可以实现多个接口</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//该类需要实现接口中定义的所有方法</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"run...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Runner ra = <span class=\"keyword\">new</span> American();<span class=\"comment\">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class=\"line\">        ra.run();<span class=\"comment\">//通过该变量可以调用该接口定义的方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hunter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Runner</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>类与接口的关系<ul>\n<li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li>\n<li>接口和接口使用<code>extends</code>继承，支持多继承。</li>\n<li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li>\n</ul>\n</li>\n<li>抽象类与接口的关系（笔试题）<ol>\n<li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li>\n<li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li>\n<li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li>\n<li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li>\n<li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li>\n<li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li>\n<li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li>\n</ol>\n</li>\n</ol>\n<p><span id=\"id17\"><span></span></span></p>\n<h3 id=\"17-内部类\"><a href=\"#17-内部类\" class=\"headerlink\" title=\"17. 内部类\"></a>17. 内部类</h3><ul>\n<li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li>\n<li>内部类定义在 类的内部 ，与类成员层次一致</li>\n<li>内部类定义在 方法/块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul>\n<li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>局部内部类：将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>匿名内部类：成员匿名内部类，局部匿名内部类</li>\n<li>静态内部类：成员静态内部类</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"17-1-成员内部类\"><a href=\"#17-1-成员内部类\" class=\"headerlink\" title=\"17.1 *成员内部类\"></a>17.1 *成员内部类</h4><ul>\n<li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li>\n<li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li>\n<li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li>\n<li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li>\n<li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li>\n</ul>\n<h4 id=\"17-2-局部内部类\"><a href=\"#17-2-局部内部类\" class=\"headerlink\" title=\"17.2 局部内部类\"></a>17.2 局部内部类</h4><ul>\n<li>将一个类定义在方法/块里面，作为成员的内部结构，与临时的局部变量一个层次</li>\n<li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li>\n<li>只能用abstract或final</li>\n<li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li>\n<li>局部内部类使用的变量只能是final修饰</li>\n</ul>\n<h4 id=\"17-3-匿名内部类\"><a href=\"#17-3-匿名内部类\" class=\"headerlink\" title=\"17.3 *匿名内部类\"></a>17.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p>\n<ul>\n<li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol>\n<li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li>\n<li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubA</span> <span class=\"keyword\">implements</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"这里自定义类实现接口并重写抽象方法！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ATest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(A a)</span> </span>&#123;</span><br><span class=\"line\">        a.show();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class=\"line\">        <span class=\"comment\">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class=\"line\">        ATest.test(<span class=\"keyword\">new</span> ASub());<span class=\"comment\">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//-方式2：匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class=\"line\">        A ta = <span class=\"keyword\">new</span> A() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"这里是匿名内部类\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        ATest.test(ta);<span class=\"comment\">//得到接口类型的引用，再作为实参传递</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li>\n<li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() {匿名类类体，这里重写方法};</code>。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SuperType obj = <span class=\"keyword\">new</span> SuperType(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-静态内部类\"><a href=\"#17-4-静态内部类\" class=\"headerlink\" title=\"17.4 静态内部类\"></a>17.4 静态内部类</h4><ul>\n<li>成员静态内部类</li>\n<li>不需要外部类对象，通过正常的方式直接创建内部类</li>\n<li>静态元素不能访问非静态成员(自己类和外部类)</li>\n</ul>\n<p><span id=\"id18\"><span></span></span></p>\n<h3 id=\"18-回调模式\"><a href=\"#18-回调模式\" class=\"headerlink\" title=\"18. 回调模式\"></a>18. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">repeat</span><span class=\"params\">(<span class=\"keyword\">int</span> n, Action ac)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    repeat(<span class=\"number\">5</span>, <span class=\"keyword\">new</span> Action()&#123;<span class=\"comment\">//通过匿名内部类传递参数</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doSth</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Hello\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id19\"><span></span></span></p>\n<h3 id=\"19-抽象方法的笔试考点\"><a href=\"#19-抽象方法的笔试考点\" class=\"headerlink\" title=\"19. 抽象方法的笔试考点\"></a>19. 抽象方法的笔试考点</h3><ul>\n<li><code>abstract</code>与哪些关键字不能共存：<ol>\n<li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li>\n<li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li>\n<li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id20\"><span></span></span></p>\n<h3 id=\"20-枚举类（enum）\"><a href=\"#20-枚举类（enum）\" class=\"headerlink\" title=\"20. 枚举类（enum）\"></a>20. 枚举类（enum）</h3><ul>\n<li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li>\n<li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<e>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</e></li>\n<li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li>\n<li>Enum类型，有两个属性<ul>\n<li>name—–&gt;枚举对象的名字，name()获取name属性</li>\n<li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li>\n</ul>\n</li>\n<li>一些常用的方法<ul>\n<li>valueOf()   通过给定的name获取对应的枚举对象</li>\n<li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li>\n<li>compareTo()   可以比较两个枚举对象   int</li>\n<li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li>\n</ul>\n</li>\n<li>switch内部判断枚举的应用</li>\n<li>我们也可以在enum中描述自己的一些属性或方法<ul>\n<li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li>\n<li>可以定义自己的属性</li>\n<li>类创建的过程中  帮我们创建枚举类型的对象</li>\n<li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Day&#123;</span><br><span class=\"line\">    <span class=\"comment\">//描述了七个当前类的对象</span></span><br><span class=\"line\">    monday(<span class=\"string\">\"星期一\"</span>,<span class=\"number\">1</span>),tuesday(<span class=\"string\">\"星期二\"</span>,<span class=\"number\">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Day</span><span class=\"params\">(String  name,<span class=\"keyword\">int</span> index)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.index=index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name=name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id21\"><span></span></span></p>\n<h3 id=\"21-内存机制问题\"><a href=\"#21-内存机制问题\" class=\"headerlink\" title=\"21. 内存机制问题\"></a>21. 内存机制问题</h3><ul>\n<li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li>\n<li>栈内存—&gt;Person p = new Person();—-&gt;堆内存    方法区—类模板<ul>\n<li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li>\n<li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li>\n<li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li>\n</ul>\n</li>\n<li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul>\n<li>maxMemory</li>\n<li>totalMemory</li>\n<li>freeMemory</li>\n<li>栈内存溢出错误StackOverflowError </li>\n<li>堆内存溢出错误OutOfMemoryError</li>\n</ul>\n</li>\n<li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li>\n<li>GC系统提供的一个线程    回收算法</li>\n</ul>"},{"title":"三、JavaSE核心工具类","date":"2019-07-08T08:42:47.000Z","_content":"\n\nAPI (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。\n<!-- more -->\n\n1. [Object类与其常用方法](#id1)\n2. [包装类](#id2)\n3. [数学处理类](#id3)\n4. [Scanner类和System类](#id4)\n5. [日期类](#id5)\n6. [String类](#id6)\n7. [StringBuilder类/StringBuffer类](#id7)\n8. [Optional类](#id8)\n\n\n### 常用的包\n- java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类...\n- java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类...\n- java.io包：是输入输出包，包括读写各种设备。\n- java.net包：是网络编程的包，包括各种网络编程。\n- java.sql包：是操作数据库的所有类和接口。\n\n<span id=\"id1\"><span>\n### 1. Object类与其常用方法\n#### 1.1 Object类\n- java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。\n- Object定义了“对象”的基本行为，被子类默认继承。\n\n#### 1.2 equals() 和 hashCode()\n- boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。\n- equals()方法要求：自反性/对称性/传递性/一致性/非空性。\n- Java类可以根据需要重写继承自Object的equals()方法。\n\n> 注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n\n- int hashCode():返回对象的哈希码值，对应一个内存。\n- hashCode规范要求：\n    * 一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的\n    * 如果两个对象判定相等，它们的hashCode应该时同一个值\n    * 如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。\n\n- hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。\n\n#### 1.3 toString()\n- String toString()：用于获取调用对象的字符串形式，返回\"包名.类名@hashCode值的16进制\"。\n- Java类可以根据需要重写toString方法返回更有意义的信息。\n- Java在使用System.out.println()打印对象时或者`+`连接字符串时，默认调用toString()方法。\n\n<span id=\"id2\"><span>\n### 2. 包装类\n#### 2.1 包装类\n- 由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。\n- Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。\n\n|基本类型 |对应包装类         |\n|--------|------------------|\n|byte    |java.lang.Byte    |\n|short   |java.lang.Short   |\n|int     |java.lang.Integer |\n|long    |java.lang.Long    |\n|float   |java.lang.Float   |\n|double  |java.lang.Double  |\n|boolean |java.lang.Boolean |\n|char    |java.lang.Character|\n\n1. 八个包装类都在同一个包下（java.lang包），不需要import导包直接使用\n2. 八个包装类中有六个是与数字相关，都默认继承父类Number\n3. 八个包装类都实现了Serializable, Comparable\n4. 八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型\n5. 八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型\n\n#### 2.2 Integer类\n- java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。\n- Integer类重写了**equals()**方法（重写后比较的是数值）、hashCode()以及toString()方法。\n\n|Integer类的常用方法|                  |\n|-----------------|------------------|\n|Integer(int i)               |根据参数指定整数来构造对象|\n|Integer(String s)            |根据参数指定的字符串来构造对象|\n|int intValue()               |获取调用对象中整数值并返回|\n|static Integer valueOf(int i)|根据参数指定整数值得到Integer类型对象|\n|static int parseInt(String s)|将字符串类型转换为int类型并返回|\n\n#### 2.3 装箱和拆箱\n\n``` java\nint i = 100;\nInteger it = Integer.valueOf(i); //实现了int类型到Integer类型的转换，这个过程叫做装箱\nint ia = it.intValue();//实现了Integer类型到int类型的转换，这个过程叫做拆箱\n//jdk5增加了自动拆箱和装箱功能（编译器预处理）:\nInteger i = 100;//自动装箱\nint ia = i;//自动拆箱\n```\n\n- 笔试考点：\n> * 在Integer类部提供了自动装箱池技术，将**-128~127间的整数已经装箱完毕**，当使用该范围整数时直接取池中的对象即可，从而提高效率。\n> * Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。\n\n``` java\nInteger it1 = 128;\nInteger it2 = 128;\nInteger it3 = new Integer(128);\nInteger it4 = new Integer(128);\nSystem.out.println(it1.equals(it2));//比较内容 true\nSystem.out.println(it1 == it2);//比较地址 false\nSystem.out.println(it3.equals(it4));//比较内容 true\nSystem.out.println(it3 == it4);//比较地址 false\n\nInteger it5 = 127;\nInteger it6 = 127;\nInteger it7 = new Integer(127);\nInteger it8 = new Integer(127);\nSystem.out.println(it5.equals(it6));//比较内容 true\nSystem.out.println(it5 == it6);//比较地址 true, 自动装箱池范围-128~127。\nSystem.out.println(it7.equals(it8));//比较内容 true\nSystem.out.println(it7 == it8);//比较地址 false\n```\n\n<span id=\"id3\"><span>\n### 3. 数学处理类\n- java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。\n\n| 常用的方法             |返回值类型|  |\n|-----------------------|---------|---|\n|Math.abs()             |      |返回给定数字的绝对值(参数 int long float double)|\n|Math.ceil()            |double| 向上取整|\n|Math.floor()           |double| 向下取整|\n|Math.rint()            |double| 临近的整数 如果两边距离一样 则返回偶数|\n|Math.round()           |int   | 四舍五入的整数|\n|Math.max(a,b)/min(a,b) |      | (参数int  long  float  double)|\n|Math.pow(a,b)          |double| a的b次方  (参数double 返回值double)|\n|Math.sqrt(double a)    |      |获取给定参数的平方根|\n|Math.random()          |double|随机产生一个[0.0--1.0)|\n\n- 0-9之间的随机整数：int value = (int)**(Math.random()*10**);\n- Math.random()计算小数的时候精确程度可能有些损失\n\n#### 3.1 Random类\n- java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n\n| 常用的方法                |Random r = new Random();  |\n|--------------------------|--------|\n| r.nextInt();             |随机产生 int取值范围的整数 有正有负(`-2^31`\\~`2^31-1`即`正负21亿`之间)|\n| r.nextInt(int bound);    |随机产生一个[0--bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException|\n| r.nextFloat()            |随机产生一个 [0.0---1.0)|\n| r.nextBoolean()          |随机产生一个boolean值   true  false|\n\n#### 3.2 UUID类\n- java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n- 只有有参构造方法，我们通常不会创建对象\n- UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key\n- 产生一个32位的随机元素 每一个位置是一个16进制的数字\n\n#### 3.3 BigDecimal\n- java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number\n- Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。\n- 提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(\"1.23\");\n\n|BigDecimal类的常用方法|                  |\n|-----------------|------------------|\n|BigDecimal(String val)                       | 根据参数指定的字符串来构造对象|\n|BigDecimal    setScale(int newScale, RoundingMode roundingMode)|两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)|\n|BigDecimal **add**(BigDecimal augend)            | 用于实现**加法**运算 |\n|BigDecimal **subtract**(BigDecimal subtrahend)   | 用于实现**减法**运算 |\n|BigDecimal **multiply**(BigDecimal multiplicand) | 用于实现**乘法**运算 |\n|BigDecimal **divide**(BigDecimal divisor)        | 用于实现**除法**运算，也可传入更多参数设置保留小数点位数和取值模式 |\n\n``` java\nBigDecimal d3 = new BigDecimal(\"3.0\");\nBigDecimal d4 = new BigDecimal(\"2.9\");\nSystem.out.println(d3.add(d4));//加：5.9\nSystem.out.println(d3.subtract(d4));//减：0.1\nSystem.out.println(d3.multiply(d4));//乘：8.70\nSystem.out.println(d3.divide(d4, 8, BigDecimal.ROUND_HALF_UP));//除：1.03448276\n```\n\n对于divide方法，通常需要制定**精度和舍入模式**，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。\n\n#### 3.4 BigInteger\n- java.math.BigInteger类处理大整数，需要import导入，继承自Number\n- java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 \n- 如何创建对象，提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(\"123\");\n- 和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。\n\n#### 3.5 DecimalFormat类\n- 所属的包 java.text，import导入才能使用\n- 通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）\n\n``` java\n    //调用format方法将一个小数格式化成一个字符串\nDecimalFormat df = new DecimalFormat(\"000.000\");\nSystem.out.println(df.format(12.45)); //012.450\nSystem.out.println(df.format(12345.6789)); //12345.679\n\nDecimalFormat df2 = new DecimalFormat(\"###.###\");\nSystem.out.println(df2.format(12.45)); //12.45\nSystem.out.println(df2.format(12345.6789)); //12345.679\n\nDecimalFormat df3 = new DecimalFormat(\"000.###\");\nSystem.out.println(df3.format(12.45)); //012.45\nSystem.out.println(df3.format(12345.6789)); //12345.679    \n```\n\n\n<span id=\"id4\"><span>\n### 4. Scanner类和System类\n#### 4.1 Scanner类\n1. 所属的包java.util包  需要import导包\n2. 通过一个带输入流的构造方法创建对象\n3. 常用方法    nextInt()  nextFloat()   next()   nextLine()\n\n#### 4.1 System类\n1. 所属的包java.lang包 不需要导入\n2. 不需要创建对象  通过类名就可以访问\n3. 有三个属性及若干的方法\n    * 三个属性out   in   err\n    * 方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;\n\n\n<span id=\"id5\"><span>\n### 5. 日期类\n#### 5.1 Date类\n- java.util.Date类表示特定的瞬间，精确到毫秒。\n- 通常使用无参数的构造方法，或者带long构造方法\n- Date类中常用的方法\n    * before();  after();\n    * setTime()  getTime();----->long\n    * compareTo();   //-1  1  0\n- Date类大多数用于进行时间分量计算的方法已经被Calender取代。\n\n``` java\nDate date = new Date();//当前日期信息\n    //Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019\nlong time = date.getTime();//1970年1月1日距今毫秒数。\ndate.setTime(time + 24\\*60\\*60\\*1000);//通过毫秒数设置时间\n```\n\n#### 5.2 SimpleDateFormat类\n- java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类\n- 其构造方法 SimpleDateFormat(String pattern)\n\n``` java\nDate date = new Date();\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");\nString dateStr = sdf.format(date);\n// format用于将日期按指定格式转换为字符串\n\nString str = \"2013-01-06\";\nSimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date2 = sdf2.parse(str);//如果字符串格式不匹配将抛出异常\n```\n\n|常用格式字符串| 含义        |  示例  |\n|----------|------------|---------|\n|y|年      |yyyy年——2013年；yy——13年 |\n|M|月      |MM月——01月；M月——1月|\n|d|日      |dd日——01日；d日——1日|\n|H|小时(24)|HH:mm:ss—12:46:33|\n|h|小时(12)|hh(a):mm:ss—12(下午):47:48|\n|m|分钟    |--|\n|s|秒      |--|\n\n#### 5.3 Calendar类\n- java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。\n- 有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();\n- 通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现\n\n``` java\nCalendar c1 = Calendar.getInstance();\nc1.set(2008,9-1,20,8,8,8);\nSystem.out.println(c1.getTime());\n```\n\n- 常用方法\n    * after()  before()\n    * setTime()  getTime()---->Date\n    * getTimeInMillis()----time\n    * getTimeZone()---TimeZone\n    * Calendar里面包含一个date属性  可以操作date的某一个局部信息\n    * set   get\n        * calendar.set(Calendar.YEAR,2015);\n        *int year = calendar.get(Calendar.YEAR);\n\n- TimeZone\n    1. java.util包\n    2. 可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();\n    3. 常用方法\n        - tz.getID()       ---->    Asia/Shanghai\n        - tz.getDisplayName()    ---->  中国标准时间\n\n\n<span id=\"id6\"><span>\n### 6. String类\n#### 6.1 基本概念\n- String类 ---> 引用类型  ---> java.lang包\n- 没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<String>\n- java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如\"abc\"等，任何一个字符对应2字节定长编码。\n- String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。\n\n``` java\n//如何构建对象\nString str1 = \"abc\"; //直接将字符串常量赋值给str   (字符串常量池)\nString str2 = new String();//无参数构造方法创建空的对象\nString str3 = new String(\"abc\");//带string参数的构造方法创建对象\nbyte[] bArr = {97, 98, 99, 100, 101};//a:97，b:98，c:99，d:100\nString str4 = new String(bArr);//将数组中的每一个元素转化成对应的char 组合成String\nchar[] cArr = {'h', 'e', 'l', 'l', 'o'};\nString str5 = new String(cArr);//将数组中的每一个char元素拼接成最终的String\nString str6 = String(char[], index, count);//使用char数组中下标从index位置开始的count个字符来构造对象\nString str7 = String(byte[], index, length);//使用byte数组下标从index位置开始length个字节来构造对象\n```\n\n\n#### 6.2 字符串常量池\n- 由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。\n- 出于性能考虑，Java虚拟机(JVM)将**字符串字面量对象**缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。\n\n``` java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\nString str3 = new String(\"Hello\");\nSystem.out.println(str1.equals(str2));//比较内容 true\nSystem.out.println(str1==str2);//比较地址 true，不会重新创建\nSystem.out.println(str1.equals(str3));//比较内容 true\nSystem.out.println(str1==str3);//比较地址 false，使用new会重新创建新的String对象\n    //1.下面的代码中创建了几个对象并分别存放在什么位置？\nString s1 = \"hello\"; //1个对象，常量池。\nString s2 = new String(\"world\"); //2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)\n```\n\n#### 6.3 String类常用方法\n1. 第一梯队(重写): equals  hashCode  compareTo  toString\n2. 第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。\n3. 第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。\n\n- 重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口\n    1. boolean = equals(Object obj);\n        - 继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;\n    2. int = hashCode();\n        - 继承自Object类中的方法，重写了：31*h+和...\n    3. int = compareTo();\n        - 实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差\n    4. String = toString()\n        - Object类中返回类名@hashCode(16进制形式)\n        - String类重写后返回的是String对象的字面值\n\n>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();\n\n|String类的成员方法         |                  |\n|--------------------------|------------------|\n|char charAt(int index)    |返回字符串指定位置|\n|int codePointAt(int index)|\"abc\"0-->97，返回给定index对应位置的那个char所对应的code码|\n|String concat(String)     |将给定的字符串拼接在当前字符串之后|\n|int length()              |返回字符串序列的长度|\n> 注意：区别数组的length是属性，String的length()是方法，集合是size()方法\n\n``` java\nString str6 = new String(\"hello\");\nSystem.out.println(\"下标为0的字符是：\"+str6.charAt(0));// h\nSystem.out.println(\"字符串长度是：\"+str6.length());// 5\n\n    //将字符串\"12345\"转换为整数类型\nString str = new String(\"123456\");\n    //方式一：Integer类中的pareseInt方法\nint ia = Integer.parseInt(str);\nSystem.out.println(\"转换出来结果是：\"+ ia);//123456\n    //方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...\nint res = 0;\nfor(int i=0; i<str.length(); i++){\n    res = res*10 + (str.charAt(i)-'0');\n}\nSystem.out.println(\"转换出来结果是：\"+ res);//123456\n```\n\n|String类的常用基本方法|               |\n|-----------------|------------------|\n|boolean contains(CharSequence s)|判断当前字符串是否包含参数指定的内容|\n|String toLowerCase()|返回小写形式|\n|String toUpperCase()|返回大写形式|\n|String trim()|返回去掉前后空格的字符串|\n|boolean startsWith(String prefix)|判断是否以参数字符开头|\n|boolean endsWith(String suffix)|判断是否以参数字符结尾|\n|boolean equals(Object anObject)|比较字符串内容是否相等，String类已重写|\n|boolean equalsIgnoreCase(String anotherString)|同上，并且忽略大小写|\n|int indexOf(String str)|返回第一次出现str位置，找不到返回-1|\n|int indexOf(String str, int fromIndex)|同上，从fromIndex开始检索|\n|String substring(int beginIndex, int endIndex)|截取字符串，beginIndex开始，endIndex结束|\n|String substring(int beginIndex)|截取字符串，beginIndex开始到结尾|\n\n#### 6.4 正则相关方法\n- 正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。\n\n|正则相关方法|                  |\n|-----------------|------------------|\n|boolean matches(String regex)|用于判断是否匹配正则表达式规则。|\n|String[] split(String regx)|以正则为分割符，将字符串拆分成字符串数组|\n|String replaceAll(String regex, String replacement)|正则替换|\n\n\n<span id=\"id7\"><span>\n### 7. StringBuilder类/StringBuffer类\n#### 7.1 基本概念\n1. java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。\n2. StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable\n    - StringBuffer/StringBuilder没有compareTo方法\n    - StringBuffer/StringBuilder含有一个String没有的方法 append();拼接\n\n#### 7.2 特性\n可变字符串，char[] value;  动态扩容\n#### 7.3 对象的构建\n\n``` java\n    //无参数构造方法  构建一个默认长度16个空间的对象  char[]\nStringBuilder builder = new StringBuilder();\n    //利用给定的参数 构建一个自定义长度空间的对象 char[]\nStringBuilder builder = new StringBuilder(20);\n    //利用带String参数的构造方法  默认数组长度字符串长度+16个\nStringBuilder builder = new StringBuilder(\"abc\");\n```\n\n\n#### 7.4 StringBuilder中常用的方法\n- 最主要的方法 **append()** 频繁的拼接字符串的时候使用此方法 提高性能\n- ensureCapacity(int minimumCapacity)  确保底层数组容量够用\n- capacity();//字符串底层char[]的容量\n- length();//字符串有效元素个数(长度)\n- setLength();//设置字符串的有效元素个数\n- char = charAt(int index);\n- int = codePointAt(int index);\n- String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果\n- StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦\n- StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦\n- int = indexOf(String str [,int fromIndex]);\n- int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找\n- insert(int index,value);//将给定的value插入在index位置之上\n- replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,\"zzt\");\n- setCharAt(int index,char value);//将index位置的字符改成给定的value\n- toString();//将StringBuilder对象 构建成一个string对象 返回\n- trimToSize();//将数组中无用的容量去掉  变成length长度的数组\n\n#### 7.5 总结\n1. StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；\n2. 常用方法\n    * 与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；\n    * 与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致\n    * 不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();\n7. String家族笔试中经常容易考察的知识点\n1. String所属的包 继承关系 实现接口\n    * java.lang 继承Object 接口Serializable,CharSequence,Comparable\n2. String构建方式\n    * 常量  构造方法  \n3. String对象内存结构\n    * 字符串常量区  new堆内存对象\n    * ==  equals()区别\n    * \"a\"+\"b\"+\"c\"\n4. String不可变特性\n    * 长度及内容\n5. String中的常用方法\n    * concat();  toUpperCase();\n6. String和StringBuilder区别   |   String和StringBuffer区别\n    * String不可变字符串\n        - JDK1.0\n        - 有一个接口Comparable\n        - 不可变体现在长度及内容\n        - 有一些方法StringBuilder没有 concat  compareTo  toUpperCase\n    * StringBuilder可变字符串\n        - JDK1.5\n        - 有一个接口Appendable\n        - 可变字符串  没有final修饰  底层可以进行数组扩容\n        - 有一些方法String没有  append() insert() delete() reverse()\n7. StringBuffer和StringBuilder的不同\n    * 它们方法基本相同\n    * StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低\n    * StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高\n\n\n<span id=\"id8\"><span>\n### 8. Optional类\n- 可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。\n- 获取字符串长度：\n  1. 方式1：if(null==str){return 0;}else{return str.length();}\n  2. 方式2：return Optional.ofNullable(str).map(String::length).orElse(0);\n\n``` java\n// 获取两个字符串长度和\nString str1 = \"zhangsan\";\nString str2 = null;\nint str1Length = Optional.ofNullable(str1).map(String::length).orElse(0);\nint str2Length = Optional.ofNullable(str2).map(String::length).orElse(0);\nSystem.out.println(str1Length + str2Length);//8，8+0\n//步骤分解:\n//构建Optional对象\nOptional<String> op1 = Optional.ofNullable(str1);\n//将str1的长度的结果构建成Optional对象\nOptional<Integer> op2 = op1.map(String::length);\n//如果长度不为空，则获取长度值，否则返回默认值\nint len = op2.orElse(0);\nSystem.out.println(len);//8\n```\n\n","source":"_posts/03_JavaSE核心工具类.md","raw":"---\ntitle: 三、JavaSE核心工具类\ndate: 2019-07-08 16:42:47\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\nAPI (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。\n<!-- more -->\n\n1. [Object类与其常用方法](#id1)\n2. [包装类](#id2)\n3. [数学处理类](#id3)\n4. [Scanner类和System类](#id4)\n5. [日期类](#id5)\n6. [String类](#id6)\n7. [StringBuilder类/StringBuffer类](#id7)\n8. [Optional类](#id8)\n\n\n### 常用的包\n- java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类...\n- java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类...\n- java.io包：是输入输出包，包括读写各种设备。\n- java.net包：是网络编程的包，包括各种网络编程。\n- java.sql包：是操作数据库的所有类和接口。\n\n<span id=\"id1\"><span>\n### 1. Object类与其常用方法\n#### 1.1 Object类\n- java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。\n- Object定义了“对象”的基本行为，被子类默认继承。\n\n#### 1.2 equals() 和 hashCode()\n- boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。\n- equals()方法要求：自反性/对称性/传递性/一致性/非空性。\n- Java类可以根据需要重写继承自Object的equals()方法。\n\n> 注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。\n\n- int hashCode():返回对象的哈希码值，对应一个内存。\n- hashCode规范要求：\n    * 一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的\n    * 如果两个对象判定相等，它们的hashCode应该时同一个值\n    * 如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。\n\n- hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。\n\n#### 1.3 toString()\n- String toString()：用于获取调用对象的字符串形式，返回\"包名.类名@hashCode值的16进制\"。\n- Java类可以根据需要重写toString方法返回更有意义的信息。\n- Java在使用System.out.println()打印对象时或者`+`连接字符串时，默认调用toString()方法。\n\n<span id=\"id2\"><span>\n### 2. 包装类\n#### 2.1 包装类\n- 由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。\n- Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。\n\n|基本类型 |对应包装类         |\n|--------|------------------|\n|byte    |java.lang.Byte    |\n|short   |java.lang.Short   |\n|int     |java.lang.Integer |\n|long    |java.lang.Long    |\n|float   |java.lang.Float   |\n|double  |java.lang.Double  |\n|boolean |java.lang.Boolean |\n|char    |java.lang.Character|\n\n1. 八个包装类都在同一个包下（java.lang包），不需要import导包直接使用\n2. 八个包装类中有六个是与数字相关，都默认继承父类Number\n3. 八个包装类都实现了Serializable, Comparable\n4. 八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型\n5. 八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型\n\n#### 2.2 Integer类\n- java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。\n- Integer类重写了**equals()**方法（重写后比较的是数值）、hashCode()以及toString()方法。\n\n|Integer类的常用方法|                  |\n|-----------------|------------------|\n|Integer(int i)               |根据参数指定整数来构造对象|\n|Integer(String s)            |根据参数指定的字符串来构造对象|\n|int intValue()               |获取调用对象中整数值并返回|\n|static Integer valueOf(int i)|根据参数指定整数值得到Integer类型对象|\n|static int parseInt(String s)|将字符串类型转换为int类型并返回|\n\n#### 2.3 装箱和拆箱\n\n``` java\nint i = 100;\nInteger it = Integer.valueOf(i); //实现了int类型到Integer类型的转换，这个过程叫做装箱\nint ia = it.intValue();//实现了Integer类型到int类型的转换，这个过程叫做拆箱\n//jdk5增加了自动拆箱和装箱功能（编译器预处理）:\nInteger i = 100;//自动装箱\nint ia = i;//自动拆箱\n```\n\n- 笔试考点：\n> * 在Integer类部提供了自动装箱池技术，将**-128~127间的整数已经装箱完毕**，当使用该范围整数时直接取池中的对象即可，从而提高效率。\n> * Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。\n\n``` java\nInteger it1 = 128;\nInteger it2 = 128;\nInteger it3 = new Integer(128);\nInteger it4 = new Integer(128);\nSystem.out.println(it1.equals(it2));//比较内容 true\nSystem.out.println(it1 == it2);//比较地址 false\nSystem.out.println(it3.equals(it4));//比较内容 true\nSystem.out.println(it3 == it4);//比较地址 false\n\nInteger it5 = 127;\nInteger it6 = 127;\nInteger it7 = new Integer(127);\nInteger it8 = new Integer(127);\nSystem.out.println(it5.equals(it6));//比较内容 true\nSystem.out.println(it5 == it6);//比较地址 true, 自动装箱池范围-128~127。\nSystem.out.println(it7.equals(it8));//比较内容 true\nSystem.out.println(it7 == it8);//比较地址 false\n```\n\n<span id=\"id3\"><span>\n### 3. 数学处理类\n- java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。\n\n| 常用的方法             |返回值类型|  |\n|-----------------------|---------|---|\n|Math.abs()             |      |返回给定数字的绝对值(参数 int long float double)|\n|Math.ceil()            |double| 向上取整|\n|Math.floor()           |double| 向下取整|\n|Math.rint()            |double| 临近的整数 如果两边距离一样 则返回偶数|\n|Math.round()           |int   | 四舍五入的整数|\n|Math.max(a,b)/min(a,b) |      | (参数int  long  float  double)|\n|Math.pow(a,b)          |double| a的b次方  (参数double 返回值double)|\n|Math.sqrt(double a)    |      |获取给定参数的平方根|\n|Math.random()          |double|随机产生一个[0.0--1.0)|\n\n- 0-9之间的随机整数：int value = (int)**(Math.random()*10**);\n- Math.random()计算小数的时候精确程度可能有些损失\n\n#### 3.1 Random类\n- java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n\n| 常用的方法                |Random r = new Random();  |\n|--------------------------|--------|\n| r.nextInt();             |随机产生 int取值范围的整数 有正有负(`-2^31`\\~`2^31-1`即`正负21亿`之间)|\n| r.nextInt(int bound);    |随机产生一个[0--bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException|\n| r.nextFloat()            |随机产生一个 [0.0---1.0)|\n| r.nextBoolean()          |随机产生一个boolean值   true  false|\n\n#### 3.2 UUID类\n- java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类\n- 只有有参构造方法，我们通常不会创建对象\n- UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key\n- 产生一个32位的随机元素 每一个位置是一个16进制的数字\n\n#### 3.3 BigDecimal\n- java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number\n- Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。\n- 提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(\"1.23\");\n\n|BigDecimal类的常用方法|                  |\n|-----------------|------------------|\n|BigDecimal(String val)                       | 根据参数指定的字符串来构造对象|\n|BigDecimal    setScale(int newScale, RoundingMode roundingMode)|两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)|\n|BigDecimal **add**(BigDecimal augend)            | 用于实现**加法**运算 |\n|BigDecimal **subtract**(BigDecimal subtrahend)   | 用于实现**减法**运算 |\n|BigDecimal **multiply**(BigDecimal multiplicand) | 用于实现**乘法**运算 |\n|BigDecimal **divide**(BigDecimal divisor)        | 用于实现**除法**运算，也可传入更多参数设置保留小数点位数和取值模式 |\n\n``` java\nBigDecimal d3 = new BigDecimal(\"3.0\");\nBigDecimal d4 = new BigDecimal(\"2.9\");\nSystem.out.println(d3.add(d4));//加：5.9\nSystem.out.println(d3.subtract(d4));//减：0.1\nSystem.out.println(d3.multiply(d4));//乘：8.70\nSystem.out.println(d3.divide(d4, 8, BigDecimal.ROUND_HALF_UP));//除：1.03448276\n```\n\n对于divide方法，通常需要制定**精度和舍入模式**，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。\n\n#### 3.4 BigInteger\n- java.math.BigInteger类处理大整数，需要import导入，继承自Number\n- java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 \n- 如何创建对象，提供的构造方法全部都是带参数的\n    * 通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(\"123\");\n- 和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。\n\n#### 3.5 DecimalFormat类\n- 所属的包 java.text，import导入才能使用\n- 通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）\n\n``` java\n    //调用format方法将一个小数格式化成一个字符串\nDecimalFormat df = new DecimalFormat(\"000.000\");\nSystem.out.println(df.format(12.45)); //012.450\nSystem.out.println(df.format(12345.6789)); //12345.679\n\nDecimalFormat df2 = new DecimalFormat(\"###.###\");\nSystem.out.println(df2.format(12.45)); //12.45\nSystem.out.println(df2.format(12345.6789)); //12345.679\n\nDecimalFormat df3 = new DecimalFormat(\"000.###\");\nSystem.out.println(df3.format(12.45)); //012.45\nSystem.out.println(df3.format(12345.6789)); //12345.679    \n```\n\n\n<span id=\"id4\"><span>\n### 4. Scanner类和System类\n#### 4.1 Scanner类\n1. 所属的包java.util包  需要import导包\n2. 通过一个带输入流的构造方法创建对象\n3. 常用方法    nextInt()  nextFloat()   next()   nextLine()\n\n#### 4.1 System类\n1. 所属的包java.lang包 不需要导入\n2. 不需要创建对象  通过类名就可以访问\n3. 有三个属性及若干的方法\n    * 三个属性out   in   err\n    * 方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;\n\n\n<span id=\"id5\"><span>\n### 5. 日期类\n#### 5.1 Date类\n- java.util.Date类表示特定的瞬间，精确到毫秒。\n- 通常使用无参数的构造方法，或者带long构造方法\n- Date类中常用的方法\n    * before();  after();\n    * setTime()  getTime();----->long\n    * compareTo();   //-1  1  0\n- Date类大多数用于进行时间分量计算的方法已经被Calender取代。\n\n``` java\nDate date = new Date();//当前日期信息\n    //Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019\nlong time = date.getTime();//1970年1月1日距今毫秒数。\ndate.setTime(time + 24\\*60\\*60\\*1000);//通过毫秒数设置时间\n```\n\n#### 5.2 SimpleDateFormat类\n- java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类\n- 其构造方法 SimpleDateFormat(String pattern)\n\n``` java\nDate date = new Date();\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\");\nString dateStr = sdf.format(date);\n// format用于将日期按指定格式转换为字符串\n\nString str = \"2013-01-06\";\nSimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd\");\nDate date2 = sdf2.parse(str);//如果字符串格式不匹配将抛出异常\n```\n\n|常用格式字符串| 含义        |  示例  |\n|----------|------------|---------|\n|y|年      |yyyy年——2013年；yy——13年 |\n|M|月      |MM月——01月；M月——1月|\n|d|日      |dd日——01日；d日——1日|\n|H|小时(24)|HH:mm:ss—12:46:33|\n|h|小时(12)|hh(a):mm:ss—12(下午):47:48|\n|m|分钟    |--|\n|s|秒      |--|\n\n#### 5.3 Calendar类\n- java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。\n- 有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();\n- 通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现\n\n``` java\nCalendar c1 = Calendar.getInstance();\nc1.set(2008,9-1,20,8,8,8);\nSystem.out.println(c1.getTime());\n```\n\n- 常用方法\n    * after()  before()\n    * setTime()  getTime()---->Date\n    * getTimeInMillis()----time\n    * getTimeZone()---TimeZone\n    * Calendar里面包含一个date属性  可以操作date的某一个局部信息\n    * set   get\n        * calendar.set(Calendar.YEAR,2015);\n        *int year = calendar.get(Calendar.YEAR);\n\n- TimeZone\n    1. java.util包\n    2. 可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();\n    3. 常用方法\n        - tz.getID()       ---->    Asia/Shanghai\n        - tz.getDisplayName()    ---->  中国标准时间\n\n\n<span id=\"id6\"><span>\n### 6. String类\n#### 6.1 基本概念\n- String类 ---> 引用类型  ---> java.lang包\n- 没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<String>\n- java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如\"abc\"等，任何一个字符对应2字节定长编码。\n- String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。\n\n``` java\n//如何构建对象\nString str1 = \"abc\"; //直接将字符串常量赋值给str   (字符串常量池)\nString str2 = new String();//无参数构造方法创建空的对象\nString str3 = new String(\"abc\");//带string参数的构造方法创建对象\nbyte[] bArr = {97, 98, 99, 100, 101};//a:97，b:98，c:99，d:100\nString str4 = new String(bArr);//将数组中的每一个元素转化成对应的char 组合成String\nchar[] cArr = {'h', 'e', 'l', 'l', 'o'};\nString str5 = new String(cArr);//将数组中的每一个char元素拼接成最终的String\nString str6 = String(char[], index, count);//使用char数组中下标从index位置开始的count个字符来构造对象\nString str7 = String(byte[], index, length);//使用byte数组下标从index位置开始length个字节来构造对象\n```\n\n\n#### 6.2 字符串常量池\n- 由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。\n- 出于性能考虑，Java虚拟机(JVM)将**字符串字面量对象**缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。\n\n``` java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\nString str3 = new String(\"Hello\");\nSystem.out.println(str1.equals(str2));//比较内容 true\nSystem.out.println(str1==str2);//比较地址 true，不会重新创建\nSystem.out.println(str1.equals(str3));//比较内容 true\nSystem.out.println(str1==str3);//比较地址 false，使用new会重新创建新的String对象\n    //1.下面的代码中创建了几个对象并分别存放在什么位置？\nString s1 = \"hello\"; //1个对象，常量池。\nString s2 = new String(\"world\"); //2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)\n```\n\n#### 6.3 String类常用方法\n1. 第一梯队(重写): equals  hashCode  compareTo  toString\n2. 第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。\n3. 第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。\n\n- 重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口\n    1. boolean = equals(Object obj);\n        - 继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;\n    2. int = hashCode();\n        - 继承自Object类中的方法，重写了：31*h+和...\n    3. int = compareTo();\n        - 实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差\n    4. String = toString()\n        - Object类中返回类名@hashCode(16进制形式)\n        - String类重写后返回的是String对象的字面值\n\n>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();\n\n|String类的成员方法         |                  |\n|--------------------------|------------------|\n|char charAt(int index)    |返回字符串指定位置|\n|int codePointAt(int index)|\"abc\"0-->97，返回给定index对应位置的那个char所对应的code码|\n|String concat(String)     |将给定的字符串拼接在当前字符串之后|\n|int length()              |返回字符串序列的长度|\n> 注意：区别数组的length是属性，String的length()是方法，集合是size()方法\n\n``` java\nString str6 = new String(\"hello\");\nSystem.out.println(\"下标为0的字符是：\"+str6.charAt(0));// h\nSystem.out.println(\"字符串长度是：\"+str6.length());// 5\n\n    //将字符串\"12345\"转换为整数类型\nString str = new String(\"123456\");\n    //方式一：Integer类中的pareseInt方法\nint ia = Integer.parseInt(str);\nSystem.out.println(\"转换出来结果是：\"+ ia);//123456\n    //方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...\nint res = 0;\nfor(int i=0; i<str.length(); i++){\n    res = res*10 + (str.charAt(i)-'0');\n}\nSystem.out.println(\"转换出来结果是：\"+ res);//123456\n```\n\n|String类的常用基本方法|               |\n|-----------------|------------------|\n|boolean contains(CharSequence s)|判断当前字符串是否包含参数指定的内容|\n|String toLowerCase()|返回小写形式|\n|String toUpperCase()|返回大写形式|\n|String trim()|返回去掉前后空格的字符串|\n|boolean startsWith(String prefix)|判断是否以参数字符开头|\n|boolean endsWith(String suffix)|判断是否以参数字符结尾|\n|boolean equals(Object anObject)|比较字符串内容是否相等，String类已重写|\n|boolean equalsIgnoreCase(String anotherString)|同上，并且忽略大小写|\n|int indexOf(String str)|返回第一次出现str位置，找不到返回-1|\n|int indexOf(String str, int fromIndex)|同上，从fromIndex开始检索|\n|String substring(int beginIndex, int endIndex)|截取字符串，beginIndex开始，endIndex结束|\n|String substring(int beginIndex)|截取字符串，beginIndex开始到结尾|\n\n#### 6.4 正则相关方法\n- 正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。\n\n|正则相关方法|                  |\n|-----------------|------------------|\n|boolean matches(String regex)|用于判断是否匹配正则表达式规则。|\n|String[] split(String regx)|以正则为分割符，将字符串拆分成字符串数组|\n|String replaceAll(String regex, String replacement)|正则替换|\n\n\n<span id=\"id7\"><span>\n### 7. StringBuilder类/StringBuffer类\n#### 7.1 基本概念\n1. java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。\n2. StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable\n    - StringBuffer/StringBuilder没有compareTo方法\n    - StringBuffer/StringBuilder含有一个String没有的方法 append();拼接\n\n#### 7.2 特性\n可变字符串，char[] value;  动态扩容\n#### 7.3 对象的构建\n\n``` java\n    //无参数构造方法  构建一个默认长度16个空间的对象  char[]\nStringBuilder builder = new StringBuilder();\n    //利用给定的参数 构建一个自定义长度空间的对象 char[]\nStringBuilder builder = new StringBuilder(20);\n    //利用带String参数的构造方法  默认数组长度字符串长度+16个\nStringBuilder builder = new StringBuilder(\"abc\");\n```\n\n\n#### 7.4 StringBuilder中常用的方法\n- 最主要的方法 **append()** 频繁的拼接字符串的时候使用此方法 提高性能\n- ensureCapacity(int minimumCapacity)  确保底层数组容量够用\n- capacity();//字符串底层char[]的容量\n- length();//字符串有效元素个数(长度)\n- setLength();//设置字符串的有效元素个数\n- char = charAt(int index);\n- int = codePointAt(int index);\n- String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果\n- StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦\n- StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦\n- int = indexOf(String str [,int fromIndex]);\n- int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找\n- insert(int index,value);//将给定的value插入在index位置之上\n- replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,\"zzt\");\n- setCharAt(int index,char value);//将index位置的字符改成给定的value\n- toString();//将StringBuilder对象 构建成一个string对象 返回\n- trimToSize();//将数组中无用的容量去掉  变成length长度的数组\n\n#### 7.5 总结\n1. StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；\n2. 常用方法\n    * 与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；\n    * 与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致\n    * 不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();\n7. String家族笔试中经常容易考察的知识点\n1. String所属的包 继承关系 实现接口\n    * java.lang 继承Object 接口Serializable,CharSequence,Comparable\n2. String构建方式\n    * 常量  构造方法  \n3. String对象内存结构\n    * 字符串常量区  new堆内存对象\n    * ==  equals()区别\n    * \"a\"+\"b\"+\"c\"\n4. String不可变特性\n    * 长度及内容\n5. String中的常用方法\n    * concat();  toUpperCase();\n6. String和StringBuilder区别   |   String和StringBuffer区别\n    * String不可变字符串\n        - JDK1.0\n        - 有一个接口Comparable\n        - 不可变体现在长度及内容\n        - 有一些方法StringBuilder没有 concat  compareTo  toUpperCase\n    * StringBuilder可变字符串\n        - JDK1.5\n        - 有一个接口Appendable\n        - 可变字符串  没有final修饰  底层可以进行数组扩容\n        - 有一些方法String没有  append() insert() delete() reverse()\n7. StringBuffer和StringBuilder的不同\n    * 它们方法基本相同\n    * StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低\n    * StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高\n\n\n<span id=\"id8\"><span>\n### 8. Optional类\n- 可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。\n- 获取字符串长度：\n  1. 方式1：if(null==str){return 0;}else{return str.length();}\n  2. 方式2：return Optional.ofNullable(str).map(String::length).orElse(0);\n\n``` java\n// 获取两个字符串长度和\nString str1 = \"zhangsan\";\nString str2 = null;\nint str1Length = Optional.ofNullable(str1).map(String::length).orElse(0);\nint str2Length = Optional.ofNullable(str2).map(String::length).orElse(0);\nSystem.out.println(str1Length + str2Length);//8，8+0\n//步骤分解:\n//构建Optional对象\nOptional<String> op1 = Optional.ofNullable(str1);\n//将str1的长度的结果构建成Optional对象\nOptional<Integer> op2 = op1.map(String::length);\n//如果长度不为空，则获取长度值，否则返回默认值\nint len = op2.orElse(0);\nSystem.out.println(len);//8\n```\n\n","slug":"03_JavaSE核心工具类","published":1,"updated":"2019-07-20T14:46:02.537Z","_id":"cjyblnrxv002hxwt3215zujxv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">Object类与其常用方法</a></li>\n<li><a href=\"#id2\">包装类</a></li>\n<li><a href=\"#id3\">数学处理类</a></li>\n<li><a href=\"#id4\">Scanner类和System类</a></li>\n<li><a href=\"#id5\">日期类</a></li>\n<li><a href=\"#id6\">String类</a></li>\n<li><a href=\"#id7\">StringBuilder类/StringBuffer类</a></li>\n<li><a href=\"#id8\">Optional类</a></li>\n</ol>\n<h3 id=\"常用的包\"><a href=\"#常用的包\" class=\"headerlink\" title=\"常用的包\"></a>常用的包</h3><ul>\n<li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li>\n<li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li>\n<li>java.io包：是输入输出包，包括读写各种设备。</li>\n<li>java.net包：是网络编程的包，包括各种网络编程。</li>\n<li>java.sql包：是操作数据库的所有类和接口。</li>\n</ul>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Object类与其常用方法\"><a href=\"#1-Object类与其常用方法\" class=\"headerlink\" title=\"1. Object类与其常用方法\"></a>1. Object类与其常用方法</h3><h4 id=\"1-1-Object类\"><a href=\"#1-1-Object类\" class=\"headerlink\" title=\"1.1 Object类\"></a>1.1 Object类</h4><ul>\n<li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li>\n<li>Object定义了“对象”的基本行为，被子类默认继承。</li>\n</ul>\n<h4 id=\"1-2-equals-和-hashCode\"><a href=\"#1-2-equals-和-hashCode\" class=\"headerlink\" title=\"1.2 equals() 和 hashCode()\"></a>1.2 equals() 和 hashCode()</h4><ul>\n<li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li>\n<li>equals()方法要求：自反性/对称性/传递性/一致性/非空性。</li>\n<li>Java类可以根据需要重写继承自Object的equals()方法。</li>\n</ul>\n<blockquote>\n<p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n</blockquote>\n<ul>\n<li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p>\n</li>\n<li><p>hashCode规范要求：</p>\n<ul>\n<li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li>\n<li>如果两个对象判定相等，它们的hashCode应该时同一个值</li>\n<li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li>\n</ul>\n</li>\n<li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p>\n</li>\n</ul>\n<h4 id=\"1-3-toString\"><a href=\"#1-3-toString\" class=\"headerlink\" title=\"1.3 toString()\"></a>1.3 toString()</h4><ul>\n<li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li>\n<li>Java类可以根据需要重写toString方法返回更有意义的信息。</li>\n<li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-包装类\"><a href=\"#2-包装类\" class=\"headerlink\" title=\"2. 包装类\"></a>2. 包装类</h3><h4 id=\"2-1-包装类\"><a href=\"#2-1-包装类\" class=\"headerlink\" title=\"2.1 包装类\"></a>2.1 包装类</h4><ul>\n<li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li>\n<li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>对应包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>java.lang.Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>java.lang.Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>java.lang.Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>java.lang.Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>java.lang.Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>java.lang.Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>java.lang.Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>java.lang.Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li>\n<li>八个包装类中有六个是与数字相关，都默认继承父类Number</li>\n<li>八个包装类都实现了Serializable, Comparable</li>\n<li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li>\n<li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li>\n</ol>\n<h4 id=\"2-2-Integer类\"><a href=\"#2-2-Integer类\" class=\"headerlink\" title=\"2.2 Integer类\"></a>2.2 Integer类</h4><ul>\n<li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li>\n<li>Integer类重写了<strong>equals()</strong>方法（重写后比较的是数值）、hashCode()以及toString()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Integer类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Integer(int i)</td>\n<td>根据参数指定整数来构造对象</td>\n</tr>\n<tr>\n<td>Integer(String s)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>int intValue()</td>\n<td>获取调用对象中整数值并返回</td>\n</tr>\n<tr>\n<td>static Integer valueOf(int i)</td>\n<td>根据参数指定整数值得到Integer类型对象</td>\n</tr>\n<tr>\n<td>static int parseInt(String s)</td>\n<td>将字符串类型转换为int类型并返回</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-装箱和拆箱\"><a href=\"#2-3-装箱和拆箱\" class=\"headerlink\" title=\"2.3 装箱和拆箱\"></a>2.3 装箱和拆箱</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer it = Integer.valueOf(i); <span class=\"comment\">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = it.intValue();<span class=\"comment\">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class=\"line\">Integer i = <span class=\"number\">100</span>;<span class=\"comment\">//自动装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = i;<span class=\"comment\">//自动拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>笔试考点：<blockquote>\n<ul>\n<li>在Integer类部提供了自动装箱池技术，将<strong>-128~127间的整数已经装箱完毕</strong>，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li>\n<li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer it1 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it2 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it3 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">Integer it4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">System.out.println(it1.equals(it2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it1 == it2);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\">System.out.println(it3.equals(it4));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it3 == it4);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Integer it5 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it6 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it7 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">Integer it8 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">System.out.println(it5.equals(it6));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it5 == it6);<span class=\"comment\">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class=\"line\">System.out.println(it7.equals(it8));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it7 == it8);<span class=\"comment\">//比较地址 false</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数学处理类\"><a href=\"#3-数学处理类\" class=\"headerlink\" title=\"3. 数学处理类\"></a>3. 数学处理类</h3><ul>\n<li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>返回值类型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs()</td>\n<td></td>\n<td>返回给定数字的绝对值(参数 int long float double)</td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td>double</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td>double</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>Math.rint()</td>\n<td>double</td>\n<td>临近的整数 如果两边距离一样 则返回偶数</td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>int</td>\n<td>四舍五入的整数</td>\n</tr>\n<tr>\n<td>Math.max(a,b)/min(a,b)</td>\n<td></td>\n<td>(参数int  long  float  double)</td>\n</tr>\n<tr>\n<td>Math.pow(a,b)</td>\n<td>double</td>\n<td>a的b次方  (参数double 返回值double)</td>\n</tr>\n<tr>\n<td>Math.sqrt(double a)</td>\n<td></td>\n<td>获取给定参数的平方根</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>double</td>\n<td>随机产生一个[0.0–1.0)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>0-9之间的随机整数：int value = (int)<strong>(Math.random()*10</strong>);</li>\n<li>Math.random()计算小数的时候精确程度可能有些损失</li>\n</ul>\n<h4 id=\"3-1-Random类\"><a href=\"#3-1-Random类\" class=\"headerlink\" title=\"3.1 Random类\"></a>3.1 Random类</h4><ul>\n<li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>Random r = new Random();</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r.nextInt();</td>\n<td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td>\n</tr>\n<tr>\n<td>r.nextInt(int bound);</td>\n<td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td>\n</tr>\n<tr>\n<td>r.nextFloat()</td>\n<td>随机产生一个 [0.0—1.0)</td>\n</tr>\n<tr>\n<td>r.nextBoolean()</td>\n<td>随机产生一个boolean值   true  false</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-UUID类\"><a href=\"#3-2-UUID类\" class=\"headerlink\" title=\"3.2 UUID类\"></a>3.2 UUID类</h4><ul>\n<li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n<li>只有有参构造方法，我们通常不会创建对象</li>\n<li>UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key</li>\n<li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li>\n</ul>\n<h4 id=\"3-3-BigDecimal\"><a href=\"#3-3-BigDecimal\" class=\"headerlink\" title=\"3.3 BigDecimal\"></a>3.3 BigDecimal</h4><ul>\n<li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li>\n<li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li>\n<li>提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(“1.23”);</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>BigDecimal类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BigDecimal(String val)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td>\n<td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>add</strong>(BigDecimal augend)</td>\n<td>用于实现<strong>加法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td>\n<td>用于实现<strong>减法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td>\n<td>用于实现<strong>乘法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td>\n<td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"3.0\"</span>);</span><br><span class=\"line\">BigDecimal d4 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"2.9\"</span>);</span><br><span class=\"line\">System.out.println(d3.add(d4));<span class=\"comment\">//加：5.9</span></span><br><span class=\"line\">System.out.println(d3.subtract(d4));<span class=\"comment\">//减：0.1</span></span><br><span class=\"line\">System.out.println(d3.multiply(d4));<span class=\"comment\">//乘：8.70</span></span><br><span class=\"line\">System.out.println(d3.divide(d4, <span class=\"number\">8</span>, BigDecimal.ROUND_HALF_UP));<span class=\"comment\">//除：1.03448276</span></span><br></pre></td></tr></table></figure>\n\n<p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p>\n<h4 id=\"3-4-BigInteger\"><a href=\"#3-4-BigInteger\" class=\"headerlink\" title=\"3.4 BigInteger\"></a>3.4 BigInteger</h4><ul>\n<li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li>\n<li>java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li>\n<li>如何创建对象，提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(“123”);</li>\n</ul>\n</li>\n<li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li>\n</ul>\n<h4 id=\"3-5-DecimalFormat类\"><a href=\"#3-5-DecimalFormat类\" class=\"headerlink\" title=\"3.5 DecimalFormat类\"></a>3.5 DecimalFormat类</h4><ul>\n<li>所属的包 java.text，import导入才能使用</li>\n<li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class=\"line\">DecimalFormat df = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.000\"</span>);</span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.450</span></span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df2 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"###.###\"</span>);</span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//12.45</span></span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df3 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.###\"</span>);</span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.45</span></span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Scanner类和System类\"><a href=\"#4-Scanner类和System类\" class=\"headerlink\" title=\"4. Scanner类和System类\"></a>4. Scanner类和System类</h3><h4 id=\"4-1-Scanner类\"><a href=\"#4-1-Scanner类\" class=\"headerlink\" title=\"4.1 Scanner类\"></a>4.1 Scanner类</h4><ol>\n<li>所属的包java.util包  需要import导包</li>\n<li>通过一个带输入流的构造方法创建对象</li>\n<li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li>\n</ol>\n<h4 id=\"4-1-System类\"><a href=\"#4-1-System类\" class=\"headerlink\" title=\"4.1 System类\"></a>4.1 System类</h4><ol>\n<li>所属的包java.lang包 不需要导入</li>\n<li>不需要创建对象  通过类名就可以访问</li>\n<li>有三个属性及若干的方法<ul>\n<li>三个属性out   in   err</li>\n<li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-日期类\"><a href=\"#5-日期类\" class=\"headerlink\" title=\"5. 日期类\"></a>5. 日期类</h3><h4 id=\"5-1-Date类\"><a href=\"#5-1-Date类\" class=\"headerlink\" title=\"5.1 Date类\"></a>5.1 Date类</h4><ul>\n<li>java.util.Date类表示特定的瞬间，精确到毫秒。</li>\n<li>通常使用无参数的构造方法，或者带long构造方法</li>\n<li>Date类中常用的方法<ul>\n<li>before();  after();</li>\n<li>setTime()  getTime();—–&gt;long</li>\n<li>compareTo();   //-1  1  0</li>\n</ul>\n</li>\n<li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();<span class=\"comment\">//当前日期信息</span></span><br><span class=\"line\">    <span class=\"comment\">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> time = date.getTime();<span class=\"comment\">//1970年1月1日距今毫秒数。</span></span><br><span class=\"line\">date.setTime(time + <span class=\"number\">24</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">1000</span>);<span class=\"comment\">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-SimpleDateFormat类\"><a href=\"#5-2-SimpleDateFormat类\" class=\"headerlink\" title=\"5.2 SimpleDateFormat类\"></a>5.2 SimpleDateFormat类</h4><ul>\n<li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li>\n<li>其构造方法 SimpleDateFormat(String pattern)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy年MM月dd日\"</span>);</span><br><span class=\"line\">String dateStr = sdf.format(date);</span><br><span class=\"line\"><span class=\"comment\">// format用于将日期按指定格式转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">String str = <span class=\"string\">\"2013-01-06\"</span>;</span><br><span class=\"line\">SimpleDateFormat sdf2 = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>);</span><br><span class=\"line\">Date date2 = sdf2.parse(str);<span class=\"comment\">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>常用格式字符串</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>年</td>\n<td>yyyy年——2013年；yy——13年</td>\n</tr>\n<tr>\n<td>M</td>\n<td>月</td>\n<td>MM月——01月；M月——1月</td>\n</tr>\n<tr>\n<td>d</td>\n<td>日</td>\n<td>dd日——01日；d日——1日</td>\n</tr>\n<tr>\n<td>H</td>\n<td>小时(24)</td>\n<td>HH:mm:ss—12:46:33</td>\n</tr>\n<tr>\n<td>h</td>\n<td>小时(12)</td>\n<td>hh(a):mm:ss—12(下午):47:48</td>\n</tr>\n<tr>\n<td>m</td>\n<td>分钟</td>\n<td>–</td>\n</tr>\n<tr>\n<td>s</td>\n<td>秒</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-3-Calendar类\"><a href=\"#5-3-Calendar类\" class=\"headerlink\" title=\"5.3 Calendar类\"></a>5.3 Calendar类</h4><ul>\n<li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li>\n<li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li>\n<li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c1 = Calendar.getInstance();</span><br><span class=\"line\">c1.set(<span class=\"number\">2008</span>,<span class=\"number\">9</span>-<span class=\"number\">1</span>,<span class=\"number\">20</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>常用方法</p>\n<ul>\n<li>after()  before()</li>\n<li>setTime()  getTime()—-&gt;Date</li>\n<li>getTimeInMillis()—-time</li>\n<li>getTimeZone()—TimeZone</li>\n<li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li>\n<li>set   get<ul>\n<li>calendar.set(Calendar.YEAR,2015);</li>\n<li>int year = calendar.get(Calendar.YEAR);</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TimeZone</p>\n<ol>\n<li>java.util包</li>\n<li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li>\n<li>常用方法<ul>\n<li>tz.getID()       —-&gt;    Asia/Shanghai</li>\n<li>tz.getDisplayName()    —-&gt;  中国标准时间</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-String类\"><a href=\"#6-String类\" class=\"headerlink\" title=\"6. String类\"></a>6. String类</h3><h4 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h4><ul>\n<li>String类 —&gt; 引用类型  —&gt; java.lang包</li>\n<li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<string></string></li>\n<li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li>\n<li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何构建对象</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"abc\"</span>; <span class=\"comment\">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String();<span class=\"comment\">//无参数构造方法创建空的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//带string参数的构造方法创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bArr = &#123;<span class=\"number\">97</span>, <span class=\"number\">98</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">101</span>&#125;;<span class=\"comment\">//a:97，b:98，c:99，d:100</span></span><br><span class=\"line\">String str4 = <span class=\"keyword\">new</span> String(bArr);<span class=\"comment\">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] cArr = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>&#125;;</span><br><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(cArr);<span class=\"comment\">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class=\"line\">String str6 = String(<span class=\"keyword\">char</span>[], index, count);<span class=\"comment\">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class=\"line\">String str7 = String(<span class=\"keyword\">byte</span>[], index, length);<span class=\"comment\">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符串常量池\"><a href=\"#6-2-字符串常量池\" class=\"headerlink\" title=\"6.2 字符串常量池\"></a>6.2 字符串常量池</h4><ul>\n<li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li>\n<li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">System.out.println(str1.equals(str2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//比较地址 true，不会重新创建</span></span><br><span class=\"line\">System.out.println(str1.equals(str3));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str3);<span class=\"comment\">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class=\"line\">    <span class=\"comment\">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class=\"line\">String s1 = <span class=\"string\">\"hello\"</span>; <span class=\"comment\">//1个对象，常量池。</span></span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-String类常用方法\"><a href=\"#6-3-String类常用方法\" class=\"headerlink\" title=\"6.3 String类常用方法\"></a>6.3 String类常用方法</h4><ol>\n<li>第一梯队(重写): equals  hashCode  compareTo  toString</li>\n<li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li>\n<li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li>\n</ol>\n<ul>\n<li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol>\n<li>boolean = equals(Object obj);<ul>\n<li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;</li>\n</ul>\n</li>\n<li>int = hashCode();<ul>\n<li>继承自Object类中的方法，重写了：31*h+和…</li>\n</ul>\n</li>\n<li>int = compareTo();<ul>\n<li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li>\n</ul>\n</li>\n<li>String = toString()<ul>\n<li>Object类中返回类名@hashCode(16进制形式)</li>\n<li>String类重写后返回的是String对象的字面值</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>String类的成员方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char charAt(int index)</td>\n<td>返回字符串指定位置</td>\n</tr>\n<tr>\n<td>int codePointAt(int index)</td>\n<td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td>\n</tr>\n<tr>\n<td>String concat(String)</td>\n<td>将给定的字符串拼接在当前字符串之后</td>\n</tr>\n<tr>\n<td>int length()</td>\n<td>返回字符串序列的长度</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str6 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"下标为0的字符是：\"</span>+str6.charAt(<span class=\"number\">0</span>));<span class=\"comment\">// h</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"字符串长度是：\"</span>+str6.length());<span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串\"12345\"转换为整数类型</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//方式一：Integer类中的pareseInt方法</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ ia);<span class=\"comment\">//123456</span></span><br><span class=\"line\">    <span class=\"comment\">//方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class=\"line\">    res = res*<span class=\"number\">10</span> + (str.charAt(i)-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ res);<span class=\"comment\">//123456</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>String类的常用基本方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean contains(CharSequence s)</td>\n<td>判断当前字符串是否包含参数指定的内容</td>\n</tr>\n<tr>\n<td>String toLowerCase()</td>\n<td>返回小写形式</td>\n</tr>\n<tr>\n<td>String toUpperCase()</td>\n<td>返回大写形式</td>\n</tr>\n<tr>\n<td>String trim()</td>\n<td>返回去掉前后空格的字符串</td>\n</tr>\n<tr>\n<td>boolean startsWith(String prefix)</td>\n<td>判断是否以参数字符开头</td>\n</tr>\n<tr>\n<td>boolean endsWith(String suffix)</td>\n<td>判断是否以参数字符结尾</td>\n</tr>\n<tr>\n<td>boolean equals(Object anObject)</td>\n<td>比较字符串内容是否相等，String类已重写</td>\n</tr>\n<tr>\n<td>boolean equalsIgnoreCase(String anotherString)</td>\n<td>同上，并且忽略大小写</td>\n</tr>\n<tr>\n<td>int indexOf(String str)</td>\n<td>返回第一次出现str位置，找不到返回-1</td>\n</tr>\n<tr>\n<td>int indexOf(String str, int fromIndex)</td>\n<td>同上，从fromIndex开始检索</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex, int endIndex)</td>\n<td>截取字符串，beginIndex开始，endIndex结束</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex)</td>\n<td>截取字符串，beginIndex开始到结尾</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-4-正则相关方法\"><a href=\"#6-4-正则相关方法\" class=\"headerlink\" title=\"6.4 正则相关方法\"></a>6.4 正则相关方法</h4><ul>\n<li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>正则相关方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean matches(String regex)</td>\n<td>用于判断是否匹配正则表达式规则。</td>\n</tr>\n<tr>\n<td>String[] split(String regx)</td>\n<td>以正则为分割符，将字符串拆分成字符串数组</td>\n</tr>\n<tr>\n<td>String replaceAll(String regex, String replacement)</td>\n<td>正则替换</td>\n</tr>\n</tbody></table>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-StringBuilder类-StringBuffer类\"><a href=\"#7-StringBuilder类-StringBuffer类\" class=\"headerlink\" title=\"7. StringBuilder类/StringBuffer类\"></a>7. StringBuilder类/StringBuffer类</h3><h4 id=\"7-1-基本概念\"><a href=\"#7-1-基本概念\" class=\"headerlink\" title=\"7.1 基本概念\"></a>7.1 基本概念</h4><ol>\n<li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li>\n<li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul>\n<li>StringBuffer/StringBuilder没有compareTo方法</li>\n<li>StringBuffer/StringBuilder含有一个String没有的方法 append();拼接</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-特性\"><a href=\"#7-2-特性\" class=\"headerlink\" title=\"7.2 特性\"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p>\n<h4 id=\"7-3-对象的构建\"><a href=\"#7-3-对象的构建\" class=\"headerlink\" title=\"7.3 对象的构建\"></a>7.3 对象的构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"comment\">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-StringBuilder中常用的方法\"><a href=\"#7-4-StringBuilder中常用的方法\" class=\"headerlink\" title=\"7.4 StringBuilder中常用的方法\"></a>7.4 StringBuilder中常用的方法</h4><ul>\n<li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li>\n<li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li>\n<li>capacity();//字符串底层char[]的容量</li>\n<li>length();//字符串有效元素个数(长度)</li>\n<li>setLength();//设置字符串的有效元素个数</li>\n<li>char = charAt(int index);</li>\n<li>int = codePointAt(int index);</li>\n<li>String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果</li>\n<li>StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li>\n<li>StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦</li>\n<li>int = indexOf(String str [,int fromIndex]);</li>\n<li>int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li>\n<li>insert(int index,value);//将给定的value插入在index位置之上</li>\n<li>replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li>\n<li>setCharAt(int index,char value);//将index位置的字符改成给定的value</li>\n<li>toString();//将StringBuilder对象 构建成一个string对象 返回</li>\n<li>trimToSize();//将数组中无用的容量去掉  变成length长度的数组</li>\n</ul>\n<h4 id=\"7-5-总结\"><a href=\"#7-5-总结\" class=\"headerlink\" title=\"7.5 总结\"></a>7.5 总结</h4><ol>\n<li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li>\n<li>常用方法<ul>\n<li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li>\n<li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li>\n<li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li>\n</ul>\n</li>\n<li>String家族笔试中经常容易考察的知识点</li>\n<li>String所属的包 继承关系 实现接口<ul>\n<li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li>\n</ul>\n</li>\n<li>String构建方式<ul>\n<li>常量  构造方法  </li>\n</ul>\n</li>\n<li>String对象内存结构<ul>\n<li>字符串常量区  new堆内存对象</li>\n<li>==  equals()区别</li>\n<li>“a”+”b”+”c”</li>\n</ul>\n</li>\n<li>String不可变特性<ul>\n<li>长度及内容</li>\n</ul>\n</li>\n<li>String中的常用方法<ul>\n<li>concat();  toUpperCase();</li>\n</ul>\n</li>\n<li>String和StringBuilder区别   |   String和StringBuffer区别<ul>\n<li>String不可变字符串<ul>\n<li>JDK1.0</li>\n<li>有一个接口Comparable</li>\n<li>不可变体现在长度及内容</li>\n<li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li>\n</ul>\n</li>\n<li>StringBuilder可变字符串<ul>\n<li>JDK1.5</li>\n<li>有一个接口Appendable</li>\n<li>可变字符串  没有final修饰  底层可以进行数组扩容</li>\n<li>有一些方法String没有  append() insert() delete() reverse()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>StringBuffer和StringBuilder的不同<ul>\n<li>它们方法基本相同</li>\n<li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li>\n<li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Optional类\"><a href=\"#8-Optional类\" class=\"headerlink\" title=\"8. Optional类\"></a>8. Optional类</h3><ul>\n<li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li>\n<li>获取字符串长度：<ol>\n<li>方式1：if(null==str){return 0;}else{return str.length();}</li>\n<li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取两个字符串长度和</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> str1Length = Optional.ofNullable(str1).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> str2Length = Optional.ofNullable(str2).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(str1Length + str2Length);<span class=\"comment\">//8，8+0</span></span><br><span class=\"line\"><span class=\"comment\">//步骤分解:</span></span><br><span class=\"line\"><span class=\"comment\">//构建Optional对象</span></span><br><span class=\"line\">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class=\"line\"><span class=\"comment\">//将str1的长度的结果构建成Optional对象</span></span><br><span class=\"line\">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class=\"line\"><span class=\"comment\">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> len = op2.orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(len);<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p>","more":"<ol>\n<li><a href=\"#id1\">Object类与其常用方法</a></li>\n<li><a href=\"#id2\">包装类</a></li>\n<li><a href=\"#id3\">数学处理类</a></li>\n<li><a href=\"#id4\">Scanner类和System类</a></li>\n<li><a href=\"#id5\">日期类</a></li>\n<li><a href=\"#id6\">String类</a></li>\n<li><a href=\"#id7\">StringBuilder类/StringBuffer类</a></li>\n<li><a href=\"#id8\">Optional类</a></li>\n</ol>\n<h3 id=\"常用的包\"><a href=\"#常用的包\" class=\"headerlink\" title=\"常用的包\"></a>常用的包</h3><ul>\n<li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li>\n<li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li>\n<li>java.io包：是输入输出包，包括读写各种设备。</li>\n<li>java.net包：是网络编程的包，包括各种网络编程。</li>\n<li>java.sql包：是操作数据库的所有类和接口。</li>\n</ul>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-Object类与其常用方法\"><a href=\"#1-Object类与其常用方法\" class=\"headerlink\" title=\"1. Object类与其常用方法\"></a>1. Object类与其常用方法</h3><h4 id=\"1-1-Object类\"><a href=\"#1-1-Object类\" class=\"headerlink\" title=\"1.1 Object类\"></a>1.1 Object类</h4><ul>\n<li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li>\n<li>Object定义了“对象”的基本行为，被子类默认继承。</li>\n</ul>\n<h4 id=\"1-2-equals-和-hashCode\"><a href=\"#1-2-equals-和-hashCode\" class=\"headerlink\" title=\"1.2 equals() 和 hashCode()\"></a>1.2 equals() 和 hashCode()</h4><ul>\n<li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li>\n<li>equals()方法要求：自反性/对称性/传递性/一致性/非空性。</li>\n<li>Java类可以根据需要重写继承自Object的equals()方法。</li>\n</ul>\n<blockquote>\n<p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p>\n</blockquote>\n<ul>\n<li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p>\n</li>\n<li><p>hashCode规范要求：</p>\n<ul>\n<li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li>\n<li>如果两个对象判定相等，它们的hashCode应该时同一个值</li>\n<li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li>\n</ul>\n</li>\n<li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p>\n</li>\n</ul>\n<h4 id=\"1-3-toString\"><a href=\"#1-3-toString\" class=\"headerlink\" title=\"1.3 toString()\"></a>1.3 toString()</h4><ul>\n<li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li>\n<li>Java类可以根据需要重写toString方法返回更有意义的信息。</li>\n<li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li>\n</ul>\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-包装类\"><a href=\"#2-包装类\" class=\"headerlink\" title=\"2. 包装类\"></a>2. 包装类</h3><h4 id=\"2-1-包装类\"><a href=\"#2-1-包装类\" class=\"headerlink\" title=\"2.1 包装类\"></a>2.1 包装类</h4><ul>\n<li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li>\n<li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>基本类型</th>\n<th>对应包装类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte</td>\n<td>java.lang.Byte</td>\n</tr>\n<tr>\n<td>short</td>\n<td>java.lang.Short</td>\n</tr>\n<tr>\n<td>int</td>\n<td>java.lang.Integer</td>\n</tr>\n<tr>\n<td>long</td>\n<td>java.lang.Long</td>\n</tr>\n<tr>\n<td>float</td>\n<td>java.lang.Float</td>\n</tr>\n<tr>\n<td>double</td>\n<td>java.lang.Double</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>java.lang.Boolean</td>\n</tr>\n<tr>\n<td>char</td>\n<td>java.lang.Character</td>\n</tr>\n</tbody></table>\n<ol>\n<li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li>\n<li>八个包装类中有六个是与数字相关，都默认继承父类Number</li>\n<li>八个包装类都实现了Serializable, Comparable</li>\n<li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li>\n<li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li>\n</ol>\n<h4 id=\"2-2-Integer类\"><a href=\"#2-2-Integer类\" class=\"headerlink\" title=\"2.2 Integer类\"></a>2.2 Integer类</h4><ul>\n<li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li>\n<li>Integer类重写了<strong>equals()</strong>方法（重写后比较的是数值）、hashCode()以及toString()方法。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Integer类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Integer(int i)</td>\n<td>根据参数指定整数来构造对象</td>\n</tr>\n<tr>\n<td>Integer(String s)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>int intValue()</td>\n<td>获取调用对象中整数值并返回</td>\n</tr>\n<tr>\n<td>static Integer valueOf(int i)</td>\n<td>根据参数指定整数值得到Integer类型对象</td>\n</tr>\n<tr>\n<td>static int parseInt(String s)</td>\n<td>将字符串类型转换为int类型并返回</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-装箱和拆箱\"><a href=\"#2-3-装箱和拆箱\" class=\"headerlink\" title=\"2.3 装箱和拆箱\"></a>2.3 装箱和拆箱</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer it = Integer.valueOf(i); <span class=\"comment\">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = it.intValue();<span class=\"comment\">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class=\"line\">Integer i = <span class=\"number\">100</span>;<span class=\"comment\">//自动装箱</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = i;<span class=\"comment\">//自动拆箱</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>笔试考点：<blockquote>\n<ul>\n<li>在Integer类部提供了自动装箱池技术，将<strong>-128~127间的整数已经装箱完毕</strong>，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li>\n<li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer it1 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it2 = <span class=\"number\">128</span>;</span><br><span class=\"line\">Integer it3 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">Integer it4 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">128</span>);</span><br><span class=\"line\">System.out.println(it1.equals(it2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it1 == it2);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\">System.out.println(it3.equals(it4));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it3 == it4);<span class=\"comment\">//比较地址 false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Integer it5 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it6 = <span class=\"number\">127</span>;</span><br><span class=\"line\">Integer it7 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">Integer it8 = <span class=\"keyword\">new</span> Integer(<span class=\"number\">127</span>);</span><br><span class=\"line\">System.out.println(it5.equals(it6));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it5 == it6);<span class=\"comment\">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class=\"line\">System.out.println(it7.equals(it8));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(it7 == it8);<span class=\"comment\">//比较地址 false</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-数学处理类\"><a href=\"#3-数学处理类\" class=\"headerlink\" title=\"3. 数学处理类\"></a>3. 数学处理类</h3><ul>\n<li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>返回值类型</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Math.abs()</td>\n<td></td>\n<td>返回给定数字的绝对值(参数 int long float double)</td>\n</tr>\n<tr>\n<td>Math.ceil()</td>\n<td>double</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>Math.floor()</td>\n<td>double</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>Math.rint()</td>\n<td>double</td>\n<td>临近的整数 如果两边距离一样 则返回偶数</td>\n</tr>\n<tr>\n<td>Math.round()</td>\n<td>int</td>\n<td>四舍五入的整数</td>\n</tr>\n<tr>\n<td>Math.max(a,b)/min(a,b)</td>\n<td></td>\n<td>(参数int  long  float  double)</td>\n</tr>\n<tr>\n<td>Math.pow(a,b)</td>\n<td>double</td>\n<td>a的b次方  (参数double 返回值double)</td>\n</tr>\n<tr>\n<td>Math.sqrt(double a)</td>\n<td></td>\n<td>获取给定参数的平方根</td>\n</tr>\n<tr>\n<td>Math.random()</td>\n<td>double</td>\n<td>随机产生一个[0.0–1.0)</td>\n</tr>\n</tbody></table>\n<ul>\n<li>0-9之间的随机整数：int value = (int)<strong>(Math.random()*10</strong>);</li>\n<li>Math.random()计算小数的时候精确程度可能有些损失</li>\n</ul>\n<h4 id=\"3-1-Random类\"><a href=\"#3-1-Random类\" class=\"headerlink\" title=\"3.1 Random类\"></a>3.1 Random类</h4><ul>\n<li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>常用的方法</th>\n<th>Random r = new Random();</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r.nextInt();</td>\n<td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td>\n</tr>\n<tr>\n<td>r.nextInt(int bound);</td>\n<td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td>\n</tr>\n<tr>\n<td>r.nextFloat()</td>\n<td>随机产生一个 [0.0—1.0)</td>\n</tr>\n<tr>\n<td>r.nextBoolean()</td>\n<td>随机产生一个boolean值   true  false</td>\n</tr>\n</tbody></table>\n<h4 id=\"3-2-UUID类\"><a href=\"#3-2-UUID类\" class=\"headerlink\" title=\"3.2 UUID类\"></a>3.2 UUID类</h4><ul>\n<li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li>\n<li>只有有参构造方法，我们通常不会创建对象</li>\n<li>UUID uuid = UUID.randomUUID();//通常用于数据库表格主键 primary key</li>\n<li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li>\n</ul>\n<h4 id=\"3-3-BigDecimal\"><a href=\"#3-3-BigDecimal\" class=\"headerlink\" title=\"3.3 BigDecimal\"></a>3.3 BigDecimal</h4><ul>\n<li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li>\n<li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li>\n<li>提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi = new BigDecimal(“1.23”);</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>BigDecimal类的常用方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BigDecimal(String val)</td>\n<td>根据参数指定的字符串来构造对象</td>\n</tr>\n<tr>\n<td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td>\n<td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>add</strong>(BigDecimal augend)</td>\n<td>用于实现<strong>加法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td>\n<td>用于实现<strong>减法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td>\n<td>用于实现<strong>乘法</strong>运算</td>\n</tr>\n<tr>\n<td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td>\n<td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"3.0\"</span>);</span><br><span class=\"line\">BigDecimal d4 = <span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"2.9\"</span>);</span><br><span class=\"line\">System.out.println(d3.add(d4));<span class=\"comment\">//加：5.9</span></span><br><span class=\"line\">System.out.println(d3.subtract(d4));<span class=\"comment\">//减：0.1</span></span><br><span class=\"line\">System.out.println(d3.multiply(d4));<span class=\"comment\">//乘：8.70</span></span><br><span class=\"line\">System.out.println(d3.divide(d4, <span class=\"number\">8</span>, BigDecimal.ROUND_HALF_UP));<span class=\"comment\">//除：1.03448276</span></span><br></pre></td></tr></table></figure>\n\n<p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p>\n<h4 id=\"3-4-BigInteger\"><a href=\"#3-4-BigInteger\" class=\"headerlink\" title=\"3.4 BigInteger\"></a>3.4 BigInteger</h4><ul>\n<li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li>\n<li>java提供的整数类型(int\\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li>\n<li>如何创建对象，提供的构造方法全部都是带参数的<ul>\n<li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi = new BigInteger(“123”);</li>\n</ul>\n</li>\n<li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li>\n</ul>\n<h4 id=\"3-5-DecimalFormat类\"><a href=\"#3-5-DecimalFormat类\" class=\"headerlink\" title=\"3.5 DecimalFormat类\"></a>3.5 DecimalFormat类</h4><ul>\n<li>所属的包 java.text，import导入才能使用</li>\n<li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class=\"line\">DecimalFormat df = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.000\"</span>);</span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.450</span></span><br><span class=\"line\">System.out.println(df.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df2 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"###.###\"</span>);</span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//12.45</span></span><br><span class=\"line\">System.out.println(df2.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br><span class=\"line\"></span><br><span class=\"line\">DecimalFormat df3 = <span class=\"keyword\">new</span> DecimalFormat(<span class=\"string\">\"000.###\"</span>);</span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12.45</span>)); <span class=\"comment\">//012.45</span></span><br><span class=\"line\">System.out.println(df3.format(<span class=\"number\">12345.6789</span>)); <span class=\"comment\">//12345.679</span></span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-Scanner类和System类\"><a href=\"#4-Scanner类和System类\" class=\"headerlink\" title=\"4. Scanner类和System类\"></a>4. Scanner类和System类</h3><h4 id=\"4-1-Scanner类\"><a href=\"#4-1-Scanner类\" class=\"headerlink\" title=\"4.1 Scanner类\"></a>4.1 Scanner类</h4><ol>\n<li>所属的包java.util包  需要import导包</li>\n<li>通过一个带输入流的构造方法创建对象</li>\n<li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li>\n</ol>\n<h4 id=\"4-1-System类\"><a href=\"#4-1-System类\" class=\"headerlink\" title=\"4.1 System类\"></a>4.1 System类</h4><ol>\n<li>所属的包java.lang包 不需要导入</li>\n<li>不需要创建对象  通过类名就可以访问</li>\n<li>有三个属性及若干的方法<ul>\n<li>三个属性out   in   err</li>\n<li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-日期类\"><a href=\"#5-日期类\" class=\"headerlink\" title=\"5. 日期类\"></a>5. 日期类</h3><h4 id=\"5-1-Date类\"><a href=\"#5-1-Date类\" class=\"headerlink\" title=\"5.1 Date类\"></a>5.1 Date类</h4><ul>\n<li>java.util.Date类表示特定的瞬间，精确到毫秒。</li>\n<li>通常使用无参数的构造方法，或者带long构造方法</li>\n<li>Date类中常用的方法<ul>\n<li>before();  after();</li>\n<li>setTime()  getTime();—–&gt;long</li>\n<li>compareTo();   //-1  1  0</li>\n</ul>\n</li>\n<li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();<span class=\"comment\">//当前日期信息</span></span><br><span class=\"line\">    <span class=\"comment\">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> time = date.getTime();<span class=\"comment\">//1970年1月1日距今毫秒数。</span></span><br><span class=\"line\">date.setTime(time + <span class=\"number\">24</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">60</span>\\*<span class=\"number\">1000</span>);<span class=\"comment\">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-SimpleDateFormat类\"><a href=\"#5-2-SimpleDateFormat类\" class=\"headerlink\" title=\"5.2 SimpleDateFormat类\"></a>5.2 SimpleDateFormat类</h4><ul>\n<li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li>\n<li>其构造方法 SimpleDateFormat(String pattern)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Date date = <span class=\"keyword\">new</span> Date();</span><br><span class=\"line\">SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy年MM月dd日\"</span>);</span><br><span class=\"line\">String dateStr = sdf.format(date);</span><br><span class=\"line\"><span class=\"comment\">// format用于将日期按指定格式转换为字符串</span></span><br><span class=\"line\"></span><br><span class=\"line\">String str = <span class=\"string\">\"2013-01-06\"</span>;</span><br><span class=\"line\">SimpleDateFormat sdf2 = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd\"</span>);</span><br><span class=\"line\">Date date2 = sdf2.parse(str);<span class=\"comment\">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>常用格式字符串</th>\n<th>含义</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>y</td>\n<td>年</td>\n<td>yyyy年——2013年；yy——13年</td>\n</tr>\n<tr>\n<td>M</td>\n<td>月</td>\n<td>MM月——01月；M月——1月</td>\n</tr>\n<tr>\n<td>d</td>\n<td>日</td>\n<td>dd日——01日；d日——1日</td>\n</tr>\n<tr>\n<td>H</td>\n<td>小时(24)</td>\n<td>HH:mm:ss—12:46:33</td>\n</tr>\n<tr>\n<td>h</td>\n<td>小时(12)</td>\n<td>hh(a):mm:ss—12(下午):47:48</td>\n</tr>\n<tr>\n<td>m</td>\n<td>分钟</td>\n<td>–</td>\n</tr>\n<tr>\n<td>s</td>\n<td>秒</td>\n<td>–</td>\n</tr>\n</tbody></table>\n<h4 id=\"5-3-Calendar类\"><a href=\"#5-3-Calendar类\" class=\"headerlink\" title=\"5.3 Calendar类\"></a>5.3 Calendar类</h4><ul>\n<li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li>\n<li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li>\n<li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Calendar c1 = Calendar.getInstance();</span><br><span class=\"line\">c1.set(<span class=\"number\">2008</span>,<span class=\"number\">9</span>-<span class=\"number\">1</span>,<span class=\"number\">20</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>,<span class=\"number\">8</span>);</span><br><span class=\"line\">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>常用方法</p>\n<ul>\n<li>after()  before()</li>\n<li>setTime()  getTime()—-&gt;Date</li>\n<li>getTimeInMillis()—-time</li>\n<li>getTimeZone()—TimeZone</li>\n<li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li>\n<li>set   get<ul>\n<li>calendar.set(Calendar.YEAR,2015);</li>\n<li>int year = calendar.get(Calendar.YEAR);</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TimeZone</p>\n<ol>\n<li>java.util包</li>\n<li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li>\n<li>常用方法<ul>\n<li>tz.getID()       —-&gt;    Asia/Shanghai</li>\n<li>tz.getDisplayName()    —-&gt;  中国标准时间</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-String类\"><a href=\"#6-String类\" class=\"headerlink\" title=\"6. String类\"></a>6. String类</h3><h4 id=\"6-1-基本概念\"><a href=\"#6-1-基本概念\" class=\"headerlink\" title=\"6.1 基本概念\"></a>6.1 基本概念</h4><ul>\n<li>String类 —&gt; 引用类型  —&gt; java.lang包</li>\n<li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<string></string></li>\n<li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li>\n<li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如何构建对象</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"abc\"</span>; <span class=\"comment\">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class=\"line\">String str2 = <span class=\"keyword\">new</span> String();<span class=\"comment\">//无参数构造方法创建空的对象</span></span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"abc\"</span>);<span class=\"comment\">//带string参数的构造方法创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] bArr = &#123;<span class=\"number\">97</span>, <span class=\"number\">98</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">101</span>&#125;;<span class=\"comment\">//a:97，b:98，c:99，d:100</span></span><br><span class=\"line\">String str4 = <span class=\"keyword\">new</span> String(bArr);<span class=\"comment\">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>[] cArr = &#123;<span class=\"string\">'h'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>&#125;;</span><br><span class=\"line\">String str5 = <span class=\"keyword\">new</span> String(cArr);<span class=\"comment\">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class=\"line\">String str6 = String(<span class=\"keyword\">char</span>[], index, count);<span class=\"comment\">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class=\"line\">String str7 = String(<span class=\"keyword\">byte</span>[], index, length);<span class=\"comment\">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符串常量池\"><a href=\"#6-2-字符串常量池\" class=\"headerlink\" title=\"6.2 字符串常量池\"></a>6.2 字符串常量池</h4><ul>\n<li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li>\n<li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">String str3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">System.out.println(str1.equals(str2));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//比较地址 true，不会重新创建</span></span><br><span class=\"line\">System.out.println(str1.equals(str3));<span class=\"comment\">//比较内容 true</span></span><br><span class=\"line\">System.out.println(str1==str3);<span class=\"comment\">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class=\"line\">    <span class=\"comment\">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class=\"line\">String s1 = <span class=\"string\">\"hello\"</span>; <span class=\"comment\">//1个对象，常量池。</span></span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-3-String类常用方法\"><a href=\"#6-3-String类常用方法\" class=\"headerlink\" title=\"6.3 String类常用方法\"></a>6.3 String类常用方法</h4><ol>\n<li>第一梯队(重写): equals  hashCode  compareTo  toString</li>\n<li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li>\n<li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li>\n</ol>\n<ul>\n<li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol>\n<li>boolean = equals(Object obj);<ul>\n<li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（==与equals()区别）;</li>\n</ul>\n</li>\n<li>int = hashCode();<ul>\n<li>继承自Object类中的方法，重写了：31*h+和…</li>\n</ul>\n</li>\n<li>int = compareTo();<ul>\n<li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li>\n</ul>\n</li>\n<li>String = toString()<ul>\n<li>Object类中返回类名@hashCode(16进制形式)</li>\n<li>String类重写后返回的是String对象的字面值</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>String类的成员方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>char charAt(int index)</td>\n<td>返回字符串指定位置</td>\n</tr>\n<tr>\n<td>int codePointAt(int index)</td>\n<td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td>\n</tr>\n<tr>\n<td>String concat(String)</td>\n<td>将给定的字符串拼接在当前字符串之后</td>\n</tr>\n<tr>\n<td>int length()</td>\n<td>返回字符串序列的长度</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str6 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"下标为0的字符是：\"</span>+str6.charAt(<span class=\"number\">0</span>));<span class=\"comment\">// h</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"字符串长度是：\"</span>+str6.length());<span class=\"comment\">// 5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//将字符串\"12345\"转换为整数类型</span></span><br><span class=\"line\">String str = <span class=\"keyword\">new</span> String(<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//方式一：Integer类中的pareseInt方法</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ia = Integer.parseInt(str);</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ ia);<span class=\"comment\">//123456</span></span><br><span class=\"line\">    <span class=\"comment\">//方式二：利用ASCII数值进行转换'1'-'0'=1，'2'-'0'=2，...</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class=\"line\">    res = res*<span class=\"number\">10</span> + (str.charAt(i)-<span class=\"string\">'0'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"转换出来结果是：\"</span>+ res);<span class=\"comment\">//123456</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>String类的常用基本方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean contains(CharSequence s)</td>\n<td>判断当前字符串是否包含参数指定的内容</td>\n</tr>\n<tr>\n<td>String toLowerCase()</td>\n<td>返回小写形式</td>\n</tr>\n<tr>\n<td>String toUpperCase()</td>\n<td>返回大写形式</td>\n</tr>\n<tr>\n<td>String trim()</td>\n<td>返回去掉前后空格的字符串</td>\n</tr>\n<tr>\n<td>boolean startsWith(String prefix)</td>\n<td>判断是否以参数字符开头</td>\n</tr>\n<tr>\n<td>boolean endsWith(String suffix)</td>\n<td>判断是否以参数字符结尾</td>\n</tr>\n<tr>\n<td>boolean equals(Object anObject)</td>\n<td>比较字符串内容是否相等，String类已重写</td>\n</tr>\n<tr>\n<td>boolean equalsIgnoreCase(String anotherString)</td>\n<td>同上，并且忽略大小写</td>\n</tr>\n<tr>\n<td>int indexOf(String str)</td>\n<td>返回第一次出现str位置，找不到返回-1</td>\n</tr>\n<tr>\n<td>int indexOf(String str, int fromIndex)</td>\n<td>同上，从fromIndex开始检索</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex, int endIndex)</td>\n<td>截取字符串，beginIndex开始，endIndex结束</td>\n</tr>\n<tr>\n<td>String substring(int beginIndex)</td>\n<td>截取字符串，beginIndex开始到结尾</td>\n</tr>\n</tbody></table>\n<h4 id=\"6-4-正则相关方法\"><a href=\"#6-4-正则相关方法\" class=\"headerlink\" title=\"6.4 正则相关方法\"></a>6.4 正则相关方法</h4><ul>\n<li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>正则相关方法</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean matches(String regex)</td>\n<td>用于判断是否匹配正则表达式规则。</td>\n</tr>\n<tr>\n<td>String[] split(String regx)</td>\n<td>以正则为分割符，将字符串拆分成字符串数组</td>\n</tr>\n<tr>\n<td>String replaceAll(String regex, String replacement)</td>\n<td>正则替换</td>\n</tr>\n</tbody></table>\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-StringBuilder类-StringBuffer类\"><a href=\"#7-StringBuilder类-StringBuffer类\" class=\"headerlink\" title=\"7. StringBuilder类/StringBuffer类\"></a>7. StringBuilder类/StringBuffer类</h3><h4 id=\"7-1-基本概念\"><a href=\"#7-1-基本概念\" class=\"headerlink\" title=\"7.1 基本概念\"></a>7.1 基本概念</h4><ol>\n<li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li>\n<li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul>\n<li>StringBuffer/StringBuilder没有compareTo方法</li>\n<li>StringBuffer/StringBuilder含有一个String没有的方法 append();拼接</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"7-2-特性\"><a href=\"#7-2-特性\" class=\"headerlink\" title=\"7.2 特性\"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p>\n<h4 id=\"7-3-对象的构建\"><a href=\"#7-3-对象的构建\" class=\"headerlink\" title=\"7.3 对象的构建\"></a>7.3 对象的构建</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    <span class=\"comment\">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">20</span>);</span><br><span class=\"line\">    <span class=\"comment\">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"abc\"</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-4-StringBuilder中常用的方法\"><a href=\"#7-4-StringBuilder中常用的方法\" class=\"headerlink\" title=\"7.4 StringBuilder中常用的方法\"></a>7.4 StringBuilder中常用的方法</h4><ul>\n<li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li>\n<li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li>\n<li>capacity();//字符串底层char[]的容量</li>\n<li>length();//字符串有效元素个数(长度)</li>\n<li>setLength();//设置字符串的有效元素个数</li>\n<li>char = charAt(int index);</li>\n<li>int = codePointAt(int index);</li>\n<li>String = substring(int start [,int end]);//注意需要接受返回值 看见截取出来的新字符串效果</li>\n<li>StringBuilder = delete(int start [,int end]);//StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li>\n<li>StringBuilder = deleteCharAt(int index);//String类中没有的方法，将给定index位置的某一个字符删除掉啦</li>\n<li>int = indexOf(String str [,int fromIndex]);</li>\n<li>int = lastIndexOf(String str [,int fromIndex]);//找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li>\n<li>insert(int index,value);//将给定的value插入在index位置之上</li>\n<li>replace(int start,int end,String str);//将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li>\n<li>setCharAt(int index,char value);//将index位置的字符改成给定的value</li>\n<li>toString();//将StringBuilder对象 构建成一个string对象 返回</li>\n<li>trimToSize();//将数组中无用的容量去掉  变成length长度的数组</li>\n</ul>\n<h4 id=\"7-5-总结\"><a href=\"#7-5-总结\" class=\"headerlink\" title=\"7.5 总结\"></a>7.5 总结</h4><ol>\n<li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li>\n<li>常用方法<ul>\n<li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li>\n<li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li>\n<li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li>\n</ul>\n</li>\n<li>String家族笔试中经常容易考察的知识点</li>\n<li>String所属的包 继承关系 实现接口<ul>\n<li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li>\n</ul>\n</li>\n<li>String构建方式<ul>\n<li>常量  构造方法  </li>\n</ul>\n</li>\n<li>String对象内存结构<ul>\n<li>字符串常量区  new堆内存对象</li>\n<li>==  equals()区别</li>\n<li>“a”+”b”+”c”</li>\n</ul>\n</li>\n<li>String不可变特性<ul>\n<li>长度及内容</li>\n</ul>\n</li>\n<li>String中的常用方法<ul>\n<li>concat();  toUpperCase();</li>\n</ul>\n</li>\n<li>String和StringBuilder区别   |   String和StringBuffer区别<ul>\n<li>String不可变字符串<ul>\n<li>JDK1.0</li>\n<li>有一个接口Comparable</li>\n<li>不可变体现在长度及内容</li>\n<li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li>\n</ul>\n</li>\n<li>StringBuilder可变字符串<ul>\n<li>JDK1.5</li>\n<li>有一个接口Appendable</li>\n<li>可变字符串  没有final修饰  底层可以进行数组扩容</li>\n<li>有一些方法String没有  append() insert() delete() reverse()</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>StringBuffer和StringBuilder的不同<ul>\n<li>它们方法基本相同</li>\n<li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li>\n<li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li>\n</ul>\n</li>\n</ol>\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-Optional类\"><a href=\"#8-Optional类\" class=\"headerlink\" title=\"8. Optional类\"></a>8. Optional类</h3><ul>\n<li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li>\n<li>获取字符串长度：<ol>\n<li>方式1：if(null==str){return 0;}else{return str.length();}</li>\n<li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取两个字符串长度和</span></span><br><span class=\"line\">String str1 = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> str1Length = Optional.ofNullable(str1).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> str2Length = Optional.ofNullable(str2).map(String::length).orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(str1Length + str2Length);<span class=\"comment\">//8，8+0</span></span><br><span class=\"line\"><span class=\"comment\">//步骤分解:</span></span><br><span class=\"line\"><span class=\"comment\">//构建Optional对象</span></span><br><span class=\"line\">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class=\"line\"><span class=\"comment\">//将str1的长度的结果构建成Optional对象</span></span><br><span class=\"line\">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class=\"line\"><span class=\"comment\">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> len = op2.orElse(<span class=\"number\">0</span>);</span><br><span class=\"line\">System.out.println(len);<span class=\"comment\">//8</span></span><br></pre></td></tr></table></figure>"},{"title":"六、JavaSE输入输出(IO)","date":"2019-07-09T09:31:22.000Z","_content":"\n\n输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。\n<!-- more -->\n\n1. [File类](#id1)\n2. [IO流](#id2)\n3. [文件流](#id3)\n4. [字节型文件流](#id4)\n5. [字符型文件流](#id5)\n6. [*缓冲流](#id6)\n7. [转换流](#id7)\n8. [对象流](#id8)\n9. [打印流(PrintStream类)](#id9)\n10. [Properties类的使用](#id10)\n\n<span id=\"id1\"><span>\n### 1. File类\n- File与真实硬盘中的文件或文件夹  不是一个东西\n    * File是在内存中的一个对象<---映射--->硬盘上的文件或文件夹\n- java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。\n- File类中的常用的方法\n    + canRead()，canWrite()，isHidden()，isFile()，isDirectory()\n    + length()，获取文件中字节的个数\n    + lastModified()，获取文件最后的修改时间--->毫秒值\n    + *String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt\n        * 绝对路径<---->相对路径\n        * 绝对路径可以通过完整的字符串，定位盘符，文件夹，文件\n        * 相对路径没有盘符的写法，当前工程(项目)所在的位置找寻\n    + String name = getName()，获取文件的名字    Test.txt\n    + *boolean = **createNewFile()**，创建新的文件\n    + *boolean = **mkdir** ，创建新的文件夹  外层没有 不能创建\n    + *boolean = **mkdirs**，创建新的文件夹  外层没有 可以自动创建\n    + String pname = getParent()，获取当前file的父亲file名字\n    + *File file = getParentFile()，获取当前file的父亲file对象\n    + String[] names = list()，获取当前file的所有儿子名字\n    + *File[] files = listFiles()，获取当前file的所有儿子对象\n    + *boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹\n- 文件夹的路径(找父目录)\n\n``` java\n//查找当前file的所有父目录\nFile file = new File(\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\");\nFile pfile = file.getParentFile();\nwhile(pfile!=null){\n    System.out.println(pfile.getAbsolutePath());\n    pfile = pfile.getParentFile();//再找一遍\n}\n```\n\n- 文件夹的遍历----需要一个递归\n\n``` java\n//设计一个方法  用来展示(遍历)文件夹,参数-->file(代表文件或文件夹)\npublic void showFile(File file){\n    //获取file的子元素\n    //files==null是个文件\n    //files!=null是个文件夹\n    //files.length!=0是一个带元素的文件夹\n    File[] files = file.listFiles();//test文件夹所有子元素\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.showFile(f);\n        }\n    }\n    //做自己的显示(file是文件或file是一个空的文件夹)\n    System.out.println(file.getAbsolutePath());\n}\n```\n\n- 文件夹的删除----需要一个递归\n\n``` java\n//设计一个方法 删除文件夹,参数 file\npublic void deleteFile(File file){\n    //判断file不是空文件夹\n    File[] files = file.listFiles();\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.deleteFile(f);\n        }\n    }\n    //删除file (file是个文件或file是一个空文件夹)\n    file.delete();\n}\n```\n\n\n<span id=\"id2\"><span>\n### 2. IO流\n- 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 \n- 流的分类:\n    * 根据处理数据类型的不同分为：字符流和字节流\n    * 根据数据流向不同分为：输入流in(读取)和输出流out(写入)\n    * 操作的目标来区分:\n        - 文件流，数组流，字符串流，数据流，对象流，网络流...\n- IO流的框架结构\n\n```\n|——IO流\n    |————字节流\n        |————InputStream\n            |————FileInputStream\n            |————DataInputStream\n            |————ObjectInputStream\n        |————OutputStream\n            |————FileOutputStream\n            |————DataOutputStream\n            |————ObjectOutputStream\n            |————PrintStream\n    |————字符流\n        |————Reader\n            |————BufferedReader\n            |————InputStreamReader\n        |————Writer\n            |————BufferedWriter\n            |————OutputStreamWriter\n```\n\n\n<span id=\"id3\"><span>\n### 3. 文件流\n读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分\n- 字节型文件流(1字节)：FileInputStream/FileOutputStream\n- 字符型文件流(2字节--1字符)：FileReader/FileWriter\n- 字节流和字符流的区别：\n    * 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n    * 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n- 结论：只要是处理**纯文本**数据，就优先考虑使用**字符流**。 除此之外都使用**字节流**。\n- 输入流和输出流\n    * 对输入流只能进行**读**操作，对输出流只能进行**写**操作。 \n\n\n<span id=\"id4\"><span>\n### 4. 字节型文件流\n#### 4.1 字节型文件输入流FileInputStream(读)\n- FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    + int code = read();    每次从流管道中读取一个字节，返回字节的code码\n    + *int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数\n    + int count = available();   返回流管道中还有多少缓存的字节数\n    + skip(long n);跳过几个字节  读取\n        * 多线程--->利用几个线程同时读取文件\n    + *close()    将流管道关闭---必须要做,最好放在finally里\n        * 注意代码的健壮性，判断严谨（eg:非空判断）\n    \n#### 4.2 字节型文件输出流FileOutputStream(写)\n- FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。\n- 创建对象\n    + 调用一个带File参数，还有File boolean重载\n    + 调用一个带String参数，还有String boolean重载\n    + eg: new FileOutputStream(\"D://test//bbb.txt\", true)//第二个参控制每次写入追加还是重载\n- 常用方法\n    + write(int code);  将给定code对应的字符写入文件   '='\n    + write(byte[]);  将数组中的全部字节写入文件   getByte()\n    + write(byte[] b, int off, int len);\n    + flush();    将管道内的字节推入(刷新)文件\n    + close();    注意在finally中关闭\n\n> - 创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException\n> - 创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件\n\n* 设计一个文件复制的方法\n\n``` java\npublic void copyFile(File file, String path) {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n        //创建输入流读取信息\n        fis = new FileInputStream(file);\n        //创建一个新的File对象\n        File newFile = new File(path +\"\\\\\"+ file.getName());//\"E:\\\\test\\\\test.txt\"\n        //创建一个输出流\n        fos = new FileOutputStream(newFile);\n        byte[] b = new byte[1024];//通常1kb-8kb之间\n        int count = fis.read(b);\n        while(count != -1) {\n            fos.write(b, 0, count);//将读取到的有效字节写入\n            fos.flush();\n            count = fis.read(b);\n        }\n        System.out.println(\"复制完毕！\");\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        //关闭\n        if(fis!=null) {\n            try { fis.close(); }\n            catch (IOException e) {e.printStackTrace();}\n        }\n        if(fos!=null) {\n            try {fos.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n    }\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. 字符型文件流\nFileReader/FileWriter：只能操作纯文本的文件 .txt / .properties\n\n#### 5.1 字符型文件输入流FileReader(读)\n- FileReader类在java.io包，继承自InputStreamReader，Reader\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    * read()\n    * read(char[])\n    * close()\n\n``` java\nFile file = new File(\"F://test//Test.txt\");\ntry {\n    FileReader fr = new FileReader(file);\n    // int code = fr.read();\n    // System.out.println(code);\n    char[] c = new char[1024];\n    int count = fr.read(c);\n    while(count!=-1) {\n        System.out.println(new String(c, 0, count));\n        count = fr.read(c);\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n#### 5.2 字符型文件输出流FileWriter(写)\n- FileWriter类在java.io包，继承自OutputStreamWriter，Writer\n- 构造方法\n    * 带file参数，带file,boolean参数\n    * 带String参数，带String,boolean参数\n- 常用方法\n    * write(int)\n    * write(char[])\n    * write(string)\n    * flush()，close()\n\n\n<span id=\"id6\"><span>\n### 6. *缓冲流\n- 缓冲流,也叫高效流，是对4个基本的File...流的增强，所以也是4个流，按照数据类型分类：\n    * 字节缓冲流：BufferedInputStream，BufferedOutputStream \n    * 字符缓冲流：BufferedReader，BufferedWriter\n- 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n- 缓冲流读写方法与基本的流是一致\n\n#### 6.1 字节缓冲流\n- BufferedInputStream，BufferedOutputStream\n- 构造方法\n    * public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 \n    * public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n\n#### 6.2 字符缓冲流\n- BufferedReader，BufferedWriter\n- 构造方法\n    * public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 \n    * public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n- 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n- 特有方法: \n    * BufferedReader：public String readLine(): 读一行文字。 \n    * BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\n\n``` java\n//设计一个方法，用来用户登录认证\npublic String login(String username, String password) {\n    try {\n        BufferedReader br = new BufferedReader(new FileReader(\"F://test//User.txt\"));\n        //User.txt每行存储格式：张三-123\n        String user = br.readLine();//user表示一行记录，记录账号密码\n        while(user!=null) {\n            //将user信息拆分，分别与参数比较\n            String[] value = user.split(\"-\");//value[0]账号，value[1]密码\n            System.out.println(value[0]);\n            if(value[0].equals(username)) {\n                if(value[1].equals(password)) {\n                    return \"登录成功\";\n                }\n            }\n            user = br.readLine();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return \"账号或密码错误！\";\n}\n```\n\n- readLine方法演示:\n\n```\ntry {\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"F://test//User.txt\", true));\n    bw.newLine();\n    bw.write(\"java-888\");\n    bw.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 转换流\n#### 7.1 字符编码\n- 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n- 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n- 常见字符集:\n    * ASCII字符集 ：\n        + ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）\n    * ISO-8859-1字符集：\n        + 拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。\n    * GBxxx字符集：\n        + GB就是国标的意思，是为了显示中文而设计的一套字符集。\n        + GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）\n    * Unicode字符集 ：\n        + Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n        + UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。\n- 编码引出的问题\n    * 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n\n#### 7.2 InputStreamReader类 \n转换流java.io.InputStreamReader，是Reader的子类，是从**字节流到字符流**的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 \n    * InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n- 指定编码读取:\n\n``` java\npublic class ReaderDemo2 {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径,文件为gbk编码\n       String FileName = \"E:\\\\file_gbk.txt\";\n    // 创建流对象,默认UTF8编码\n       InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n    // 创建流对象,指定GBK编码\n       InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n// 定义变量,保存字符\n       int read;\n    // 使用默认编码字符流读取,乱码\n       while ((read = isr.read()) != -1) {\n           System.out.print((char)read); // ��Һ�\n      }\n       isr.close();\n    // 使用指定编码字符流读取,正常解析\n       while ((read = isr2.read()) != -1) {\n           System.out.print((char)read);// 大家好\n      }\n       isr2.close();\n  }\n}\n```\n\n\n#### 7.3 OutputStreamWriter类 \n转换流java.io.OutputStreamWriter ，是Writer的子类，是从**字符流到字节流**的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 \n    * OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n- 指定编码写出\n\n``` java\npublic class OutputDemo {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径\n       String FileName = \"E:\\\\out.txt\";\n    // 创建流对象,默认UTF8编码\n       OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n       // 写出数据\n    osw.write(\"你好\"); // 保存为6个字节\n       osw.close();\n// 定义文件路径\nString FileName2 = \"E:\\\\out2.txt\";\n    // 创建流对象,指定GBK编码\n       OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n       // 写出数据\n    osw2.write(\"你好\");// 保存为4个字节\n       osw2.close();\n  }\n}\n```\n\n\n<span id=\"id8\"><span>\n### 8. 对象流\n- 对象序列化和反序列化\n    * Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 \n    * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象\n    * 简单来讲\n        + 对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中\n        + 对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象\n        + 如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口； \n        如果想要将对象反序列化：需要给对象提供一个序列化的版本号，`private long serialVersionUID = 任意L`;\n\n\n### 8.1 ObjectOutputStream类\n- java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n- 构造方法\n    * public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\n\n``` java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n- 序列化操作\n    1. 一个对象要想序列化，必须满足两个条件:\n        + 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n        + 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n    2. 写出对象方法\n        + public final void writeObject (Object obj) : 将指定的对象写出。\n``` java\n//满足两个条件\npublic class Employee implements java.io.Serializable {\n   public String name;\n   public String address;\n   public transient int age; // transient瞬态修饰成员,不会被序列化\n   public void addressCheck() {\n    System.out.println(\"Address check : \" + name + \" -- \" + address);\n  }\n}\n//写出对象方法\npublic class SerializeDemo{\n  public static void main(String [] args)   {\n  Employee e = new Employee();\n  e.name = \"zhangsan\";\n  e.address = \"beiqinglu\";\n  e.age = 20; \n  try {\n    // 创建序列化流对象\n         ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n      // 写出对象\n      out.writeObject(e);\n      // 释放资源\n      out.close();\n      fileOut.close();\n      System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n      } catch(IOException i)   {\n           i.printStackTrace();\n      }\n  }\n}\n//输出结果：\n//Serialized data is saved\n```\n\n\n#### 8.1 ObjectInputStream类\n- ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n- 构造方法\n    * public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\n- 反序列化操作1\n    * 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。\n    * 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n    * public final Object readObject () : 读取一个对象。\n\n``` java\npublic class DeserializeDemo {\n  public static void main(String [] args)   {\n       Employee e = null;\n       try {\n            // 创建反序列化流\n            FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            // 读取一个对象\n            e = (Employee) in.readObject();\n            // 释放资源\n            in.close();\n            fileIn.close();\n      }catch(IOException i) {\n            // 捕获其他异常\n            i.printStackTrace();\n            return;\n      }catch(ClassNotFoundException c) {\n      // 捕获类找不到异常\n            System.out.println(\"Employee class not found\");\n            c.printStackTrace();\n            return;\n      }\n       // 无异常,直接打印输出\n       System.out.println(\"Name: \" + e.name);// zhangsan\n       System.out.println(\"Address: \" + e.address); // beiqinglu\n       System.out.println(\"age: \" + e.age); // 0\n  }\n}\n```\n\n\n- 反序列化操作2\n    * 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n        + 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n        + 该类包含未知数据类型 \n        + 该类没有可访问的无参数构造方法 \n    * Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n``` java\npublic class Employee implements java.io.Serializable {\n    // 加入序列版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public String address;\n    // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n    public int eid; \n\n    public void addressCheck() {\n        System.out.println(\"Address check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 打印流(PrintStream类)\n- 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n- 构造方法\n    * `public PrintStream(String fileName);`  使用指定的文件名创建一个新的打印流。\n\n``` java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n- 改变打印流向\n    * System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。\n\n``` java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n        // 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n        // 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n        // 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n        // 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Properties类的使用\n- Java.util.Properties，主要用于读取Java的配置文件。\n- Properties类继承自Hashtable\n- 配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用\"#\"来注释。\n- Properties类的主要方法：\n    1. getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\n    2. load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。\n    3. setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\n    4. store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\n    5. clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。\n\n\n","source":"_posts/06_JavaSE输入输出-IO.md","raw":"---\ntitle: 六、JavaSE输入输出(IO)\ndate: 2019-07-09 17:31:22\ntags: [javaSE, 后端开发]\ncategories: javaSE知识梳理\n---\n\n\n输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。\n<!-- more -->\n\n1. [File类](#id1)\n2. [IO流](#id2)\n3. [文件流](#id3)\n4. [字节型文件流](#id4)\n5. [字符型文件流](#id5)\n6. [*缓冲流](#id6)\n7. [转换流](#id7)\n8. [对象流](#id8)\n9. [打印流(PrintStream类)](#id9)\n10. [Properties类的使用](#id10)\n\n<span id=\"id1\"><span>\n### 1. File类\n- File与真实硬盘中的文件或文件夹  不是一个东西\n    * File是在内存中的一个对象<---映射--->硬盘上的文件或文件夹\n- java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。\n- File类中的常用的方法\n    + canRead()，canWrite()，isHidden()，isFile()，isDirectory()\n    + length()，获取文件中字节的个数\n    + lastModified()，获取文件最后的修改时间--->毫秒值\n    + *String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt\n        * 绝对路径<---->相对路径\n        * 绝对路径可以通过完整的字符串，定位盘符，文件夹，文件\n        * 相对路径没有盘符的写法，当前工程(项目)所在的位置找寻\n    + String name = getName()，获取文件的名字    Test.txt\n    + *boolean = **createNewFile()**，创建新的文件\n    + *boolean = **mkdir** ，创建新的文件夹  外层没有 不能创建\n    + *boolean = **mkdirs**，创建新的文件夹  外层没有 可以自动创建\n    + String pname = getParent()，获取当前file的父亲file名字\n    + *File file = getParentFile()，获取当前file的父亲file对象\n    + String[] names = list()，获取当前file的所有儿子名字\n    + *File[] files = listFiles()，获取当前file的所有儿子对象\n    + *boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹\n- 文件夹的路径(找父目录)\n\n``` java\n//查找当前file的所有父目录\nFile file = new File(\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\");\nFile pfile = file.getParentFile();\nwhile(pfile!=null){\n    System.out.println(pfile.getAbsolutePath());\n    pfile = pfile.getParentFile();//再找一遍\n}\n```\n\n- 文件夹的遍历----需要一个递归\n\n``` java\n//设计一个方法  用来展示(遍历)文件夹,参数-->file(代表文件或文件夹)\npublic void showFile(File file){\n    //获取file的子元素\n    //files==null是个文件\n    //files!=null是个文件夹\n    //files.length!=0是一个带元素的文件夹\n    File[] files = file.listFiles();//test文件夹所有子元素\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.showFile(f);\n        }\n    }\n    //做自己的显示(file是文件或file是一个空的文件夹)\n    System.out.println(file.getAbsolutePath());\n}\n```\n\n- 文件夹的删除----需要一个递归\n\n``` java\n//设计一个方法 删除文件夹,参数 file\npublic void deleteFile(File file){\n    //判断file不是空文件夹\n    File[] files = file.listFiles();\n    if(files!=null && files.length!=0){\n        for(File f:files){\n            this.deleteFile(f);\n        }\n    }\n    //删除file (file是个文件或file是一个空文件夹)\n    file.delete();\n}\n```\n\n\n<span id=\"id2\"><span>\n### 2. IO流\n- 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 \n- 流的分类:\n    * 根据处理数据类型的不同分为：字符流和字节流\n    * 根据数据流向不同分为：输入流in(读取)和输出流out(写入)\n    * 操作的目标来区分:\n        - 文件流，数组流，字符串流，数据流，对象流，网络流...\n- IO流的框架结构\n\n```\n|——IO流\n    |————字节流\n        |————InputStream\n            |————FileInputStream\n            |————DataInputStream\n            |————ObjectInputStream\n        |————OutputStream\n            |————FileOutputStream\n            |————DataOutputStream\n            |————ObjectOutputStream\n            |————PrintStream\n    |————字符流\n        |————Reader\n            |————BufferedReader\n            |————InputStreamReader\n        |————Writer\n            |————BufferedWriter\n            |————OutputStreamWriter\n```\n\n\n<span id=\"id3\"><span>\n### 3. 文件流\n读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分\n- 字节型文件流(1字节)：FileInputStream/FileOutputStream\n- 字符型文件流(2字节--1字符)：FileReader/FileWriter\n- 字节流和字符流的区别：\n    * 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。\n    * 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。\n- 结论：只要是处理**纯文本**数据，就优先考虑使用**字符流**。 除此之外都使用**字节流**。\n- 输入流和输出流\n    * 对输入流只能进行**读**操作，对输出流只能进行**写**操作。 \n\n\n<span id=\"id4\"><span>\n### 4. 字节型文件流\n#### 4.1 字节型文件输入流FileInputStream(读)\n- FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    + int code = read();    每次从流管道中读取一个字节，返回字节的code码\n    + *int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数\n    + int count = available();   返回流管道中还有多少缓存的字节数\n    + skip(long n);跳过几个字节  读取\n        * 多线程--->利用几个线程同时读取文件\n    + *close()    将流管道关闭---必须要做,最好放在finally里\n        * 注意代码的健壮性，判断严谨（eg:非空判断）\n    \n#### 4.2 字节型文件输出流FileOutputStream(写)\n- FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。\n- 创建对象\n    + 调用一个带File参数，还有File boolean重载\n    + 调用一个带String参数，还有String boolean重载\n    + eg: new FileOutputStream(\"D://test//bbb.txt\", true)//第二个参控制每次写入追加还是重载\n- 常用方法\n    + write(int code);  将给定code对应的字符写入文件   '='\n    + write(byte[]);  将数组中的全部字节写入文件   getByte()\n    + write(byte[] b, int off, int len);\n    + flush();    将管道内的字节推入(刷新)文件\n    + close();    注意在finally中关闭\n\n> - 创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException\n> - 创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件\n\n* 设计一个文件复制的方法\n\n``` java\npublic void copyFile(File file, String path) {\n    FileInputStream fis = null;\n    FileOutputStream fos = null;\n    try {\n        //创建输入流读取信息\n        fis = new FileInputStream(file);\n        //创建一个新的File对象\n        File newFile = new File(path +\"\\\\\"+ file.getName());//\"E:\\\\test\\\\test.txt\"\n        //创建一个输出流\n        fos = new FileOutputStream(newFile);\n        byte[] b = new byte[1024];//通常1kb-8kb之间\n        int count = fis.read(b);\n        while(count != -1) {\n            fos.write(b, 0, count);//将读取到的有效字节写入\n            fos.flush();\n            count = fis.read(b);\n        }\n        System.out.println(\"复制完毕！\");\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        //关闭\n        if(fis!=null) {\n            try { fis.close(); }\n            catch (IOException e) {e.printStackTrace();}\n        }\n        if(fos!=null) {\n            try {fos.close();}\n            catch (IOException e) {e.printStackTrace();}\n        }\n    }\n}\n```\n\n\n<span id=\"id5\"><span>\n### 5. 字符型文件流\nFileReader/FileWriter：只能操作纯文本的文件 .txt / .properties\n\n#### 5.1 字符型文件输入流FileReader(读)\n- FileReader类在java.io包，继承自InputStreamReader，Reader\n- 创建对象\n    * 调用一个带File类型的构造方法\n    * 调用一个带String类型的构造方法\n- 常用方法\n    * read()\n    * read(char[])\n    * close()\n\n``` java\nFile file = new File(\"F://test//Test.txt\");\ntry {\n    FileReader fr = new FileReader(file);\n    // int code = fr.read();\n    // System.out.println(code);\n    char[] c = new char[1024];\n    int count = fr.read(c);\n    while(count!=-1) {\n        System.out.println(new String(c, 0, count));\n        count = fr.read(c);\n    }\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n#### 5.2 字符型文件输出流FileWriter(写)\n- FileWriter类在java.io包，继承自OutputStreamWriter，Writer\n- 构造方法\n    * 带file参数，带file,boolean参数\n    * 带String参数，带String,boolean参数\n- 常用方法\n    * write(int)\n    * write(char[])\n    * write(string)\n    * flush()，close()\n\n\n<span id=\"id6\"><span>\n### 6. *缓冲流\n- 缓冲流,也叫高效流，是对4个基本的File...流的增强，所以也是4个流，按照数据类型分类：\n    * 字节缓冲流：BufferedInputStream，BufferedOutputStream \n    * 字符缓冲流：BufferedReader，BufferedWriter\n- 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n- 缓冲流读写方法与基本的流是一致\n\n#### 6.1 字节缓冲流\n- BufferedInputStream，BufferedOutputStream\n- 构造方法\n    * public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 \n    * public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n\n#### 6.2 字符缓冲流\n- BufferedReader，BufferedWriter\n- 构造方法\n    * public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 \n    * public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。\n\n``` java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n- 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n- 特有方法: \n    * BufferedReader：public String readLine(): 读一行文字。 \n    * BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。\n\n``` java\n//设计一个方法，用来用户登录认证\npublic String login(String username, String password) {\n    try {\n        BufferedReader br = new BufferedReader(new FileReader(\"F://test//User.txt\"));\n        //User.txt每行存储格式：张三-123\n        String user = br.readLine();//user表示一行记录，记录账号密码\n        while(user!=null) {\n            //将user信息拆分，分别与参数比较\n            String[] value = user.split(\"-\");//value[0]账号，value[1]密码\n            System.out.println(value[0]);\n            if(value[0].equals(username)) {\n                if(value[1].equals(password)) {\n                    return \"登录成功\";\n                }\n            }\n            user = br.readLine();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return \"账号或密码错误！\";\n}\n```\n\n- readLine方法演示:\n\n```\ntry {\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"F://test//User.txt\", true));\n    bw.newLine();\n    bw.write(\"java-888\");\n    bw.flush();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n\n\n<span id=\"id7\"><span>\n### 7. 转换流\n#### 7.1 字符编码\n- 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。\n- 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n- 常见字符集:\n    * ASCII字符集 ：\n        + ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）\n    * ISO-8859-1字符集：\n        + 拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。\n    * GBxxx字符集：\n        + GB就是国标的意思，是为了显示中文而设计的一套字符集。\n        + GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）\n    * Unicode字符集 ：\n        + Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n        + UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。\n- 编码引出的问题\n    * 在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n\n#### 7.2 InputStreamReader类 \n转换流java.io.InputStreamReader，是Reader的子类，是从**字节流到字符流**的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 \n    * InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n- 指定编码读取:\n\n``` java\npublic class ReaderDemo2 {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径,文件为gbk编码\n       String FileName = \"E:\\\\file_gbk.txt\";\n    // 创建流对象,默认UTF8编码\n       InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n    // 创建流对象,指定GBK编码\n       InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n// 定义变量,保存字符\n       int read;\n    // 使用默认编码字符流读取,乱码\n       while ((read = isr.read()) != -1) {\n           System.out.print((char)read); // ��Һ�\n      }\n       isr.close();\n    // 使用指定编码字符流读取,正常解析\n       while ((read = isr2.read()) != -1) {\n           System.out.print((char)read);// 大家好\n      }\n       isr2.close();\n  }\n}\n```\n\n\n#### 7.3 OutputStreamWriter类 \n转换流java.io.OutputStreamWriter ，是Writer的子类，是从**字符流到字节流**的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n- 构造方法\n    * OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 \n    * OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n``` java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n- 指定编码写出\n\n``` java\npublic class OutputDemo {\n   public static void main(String[] args) throws IOException {\n    // 定义文件路径\n       String FileName = \"E:\\\\out.txt\";\n    // 创建流对象,默认UTF8编码\n       OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n       // 写出数据\n    osw.write(\"你好\"); // 保存为6个字节\n       osw.close();\n// 定义文件路径\nString FileName2 = \"E:\\\\out2.txt\";\n    // 创建流对象,指定GBK编码\n       OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n       // 写出数据\n    osw2.write(\"你好\");// 保存为4个字节\n       osw2.close();\n  }\n}\n```\n\n\n<span id=\"id8\"><span>\n### 8. 对象流\n- 对象序列化和反序列化\n    * Java 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 \n    * 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象\n    * 简单来讲\n        + 对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中\n        + 对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象\n        + 如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口； \n        如果想要将对象反序列化：需要给对象提供一个序列化的版本号，`private long serialVersionUID = 任意L`;\n\n\n### 8.1 ObjectOutputStream类\n- java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n- 构造方法\n    * public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\n\n``` java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n- 序列化操作\n    1. 一个对象要想序列化，必须满足两个条件:\n        + 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n        + 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n    2. 写出对象方法\n        + public final void writeObject (Object obj) : 将指定的对象写出。\n``` java\n//满足两个条件\npublic class Employee implements java.io.Serializable {\n   public String name;\n   public String address;\n   public transient int age; // transient瞬态修饰成员,不会被序列化\n   public void addressCheck() {\n    System.out.println(\"Address check : \" + name + \" -- \" + address);\n  }\n}\n//写出对象方法\npublic class SerializeDemo{\n  public static void main(String [] args)   {\n  Employee e = new Employee();\n  e.name = \"zhangsan\";\n  e.address = \"beiqinglu\";\n  e.age = 20; \n  try {\n    // 创建序列化流对象\n         ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n      // 写出对象\n      out.writeObject(e);\n      // 释放资源\n      out.close();\n      fileOut.close();\n      System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n      } catch(IOException i)   {\n           i.printStackTrace();\n      }\n  }\n}\n//输出结果：\n//Serialized data is saved\n```\n\n\n#### 8.1 ObjectInputStream类\n- ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n- 构造方法\n    * public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\n- 反序列化操作1\n    * 如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。\n    * 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n    * public final Object readObject () : 读取一个对象。\n\n``` java\npublic class DeserializeDemo {\n  public static void main(String [] args)   {\n       Employee e = null;\n       try {\n            // 创建反序列化流\n            FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n            ObjectInputStream in = new ObjectInputStream(fileIn);\n            // 读取一个对象\n            e = (Employee) in.readObject();\n            // 释放资源\n            in.close();\n            fileIn.close();\n      }catch(IOException i) {\n            // 捕获其他异常\n            i.printStackTrace();\n            return;\n      }catch(ClassNotFoundException c) {\n      // 捕获类找不到异常\n            System.out.println(\"Employee class not found\");\n            c.printStackTrace();\n            return;\n      }\n       // 无异常,直接打印输出\n       System.out.println(\"Name: \" + e.name);// zhangsan\n       System.out.println(\"Address: \" + e.address); // beiqinglu\n       System.out.println(\"age: \" + e.age); // 0\n  }\n}\n```\n\n\n- 反序列化操作2\n    * 另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n        + 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n        + 该类包含未知数据类型 \n        + 该类没有可访问的无参数构造方法 \n    * Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n``` java\npublic class Employee implements java.io.Serializable {\n    // 加入序列版本号\n    private static final long serialVersionUID = 1L;\n    public String name;\n    public String address;\n    // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n    public int eid; \n\n    public void addressCheck() {\n        System.out.println(\"Address check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n\n<span id=\"id9\"><span>\n### 9. 打印流(PrintStream类)\n- 平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n- 构造方法\n    * `public PrintStream(String fileName);`  使用指定的文件名创建一个新的打印流。\n\n``` java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n- 改变打印流向\n    * System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。\n\n``` java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n        // 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n        // 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n        // 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n        // 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```\n\n\n\n<span id=\"id10\"><span>\n### 10. Properties类的使用\n- Java.util.Properties，主要用于读取Java的配置文件。\n- Properties类继承自Hashtable\n- 配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用\"#\"来注释。\n- Properties类的主要方法：\n    1. getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。\n    2. load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。\n    3. setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。\n    4. store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。\n    5. clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。\n\n\n","slug":"06_JavaSE输入输出-IO","published":1,"updated":"2019-07-20T14:47:09.875Z","_id":"cjyblnrxy002jxwt33m4tvcj4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p>\n<a id=\"more\"></a>\n\n<ol>\n<li><a href=\"#id1\">File类</a></li>\n<li><a href=\"#id2\">IO流</a></li>\n<li><a href=\"#id3\">文件流</a></li>\n<li><a href=\"#id4\">字节型文件流</a></li>\n<li><a href=\"#id5\">字符型文件流</a></li>\n<li><a href=\"#id6\">*缓冲流</a></li>\n<li><a href=\"#id7\">转换流</a></li>\n<li><a href=\"#id8\">对象流</a></li>\n<li><a href=\"#id9\">打印流(PrintStream类)</a></li>\n<li><a href=\"#id10\">Properties类的使用</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-File类\"><a href=\"#1-File类\" class=\"headerlink\" title=\"1. File类\"></a>1. File类</h3><ul>\n<li>File与真实硬盘中的文件或文件夹  不是一个东西<ul>\n<li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li>\n</ul>\n</li>\n<li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li>\n<li>File类中的常用的方法<ul>\n<li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li>\n<li>length()，获取文件中字节的个数</li>\n<li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li>\n<li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul>\n<li>绝对路径&lt;—-&gt;相对路径</li>\n<li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li>\n<li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li>\n</ul>\n</li>\n<li>String name = getName()，获取文件的名字    Test.txt</li>\n<li><em>boolean = *</em>createNewFile()**，创建新的文件</li>\n<li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li>\n<li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li>\n<li>String pname = getParent()，获取当前file的父亲file名字</li>\n<li>*File file = getParentFile()，获取当前file的父亲file对象</li>\n<li>String[] names = list()，获取当前file的所有儿子名字</li>\n<li>*File[] files = listFiles()，获取当前file的所有儿子对象</li>\n<li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li>\n</ul>\n</li>\n<li>文件夹的路径(找父目录)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找当前file的所有父目录</span></span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\"</span>);</span><br><span class=\"line\">File pfile = file.getParentFile();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(pfile!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(pfile.getAbsolutePath());</span><br><span class=\"line\">    pfile = pfile.getParentFile();<span class=\"comment\">//再找一遍</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的遍历—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取file的子元素</span></span><br><span class=\"line\">    <span class=\"comment\">//files==null是个文件</span></span><br><span class=\"line\">    <span class=\"comment\">//files!=null是个文件夹</span></span><br><span class=\"line\">    <span class=\"comment\">//files.length!=0是一个带元素的文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();<span class=\"comment\">//test文件夹所有子元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class=\"line\">    System.out.println(file.getAbsolutePath());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的删除—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法 删除文件夹,参数 file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断file不是空文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deleteFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class=\"line\">    file.delete();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-IO流\"><a href=\"#2-IO流\" class=\"headerlink\" title=\"2. IO流\"></a>2. IO流</h3><ul>\n<li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li>\n<li>流的分类:<ul>\n<li>根据处理数据类型的不同分为：字符流和字节流</li>\n<li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li>\n<li>操作的目标来区分:<ul>\n<li>文件流，数组流，字符串流，数据流，对象流，网络流…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO流的框架结构</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|——IO流</span><br><span class=\"line\">    |————字节流</span><br><span class=\"line\">        |————InputStream</span><br><span class=\"line\">            |————FileInputStream</span><br><span class=\"line\">            |————DataInputStream</span><br><span class=\"line\">            |————ObjectInputStream</span><br><span class=\"line\">        |————OutputStream</span><br><span class=\"line\">            |————FileOutputStream</span><br><span class=\"line\">            |————DataOutputStream</span><br><span class=\"line\">            |————ObjectOutputStream</span><br><span class=\"line\">            |————PrintStream</span><br><span class=\"line\">    |————字符流</span><br><span class=\"line\">        |————Reader</span><br><span class=\"line\">            |————BufferedReader</span><br><span class=\"line\">            |————InputStreamReader</span><br><span class=\"line\">        |————Writer</span><br><span class=\"line\">            |————BufferedWriter</span><br><span class=\"line\">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-文件流\"><a href=\"#3-文件流\" class=\"headerlink\" title=\"3. 文件流\"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p>\n<ul>\n<li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li>\n<li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li>\n<li>字节流和字符流的区别：<ul>\n<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>\n<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>\n</ul>\n</li>\n<li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li>\n<li>输入流和输出流<ul>\n<li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-字节型文件流\"><a href=\"#4-字节型文件流\" class=\"headerlink\" title=\"4. 字节型文件流\"></a>4. 字节型文件流</h3><h4 id=\"4-1-字节型文件输入流FileInputStream-读\"><a href=\"#4-1-字节型文件输入流FileInputStream-读\" class=\"headerlink\" title=\"4.1 字节型文件输入流FileInputStream(读)\"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul>\n<li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li>\n<li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li>\n<li>int count = available();   返回流管道中还有多少缓存的字节数</li>\n<li>skip(long n);跳过几个字节  读取<ul>\n<li>多线程—&gt;利用几个线程同时读取文件</li>\n</ul>\n</li>\n<li>*close()    将流管道关闭—必须要做,最好放在finally里<ul>\n<li>注意代码的健壮性，判断严谨（eg:非空判断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-字节型文件输出流FileOutputStream-写\"><a href=\"#4-2-字节型文件输出流FileOutputStream-写\" class=\"headerlink\" title=\"4.2 字节型文件输出流FileOutputStream(写)\"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul>\n<li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File参数，还有File boolean重载</li>\n<li>调用一个带String参数，还有String boolean重载</li>\n<li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int code);  将给定code对应的字符写入文件   ‘=’</li>\n<li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li>\n<li>write(byte[] b, int off, int len);</li>\n<li>flush();    将管道内的字节推入(刷新)文件</li>\n<li>close();    注意在finally中关闭</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li>\n<li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li>\n</ul>\n</blockquote>\n<ul>\n<li>设计一个文件复制的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File file, String path)</span> </span>&#123;</span><br><span class=\"line\">    FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileOutputStream fos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建输入流读取信息</span></span><br><span class=\"line\">        fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个新的File对象</span></span><br><span class=\"line\">        File newFile = <span class=\"keyword\">new</span> File(path +<span class=\"string\">\"\\\\\"</span>+ file.getName());<span class=\"comment\">//\"E:\\\\test\\\\test.txt\"</span></span><br><span class=\"line\">        <span class=\"comment\">//创建一个输出流</span></span><br><span class=\"line\">        fos = <span class=\"keyword\">new</span> FileOutputStream(newFile);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//通常1kb-8kb之间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = fis.read(b);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(count != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fos.write(b, <span class=\"number\">0</span>, count);<span class=\"comment\">//将读取到的有效字节写入</span></span><br><span class=\"line\">            fos.flush();</span><br><span class=\"line\">            count = fis.read(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"复制完毕！\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fis!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123; fis.close(); &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fos!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;fos.close();&#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-字符型文件流\"><a href=\"#5-字符型文件流\" class=\"headerlink\" title=\"5. 字符型文件流\"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p>\n<h4 id=\"5-1-字符型文件输入流FileReader-读\"><a href=\"#5-1-字符型文件输入流FileReader-读\" class=\"headerlink\" title=\"5.1 字符型文件输入流FileReader(读)\"></a>5.1 字符型文件输入流FileReader(读)</h4><ul>\n<li>FileReader类在java.io包，继承自InputStreamReader，Reader</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>read()</li>\n<li>read(char[])</li>\n<li>close()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F://test//Test.txt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    FileReader fr = <span class=\"keyword\">new</span> FileReader(file);</span><br><span class=\"line\">    <span class=\"comment\">// int code = fr.read();</span></span><br><span class=\"line\">    <span class=\"comment\">// System.out.println(code);</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = fr.read(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(c, <span class=\"number\">0</span>, count));</span><br><span class=\"line\">        count = fr.read(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-字符型文件输出流FileWriter-写\"><a href=\"#5-2-字符型文件输出流FileWriter-写\" class=\"headerlink\" title=\"5.2 字符型文件输出流FileWriter(写)\"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul>\n<li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li>\n<li>构造方法<ul>\n<li>带file参数，带file,boolean参数</li>\n<li>带String参数，带String,boolean参数</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int)</li>\n<li>write(char[])</li>\n<li>write(string)</li>\n<li>flush()，close()</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-缓冲流\"><a href=\"#6-缓冲流\" class=\"headerlink\" title=\"6. *缓冲流\"></a>6. *缓冲流</h3><ul>\n<li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul>\n<li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li>\n<li>字符缓冲流：BufferedReader，BufferedWriter</li>\n</ul>\n</li>\n<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>\n<li>缓冲流读写方法与基本的流是一致</li>\n</ul>\n<h4 id=\"6-1-字节缓冲流\"><a href=\"#6-1-字节缓冲流\" class=\"headerlink\" title=\"6.1 字节缓冲流\"></a>6.1 字节缓冲流</h4><ul>\n<li>BufferedInputStream，BufferedOutputStream</li>\n<li>构造方法<ul>\n<li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输入流</span></span><br><span class=\"line\">BufferedInputStream bis = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"bis.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输出流</span></span><br><span class=\"line\">BufferedOutputStream bos = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"bos.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符缓冲流\"><a href=\"#6-2-字符缓冲流\" class=\"headerlink\" title=\"6.2 字符缓冲流\"></a>6.2 字符缓冲流</h4><ul>\n<li>BufferedReader，BufferedWriter</li>\n<li>构造方法<ul>\n<li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输入流</span></span><br><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"br.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输出流</span></span><br><span class=\"line\">BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"bw.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li>\n<li>特有方法: <ul>\n<li>BufferedReader：public String readLine(): 读一行文字。 </li>\n<li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法，用来用户登录认证</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"F://test//User.txt\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//User.txt每行存储格式：张三-123</span></span><br><span class=\"line\">        String user = br.readLine();<span class=\"comment\">//user表示一行记录，记录账号密码</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(user!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将user信息拆分，分别与参数比较</span></span><br><span class=\"line\">            String[] value = user.split(<span class=\"string\">\"-\"</span>);<span class=\"comment\">//value[0]账号，value[1]密码</span></span><br><span class=\"line\">            System.out.println(value[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value[<span class=\"number\">0</span>].equals(username)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(value[<span class=\"number\">1</span>].equals(password)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"登录成功\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            user = br.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"账号或密码错误！\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>readLine方法演示:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class=\"line\">    bw.newLine();</span><br><span class=\"line\">    bw.write(&quot;java-888&quot;);</span><br><span class=\"line\">    bw.flush();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-转换流\"><a href=\"#7-转换流\" class=\"headerlink\" title=\"7. 转换流\"></a>7. 转换流</h3><h4 id=\"7-1-字符编码\"><a href=\"#7-1-字符编码\" class=\"headerlink\" title=\"7.1 字符编码\"></a>7.1 字符编码</h4><ul>\n<li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li>\n<li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>\n<li>常见字符集:<ul>\n<li>ASCII字符集 ：<ul>\n<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li>\n</ul>\n</li>\n<li>ISO-8859-1字符集：<ul>\n<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li>\n</ul>\n</li>\n<li>GBxxx字符集：<ul>\n<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>\n<li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li>\n</ul>\n</li>\n<li>Unicode字符集 ：<ul>\n<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>\n<li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码引出的问题<ul>\n<li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-2-InputStreamReader类\"><a href=\"#7-2-InputStreamReader类\" class=\"headerlink\" title=\"7.2 InputStreamReader类\"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>));</span><br><span class=\"line\">InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码读取:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderDemo2</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径,文件为gbk编码</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\file_gbk.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName));</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName) , <span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 定义变量,保存字符</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> read;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认编码字符流读取,乱码</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read); <span class=\"comment\">// ��Һ�</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr.close();</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定编码字符流读取,正常解析</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr2.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read);<span class=\"comment\">// 大家好</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-OutputStreamWriter类\"><a href=\"#7-3-OutputStreamWriter类\" class=\"headerlink\" title=\"7.3 OutputStreamWriter类\"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter isr = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>));</span><br><span class=\"line\">OutputStreamWriter isr2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码写出</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutputDemo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\out.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName));</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw.write(<span class=\"string\">\"你好\"</span>); <span class=\"comment\">// 保存为6个字节</span></span><br><span class=\"line\">       osw.close();</span><br><span class=\"line\"><span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">String FileName2 = <span class=\"string\">\"E:\\\\out2.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       OutputStreamWriter osw2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName2),<span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw2.write(<span class=\"string\">\"你好\"</span>);<span class=\"comment\">// 保存为4个字节</span></span><br><span class=\"line\">       osw2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-对象流\"><a href=\"#8-对象流\" class=\"headerlink\" title=\"8. 对象流\"></a>8. 对象流</h3><ul>\n<li>对象序列化和反序列化<ul>\n<li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li>\n<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li>\n<li>简单来讲<ul>\n<li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li>\n<li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li>\n<li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-ObjectOutputStream类\"><a href=\"#8-1-ObjectOutputStream类\" class=\"headerlink\" title=\"8.1 ObjectOutputStream类\"></a>8.1 ObjectOutputStream类</h3><ul>\n<li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>\n<li>构造方法<ul>\n<li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fileOut = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>序列化操作<ol>\n<li>一个对象要想序列化，必须满足两个条件:<ul>\n<li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li>\n</ul>\n</li>\n<li>写出对象方法<ul>\n<li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//满足两个条件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// transient瞬态修饰成员,不会被序列化</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//写出对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializeDemo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">  Employee e = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">  e.name = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">  e.address = <span class=\"string\">\"beiqinglu\"</span>;</span><br><span class=\"line\">  e.age = <span class=\"number\">20</span>; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建序列化流对象</span></span><br><span class=\"line\">         ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 写出对象</span></span><br><span class=\"line\">      out.writeObject(e);</span><br><span class=\"line\">      <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">      out.close();</span><br><span class=\"line\">      fileOut.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Serialized data is saved\"</span>); <span class=\"comment\">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(IOException i)   &#123;</span><br><span class=\"line\">           i.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//Serialized data is saved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-ObjectInputStream类\"><a href=\"#8-1-ObjectInputStream类\" class=\"headerlink\" title=\"8.1 ObjectInputStream类\"></a>8.1 ObjectInputStream类</h4><ul>\n<li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li>\n<li>构造方法<ul>\n<li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li>\n</ul>\n</li>\n<li>反序列化操作1<ul>\n<li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li>\n<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li>\n<li>public final Object readObject () : 读取一个对象。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializeDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">       Employee e = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建反序列化流</span></span><br><span class=\"line\">            FileInputStream fileIn = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">            ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(fileIn);</span><br><span class=\"line\">            <span class=\"comment\">// 读取一个对象</span></span><br><span class=\"line\">            e = (Employee) in.readObject();</span><br><span class=\"line\">            <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            fileIn.close();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 捕获其他异常</span></span><br><span class=\"line\">            i.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException c) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 捕获类找不到异常</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Employee class not found\"</span>);</span><br><span class=\"line\">            c.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 无异常,直接打印输出</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Name: \"</span> + e.name);<span class=\"comment\">// zhangsan</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Address: \"</span> + e.address); <span class=\"comment\">// beiqinglu</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"age: \"</span> + e.age); <span class=\"comment\">// 0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>反序列化操作2<ul>\n<li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul>\n<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>\n<li>该类包含未知数据类型 </li>\n<li>该类没有可访问的无参数构造方法 </li>\n</ul>\n</li>\n<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加入序列版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> eid; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-打印流-PrintStream类\"><a href=\"#9-打印流-PrintStream类\" class=\"headerlink\" title=\"9. 打印流(PrintStream类)\"></a>9. 打印流(PrintStream类)</h3><ul>\n<li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li>\n<li>构造方法<ul>\n<li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>)；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改变打印流向<ul>\n<li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,控制台直接输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建打印流,指定文件的名称</span></span><br><span class=\"line\">        PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class=\"line\">        System.setOut(ps);</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Properties类的使用\"><a href=\"#10-Properties类的使用\" class=\"headerlink\" title=\"10. Properties类的使用\"></a>10. Properties类的使用</h3><ul>\n<li>Java.util.Properties，主要用于读取Java的配置文件。</li>\n<li>Properties类继承自Hashtable</li>\n<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>\n<li>Properties类的主要方法：<ol>\n<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>\n<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>\n<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>\n<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>\n<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>输入输出（I/O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p>","more":"<ol>\n<li><a href=\"#id1\">File类</a></li>\n<li><a href=\"#id2\">IO流</a></li>\n<li><a href=\"#id3\">文件流</a></li>\n<li><a href=\"#id4\">字节型文件流</a></li>\n<li><a href=\"#id5\">字符型文件流</a></li>\n<li><a href=\"#id6\">*缓冲流</a></li>\n<li><a href=\"#id7\">转换流</a></li>\n<li><a href=\"#id8\">对象流</a></li>\n<li><a href=\"#id9\">打印流(PrintStream类)</a></li>\n<li><a href=\"#id10\">Properties类的使用</a></li>\n</ol>\n<p><span id=\"id1\"><span></span></span></p>\n<h3 id=\"1-File类\"><a href=\"#1-File类\" class=\"headerlink\" title=\"1. File类\"></a>1. File类</h3><ul>\n<li>File与真实硬盘中的文件或文件夹  不是一个东西<ul>\n<li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li>\n</ul>\n</li>\n<li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li>\n<li>File类中的常用的方法<ul>\n<li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li>\n<li>length()，获取文件中字节的个数</li>\n<li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li>\n<li>*String path = getAbsolutePath()，获取文件的绝对路径   D://test//Test.txt<ul>\n<li>绝对路径&lt;—-&gt;相对路径</li>\n<li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li>\n<li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li>\n</ul>\n</li>\n<li>String name = getName()，获取文件的名字    Test.txt</li>\n<li><em>boolean = *</em>createNewFile()**，创建新的文件</li>\n<li><em>boolean = *</em>mkdir** ，创建新的文件夹  外层没有 不能创建</li>\n<li><em>boolean = *</em>mkdirs**，创建新的文件夹  外层没有 可以自动创建</li>\n<li>String pname = getParent()，获取当前file的父亲file名字</li>\n<li>*File file = getParentFile()，获取当前file的父亲file对象</li>\n<li>String[] names = list()，获取当前file的所有儿子名字</li>\n<li>*File[] files = listFiles()，获取当前file的所有儿子对象</li>\n<li>*boolean = delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li>\n</ul>\n</li>\n<li>文件夹的路径(找父目录)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查找当前file的所有父目录</span></span><br><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"D:\\\\test\\\\bbb\\\\inner\\\\InnerTest.txt\"</span>);</span><br><span class=\"line\">File pfile = file.getParentFile();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(pfile!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(pfile.getAbsolutePath());</span><br><span class=\"line\">    pfile = pfile.getParentFile();<span class=\"comment\">//再找一遍</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的遍历—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取file的子元素</span></span><br><span class=\"line\">    <span class=\"comment\">//files==null是个文件</span></span><br><span class=\"line\">    <span class=\"comment\">//files!=null是个文件夹</span></span><br><span class=\"line\">    <span class=\"comment\">//files.length!=0是一个带元素的文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();<span class=\"comment\">//test文件夹所有子元素</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.showFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class=\"line\">    System.out.println(file.getAbsolutePath());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>文件夹的删除—-需要一个递归</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法 删除文件夹,参数 file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteFile</span><span class=\"params\">(File file)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断file不是空文件夹</span></span><br><span class=\"line\">    File[] files = file.listFiles();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span> &amp;&amp; files.length!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(File f:files)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.deleteFile(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class=\"line\">    file.delete();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id2\"><span></span></span></p>\n<h3 id=\"2-IO流\"><a href=\"#2-IO流\" class=\"headerlink\" title=\"2. IO流\"></a>2. IO流</h3><ul>\n<li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li>\n<li>流的分类:<ul>\n<li>根据处理数据类型的不同分为：字符流和字节流</li>\n<li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li>\n<li>操作的目标来区分:<ul>\n<li>文件流，数组流，字符串流，数据流，对象流，网络流…</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>IO流的框架结构</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|——IO流</span><br><span class=\"line\">    |————字节流</span><br><span class=\"line\">        |————InputStream</span><br><span class=\"line\">            |————FileInputStream</span><br><span class=\"line\">            |————DataInputStream</span><br><span class=\"line\">            |————ObjectInputStream</span><br><span class=\"line\">        |————OutputStream</span><br><span class=\"line\">            |————FileOutputStream</span><br><span class=\"line\">            |————DataOutputStream</span><br><span class=\"line\">            |————ObjectOutputStream</span><br><span class=\"line\">            |————PrintStream</span><br><span class=\"line\">    |————字符流</span><br><span class=\"line\">        |————Reader</span><br><span class=\"line\">            |————BufferedReader</span><br><span class=\"line\">            |————InputStreamReader</span><br><span class=\"line\">        |————Writer</span><br><span class=\"line\">            |————BufferedWriter</span><br><span class=\"line\">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id3\"><span></span></span></p>\n<h3 id=\"3-文件流\"><a href=\"#3-文件流\" class=\"headerlink\" title=\"3. 文件流\"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p>\n<ul>\n<li>字节型文件流(1字节)：FileInputStream/FileOutputStream</li>\n<li>字符型文件流(2字节–1字符)：FileReader/FileWriter</li>\n<li>字节流和字符流的区别：<ul>\n<li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>\n<li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li>\n</ul>\n</li>\n<li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li>\n<li>输入流和输出流<ul>\n<li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。 </li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id4\"><span></span></span></p>\n<h3 id=\"4-字节型文件流\"><a href=\"#4-字节型文件流\" class=\"headerlink\" title=\"4. 字节型文件流\"></a>4. 字节型文件流</h3><h4 id=\"4-1-字节型文件输入流FileInputStream-读\"><a href=\"#4-1-字节型文件输入流FileInputStream-读\" class=\"headerlink\" title=\"4.1 字节型文件输入流FileInputStream(读)\"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul>\n<li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>int code = read();    每次从流管道中读取一个字节，返回字节的code码</li>\n<li>*int count = read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li>\n<li>int count = available();   返回流管道中还有多少缓存的字节数</li>\n<li>skip(long n);跳过几个字节  读取<ul>\n<li>多线程—&gt;利用几个线程同时读取文件</li>\n</ul>\n</li>\n<li>*close()    将流管道关闭—必须要做,最好放在finally里<ul>\n<li>注意代码的健壮性，判断严谨（eg:非空判断）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-2-字节型文件输出流FileOutputStream-写\"><a href=\"#4-2-字节型文件输出流FileOutputStream-写\" class=\"headerlink\" title=\"4.2 字节型文件输出流FileOutputStream(写)\"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul>\n<li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li>\n<li>创建对象<ul>\n<li>调用一个带File参数，还有File boolean重载</li>\n<li>调用一个带String参数，还有String boolean重载</li>\n<li>eg: new FileOutputStream(“D://test//bbb.txt”, true)//第二个参控制每次写入追加还是重载</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int code);  将给定code对应的字符写入文件   ‘=’</li>\n<li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li>\n<li>write(byte[] b, int off, int len);</li>\n<li>flush();    将管道内的字节推入(刷新)文件</li>\n<li>close();    注意在finally中关闭</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li>\n<li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li>\n</ul>\n</blockquote>\n<ul>\n<li>设计一个文件复制的方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copyFile</span><span class=\"params\">(File file, String path)</span> </span>&#123;</span><br><span class=\"line\">    FileInputStream fis = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    FileOutputStream fos = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建输入流读取信息</span></span><br><span class=\"line\">        fis = <span class=\"keyword\">new</span> FileInputStream(file);</span><br><span class=\"line\">        <span class=\"comment\">//创建一个新的File对象</span></span><br><span class=\"line\">        File newFile = <span class=\"keyword\">new</span> File(path +<span class=\"string\">\"\\\\\"</span>+ file.getName());<span class=\"comment\">//\"E:\\\\test\\\\test.txt\"</span></span><br><span class=\"line\">        <span class=\"comment\">//创建一个输出流</span></span><br><span class=\"line\">        fos = <span class=\"keyword\">new</span> FileOutputStream(newFile);</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];<span class=\"comment\">//通常1kb-8kb之间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = fis.read(b);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(count != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fos.write(b, <span class=\"number\">0</span>, count);<span class=\"comment\">//将读取到的有效字节写入</span></span><br><span class=\"line\">            fos.flush();</span><br><span class=\"line\">            count = fis.read(b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"复制完毕！\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//关闭</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fis!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123; fis.close(); &#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fos!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;fos.close();&#125;</span><br><span class=\"line\">            <span class=\"keyword\">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id5\"><span></span></span></p>\n<h3 id=\"5-字符型文件流\"><a href=\"#5-字符型文件流\" class=\"headerlink\" title=\"5. 字符型文件流\"></a>5. 字符型文件流</h3><p>FileReader/FileWriter：只能操作纯文本的文件 .txt / .properties</p>\n<h4 id=\"5-1-字符型文件输入流FileReader-读\"><a href=\"#5-1-字符型文件输入流FileReader-读\" class=\"headerlink\" title=\"5.1 字符型文件输入流FileReader(读)\"></a>5.1 字符型文件输入流FileReader(读)</h4><ul>\n<li>FileReader类在java.io包，继承自InputStreamReader，Reader</li>\n<li>创建对象<ul>\n<li>调用一个带File类型的构造方法</li>\n<li>调用一个带String类型的构造方法</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>read()</li>\n<li>read(char[])</li>\n<li>close()</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">File file = <span class=\"keyword\">new</span> File(<span class=\"string\">\"F://test//Test.txt\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    FileReader fr = <span class=\"keyword\">new</span> FileReader(file);</span><br><span class=\"line\">    <span class=\"comment\">// int code = fr.read();</span></span><br><span class=\"line\">    <span class=\"comment\">// System.out.println(code);</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] c = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = fr.read(c);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count!=-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">new</span> String(c, <span class=\"number\">0</span>, count));</span><br><span class=\"line\">        count = fr.read(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-字符型文件输出流FileWriter-写\"><a href=\"#5-2-字符型文件输出流FileWriter-写\" class=\"headerlink\" title=\"5.2 字符型文件输出流FileWriter(写)\"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul>\n<li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li>\n<li>构造方法<ul>\n<li>带file参数，带file,boolean参数</li>\n<li>带String参数，带String,boolean参数</li>\n</ul>\n</li>\n<li>常用方法<ul>\n<li>write(int)</li>\n<li>write(char[])</li>\n<li>write(string)</li>\n<li>flush()，close()</li>\n</ul>\n</li>\n</ul>\n<p><span id=\"id6\"><span></span></span></p>\n<h3 id=\"6-缓冲流\"><a href=\"#6-缓冲流\" class=\"headerlink\" title=\"6. *缓冲流\"></a>6. *缓冲流</h3><ul>\n<li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul>\n<li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li>\n<li>字符缓冲流：BufferedReader，BufferedWriter</li>\n</ul>\n</li>\n<li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>\n<li>缓冲流读写方法与基本的流是一致</li>\n</ul>\n<h4 id=\"6-1-字节缓冲流\"><a href=\"#6-1-字节缓冲流\" class=\"headerlink\" title=\"6.1 字节缓冲流\"></a>6.1 字节缓冲流</h4><ul>\n<li>BufferedInputStream，BufferedOutputStream</li>\n<li>构造方法<ul>\n<li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输入流</span></span><br><span class=\"line\">BufferedInputStream bis = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"bis.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字节缓冲输出流</span></span><br><span class=\"line\">BufferedOutputStream bos = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"bos.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-2-字符缓冲流\"><a href=\"#6-2-字符缓冲流\" class=\"headerlink\" title=\"6.2 字符缓冲流\"></a>6.2 字符缓冲流</h4><ul>\n<li>BufferedReader，BufferedWriter</li>\n<li>构造方法<ul>\n<li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li>\n<li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输入流</span></span><br><span class=\"line\">BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"br.txt\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// 创建字符缓冲输出流</span></span><br><span class=\"line\">BufferedWriter bw = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"bw.txt\"</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li>\n<li>特有方法: <ul>\n<li>BufferedReader：public String readLine(): 读一行文字。 </li>\n<li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//设计一个方法，用来用户登录认证</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">login</span><span class=\"params\">(String username, String password)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"F://test//User.txt\"</span>));</span><br><span class=\"line\">        <span class=\"comment\">//User.txt每行存储格式：张三-123</span></span><br><span class=\"line\">        String user = br.readLine();<span class=\"comment\">//user表示一行记录，记录账号密码</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(user!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//将user信息拆分，分别与参数比较</span></span><br><span class=\"line\">            String[] value = user.split(<span class=\"string\">\"-\"</span>);<span class=\"comment\">//value[0]账号，value[1]密码</span></span><br><span class=\"line\">            System.out.println(value[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value[<span class=\"number\">0</span>].equals(username)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(value[<span class=\"number\">1</span>].equals(password)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"登录成功\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            user = br.readLine();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"账号或密码错误！\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>readLine方法演示:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class=\"line\">    bw.newLine();</span><br><span class=\"line\">    bw.write(&quot;java-888&quot;);</span><br><span class=\"line\">    bw.flush();</span><br><span class=\"line\">&#125; catch (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id7\"><span></span></span></p>\n<h3 id=\"7-转换流\"><a href=\"#7-转换流\" class=\"headerlink\" title=\"7. 转换流\"></a>7. 转换流</h3><h4 id=\"7-1-字符编码\"><a href=\"#7-1-字符编码\" class=\"headerlink\" title=\"7.1 字符编码\"></a>7.1 字符编码</h4><ul>\n<li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li>\n<li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>\n<li>常见字符集:<ul>\n<li>ASCII字符集 ：<ul>\n<li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li>\n</ul>\n</li>\n<li>ISO-8859-1字符集：<ul>\n<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li>\n</ul>\n</li>\n<li>GBxxx字符集：<ul>\n<li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li>\n<li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li>\n</ul>\n</li>\n<li>Unicode字符集 ：<ul>\n<li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li>\n<li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>编码引出的问题<ul>\n<li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-2-InputStreamReader类\"><a href=\"#7-2-InputStreamReader类\" class=\"headerlink\" title=\"7.2 InputStreamReader类\"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>));</span><br><span class=\"line\">InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"in.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码读取:</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderDemo2</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径,文件为gbk编码</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\file_gbk.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName));</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       InputStreamReader isr2 = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(FileName) , <span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 定义变量,保存字符</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> read;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认编码字符流读取,乱码</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read); <span class=\"comment\">// ��Һ�</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr.close();</span><br><span class=\"line\">    <span class=\"comment\">// 使用指定编码字符流读取,正常解析</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((read = isr2.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print((<span class=\"keyword\">char</span>)read);<span class=\"comment\">// 大家好</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       isr2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-3-OutputStreamWriter类\"><a href=\"#7-3-OutputStreamWriter类\" class=\"headerlink\" title=\"7.3 OutputStreamWriter类\"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>\n<ul>\n<li>构造方法<ul>\n<li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li>\n<li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OutputStreamWriter isr = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>));</span><br><span class=\"line\">OutputStreamWriter isr2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"out.txt\"</span>) , <span class=\"string\">\"GBK\"</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>指定编码写出</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutputDemo</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">       String FileName = <span class=\"string\">\"E:\\\\out.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,默认UTF8编码</span></span><br><span class=\"line\">       OutputStreamWriter osw = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName));</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw.write(<span class=\"string\">\"你好\"</span>); <span class=\"comment\">// 保存为6个字节</span></span><br><span class=\"line\">       osw.close();</span><br><span class=\"line\"><span class=\"comment\">// 定义文件路径</span></span><br><span class=\"line\">String FileName2 = <span class=\"string\">\"E:\\\\out2.txt\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建流对象,指定GBK编码</span></span><br><span class=\"line\">       OutputStreamWriter osw2 = <span class=\"keyword\">new</span> OutputStreamWriter(<span class=\"keyword\">new</span> FileOutputStream(FileName2),<span class=\"string\">\"GBK\"</span>);</span><br><span class=\"line\">       <span class=\"comment\">// 写出数据</span></span><br><span class=\"line\">    osw2.write(<span class=\"string\">\"你好\"</span>);<span class=\"comment\">// 保存为4个字节</span></span><br><span class=\"line\">       osw2.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id8\"><span></span></span></p>\n<h3 id=\"8-对象流\"><a href=\"#8-对象流\" class=\"headerlink\" title=\"8. 对象流\"></a>8. 对象流</h3><ul>\n<li>对象序列化和反序列化<ul>\n<li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li>\n<li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li>\n<li>简单来讲<ul>\n<li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li>\n<li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li>\n<li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-1-ObjectOutputStream类\"><a href=\"#8-1-ObjectOutputStream类\" class=\"headerlink\" title=\"8.1 ObjectOutputStream类\"></a>8.1 ObjectOutputStream类</h3><ul>\n<li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li>\n<li>构造方法<ul>\n<li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileOutputStream fileOut = <span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>序列化操作<ol>\n<li>一个对象要想序列化，必须满足两个条件:<ul>\n<li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li>\n<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li>\n</ul>\n</li>\n<li>写出对象方法<ul>\n<li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//满足两个条件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// transient瞬态修饰成员,不会被序列化</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//写出对象方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SerializeDemo</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">  Employee e = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">  e.name = <span class=\"string\">\"zhangsan\"</span>;</span><br><span class=\"line\">  e.address = <span class=\"string\">\"beiqinglu\"</span>;</span><br><span class=\"line\">  e.age = <span class=\"number\">20</span>; </span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建序列化流对象</span></span><br><span class=\"line\">         ObjectOutputStream out = <span class=\"keyword\">new</span> ObjectOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"string\">\"employee.txt\"</span>));</span><br><span class=\"line\">      <span class=\"comment\">// 写出对象</span></span><br><span class=\"line\">      out.writeObject(e);</span><br><span class=\"line\">      <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">      out.close();</span><br><span class=\"line\">      fileOut.close();</span><br><span class=\"line\">      System.out.println(<span class=\"string\">\"Serialized data is saved\"</span>); <span class=\"comment\">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span>(IOException i)   &#123;</span><br><span class=\"line\">           i.printStackTrace();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//Serialized data is saved</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"8-1-ObjectInputStream类\"><a href=\"#8-1-ObjectInputStream类\" class=\"headerlink\" title=\"8.1 ObjectInputStream类\"></a>8.1 ObjectInputStream类</h4><ul>\n<li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li>\n<li>构造方法<ul>\n<li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li>\n</ul>\n</li>\n<li>反序列化操作1<ul>\n<li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li>\n<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li>\n<li>public final Object readObject () : 读取一个对象。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeserializeDemo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String [] args)</span>   </span>&#123;</span><br><span class=\"line\">       Employee e = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建反序列化流</span></span><br><span class=\"line\">            FileInputStream fileIn = <span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"employee.txt\"</span>);</span><br><span class=\"line\">            ObjectInputStream in = <span class=\"keyword\">new</span> ObjectInputStream(fileIn);</span><br><span class=\"line\">            <span class=\"comment\">// 读取一个对象</span></span><br><span class=\"line\">            e = (Employee) in.readObject();</span><br><span class=\"line\">            <span class=\"comment\">// 释放资源</span></span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            fileIn.close();</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(IOException i) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 捕获其他异常</span></span><br><span class=\"line\">            i.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">catch</span>(ClassNotFoundException c) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 捕获类找不到异常</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Employee class not found\"</span>);</span><br><span class=\"line\">            c.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">       <span class=\"comment\">// 无异常,直接打印输出</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Name: \"</span> + e.name);<span class=\"comment\">// zhangsan</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"Address: \"</span> + e.address); <span class=\"comment\">// beiqinglu</span></span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"age: \"</span> + e.age); <span class=\"comment\">// 0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>反序列化操作2<ul>\n<li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul>\n<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>\n<li>该类包含未知数据类型 </li>\n<li>该类没有可访问的无参数构造方法 </li>\n</ul>\n</li>\n<li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加入序列版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String address;</span><br><span class=\"line\">    <span class=\"comment\">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> eid; </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addressCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Address check : \"</span> + name + <span class=\"string\">\" -- \"</span> + address);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id9\"><span></span></span></p>\n<h3 id=\"9-打印流-PrintStream类\"><a href=\"#9-打印流-PrintStream类\" class=\"headerlink\" title=\"9. 打印流(PrintStream类)\"></a>9. 打印流(PrintStream类)</h3><ul>\n<li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li>\n<li>构造方法<ul>\n<li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>)；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>改变打印流向<ul>\n<li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrintDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,控制台直接输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建打印流,指定文件的名称</span></span><br><span class=\"line\">        PrintStream ps = <span class=\"keyword\">new</span> PrintStream(<span class=\"string\">\"ps.txt\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class=\"line\">        System.setOut(ps);</span><br><span class=\"line\">        <span class=\"comment\">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class=\"line\">        System.out.println(<span class=\"number\">97</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><span id=\"id10\"><span></span></span></p>\n<h3 id=\"10-Properties类的使用\"><a href=\"#10-Properties类的使用\" class=\"headerlink\" title=\"10. Properties类的使用\"></a>10. Properties类的使用</h3><ul>\n<li>Java.util.Properties，主要用于读取Java的配置文件。</li>\n<li>Properties类继承自Hashtable</li>\n<li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键=值”的格式，文本注释信息可以用”#”来注释。</li>\n<li>Properties类的主要方法：<ol>\n<li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li>\n<li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li>\n<li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li>\n<li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li>\n<li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li>\n</ol>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjyblnrqt0000xwt3j2t1ly4k","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrrt000dxwt3f6y8ftej"},{"post_id":"cjyblnrr80002xwt3l5zlgrak","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrry000hxwt3sildwgvl"},{"post_id":"cjyblnrrf0005xwt3kkx8ysmz","category_id":"cjyblnrrs000cxwt3ea019jh0","_id":"cjyblnrs1000lxwt3m1lw8szo"},{"post_id":"cjyblnrri0006xwt39mhtfbyy","category_id":"cjyblnrrz000jxwt35y2tdo0f","_id":"cjyblnrs5000rxwt3g6ezdi10"},{"post_id":"cjyblnrrj0007xwt3wkg8uf4r","category_id":"cjyblnrrs000cxwt3ea019jh0","_id":"cjyblnrs7000vxwt31o1wq42q"},{"post_id":"cjyblnrrn000axwt3taro17n0","category_id":"cjyblnrrz000jxwt35y2tdo0f","_id":"cjyblnrs9000zxwt38rq0f2j9"},{"post_id":"cjyblnrrq000bxwt3oydn76sr","category_id":"cjyblnrrs000cxwt3ea019jh0","_id":"cjyblnrsa0012xwt3d4klotfy"},{"post_id":"cjyblnrrv000fxwt3w6psk7id","category_id":"cjyblnrs8000yxwt38jqz9kar","_id":"cjyblnrsb0015xwt36lvb27qf"},{"post_id":"cjyblnrsk001bxwt3kcg8nvj5","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrss001hxwt35jqduhfh"},{"post_id":"cjyblnrsl001cxwt30sj3188v","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrsu001kxwt37w5o2a5z"},{"post_id":"cjyblnrso001exwt3hfmb6xp6","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrsx001nxwt3drbhgqww"},{"post_id":"cjyblnrsr001gxwt3ey6qnm3p","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrt0001rxwt3pmjzqauc"},{"post_id":"cjyblnrst001jxwt3c3slimry","category_id":"cjyblnrrs000cxwt3ea019jh0","_id":"cjyblnrt2001uxwt3xww54epp"},{"post_id":"cjyblnrsw001mxwt3vx0jjl6w","category_id":"cjyblnrt1001sxwt30xadspjk","_id":"cjyblnrt60020xwt32ynbx1w9"},{"post_id":"cjyblnrwu0022xwt3lpfp4kb5","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrx00027xwt3hfsesx42"},{"post_id":"cjyblnrww0023xwt3c7zzkv5r","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnrx1002bxwt352e72isw"},{"post_id":"cjyblnrwy0025xwt3qui7c7c1","category_id":"cjyblnrx00028xwt32hw2il0x","_id":"cjyblnrx3002fxwt3p5gedg93"},{"post_id":"cjyblnrxt002gxwt3tl63xxkh","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnry0002lxwt3bq4sg55s"},{"post_id":"cjyblnrxv002hxwt3215zujxv","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnry1002nxwt3j89g67iw"},{"post_id":"cjyblnrxy002jxwt33m4tvcj4","category_id":"cjyblnrrb0003xwt3avk43gs4","_id":"cjyblnry2002pxwt30he1hos8"}],"PostTag":[{"post_id":"cjyblnrqt0000xwt3j2t1ly4k","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrry000gxwt34n5k4i4f"},{"post_id":"cjyblnrqt0000xwt3j2t1ly4k","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrrz000ixwt3uhsqhrf8"},{"post_id":"cjyblnrr80002xwt3l5zlgrak","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrs3000oxwt3gzb6fm1l"},{"post_id":"cjyblnrr80002xwt3l5zlgrak","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrs4000pxwt38yjn8l3d"},{"post_id":"cjyblnrrf0005xwt3kkx8ysmz","tag_id":"cjyblnrs1000mxwt3pnz568gb","_id":"cjyblnrs6000txwt30efrdcff"},{"post_id":"cjyblnrri0006xwt39mhtfbyy","tag_id":"cjyblnrs5000sxwt3f05f9yy9","_id":"cjyblnrs8000xxwt326jydynn"},{"post_id":"cjyblnrrj0007xwt3wkg8uf4r","tag_id":"cjyblnrs1000mxwt3pnz568gb","_id":"cjyblnrs90011xwt3hwpaqdnh"},{"post_id":"cjyblnrrn000axwt3taro17n0","tag_id":"cjyblnrs90010xwt3l3dlm1pl","_id":"cjyblnrsa0014xwt3nsur4ijz"},{"post_id":"cjyblnrrq000bxwt3oydn76sr","tag_id":"cjyblnrsa0013xwt3fx0bj28u","_id":"cjyblnrsd0018xwt311k88qum"},{"post_id":"cjyblnrrq000bxwt3oydn76sr","tag_id":"cjyblnrs1000mxwt3pnz568gb","_id":"cjyblnrsd0019xwt34mmt8mfn"},{"post_id":"cjyblnrrv000fxwt3w6psk7id","tag_id":"cjyblnrsc0017xwt3u5838w1x","_id":"cjyblnrsd001axwt3eqconeoh"},{"post_id":"cjyblnrsk001bxwt3kcg8nvj5","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrso001dxwt3fmbkqz1g"},{"post_id":"cjyblnrsk001bxwt3kcg8nvj5","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrsq001fxwt3bzd40pwd"},{"post_id":"cjyblnrsl001cxwt30sj3188v","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrst001ixwt3eqncfebu"},{"post_id":"cjyblnrsl001cxwt30sj3188v","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrsv001lxwt3md5hekr9"},{"post_id":"cjyblnrso001exwt3hfmb6xp6","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrsy001pxwt386powz0l"},{"post_id":"cjyblnrso001exwt3hfmb6xp6","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrt2001txwt36keseitr"},{"post_id":"cjyblnrsr001gxwt3ey6qnm3p","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrt3001vxwt3jft3xwo1"},{"post_id":"cjyblnrsr001gxwt3ey6qnm3p","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrt5001xxwt3cu0853wv"},{"post_id":"cjyblnrst001jxwt3c3slimry","tag_id":"cjyblnrs1000mxwt3pnz568gb","_id":"cjyblnrt5001yxwt3uzz3acwq"},{"post_id":"cjyblnrst001jxwt3c3slimry","tag_id":"cjyblnrsx001oxwt3o4edk4gm","_id":"cjyblnrt6001zxwt3rr7aihc8"},{"post_id":"cjyblnrsw001mxwt3vx0jjl6w","tag_id":"cjyblnrt4001wxwt34w39usrj","_id":"cjyblnrt70021xwt3lb2c0fuv"},{"post_id":"cjyblnrwu0022xwt3lpfp4kb5","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrwx0024xwt36yzsfyrt"},{"post_id":"cjyblnrwu0022xwt3lpfp4kb5","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrwz0026xwt3spnba9vg"},{"post_id":"cjyblnrww0023xwt3c7zzkv5r","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrx1002axwt3elhyf15m"},{"post_id":"cjyblnrww0023xwt3c7zzkv5r","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrx2002cxwt3jwk7jzpe"},{"post_id":"cjyblnrwy0025xwt3qui7c7c1","tag_id":"cjyblnrx10029xwt3v29banpz","_id":"cjyblnrx2002dxwt3duyy78uk"},{"post_id":"cjyblnrwy0025xwt3qui7c7c1","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrx2002exwt3a7bwzgfp"},{"post_id":"cjyblnrxt002gxwt3tl63xxkh","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnrxx002ixwt3fag6zr84"},{"post_id":"cjyblnrxt002gxwt3tl63xxkh","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnrxz002kxwt3uiir0awy"},{"post_id":"cjyblnrxv002hxwt3215zujxv","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnry0002mxwt3finc2m2n"},{"post_id":"cjyblnrxv002hxwt3215zujxv","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnry1002oxwt31uob1wzh"},{"post_id":"cjyblnrxy002jxwt33m4tvcj4","tag_id":"cjyblnrre0004xwt331ffb870","_id":"cjyblnry3002qxwt34y7fhfuf"},{"post_id":"cjyblnrxy002jxwt33m4tvcj4","tag_id":"cjyblnrrl0009xwt3krfymk8v","_id":"cjyblnry3002rxwt3nzpq9kdp"}],"Tag":[{"name":"javaSE","_id":"cjyblnrre0004xwt331ffb870"},{"name":"后端开发","_id":"cjyblnrrl0009xwt3krfymk8v"},{"name":"hexo","_id":"cjyblnrs1000mxwt3pnz568gb"},{"name":"bower","_id":"cjyblnrs5000sxwt3f05f9yy9"},{"name":"sublime","_id":"cjyblnrs90010xwt3l3dlm1pl"},{"name":"javascript","_id":"cjyblnrsa0013xwt3fx0bj28u"},{"name":"开源","_id":"cjyblnrsc0017xwt3u5838w1x"},{"name":"BlueLake","_id":"cjyblnrsx001oxwt3o4edk4gm"},{"name":"mongodb","_id":"cjyblnrt4001wxwt34w39usrj"},{"name":"javaEE","_id":"cjyblnrx10029xwt3v29banpz"}]}}