---
title: Java特性-JVM内存模型-GC
date: 2019-10-19 23:15:19
tags: [javaSE, 后端开发]
categories: javaSE知识梳理
---

### 1. Java特性
Java本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得**跨平台能力**；另外就是**垃圾收集**（GC, Garbage Collection），Java通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。<!-- more -->
+ 面向对象（封装，继承，多态）
+ 平台无关性（JVM运行.class文件）
+ 语言（泛型，Lambda）
+ 类库（集合，并发，网络，IO/NIO）
+ JRE（Java Runtime Environment，包括JVM，类库）
+ JDK（Java Development Kit，包括JRE，javac，诊断工具）


#### 1.1 Java运行过程
1. `Java源代码` 经过**Javac**编译成 字节码（bytecode)`.class文件`;
2. 在运行时，通过 **虚拟机(JVM)内嵌的解释器** 将`字节码`转换成为最终的`机器码`。

> 常见的JVM，都提供了 JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT能够在运行时将热点代码编译成机器码，所以准确的说Java代码会`解释执行或编译执行`。


#### 1.2 Java的类加载机制ClassLoader
ClassLoader就是用来动态加载class文件到内存当中用的。
+ 负责将 Class 加载到 JVM 中
+ 审查每个类由谁加载（父优先的等级加载机制）
+ 将 Class 字节码重新解析成 JVM 统一要求的对象格式


#### 1.3 Java默认提供的三个ClassLoader
1. `BootStrap ClassLoader`：启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，
    + 负责将%JAVA_HOME%/lib目录中或-Xbootclasspath中参数指定的路径中，并且是虚拟机识别的（按名称）类库加载到JVM中
2. `Extension ClassLoader`：扩展类加载器，负责加载Java的扩展类库，默认加载%JAVA_HOME%/jre/lib/ext/目下的所有jar。
3. `App ClassLoader`：系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。


#### 1.4 ClassLoader双亲委派机制
某个特定的类加载器在接到加载类的请求时，首先将加载任务**委托给父类加载器**，依次递归(父类的父类)，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。
+ 这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了java的核心API被篡改。


#### 1.5 类的加载方式
1. 隐式加载：new
2. 显式加载：loadClass、forName等(需要调用Class的newInstance方法获取实例)
3. 类的装载过程：`加载 --> 链接 --> 初始化`
    + 加载：通过Classloader加载class文件字节码，生成class对象
    + 链接：校验-->准备-->解析
        - 校验：检查加载的Class的正确性和安全性
        - 准备：为变量分配存储空间并设置类变量初始值
        - 解析：JVM将常量池内的符号引用转换为直接引用
    + 初始化：执行类变量赋值和静态代码块


### 2. 反射机制
简单说，反射机制是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。


#### 2.1 反射中，Class.forName和classloader的区别
+ Class.forName()得到的Class是完成初始化的
+ 而ClassLoader.loadClass()得到的Class是还没有链接的。
+ Spring IoC为了加快初始化速度，因此大量使用了延时加载技术。而使用classloader不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用到这个类的时候。


#### 2.2 哪里用到反射机制？
+ JDBC中，利用反射动态加载了数据库驱动程序。
+ Web服务器中利用反射调用了Sevlet的服务方法。
+ Eclispe等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。
+ 很多框架都用到反射机制，注入属性，调用方法，如Spring。


#### 2.3 反射机制的优缺点？
优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。
缺点：对性能有影响，这类操作总是慢于直接执行java代码。


### 3. JVM内存模型（JDK8）
线程私有：程序计数器、虚拟机栈、本地方法栈
线程共享：堆区(Heap,带有常量池)、元空间(MetaSpace)


#### 3.1 元空间（MetaSpace） 和 永久代（PermGen）
* JDK8，移除了永久代（PermGen，堆空间），替换为元空间（Metaspace，本地内存）；
* 元空间（MetaSpace）相比永久代（PermGen）的优势：
    1. 字符串常量池存在永久代（永久代在JDK7是方法区的一种实现）中，容易出现性能问题和内存溢出
    2. 类和方法的信息大小难以确定，给永久代的大小指定带来困难（太小，容易导致永久代溢出   太大，容易导致老年代溢出）
    3. 永久代会为GC带来不必要的复杂性
    4. 方便HotSpot与其他JVM如JRockit的集成


#### 3.2 JVM三大性能调优参数 -Xms -Xmx -Xss的含义
`java -Xms128m -Xmx128m -Xss256k -jar xxx.jar`
* `-Xss`: 规定了每个线程虚拟机栈（堆栈）的大小，通常256k就足够了，此配置会影响此进程中并发线程数大小
* `-Xms`: 堆的初始值，java中堆空间大小，一旦超出，就会扩容至-Xmx
* `-Xmx`: 堆能达到的最大值，通常-Xms与-Xmx相同，防止Heap不够用扩容时引发的内存抖动，影响程序运行时稳定性。


#### 3.3 Java内存模型中堆和栈的区别
1. 管理方式：栈自动释放，堆需要GC
2. 空间大小：栈比堆小
3. 碎片相关：栈产生的碎片远小于堆
4. 分配方式：栈支持动态和静态分配，堆仅支持动态分配
5. 效率：栈比堆高


### 4. 垃圾回收与算法
#### 4.1 如何确定垃圾
1. **引用计数法**：在堆中存储对象时，在对象头维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，那么这个对象就是可回收对象。
2. 可达性分析：通过一系列名为GC Roots的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则称该对象是不可达的。
    + 根节点：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈等变量。

#### 4.2 标记清除算法（Mark-Sweep）
最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。
+ 缺点：（效率不高）标注和清除过程效率都不高，产生碎片（碎片太多会导致提前GC）

#### 4.3 复制算法（copying）
为解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。
+ 优缺点：实现简单，内存效率高，不易产生碎片，但可用内存被压缩到了原本的一半

#### 4.4 标记整理算法(Mark-Compact)
结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。
+ 优缺点：没了内存碎片，但整理内存比较耗时

#### 4.5 分代收集算法（JVM所采用）
1. 新生代与复制算法
    + 一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。
2. 老年代与标记整理算法
    + 对象优先在新生代Eden中分配，大对象直接进入老年代，长期存活的对象进入老年代



### 5. JAVA四中引用类型
#### 5.1 强引用
在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。

#### 5.2 软引用
软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

#### 5.3 弱引用
弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。

#### 5.4 虚引用
虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。



### 6. GC垃圾收集器
1. 串行收集器Serial：Serial、Serial Old
2. 并行收集器Parallel：Parallel Scavenge、Parallel Old （吞吐量）
3. 并发收集器Concurrent：CMS、G1 （停顿时间）
> 并发：指多条垃圾收集线程并行工作，但用户线程仍然处于等待状态，适用弱交互场景：科学计算，后台处理等。
> 并发：用户线程与垃圾收集线程同时执行（不一定并行，可能交替），不停顿用户程序执行，适用对响应时间有要求的场景：web
> 停顿时间：垃圾收集器做垃圾回收中断应用执行时间（`-XX:MaxGCPauseMills`）
> 吞吐量：花在垃圾收集时间和应用时间占比（`-XX:GCTimeRatio=<n>`,垃圾收集时间占:1/(1+n)）

#### 6.1 Serial 垃圾收集器（单线程、复制算法）
Serial是最基本垃圾收集器，使用复制算法，是 java 虚拟机运行在 **Client模式下默认的新生代**垃圾收集器。

#### 6.2 ParNew 垃圾收集器（Serial+多线程）
ParNew垃圾收集器其实**是 Serial 收集器的多线程版本**，也使用复制算法，是很多java虚拟机运行在 **Server模式下新生代的默认**垃圾收集器。

#### 6.3 Parallel Scavenge 收集器（多线程复制算法、高效）
Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是**程序达到一个可控制的吞吐量**（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。**自适应调节策略**也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。

#### 6.4 Serial Old 收集器（单线程标记整理算法 ）
Serial Old 是 **Serial 垃圾收集器年老代版本**，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 **Client默认的年老代**垃圾收集器。

#### 6.5 Parallel Old 收集器（多线程标记整理算法）
Parallel Old 收集器是**Parallel Scavenge的年老代版本**，使用多线程的标记-整理算法，在 JDK1.6才开始提供。Parallel Old 正是为了在年老代同样提供**吞吐量优先**的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。

#### 6.6 CMS 收集器（多线程标记清除算法）
Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最**主要目标是获取最短垃圾回收停顿时间**，和其他年老代使用标记-整理算法不同，它使用**多线程的标记-清除算法**。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。
CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：
1. 初始标记：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
2. 并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
3. 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
4. 并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以**总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行**。

#### 6.7 G1 收集器
Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
**G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域**，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，**优先回收垃圾最多的区域**。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。


### 7. GC调优步骤
1. 打印GC日志
2. 根据日志得到关键性能指标
3. 分析GC原因，调优JVM参数

#### 7.1 Parallel GC调优
1. 除非确定，否则不要设置最大堆内存
2. 优先设置吞吐量目标
3. 如果吞吐量目标不达标，调大最大内存，不能让OS适用Swap，如果仍然达不到，降低目标
4. 吞吐量能达标，GC时间太长，设置停顿时间目标

#### 7.2 G1 GC最佳实践
1. 不要设置新生代和老年代的大小
    + G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。设置了新生代大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的大小。
2. 不断调优暂停时间指标
    + 通过XX:MaxGCPauseMillis=x可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选择CSet来满足响应时间的设置。一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。
3. 关注Evacuation Failure
    + Evacuation Failure类似于CMS里面的晋升失败，堆空间的垃圾太多导致无法完成Region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集。





